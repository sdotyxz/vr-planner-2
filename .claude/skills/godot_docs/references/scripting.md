# Godot_Docs - Scripting

**Pages:** 78

---

## About godot-cpp — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/cpp/about_godot_cpp.html

**Contents:**
- About godot-cpp
- Differences between godot-cpp and C++ modules
  - Advantages of godot-cpp
  - Advantages of C++ modules
- Version compatibility
- User-contributed notes

godot-cpp are the official C++ GDExtension bindings, maintained as part of the Godot project.

godot-cpp is built with the GDExtension system, which allows access to Godot in almost the same way as modules: A lot of engine code can be used in your godot-cpp project almost exactly as it is.

In particular, godot-cpp has access to all functions that GDScript and C# have, and additional access to a few more for fast low-level access of data, or deeper integration with Godot.

You can use both godot-cpp and C++ modules to run C or C++ code in a Godot project.

They also both allow you to integrate third-party libraries into Godot. The one you should choose depends on your needs.

Unlike modules, godot-cpp (and GDExtensions, in general) don't require compiling the engine's source code, making it easier to distribute your work. It gives you access to most of the API available to GDScript and C#, allowing you to code game logic with full control regarding performance. It's ideal if you need high-performance code you'd like to distribute as an add-on in the asset library.

You can use the same compiled godot-cpp library in the editor and exported project. With C++ modules, you have to recompile all the export templates you plan to use if you require its functionality at runtime.

godot-cpp only requires you to compile your library, not the whole engine. That's unlike C++ modules, which are statically compiled into the engine. Every time you change a module, you need to recompile the engine. Even with incremental builds, this process is slower than using godot-cpp.

We recommend C++ modules in cases where godot-cpp (or another GDExtension system) isn't enough:

C++ modules provide deeper integration into the engine. GDExtension's access is not as deep as static modules.

You can use C++ modules to provide additional features in a project without carrying native library files around. This extends to exported projects.

If you notice that specific systems are not accessible via godot-cpp but are via custom modules, feel free to open an issue on the godot-cpp repository to discuss implementation options for exposing the missing functionality.

GDExtensions targeting an earlier version of Godot should work in later minor versions, but not vice-versa. For example, a GDExtension targeting Godot 4.2 should work just fine in Godot 4.3, but one targeting Godot 4.3 won't work in Godot 4.2.

For this reason, when creating GDExtensions, you may want to target the lowest version of Godot that has the features you need, not the most recent version of Godot. This can save you from needing to create multiple builds for different versions of Godot.

There is one exception to this: extensions targeting Godot 4.0 will not work with Godot 4.1 and later (see Updating your GDExtension for 4.1).

GDExtensions are also only compatible with engine builds that use the same level of floating-point precision the extension was compiled for. This means that if you use an engine build with double-precision floats, the extension must also be compiled for double-precision floats and use an extension_api.json file generated by your custom engine build. See Large world coordinates for details.

Generally speaking, if you build a custom version of Godot, you should generate an extension_api.json from it for your GDExtensions, because it may have some differences from official Godot builds.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Adding documentation — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/cpp/gdextension_docs_system.html

**Contents:**
- Adding documentation
- Documentation styling
- Publishing documentation online
- User-contributed notes

Adding documentation for GDExtensions is only possible for Godot 4.3 and later. The support can be integrated into your project regardless because the snippet will check if you use the appropriate godot-cpp version. If you set the compatibility_minimum to 4.2 and you load a project with the extension through a 4.2 editor, the documentation page for that class will be empty. The extension itself will still work.

The GDExtension documentation system works in a similar manner to the built-in engine documentation. It uses a series of XML files (one per class) to document the exposed constructors, properties, methods, constants, signals, and theme items of each class.

We are assuming you are using the project files explained in the example project with the following structure:

Inside the Godot demo project directory of your GDExtension directory, run the following terminal command:

This command calls upon the Godot editor binary to generate documentation via the --doctool and --gdextension-docs commands. The ../ addition is to let Godot know where the GDExtension SConstruct file is located. By calling this command, Godot generates a doc_classes directory inside the project directory in which it generates XML files for the GDExtension classes. Those files can then be edited to add information about member variables, methods, signals, and more.

To add the now edited documentation to the GDExtension and let the editor load it, you need to add the following lines to your SConstruct file:

The if-statement checks if we are compiling the GDExtension library with the editor and template_debug flags. SCons then tries to load all the XML files inside the doc_classes directory and appends them to the sources variable which already includes all the source files of your extension. If it fails it means we are currently trying to compile the library when the godot_cpp is set to a version before 4.3.

After loading the extension in a 4.3 Godot editor or later and open the documentation of your extension class either by Ctrl + Click in the script editor or the Editor help dialog you will see something like this:

To style specific parts of text you can use BBCode tags similarly to how they can be used in RichTextLabels. You can set text as bold, italic, underlined, colored, codeblocks etc. by embedding them in tags like this:

Currently, the supported tags for the GDExtension documentation system are:

[center]{text}[/center]

[color={code/name}]{text}[/color]

You may want to publish an online reference for your GDExtension, similar to this website. The most important step is to build reStructuredText (.rst) files from your XML class reference:

Your .rst files will now be available in docs/classes/. From here, you can use any documentation builder that supports reStructuredText syntax to create a website from them.

godot-docs uses Sphinx. You can use the repository as a basis to build your own documentation system. The following guide describes the basic steps, but they are not exhaustive: You will need a bit of personal insight to make it work.

Add godot-docs as a submodule to your docs/ folder.

Copy over its conf.py, index.rst, .readthedocs.yaml files into /docs/. You may later decide to copy over and edit more of godot-docs' files, like _templates/layout.html.

Modify these files according to your project. This mostly involves adjusting paths to point to the godot-docs subfolder, as well as strings to reflect it's your project rather than Godot you're building the docs for.

Create an account on readthedocs.org. Import your project, and modify its base .readthedocs.yaml file path to /docs/.readthedocs.yaml.

Once you have completed all these steps, your documentation should be available at <repo-name>.readthedocs.io.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
gdextension_cpp_example/  # GDExtension directory
|
+--demo/                  # game example/demo to test the extension
|   |
|   +--main.tscn
|   |
|   +--bin/
|       |
|       +--gdexample.gdextension
|
+--godot-cpp/             # C++ bindings
|
+--src/                   # source code of the extension we are building
|   |
|   +--register_types.cpp
|   +--register_types.h
|   +--gdexample.cpp
|   +--gdexample.h
```

Example 2 (unknown):
```unknown
# Replace "godot" with the full path to a Godot editor binary
# if Godot is not installed in your `PATH`.
godot --doctool ../ --gdextension-docs
```

Example 3 (unknown):
```unknown
if env["target"] in ["editor", "template_debug"]:
    try:
        doc_data = env.GodotCPPDocData("src/gen/doc_data.gen.cpp", source=Glob("doc_classes/*.xml"))
        sources.append(doc_data)
    except AttributeError:
        print("Not including class reference as we're targeting a pre-4.3 baseline.")
```

Example 4 (unknown):
```unknown
[b]this text will be shown as bold[/b]
```

---

## Change scenes manually — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/change_scenes_manually.html

**Contents:**
- Change scenes manually
- User-contributed notes

Sometimes it helps to have more control over how you swap scenes around. A Viewport's child nodes will render to the image it generates. This holds true even for nodes outside of the "current" scene. Autoloads fall into this category, and also scenes which you instantiate and add to the tree at runtime:

To complete the cycle and swap out the new scene with the old one, you have a choice to make. Many strategies exist for removing a scene from view of the Viewport. The tradeoffs involve balancing operation speed and memory consumption, as well as balancing data access and integrity.

Delete the existing scene. SceneTree.change_scene_to_file() and SceneTree.change_scene_to_packed() will delete the current scene immediately. You can also delete the main scene. Assuming the root node's name is "Main", you could do get_node("/root/Main").free() to delete the whole scene.

Pro: RAM is no longer dragging the dead weight.

Con: Returning to that scene is now more expensive since it must be loaded back into memory again (takes time AND memory). Not a problem if returning soon is unnecessary.

Con: No longer have access to that scene's data. Not a problem if using that data soon is unnecessary.

Note: It can be useful to preserve the data in a soon-to-be-deleted scene by re-attaching one or more of its nodes to a different scene, or even directly to the SceneTree.

Pro: No nodes means no processing, physics processing, or input handling. The CPU is available to work on the new scene's contents.

Con: Those nodes' processing and input handling no longer operate. Not a problem if using the updated data is unnecessary.

Hide the existing scene. By changing the visibility or collision detection of the nodes, you can hide the entire node sub-tree from the player's perspective.

Pro: You can still access the data if needed.

Pro: There's no need to move any more nodes around to save data.

Con: More data is being kept in memory, which will be become a problem on memory-sensitive platforms like web or mobile.

Processing continues.

Pro: Data continues to receive processing updates, so the scene will keep any data within it that relies on delta time or frame data updated.

Pro: Nodes are still members of groups (since groups belong to the SceneTree).

Con: The CPU's attention is now divided between both scenes. Too much load could result in low frame rates. You should be sure to test performance as you go to ensure the target platform can support the load from this approach.

Remove the existing scene from the tree. Assign a variable to the existing scene's root node. Then use Node.remove_child(Node) to detach the entire scene from the tree.

Memory still exists (similar pros/cons as hiding it from view).

Processing stops (similar pros/cons as deleting it completely).

Pro: This variation of "hiding" it is much easier to show/hide. Rather than potentially keeping track of multiple changes to the scene, you only need to call the add/remove_child methods. This is similar to disabling game objects in other engines.

Con: Unlike with hiding it from view only, the data contained within the scene will become stale if it relies on delta time, input, groups, or other data that is derived from SceneTree access.

There are also cases where you may wish to have many scenes present at the same time, such as adding your own singleton at runtime, or preserving a scene's data between scene changes (adding the scene to the root node).

Another case may be displaying multiple scenes at the same time using SubViewportContainers. This is optimal for rendering different content in different parts of the screen (e.g. minimaps, split-screen multiplayer).

Each option will have cases where it is best appropriate, so you must examine the effects of each approach, and determine what path best fits your unique situation.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
var simultaneous_scene = preload("res://levels/level2.tscn").instantiate()

func _add_a_scene_manually():
    # This is like autoloading the scene, only
    # it happens after already loading the main scene.
    get_tree().root.add_child(simultaneous_scene)
```

Example 2 (unknown):
```unknown
public Node simultaneousScene;

public MyClass()
{
    simultaneousScene = ResourceLoader.Load<PackedScene>("res://levels/level2.tscn").Instantiate();
}

public void _AddASceneManually()
{
    // This is like autoloading the scene, only
    // it happens after already loading the main scene.
    GetTree().Root.AddChild(simultaneousScene);
}
```

Example 3 (unknown):
```unknown
get_tree().root.add_child(scene)
```

Example 4 (unknown):
```unknown
GetTree().Root.AddChild(scene);
```

---

## C#/.NET — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/index.html

**Contents:**
- C#/.NET
- Godot API for C#
- C# platform support

C# is a high-level programming language developed by Microsoft. Godot supports C# as an option for a scripting language, alongside Godot's own GDScript.

The standard Godot executable does not contain C# support out of the box. Instead, to enable C# support for your project you need to download a .NET version of the editor from the Godot website.

As a general purpose game engine Godot offers some high-level features as a part of its API. Articles below explain how these features integrate into C# and how C# API may be different from GDScript.

See System requirements for hardware and software version requirements for the Godot engine.

Since C# projects use the .NET runtime, also check the system requirements for the version of .NET that you'll be using. See supported OS.

Since Godot 4.2, projects written in C# support all desktop platforms (Windows, Linux, and macOS), as well as Android and iOS.

Android support is currently experimental.

iOS support is currently experimental and has a few limitations.

The official export templates for the iOS simulator only supports the x64 architecture.

Exporting to iOS can only be done from a MacOS device.

Currently, projects written in C# cannot be exported to the web platform. To use C# on that platform, consider Godot 3 instead.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Creating script templates — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/creating_script_templates.html

**Contents:**
- Creating script templates
- Locating the templates
  - Editor-defined templates
  - Project-defined templates
  - Template organization and naming
- Default behavior and overriding it
- Default template
- List of template placeholders
  - Base placeholders
  - Type placeholders

Godot provides a way to use script templates as seen in the Script Create Dialog while creating a new script:

A set of built-in script templates are provided with the editor, but it is also possible to create new ones and set them by default, both per project and at editor scope.

Templates are linked to a specific node type, so when you create a script you will only see the templates corresponding to that particular node, or one of its parent types. For example, if you are creating a script for a CharacterBody3D, you will only see templates defined for CharacterBody3Ds, Node3Ds or Nodes.

There are two places where templates can be managed.

These are available globally throughout any project. The location of these templates are determined per each OS:

Windows: %APPDATA%\Godot\script_templates\

Linux: $HOME/.config/godot/script_templates/

macOS: $HOME/Library/Application Support/Godot/script_templates/

If you're getting Godot from somewhere other than the official website, such as Steam, the folder might be in a different location. You can find it using the Godot editor. Go to Editor > Open Editor Data/Settings Folder and it will open a folder in your file browser, inside that folder is the script_templates folder.

The default path to search for templates is the res://script_templates/ directory. The path can be changed by configuring the project setting Editor > Script > Templates Search Path, both via code and the editor.

If no script_templates directory is found within a project, it is simply ignored.

Both editor and project defined templates are organized in the following way:

template_path is one of the 2 locations discussed in the previous two sections.

node_type is the node it will apply to (for example, Node, or CharacterBody3D), This is case-sensitive. If a script isn't in the proper node_type folder, it won't be detected.

file is the custom name you can chose for the template (for example, platformer_movement or smooth_camera).

extension indicates which language the template will apply to (it should be gd for GDScript or cs for C#).

script_templates/Node/smooth_camera.gd

script_templates/CharacterBody3D/platformer_movement.gd

the template's name is the same as the file name (minus the extension, prettyfied)

the description is empty

the space indent is set to 4

the template will not be set as the default for the given node

It is possible to customize this behavior by adding meta headers at the start of your file, like this:

In this case, the name will be set to "Platformer movement", with the given custom description, and it will be set as the default template for the node in which directory it has been saved.

This is an example of utilizing custom templates at editor and project level:

The script templates have the same extension as the regular script files. This may lead to an issue of a script parser treating those templates as actual scripts within a project. To avoid this, make sure to ignore the directory containing them by creating an empty .gdignore file. The directory won't be visible throughout the project's filesystem anymore, yet the templates can be modified by an external text editor anytime.

By default, every C# file inside the project directory is included in the compilation. Script templates must be manually excluded from the C# project to avoid build errors. See Exclude files from the build in the Microsoft documentation.

It is possible to create editor-level templates that have the same level as a project-specific templates, and also that have the same name as a built-in one, all will be shown on the new script dialog.

To override the default template, create a custom template at editor or project level inside a Node directory (or a more specific type, if only a subtype wants to be overridden) and start the file with the meta-default: true header.

Only one template can be set as default at the same time for the same node type.

The Default templates for basic Nodes, for both GDScript and C#, are shown here so you can use these as the base for creating other templates:

The Godot editor provides a set of useful built-in node-specific templates, such as basic_movement for both CharacterBody2D and CharacterBody3D and plugin for EditorPlugin.

The following describes the complete list of built-in template placeholders which are currently implemented.

The name of the Godot namespace (used in C# only).

The name of the new class.

The name of the new class as snake_case (used in GDScript only).

The base type a new script inherits from.

Indentation placeholder. The exact type and number of whitespace characters used for indentation is determined by the text_editor/indent/type and text_editor/indent/size settings in the EditorSettings respectively. Can be overridden by the meta-space-indent header on the template.

There used to be, in Godot 3.x, placeholders for GDScript type hints that would get replaced whenever a template was used to create a new script, such as: %INT_TYPE%, %STRING_TYPE%, %FLOAT_TYPE% or %VOID_RETURN%.

The placeholders no longer work for Godot 4.x, but if the setting text_editor/completion/add_type_hints from EditorSettings is disabled, type hints for parameters and return types will be automatically removed for a few base types:

:= will be transformed into =

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
template_path/node_type/file.extension
```

Example 2 (unknown):
```unknown
# meta-name: Platformer movement
# meta-description: Predefined movement for classical platformers
# meta-default: true
# meta-space-indent: 4
```

Example 3 (unknown):
```unknown
// meta-name: Platformer movement
// meta-description: Predefined movement for classical platformers
// meta-default: true
// meta-space-indent: 4
```

Example 4 (unknown):
```unknown
# meta-description: Base template for Node with default Godot cycle methods

extends _BASE_


# Called when the node enters the scene tree for the first time.
func _ready() -> void:
    pass # Replace with function body.


# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(delta: float) -> void:
    pass
```

---

## Cross-language scripting — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/cross_language_scripting.html

**Contents:**
- Cross-language scripting
- Instantiating nodes
  - Instantiating C# nodes from GDScript
  - Instantiating GDScript nodes from C#
- Accessing fields
  - Accessing C# fields from GDScript
  - Accessing GDScript fields from C#
- Calling methods
  - Calling C# methods from GDScript
  - Calling GDScript methods from C#

Godot allows you to mix and match scripting languages to suit your needs. This means a single project can define nodes in both C# and GDScript. This page will go through the possible interactions between two nodes written in different languages.

The following two scripts will be used as references throughout this page.

If you're not using nodes from the scene tree, you'll probably want to instantiate nodes directly from the code.

Using C# from GDScript doesn't need much work. Once loaded (see Classes as resources), the script can be instantiated with new().

When creating .cs scripts, you should always keep in mind that the class Godot will use is the one named like the .cs file itself. If that class does not exist in the file, you'll see the following error: Invalid call. Nonexistent function `new` in base.

For example, MyCoolNode.cs should contain a class named MyCoolNode.

The C# class needs to derive a Godot class, for example GodotObject. Otherwise, the same error will occur.

You also need to check your .cs file is referenced in the project's .csproj file. Otherwise, the same error will occur.

From the C# side, everything work the same way. Once loaded, the GDScript can be instantiated with GDScript.New().

Here we are using an Object, but you can use type conversion like explained in Type conversion and casting.

Accessing C# fields from GDScript is straightforward, you shouldn't have anything to worry about.

As C# is statically typed, accessing GDScript from C# is a bit more convoluted. You will have to use GodotObject.Get() and GodotObject.Set(). The first argument is the name of the field you want to access.

Keep in mind that when setting a field value you should only use types the GDScript side knows about. Essentially, you want to work with built-in types as described in Built-in types or classes extending Object.

Again, calling C# methods from GDScript should be straightforward. The marshalling process will do its best to cast the arguments to match function signatures. If that's impossible, you'll see the following error: Invalid call. Nonexistent function `FunctionName`.

To call GDScript methods from C# you'll need to use GodotObject.Call(). The first argument is the name of the method you want to call. The following arguments will be passed to said method.

Connecting to a C# signal from GDScript is the same as connecting to a signal defined in GDScript:

Connecting to a GDScript signal from C# only works with the Connect method because no C# static types exist for signals defined by GDScript:

A GDScript file may not inherit from a C# script. Likewise, a C# script may not inherit from a GDScript file. Due to how complex this would be to implement, this limitation is unlikely to be lifted in the future. See this GitHub issue for more information.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
extends Node

var my_property: String = "my gdscript value":
    get:
        return my_property
    set(value):
        my_property = value

signal my_signal
signal my_signal_with_params(msg: String, n: int)

func print_node_name(node: Node) -> void:
    print(node.get_name())

func print_array(arr: Array) -> void:
    for element in arr:
        print(element)

func print_n_times(msg: String, n: int) -> void:
    for i in range(n):
        print(msg)

func my_signal_handler():
    print("The signal handler was called!")

func my_signal_with_params_handler(msg: String, n: int):
    print_n_times(msg, n)
```

Example 2 (csharp):
```csharp
using Godot;

public partial class MyCSharpNode : Node
{
    public string MyProperty { get; set; } = "my c# value";

    [Signal] public delegate void MySignalEventHandler();
    [Signal] public delegate void MySignalWithParamsEventHandler(string msg, int n);

    public void PrintNodeName(Node node)
    {
        GD.Print(node.Name);
    }

    public void PrintArray(string[] arr)
    {
        foreach (string element in arr)
        {
            GD.Print(element);
        }
    }

    public void PrintNTimes(string msg, int n)
    {
        for (int i = 0; i < n; ++i)
        {
            GD.Print(msg);
        }
    }

    public void MySignalHandler()
    {
        GD.Print("The signal handler was called!");
    }

    public void MySignalWithParamsHandler(string msg, int n)
    {
        PrintNTimes(msg, n);
    }
}
```

Example 3 (unknown):
```unknown
var MyCSharpScript = load("res://Path/To/MyCSharpNode.cs")
var my_csharp_node = MyCSharpScript.new()
```

Example 4 (unknown):
```unknown
var myGDScript = GD.Load<GDScript>("res://path/to/my_gd_script.gd");
var myGDScriptNode = (GodotObject)myGDScript.New(); // This is a GodotObject.
```

---

## Custom performance monitors — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/debug/custom_performance_monitors.html

**Contents:**
- Custom performance monitors
- Introduction
- Creating a custom performance monitor
- Querying a performance monitor in a project
- User-contributed notes

As explained in the Debugger panel documentation, Godot features a Debugger > Monitors bottom panel that allows tracking various values with graphs showing their evolution over time. The data for those graphs is sourced from the engine's Performance singleton.

Since Godot 4.0, you can declare custom values to be displayed in the Monitors tab. Example use cases for custom performance monitors include:

Displaying performance metrics that are specific to your project. For instance, in a voxel game, you could create a performance monitor to track the number of chunks that are loaded every second.

Displaying in-game metrics that are not strictly related to performance, but are still useful to graph for debugging purposes. For instance, you could track the number of enemies present in the game to make sure your spawning mechanic works as intended.

In this example, we'll create a custom performance monitor to track how many enemies are present in the currently running project.

The main scene features a Timer node with the following script attached:

The second parameter of Performance.add_custom_monitor is a Callable.

enemy.tscn is a scene with a Node2D root node and Timer child node. The Node2D has the following script attached:

In this example, since we spawn 20 enemies per second, and each enemy despawns 2.5 seconds after they spawn, we expect the number of enemies present in the scene to stabilize to 50. We can make sure about this by looking at the graph.

To visualize the graph created from this custom performance monitor, run the project, switch to the editor while the project is running and open Debugger > Monitors at the bottom of the editor window. Scroll down to the newly available Game section and check Enemies. You should see a graph appearing as follows:

Example editor graph from a custom performance monitor

The performance monitor handling code doesn't have to live in the same script as the nodes themselves. You may choose to move the performance monitor registration and getter function to an autoload instead.

If you wish to display the value of the performance monitor in the running project's window (rather than the editor), use Performance.get_custom_monitor("category/name") to fetch the value of the custom monitor. You can display the value using a Label, RichTextLabel, Custom drawing in 2D, 3D text, etc.

This method can be used in exported projects as well (debug and release mode), which allows you to create visualizations outside the editor.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
extends Timer


func _ready():
    # The slash delimiter is used to determine the category of the monitor.
    # If there is no slash in the monitor name, a generic "Custom" category
    # will be used instead.
    Performance.add_custom_monitor("game/enemies", get_enemy_count)
    timeout.connect(_on_timeout)
    # Spawn 20 enemies per second.
    wait_time = 0.05
    start()


func _on_timeout():
    var enemy = preload("res://enemy.tscn").instantiate()
    get_parent().add_child(enemy)


# This function is called every time the performance monitor is queried
# (this occurs once per second in the editor, more if called manually).
# The function must return a number greater than or equal to 0 (int or float).
func get_enemy_count():
    return get_tree().get_nodes_in_group("enemies").size()
```

Example 2 (unknown):
```unknown
extends Node2D


func _ready():
    add_to_group("enemies")
    $Timer.timeout.connect(_on_timer_timeout)
    # Despawn enemies 2.5 seconds after they spawn.
    $Timer.wait_time = 2.5
    $Timer.start()


func _on_timer_timeout():
    queue_free()
```

---

## C# API differences to GDScript — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_differences.html

**Contents:**
- C# API differences to GDScript
- General differences
- Global scope
  - Constants
  - Math functions
  - Random functions
  - Other functions
  - Tips
  - Full list of equivalences
- @export annotation

This is an (incomplete) list of API differences between C# and GDScript.

As explained in General differences between C# and GDScript, PascalCase is used to access Godot APIs in C# instead of the snake_case used by GDScript and C++. Where possible, fields and getters/setters have been converted to properties. In general, the C# Godot API strives to be as idiomatic as is reasonably possible. See the C# style guide, which we encourage you to also use for your own C# code.

In GDScript, the setters/getters of a property can be called directly, although this is not encouraged. In C#, only the property is defined. For example, to translate the GDScript code x.set_name("Friend") to C#, write x.Name = "Friend";.

A C# IDE will provide intellisense, which is extremely useful when figuring out renamed C# APIs. The built-in Godot script editor has no support for C# intellisense, and it also doesn't provide many other C# development tools that are considered essential. See Configuring an external editor.

Global functions and some constants had to be moved to classes, since C# does not allow declaring them in namespaces. Most global constants were moved to their own enums.

In C#, only primitive types can be constant. For example, the TAU constant is replaced by the Mathf.Tau constant, but the Vector2.RIGHT constant is replaced by the Vector2.Right read-only property. This behaves similarly to a constant, but can't be used in some contexts like switch statements.

Global enum constants were moved to their own enums. For example, ERR_* constants were moved to the Error enum.

Variant.Operator enum

Math global functions, like abs, acos, asin, atan and atan2, are located under Mathf as Abs, Acos, Asin, Atan and Atan2. The PI constant can be found as Mathf.Pi.

C# also provides static System.Math and System.MathF classes that may contain other useful mathematical operations.

Random global functions, like rand_range and rand_seed, are located under GD. Example: GD.RandRange and GD.RandSeed.

Consider using System.Random or, if you need cryptographically strong randomness, System.Security.Cryptography.RandomNumberGenerator.

Many other global functions like print and var_to_str are located under GD. Example: GD.Print and GD.VarToStr.

GodotObject.WeakRef(obj)

GodotObject.InstanceFromId(id)

is_instance_id_valid(id)

GodotObject.IsInstanceIdValid(id)

is_instance_valid(obj)

GodotObject.IsInstanceValid(obj)

Sometimes it can be useful to use the using static directive. This directive allows to access the members and nested types of a class without specifying the class name.

List of Godot's global scope functions and their equivalent in C#:

Mathf.AngleDifference

Mathf.BezierDerivative

Mathf.BezierInterpolate

bytes_to_var_with_objects

GD.BytesToVarWithObjects

Mathf.CubicInterpolate

cubic_interpolate_angle

Mathf.CubicInterpolateAngle

cubic_interpolate_angle_in_time

Mathf.CubicInterpolateInTime

cubic_interpolate_in_time

Mathf.CubicInterpolateAngleInTime

GodotObject.InstanceFromId

Mathf.IsFinite or float.IsFinite or double.IsFinite

Mathf.IsInf or float.IsInfinity or double.IsInfinity

GodotObject.IsInstanceIdValid

GodotObject.IsInstanceValid

Mathf.IsNaN or float.IsNaN or double.IsNaN

operator == or object.ReferenceEquals

Use OS.IsStdoutVerbose and GD.Print

Use $ string interpolation

Variant.As<T> or GD.Convert

Variant.Type.ToString

var_to_bytes_with_objects

GD.VarToBytesWithObjects

List of GDScript utility functions and their equivalent in C#:

System.Diagnostics.Debug.Assert

Use explicit conversion: (char)65

System.Environment.StackTrace

GD.Print(System.Environment.StackTrace)

GD.Range or System.Linq.Enumerable.Range

ClassDB.ClassExists(type)

preload, as it works in GDScript, is not available in C#. Use GD.Load or ResourceLoader.Load instead.

Use the [Export] attribute instead of the GDScript @export annotation. This attribute can also be provided with optional PropertyHint and hintString parameters. Default values can be set by assigning a value.

See also: C# exported properties.

Use the [Signal] attribute to declare a signal instead of the GDScript signal keyword. This attribute should be used on a delegate, whose name signature will be used to define the signal. The delegate must have the EventHandler suffix, an event will be generated in the class with the same name but without the suffix, use that event's name with EmitSignal.

See also: C# signals.

GDScript has the ability to defer the initialization of a member variable until the ready function is called with @onready (cf. @onready annotation). For example:

However C# does not have this ability. To achieve the same effect you need to do this.

Singletons are available as static classes rather than using the singleton pattern. This is to make code less verbose than it would be with an Instance property.

However, in some very rare cases this is not enough. For example, you may want to access a member from the base class GodotObject, like Connect. For such use cases we provide a static property named Singleton that returns the singleton instance. The type of this instance is GodotObject.

If you are developing main screen plugins, it is essential to note that EditorInterface is not a static class in C#, unlike in GDScript. Therefore, you must use the singleton pattern to obtain an instance of the EditorInterface:

EditorInterface.Singleton

Use System.String (string). Most of Godot's String methods have an equivalent in System.String or are provided by the StringExtensions class as extension methods.

Note that C# strings use UTF-16 encoding, while Godot Strings use UTF-32 encoding.

Strings are immutable in .NET, so all methods that manipulate a string don't modify the original string and return a newly created string with the modifications applied. To avoid creating multiple string allocations consider using a StringBuilder.

List of Godot's String methods and their equivalent in C#:

StringExtensions.Bigrams

StringExtensions.BinToInt

StringExtensions.CEscape

StringExtensions.CUnescape

StringExtensions.Capitalize

StringExtensions.CasecmpTo or StringExtensions.CompareTo (Consider using string.Equals or string.Compare)

StringExtensions.Count (Consider using RegEx)

StringExtensions.CountN (Consider using RegEx)

StringExtensions.Dedent

string.Remove (Consider using StringBuilder to manipulate strings)

StringExtensions.Find (Consider using string.IndexOf or string.IndexOfAny)

StringExtensions.FindN (Consider using string.IndexOf or string.IndexOfAny)

Use $ string interpolation

StringExtensions.GetBaseDir

StringExtensions.GetBaseName

StringExtensions.GetExtension

StringExtensions.GetFile

StringExtensions.Hash (Consider using object.GetHashCode unless you need to guarantee the same behavior as in GDScript)

StringExtensions.HexDecode (Consider using System.Convert.FromHexString)

StringExtensions.HexToInt (Consider using int.Parse or long.Parse with System.Globalization.NumberStyles.HexNumber)

StringExtensions.Indent

string.Insert (Consider using StringBuilder to manipulate strings)

StringExtensions.IsAbsolutePath

string.IsNullOrEmpty or string.IsNullOrWhiteSpace

StringExtensions.IsRelativePath

StringExtensions.IsSubsequenceOf

StringExtensions.IsSubsequenceOfN

StringExtensions.IsValidFileName

StringExtensions.IsValidFloat (Consider using float.TryParse or double.TryParse)

StringExtensions.IsValidHexNumber

StringExtensions.IsValidHtmlColor

StringExtensions.IsValidIdentifier

StringExtensions.IsValidInt (Consider using int.TryParse or long.TryParse)

StringExtensions.IsValidIPAddress

StringExtensions.JSONEscape

StringExtensions.Left (Consider using string.Substring or string.AsSpan)

StringExtensions.Match (Consider using RegEx)

StringExtensions.MatchN (Consider using RegEx)

StringExtensions.Md5Buffer (Consider using System.Security.Cryptography.MD5.HashData)

StringExtensions.Md5Text (Consider using System.Security.Cryptography.MD5.HashData with StringExtensions.HexEncode)

N/A (Consider using string.Equals or string.Compare)

StringExtensions.NocasecmpTo or StringExtensions.CompareTo (Consider using string.Equals or string.Compare)

float.ToString or double.ToString

int.ToString or long.ToString

float.ToString or double.ToString

uint.ToString or ulong.ToString

StringExtensions.PadDecimals

StringExtensions.PadZeros

StringExtensions.PathJoin

Use string constructor or a StringBuilder

string.Replace or RegEx

StringExtensions.ReplaceN (Consider using string.Replace or RegEx)

StringExtensions.RFind (Consider using string.LastIndexOf or string.LastIndexOfAny)

StringExtensions.RFindN (Consider using string.LastIndexOf or string.LastIndexOfAny)

StringExtensions.Right (Consider using string.Substring or string.AsSpan)

StringExtensions.Sha1Buffer (Consider using System.Security.Cryptography.SHA1.HashData)

StringExtensions.Sha1Text (Consider using System.Security.Cryptography.SHA1.HashData with StringExtensions.HexEncode)

StringExtensions.Sha256Buffer (Consider using System.Security.Cryptography.SHA256.HashData)

StringExtensions.Sha256Text (Consider using System.Security.Cryptography.SHA256.HashData with StringExtensions.HexEncode)

StringExtensions.Similarity

StringExtensions.SimplifyPath

StringExtensions.Split (Consider using string.Split)

StringExtensions.SplitFloat

StringExtensions.StripEdges (Consider using string.Trim, string.TrimStart or string.TrimEnd)

StringExtensions.StripEscapes

StringExtensions.Substr (Consider using string.Substring or string.AsSpan)

StringExtensions.ToAsciiBuffer (Consider using System.Text.Encoding.ASCII.GetBytes)

StringExtensions.ToCamelCase

StringExtensions.ToFloat (Consider using float.TryParse or double.TryParse)

StringExtensions.ToInt (Consider using int.TryParse or long.TryParse)

StringExtensions.ToPascalCase

StringExtensions.ToSnakeCase

StringExtensions.ToUtf16Buffer (Consider using System.Text.Encoding.UTF16.GetBytes)

StringExtensions.ToUtf32Buffer (Consider using System.Text.Encoding.UTF32.GetBytes)

StringExtensions.ToUtf8Buffer (Consider using System.Text.Encoding.UTF8.GetBytes)

StringExtensions.ToUtf16Buffer in Windows and StringExtensions.ToUtf32Buffer in other platforms

StringExtensions.TrimPrefix

StringExtensions.TrimSuffix

StringExtensions.URIDecode (Consider using System.Uri.UnescapeDataString)

StringExtensions.URIEncode (Consider using System.Uri.EscapeDataString)

StringExtensions.ValidateNodeName

StringExtensions.XMLEscape

StringExtensions.XMLUnescape

List of Godot's PackedByteArray methods that create a String and their C# equivalent:

get_string_from_ascii

StringExtensions.GetStringFromAscii (Consider using System.Text.Encoding.ASCII.GetString)

get_string_from_utf16

StringExtensions.GetStringFromUtf16 (Consider using System.Text.Encoding.UTF16.GetString)

get_string_from_utf32

StringExtensions.GetStringFromUtf32 (Consider using System.Text.Encoding.UTF32.GetString)

StringExtensions.GetStringFromUtf8 (Consider using System.Text.Encoding.UTF8.GetString)

StringExtensions.HexEncode (Consider using System.Convert.ToHexString)

.NET provides path utility methods under the System.IO.Path class. They can only be used with native OS paths, not Godot paths (paths that start with res:// or user://). See File paths in Godot projects.

The following method was converted to a property with a different name:

The following methods were converted to properties with their respective names changed:

The Signal type implements the awaitable pattern which means it can be used with the await keyword. See await keyword.

Instead of using the Signal type, the recommended way to use Godot signals in C# is to use the generated C# events. See C# signals.

The following methods were converted to properties with their respective names changed:

Currently C# supports Callable if one of the following holds:

Callable was created using the C# Callable type.

Callable is a basic version of the engine's Callable. Custom Callables are unsupported. A Callable is custom when any of the following holds:

Callable has bound information (Callables created with bind/unbind are unsupported).

Callable was created from other languages through the GDExtension API.

Some methods such as bind and unbind are not implemented, use lambdas instead:

The lambda captures the name variable so it can be bound to the SayHello method.

This type is named Rid in C# to follow the .NET naming convention.

The following methods were converted to properties with their respective names changed:

Structs cannot have parameterless constructors in C#. Therefore, new Basis() initializes all primitive members to their default value. Use Basis.Identity for the equivalent of Basis() in GDScript and C++.

The following method was converted to a property with a different name:

Structs cannot have parameterless constructors in C#. Therefore, new Transform2D() initializes all primitive members to their default value. Please use Transform2D.Identity for the equivalent of Transform2D() in GDScript and C++.

The following methods were converted to properties with their respective names changed:

Structs cannot have parameterless constructors in C#. Therefore, new Transform3D() initializes all primitive members to their default value. Please use Transform3D.Identity for the equivalent of Transform3D() in GDScript and C++.

The following methods were converted to properties with their respective names changed:

The following field was converted to a property with a slightly different name:

The following method was converted to a property with a different name:

This type is named Rect2I in C# to follow the .NET naming convention.

The following field was converted to a property with a slightly different name:

The following method was converted to a property with a different name:

This type is named Aabb in C# to follow the .NET naming convention.

The following method was converted to a property with a different name:

Structs cannot have parameterless constructors in C#. Therefore, new Quaternion() initializes all primitive members to their default value. Please use Quaternion.Identity for the equivalent of Quaternion() in GDScript and C++.

Structs cannot have parameterless constructors in C#. Therefore, new Projection() initializes all primitive members to their default value. Please use Projection.Identity for the equivalent of Projection() in GDScript and C++.

Structs cannot have parameterless constructors in C#. Therefore, new Color() initializes all primitive members to their default value (which represents the transparent black color). Please use Colors.Black for the equivalent of Color() in GDScript and C++.

The global Color8 method to construct a Color from bytes is available as a static method in the Color type.

The Color constants are available in the Colors static class as readonly properties.

The following method was converted to a property with a different name:

The following method was converted to a method with a different name:

FromHtml(ReadOnlySpan<char>)

The following methods are available as constructors:

The equivalent of packed arrays are System.Array.

See also PackedArray in C#.

Use Godot.Collections.Array for an untyped Variant array. Godot.Collections.Array<T> is a type-safe wrapper around Godot.Collections.Array.

See also Array in C#.

Use Godot.Collections.Dictionary for an untyped Variant dictionary. Godot.Collections.Dictionary<TKey, TValue> is a type-safe wrapper around Godot.Collections.Dictionary.

See also Dictionary in C#.

Godot.Variant is used to represent Godot's native Variant type. Any Variant-compatible type can be converted from/to it.

See also: C# Variant.

This is explained extensively in Cross-language scripting.

Something similar to GDScript's await keyword can be achieved with C#'s await keyword.

The await keyword in C# can be used with any awaitable expression. It's commonly used with operands of the types Task, Task<TResult>, ValueTask, or ValueTask<TResult>.

An expression t is awaitable if one of the following holds:

t is of compile-time type dynamic.

t has an accessible instance or extension method called GetAwaiter with no parameters and no type parameters, and a return type A for which all of the following hold:

A implements the interface System.Runtime.CompilerServices.INotifyCompletion.

A has an accessible, readable instance property IsCompleted of type bool.

A has an accessible instance method GetResult with no parameters and no type parameters.

An equivalent of awaiting a signal in GDScript can be achieved with the await keyword and GodotObject.ToSignal.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (csharp):
```csharp
using static Godot.GD;

public class Test
{
    static Test()
    {
        Print("Hello"); // Instead of GD.Print("Hello");
    }
}
```

Example 2 (unknown):
```unknown
using Godot;

public partial class MyNode : Node
{
    [Export]
    private NodePath _nodePath;

    [Export]
    private string _name = "default";

    [Export(PropertyHint.Range, "0,100000,1000,or_greater")]
    private int _income;

    [Export(PropertyHint.File, "*.png,*.jpg")]
    private string _icon;
}
```

Example 3 (unknown):
```unknown
[Signal]
delegate void MySignalEventHandler(string willSendAString);
```

Example 4 (unknown):
```unknown
@onready var my_label = get_node("MyLabel")
```

---

## C# basics — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_basics.html

**Contents:**
- C# basics
- Introduction
- Prerequisites
- Configuring an external editor
  - JetBrains Rider
  - Visual Studio Code
  - Visual Studio (Windows only)
- Creating a C# script
- Project setup and workflow
- Example

This page provides a brief introduction to C#, both what it is and how to use it in Godot. Afterwards, you may want to look at how to use specific features, read about the differences between the C# and the GDScript API, and (re)visit the Scripting section of the step-by-step tutorial.

C# is a high-level programming language developed by Microsoft. In Godot, it is implemented with .NET 8.0.

Projects written in C# using Godot 4 currently cannot be exported to the web platform. To use C# on the web platform, consider Godot 3 instead. Android and iOS platform support is available as of Godot 4.2, but is experimental and some limitations apply.

This is not a full-scale tutorial on the C# language as a whole. If you aren't already familiar with its syntax or features, see the Microsoft C# guide or look for a suitable introduction elsewhere.

Godot bundles the parts of .NET needed to run already compiled games. However, Godot does not bundle the tools required to build and compile games, such as MSBuild and the C# compiler. These are included in the .NET SDK, and need to be installed separately.

In summary, you must have installed the .NET SDK and the .NET-enabled version of Godot.

Download and install the latest stable version of the SDK from the .NET download page.

Be sure to install the 64-bit version of the SDK(s) if you are using the 64-bit version of Godot.

If you are building Godot from source, make sure to follow the steps to enable .NET support in your build as outlined in the Compiling with .NET page.

C# support in Godot's built-in script editor is minimal. Consider using an external IDE or editor, such as Visual Studio Code or Visual Studio. These provide autocompletion, debugging, and other useful features for C#. To select an external editor in Godot, click on Editor → Editor Settings and scroll down to Dotnet. Under Dotnet, click on Editor, and select your external editor of choice. Godot currently supports the following external editors:

Visual Studio for Mac

See the following sections for how to configure an external editor:

After reading the "Prerequisites" section, you can download and install JetBrains Rider.

In Godot's Editor → Editor Settings menu:

Set Dotnet -> Editor -> External Editor to JetBrains Rider.

Set MSBuild version to .NET Core.

If you are using a Rider version below 2024.2, install the Godot support plugin. This functionality is now built into Rider.

After reading the "Prerequisites" section, you can download and install Visual Studio Code (aka VS Code).

In Godot's Editor → Editor Settings menu:

Set Dotnet -> Editor -> External Editor to Visual Studio Code.

In Visual Studio Code:

Install the C# extension.

To configure a project for debugging, you need a tasks.json and launch.json file in the .vscode folder with the necessary configuration.

Here is an example launch.json:

For this launch configuration to work, you need to either setup a GODOT4 environment variable that points to the Godot executable, or replace program parameter with the path to the Godot executable.

Here is an example tasks.json:

Now, when you start the debugger in Visual Studio Code, your Godot project will run.

Download and install the latest version of Visual Studio. Visual Studio will include the required SDKs if you have the correct workloads selected, so you don't need to manually install the things listed in the "Prerequisites" section.

While installing Visual Studio, select this workload:

.NET desktop development

In Godot's Editor → Editor Settings menu:

Set Dotnet -> Editor -> External Editor to Visual Studio.

If you see an error like "Unable to find package Godot.NET.Sdk", your NuGet configuration may be incorrect and need to be fixed.

A simple way to fix the NuGet configuration file is to regenerate it. In a file explorer window, go to %AppData%\NuGet. Rename or delete the NuGet.Config file. When you build your Godot project again, the file will be automatically created with default values.

To debug your C# scripts using Visual Studio, open the .sln file that is generated after opening the first C# script in the editor. In the Debug menu, go to the Debug Properties menu item for your project. Click the Create a new profile button and choose Executable. In the Executable field, browse to the path of the C# version of the Godot editor, or type %GODOT4% if you have created an environment variable for the Godot executable path. It must be the path to the main Godot executable, not the 'console' version. For the Working Directory, type a single period, ., meaning the current directory. Also check the Enable native code debugging checkbox. You may now close this window, click downward arrow on the debug profile dropdown, and select your new launch profile. Hit the green start button, and your game will begin playing in debug mode.

After you successfully set up C# for Godot, you should see the following option when selecting Attach Script in the context menu of a node in your scene:

Note that while some specifics change, most concepts work the same when using C# for scripting. If you're new to Godot, you may want to follow the tutorials on Scripting languages at this point. While some documentation pages still lack C# examples, most notions can be transferred from GDScript.

When you create the first C# script, Godot initializes the C# project files for your Godot project. This includes generating a C# solution (.sln) and a project file (.csproj), as well as some utility files and folders (.godot/mono). All of these but .godot/mono are important and should be committed to your version control system. Everything under .godot can be safely added to the ignore list of your VCS. When troubleshooting, it can sometimes help to delete the .godot/mono folder and let it regenerate.

Here's a blank C# script with some comments to demonstrate how it works.

As you can see, functions normally in global scope in GDScript like Godot's print function are available in the GD static class which is part of the Godot namespace. For a full list of methods in the GD class, see the class reference pages for @GDScript and @GlobalScope.

Keep in mind that the class you wish to attach to your node should have the same name as the .cs file. Otherwise, you will get the following error:

"Cannot find class XXX for script res://XXX.cs"

The C# API uses PascalCase instead of snake_case in GDScript/C++. Where possible, fields and getters/setters have been converted to properties. In general, the C# Godot API strives to be as idiomatic as is reasonably possible.

For more information, see the C# API differences to GDScript page.

You need to (re)build the project assemblies whenever you want to see new exported variables or signals in the editor. This build can be manually triggered by clicking the Build button in the top right corner of the editor.

You will also need to rebuild the project assemblies to apply changes in "tool" scripts.

As C# support is quite new in Godot, there are some growing pains and things that need to be ironed out. Below is a list of the most important issues you should be aware of when diving into C# in Godot, but if in doubt, also take a look over the official issue tracker for .NET issues.

Writing editor plugins is possible, but it is currently quite convoluted.

State is currently not saved and restored when hot-reloading, with the exception of exported variables.

Attached C# scripts should refer to a class that has a class name that matches the file name.

There are some methods such as Get()/Set(), Call()/CallDeferred() and signal connection method Connect() that rely on Godot's snake_case API naming conventions. So when using e.g. CallDeferred("AddChild"), AddChild will not work because the API is expecting the original snake_case version add_child. However, you can use any custom properties or methods without this limitation. Prefer using the exposed StringName in the PropertyName, MethodName and SignalName to avoid extra StringName allocations and worrying about snake_case naming.

As of Godot 4.0, exporting .NET projects is supported for desktop platforms (Linux, Windows and macOS). Other platforms will gain support in future 4.x releases.

You might encounter the following error when trying to modify some values in Godot objects, e.g. when trying to change the X coordinate of a Node2D:

This is perfectly normal. Structs (in this example, a Vector2) in C# are copied on assignment, meaning that when you retrieve such an object from a property or an indexer, you get a copy of it, not the object itself. Modifying said copy without reassigning it afterwards won't achieve anything.

The workaround is simple: retrieve the entire struct, modify the value you want to modify, and reassign the property.

Since C# 10, it is also possible to use with expressions on structs, allowing you to do the same thing in a single line.

You can read more about this error on the C# language reference.

For a performance comparison of the languages Godot supports, see Which programming language is fastest?.

Most properties of Godot C# objects that are based on GodotObject (e.g. any Node like Control or Node3D like Camera3D) require native (interop) calls as they talk to Godot's C++ core. Consider assigning values of such properties into a local variable if you need to modify or read them multiple times at a single code location:

Passing raw arrays (such as byte[]) or string to Godot's C# API requires marshalling which is comparatively pricey.

The implicit conversion from string to NodePath or StringName incur both the native interop and marshalling costs as the string has to be marshalled and passed to the respective native constructor.

NuGet packages can be installed and used with Godot, as with any C# project. Many IDEs are able to add packages directly. They can also be added manually by adding the package reference in the .csproj file located in the project root:

As of Godot 3.2.3, Godot automatically downloads and sets up newly added NuGet packages the next time it builds the project.

The following tools may be used for performance and memory profiling of your managed code:

JetBrains Rider with dotTrace/dotMemory plugin.

Standalone JetBrains dotTrace/dotMemory.

Profiling managed and unmanaged code at once is possible with both JetBrains tools and Visual Studio, but limited to Windows.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Play",
            "type": "coreclr",
            "request": "launch",
            "preLaunchTask": "build",
            "program": "${env:GODOT4}",
            "args": [],
            "cwd": "${workspaceFolder}",
            "stopAtEntry": false,
        }
    ]
}
```

Example 2 (unknown):
```unknown
{
    "version": "2.0.0",
    "tasks": [
        {
            "label": "build",
            "command": "dotnet",
            "type": "process",
            "args": [
                "build"
            ],
            "problemMatcher": "$msCompile"
        }
    ]
}
```

Example 3 (unknown):
```unknown
using Godot;

public partial class YourCustomClass : Node
{
    // Member variables here, example:
    private int _a = 2;
    private string _b = "textvar";

    public override void _Ready()
    {
        // Called every time the node is added to the scene.
        // Initialization here.
        GD.Print("Hello from C# to Godot :)");
    }

    public override void _Process(double delta)
    {
        // Called every frame. Delta is time since the last frame.
        // Update game logic here.
    }
}
```

Example 4 (unknown):
```unknown
public partial class MyNode2D : Node2D
{
    public override void _Ready()
    {
        Position.X = 100.0f;
        // CS1612: Cannot modify the return value of 'Node2D.Position' because
        // it is not a variable.
    }
}
```

---

## C# collections — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_collections.html

**Contents:**
- C# collections
- Choose a collection
- Godot collections
  - PackedArray
  - Array
  - Dictionary
- User-contributed notes

The .NET base class library contains multiple collection types that can be used to store and manipulate data. Godot also provide some collection types that are tightly integrated with the rest of the engine.

The main difference between the .NET collections and the Godot collections is that the .NET collections are implemented in C# while the Godot collections are implemented in C++ and the Godot C# API is a wrapper over it, this is an important distinction since it means every operation on a Godot collection requires marshaling which can be expensive especially inside a loop.

Due to the performance implications, using Godot collections is only recommended when absolutely necessary (such as interacting with the Godot API). Godot only understands its own collection types, so it's required to use them when talking to the engine.

If you have a collection of elements that don't need to be passed to a Godot API, using a .NET collection would be more performant.

It's also possible to convert between .NET collections and Godot collections. The Godot collections contain constructors from generic .NET collection interfaces that copy their elements, and the Godot collections can be used with the LINQ ToList, ToArray and ToDictionary methods. But keep in mind this conversion requires marshaling every element in the collection and copies it to a new collection so it can be expensive.

Despite this, the Godot collections are optimized to try and avoid unnecessary marshaling, so methods like Sort or Reverse are implemented with a single interop call and don't need to marshal every element. Keep an eye out for generic APIs that take collection interfaces like LINQ because every method requires iterating the collection and, therefore, marshaling every element. Prefer using the instance methods of the Godot collections when possible.

To choose which collection type to use for each situation, consider the following questions:

Does your collection need to interact with the Godot engine? (e.g.: the type of an exported property, calling a Godot method).

If yes, since Godot only supports Variant-compatible types, use a Godot collection.

If not, consider choosing an appropriate .NET collection.

Do you need a Godot collection that represents a list or sequential set of data?

Godot arrays are similar to the C# collection List<T>.

Godot packed arrays are more memory-efficient arrays, in C# use one of the supported System.Array types.

Do you need a Godot collection that maps a set of keys to a set of values?

Godot dictionaries store pairs of keys and values and allow easy access to the values by their associated key.

Godot packed arrays are implemented as an array of a specific type, allowing it to be more tightly packed as each element has the size of the specific type, not Variant.

In C#, packed arrays are replaced by System.Array:

Other C# arrays are not supported by the Godot C# API since a packed array equivalent does not exist. See the list of Variant-compatible types.

Godot arrays are implemented as an array of Variant and can contain several elements of any type. In C#, the equivalent type is Godot.Collections.Array.

The generic Godot.Collections.Array<T> type allows restricting the element type to a Variant-compatible type.

An untyped Godot.Collections.Array can be converted to a typed array using the Godot.Collections.Array<T>(Godot.Collections.Array) constructor.

Despite the name, Godot arrays are more similar to the C# collection List<T> than System.Array. Their size is not fixed and can grow or shrink as elements are added/removed from the collection.

List of Godot's Array methods and their equivalent in C#:

System.Linq.Enumerable.All

System.Linq.Enumerable.Any

Array[^1] or System.Linq.Enumerable.Last or System.Linq.Enumerable.LastOrDefault

System.Linq.Enumerable.Count

Use System.Linq.Enumerable.Where

Array[0] or System.Linq.Enumerable.First or System.Linq.Enumerable.FirstOrDefault

System.Linq.Enumerable.Select

PickRandom (Consider using System.Random)

Array[i] with RemoveAt(i)

Array[^1] with RemoveAt(Count - 1)

Array[0] with RemoveAt(0)

System.Linq.Enumerable.Aggregate

System.Linq.Enumerable.OrderBy

Godot dictionaries are implemented as a dictionary with Variant keys and values. In C#, the equivalent type is Godot.Collections.Dictionary.

The generic Godot.Collections.Dictionary<TKey, TValue> type allows restricting the key and value types to a Variant-compatible type.

An untyped Godot.Collections.Dictionary can be converted to a typed dictionary using the Godot.Collections.Dictionary<TKey, TValue>(Godot.Collections.Dictionary) constructor.

If you need a dictionary where the key is typed but not the value, use Variant as the TValue generic parameter of the typed dictionary.

List of Godot's Dictionary methods and their equivalent in C#:

Dictionary[Variant] indexer or TryGetValue

Dictionary[Variant] indexer, Add or TryGetValue

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
// The keys must be string, but the values can be any Variant-compatible type.
var dictionary = new Godot.Collections.Dictionary<string, Variant>();
```

---

## C# diagnostics — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/index.html

**Contents:**
- C# diagnostics
- Rules

Godot includes analyzers that inspect your C# source code to check for invalid or unsupported code and let you know that something is wrong during build time.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## C# exported properties — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_exports.html

**Contents:**
- C# exported properties
- Basic use
- Grouping exports
- Strings as paths
- Limiting editor input ranges
- Floats with easing hint
- Export with suffix hint
- Colors
- Nodes
- Resources

In Godot, class members can be exported. This means their value gets saved along with the resource (such as the scene) they're attached to. They will also be available for editing in the property editor. Exporting is done by using the [Export] attribute.

In that example the value 5 will be saved, and after building the current project it will be visible in the property editor.

One of the fundamental benefits of exporting member variables is to have them visible and editable in the editor. This way, artists and game designers can modify values that later influence how the program runs. For this, a special export syntax is provided.

Exporting can only be done with Variant-compatible types.

Exporting properties can also be done in GDScript, for information on that see GDScript exported properties.

Exporting works with fields and properties. They can have any access modifier.

Exported members can specify a default value; otherwise, the default value of the type is used instead.

An int like Number defaults to 0. Text defaults to null because string is a reference type.

Default values can be specified for fields and properties.

Properties with a backing field use the default value of the backing field.

A property's get is not actually executed to determine the default value. Instead, Godot analyzes the C# source code. This works fine for most cases, such as the examples on this page. However, some properties are too complex for the analyzer to understand.

For example, the following property attempts to use math to display the default value as 5 in the property editor, but it doesn't work:

The analyzer doesn't understand this code and falls back to the default value for int, 0. However, when running the scene or inspecting a node with an attached tool script, _number will be 2, and NumberWithBackingField will return 5. This difference may cause confusing behavior. To avoid this, don't use complex properties. Alternatively, if the default value can be explicitly specified, it can be overridden with the _PropertyCanRevert() and _PropertyGetRevert() methods.

Any type of Resource or Node can be exported. The property editor shows a user-friendly assignment dialog for these types. This can be used instead of GD.Load and GetNode. See Nodes and Resources.

It is possible to group your exported properties inside the Inspector with the [ExportGroup] attribute. Every exported property after this attribute will be added to the group. Start a new group or use [ExportGroup("")] to break out.

The second argument of the attribute can be used to only group properties with the specified prefix.

Groups cannot be nested, use [ExportSubgroup] to create subgroups within a group.

You can also change the name of your main category, or create additional categories in the property list with the [ExportCategory] attribute.

The list of properties is organized based on the class inheritance, and new categories break that expectation. Use them carefully, especially when creating projects for public use.

Property hints can be used to export strings as paths

String as a path to a file.

String as a path to a directory.

String as a path to a file, custom filter provided as hint.

Using paths in the global filesystem is also possible, but only in scripts in tool mode.

String as a path to a PNG file in the global filesystem.

String as a path to a directory in the global filesystem.

The multiline annotation tells the editor to show a large input field for editing over multiple lines.

Using the range property hint allows you to limit what can be input as a value using the editor.

Allow integer values from 0 to 20.

Allow integer values from -10 to 20.

Allow floats from -10 to 20 and snap the value to multiples of 0.2.

If you add the hints "or_greater" and/or "or_less" you can go above or below the limits when adjusting the value by typing it instead of using the slider.

Display a visual representation of the ease function when editing.

Display a unit hint suffix for exported variables. Works with numeric types, such as floats or vectors:

In the above example, \u00b2 is used to write the "squared" character (²).

Regular color given as red-green-blue-alpha value.

Color given as red-green-blue value (alpha will always be 1).

Since Godot 4.0, nodes can be directly exported without having to use NodePaths.

A specific type of node can also be directly exported. The list of nodes shown after pressing "Assign" in the inspector is filtered to the specified type, and only a correct node can be assigned.

Custom node classes can also be exported directly. The filtering behavior depends on whether the custom class is a global class.

Exporting NodePaths like in Godot 3.x is still possible, in case you need it:

In the Inspector, you can then drag and drop a resource file from the FileSystem dock into the variable slot.

Opening the inspector dropdown may result in an extremely long list of possible classes to create, however. Therefore, if you specify a type derived from Resource such as:

The drop-down menu will be limited to AnimationNode and all its derived classes. Custom resource classes can also be used, see C# global classes.

It must be noted that even if the script is not being run while in the editor, the exported properties are still editable. This can be used in conjunction with a script in "tool" mode.

Members whose type is an enum with the [Flags] attribute can be exported and their values are limited to the members of the enum type. The editor will create a widget in the Inspector, allowing to select none, one, or multiple of the enum members. The value will be stored as an integer.

A flags enum uses powers of 2 for the values of the enum members. Members that combine multiple flags using logical OR (|) are also possible.

Integers used as bit flags can store multiple true/false (boolean) values in one property. By using the Flags property hint, any of the given flags can be set from the editor.

You must provide a string description for each flag. In this example, Fire has value 1, Water has value 2, Earth has value 4 and Wind corresponds to value 8. Usually, constants should be defined accordingly (e.g. private const int ElementWind = 8 and so on).

You can add explicit values using a colon:

Only power of 2 values are valid as bit flags options. The lowest allowed value is 1, as 0 means that nothing is selected. You can also add options that are a combination of other flags:

Export annotations are also provided for the physics and render layers defined in the project settings.

Using bit flags requires some understanding of bitwise operations. If in doubt, use boolean variables instead.

Members whose type is an enum can be exported and their values are limited to the members of the enum type. The editor will create a widget in the Inspector, enumerating the following as "Thing 1", "Thing 2", "Another Thing". The value will be stored as an integer.

Integer and string members can also be limited to a specific list of values using the [Export] annotation with the PropertyHint.Enum hint. The editor will create a widget in the Inspector, enumerating the following as Warrior, Magician, Thief. The value will be stored as an integer, corresponding to the index of the selected option (i.e. 0, 1, or 2).

You can add explicit values using a colon:

If the type is string, the value will be stored as a string.

If you want to set an initial value, you must specify it explicitly:

If you want to create a clickable button in the inspector, you can use the [ExportToolButton] attribute. This exports a Callable property or field as a clickable button. Since this runs in the editor, usage of the [Tool] attribute is required. When the button is pressed, the callable is called:

You can also set an icon for the button with a second argument. If specified, an icon will be fetched via GetThemeIcon(), from the "EditorIcons" theme type.

As explained in the C# Variant documentation, only certain C# arrays and the collection types defined in the Godot.Collections namespace are Variant-compatible, therefore, only those types can be exported.

Using the generic Godot.Collections.Array<T> allows specifying the type of the array elements, which will be used as a hint for the editor. The Inspector will restrict the elements to the specified type.

The default value of Godot arrays is null. A different default can be specified:

Arrays with specified types which inherit from resource can be set by drag-and-dropping multiple files from the FileSystem dock.

Using the generic Godot.Collections.Dictionary<TKey, TValue> allows specifying the types of the key and value elements of the dictionary.

The default value of Godot dictionaries is null. A different default can be specified:

C# arrays can exported as long as the element type is a Variant-compatible type.

The default value of C# arrays is null. A different default can be specified:

When changing an exported variable's value from a script in Tool mode, the value in the inspector won't be updated automatically. To update it, call NotifyPropertyListChanged() after setting the exported variable's value.

Not every type of export can be provided on the level of the language itself to avoid unnecessary design complexity. The following describes some more or less common exporting features which can be implemented with a low-level API.

Before reading further, you should get familiar with the way properties are handled and how they can be customized with _Set(), _Get(), and _GetPropertyList() methods as described in Accessing data or logic from an object.

For binding properties using the above methods in C++, see Binding properties using _set/_get/_get_property_list.

The script must operate in the tool mode so the above methods can work from within the editor.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (csharp):
```csharp
using Godot;

public partial class ExportExample : Node3D
{
    [Export]
    public int Number { get; set; } = 5;
}
```

Example 2 (csharp):
```csharp
[Export]
private int _number;

[Export]
public int Number { get; set; }
```

Example 3 (csharp):
```csharp
[Export]
public int Number { get; set; }

[Export]
public string Text { get; set; }
```

Example 4 (csharp):
```csharp
[Export]
private string _greeting = "Hello World";

[Export]
public string Greeting { get; set; } = "Hello World";
```

---

## C# global classes — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_global_classes.html

**Contents:**
- C# global classes
- User-contributed notes

Global classes (also known as named scripts) are types registered in Godot's editor so they can be used more conveniently. In GDScript, this is achieved using the class_name keyword at the top of a script. This page describes how to achieve the same effect in C#.

Global classes show up in the Add Node and Create Resource dialogs.

If an exported property is a global class, the inspector restricts assignment, allowing only instances of that global class or any derived classes.

Global classes are registered with the [GlobalClass] attribute.

The file name must match the class name in case-sensitive fashion. For example, a global class named "MyNode" must have a file name of MyNode.cs, not myNode.cs.

The MyNode type will be registered as a global class with the same name as the type's name.

The Select a Node window for the MyNode exported property filters the list of nodes in the scene to match the assignment restriction.

If a custom type isn't registered as a global class, the assignment is restricted to the Godot type the custom type is based on. For example, inspector assignments to an export of the type MySimpleSprite2D are restricted to Sprite2D and derived types.

When combined with the [GlobalClass] attribute, the [Icon] attribute allows providing a path to an icon to show when the class is displayed in the editor.

The Stats class is a custom resource registered as a global class. Exporting properties of the type Stats will only allow instances of this resource type to be assigned, and the inspector will let you create and load instances of this type easily.

The Godot editor will hide these custom classes with names that begin with the prefix "Editor" in the "Create New Node" or "Create New Scene" dialog windows. The classes are available for instantiation at runtime via their class names, but are automatically hidden by the editor windows along with the built-in editor nodes used by the Godot editor.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
using Godot;

[GlobalClass]
public partial class MyNode : Node
{
}
```

Example 2 (csharp):
```csharp
public partial class Main : Node
{
    [Export]
    public MyNode MyNode { get; set; }
}
```

Example 3 (unknown):
```unknown
public partial class MySimpleSprite2D : Sprite2D
{
}
```

Example 4 (csharp):
```csharp
using Godot;

[GlobalClass, Icon("res://Stats/StatsIcon.svg")]
public partial class Stats : Resource
{
    [Export]
    public int Strength { get; set; }

    [Export]
    public int Defense { get; set; }

    [Export]
    public int Speed { get; set; }
}
```

---

## C++ (godot-cpp) — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/cpp/index.html

**Contents:**
- C++ (godot-cpp)

This section documents godot-cpp, the official C++ GDExtension bindings maintained as part of the Godot project.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## C# language features — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_features.html

**Contents:**
- C# language features
- Type conversion and casting
- Preprocessor defines
  - Examples
  - Full list of defines
- User-contributed notes

This page provides an overview of the commonly used features of both C# and Godot and how they are used together.

C# is a statically typed language. Therefore, you can't do the following:

The method GetNode() returns a Node instance. You must explicitly convert it to the desired derived type, Sprite2D in this case.

For this, you have various options in C#.

Casting and Type Checking

Throws InvalidCastException if the returned node cannot be cast to Sprite2D. You would use it instead of the as operator if you are pretty sure it won't fail.

Using the AS operator

The as operator returns null if the node cannot be cast to Sprite2D, and for that reason, it cannot be used with value types.

Using the generic methods

Generic methods are also provided to make this type conversion transparent.

GetNode<T>() casts the node before returning it. It will throw an InvalidCastException if the node cannot be cast to the desired type.

GetNodeOrNull<T>() uses the as operator and will return null if the node cannot be cast to the desired type.

Type checking using the IS operator

To check if the node can be cast to Sprite2D, you can use the is operator. The is operator returns false if the node cannot be cast to Sprite2D, otherwise it returns true. Note that when the is operator is used against null the result is always going to be false.

You can also declare a new variable to conditionally store the result of the cast if the is operator returns true.

For more advanced type checking, you can look into Pattern Matching.

Godot has a set of defines that allow you to change your C# code depending on the environment you are compiling to.

For example, you can change code based on the platform:

Or you can detect which engine your code is in, useful for making cross-engine libraries:

Or you can write scripts that target multiple Godot versions and take advantage of features that are only available on some of those versions:

GODOT is always defined for Godot projects.

TOOLS is defined when building with the Debug configuration (editor and editor player).

GODOT_REAL_T_IS_DOUBLE is defined when the GodotFloat64 property is set to true.

One of GODOT_LINUXBSD, GODOT_WINDOWS, GODOT_OSX, GODOT_ANDROID, GODOT_IOS, GODOT_WEB depending on the OS. These names may change in the future. These are created from the get_name() method of the OS singleton, but not every possible OS the method returns is an OS that Godot with .NET runs on.

GODOTX, GODOTX_Y, GODOTX_Y_Z, GODOTx_OR_GREATER, GODOTX_y_OR_GREATER, and GODOTX_Y_z_OR_GREATER, where X, Y, and Z are replaced by the current major, minor and patch version of Godot. x, y, and z are replaced by all values from 0 to the current version number for that component.

These defines were first added in Godot 4.0.4 and 4.1. Version defines for prior versions do not exist, regardless of the current Godot version.

For example: Godot 4.0.5 defines GODOT4, GODOT4_OR_GREATER, GODOT4_0, GODOT4_0_OR_GREATER, GODOT4_0_5, GODOT4_0_4_OR_GREATER, and GODOT4_0_5_OR_GREATER. Godot 4.3.2 defines GODOT4, GODOT4_OR_GREATER, GODOT4_3, GODOT4_0_OR_GREATER, GODOT4_1_OR_GREATER, GODOT4_2_OR_GREATER, GODOT4_3_OR_GREATER, GODOT4_3_2, GODOT4_3_0_OR_GREATER, GODOT4_3_1_OR_GREATER, and GODOT4_3_2_OR_GREATER.

When exporting, the following may also be defined depending on the export features:

One of GODOT_PC, GODOT_MOBILE, or GODOT_WEB depending on the platform type.

One of GODOT_WINDOWS, GODOT_LINUXBSD, GODOT_MACOS, GODOT_ANDROID, GODOT_IOS, or GODOT_WEB depending on the platform.

To see an example project, see the OS testing demo: https://github.com/godotengine/godot-demo-projects/tree/master/misc/os_test

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
var mySprite = GetNode("MySprite");
mySprite.SetFrame(0);
```

Example 2 (unknown):
```unknown
Sprite2D mySprite = (Sprite2D)GetNode("MySprite");
mySprite.SetFrame(0);
```

Example 3 (unknown):
```unknown
Sprite2D mySprite = GetNode("MySprite") as Sprite2D;
// Only call SetFrame() if mySprite is not null
mySprite?.SetFrame(0);
```

Example 4 (unknown):
```unknown
Sprite2D mySprite = GetNode<Sprite2D>("MySprite");
mySprite.SetFrame(0);
```

---

## C# signals — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_signals.html

**Contents:**
- C# signals
- Signals as C# events
- Custom signals as C# events
- Signal emission
- Bound values
- Signal creation at runtime
- Using Connect and Disconnect
- Disconnecting automatically when the receiver is freed
  - No automatic disconnection: a lambda expression that captures a variable
  - No automatic disconnection: a custom signal

For a detailed explanation of signals in general, see the Using signals section in the step by step tutorial.

Signals are implemented using C# events, the idiomatic way to represent the observer pattern in C#. This is the recommended way to use signals in C# and the focus of this page.

In some cases it's necessary to use the older Connect() and Disconnect() APIs. See Using Connect and Disconnect for more details.

If you encounter a System.ObjectDisposedException while handling a signal, you might be missing a signal disconnection. See Disconnecting automatically when the receiver is freed for more details.

To provide more type-safety, Godot signals are also all available through events. You can handle these events, as any other event, with the += and -= operators.

In addition, you can always access signal names associated with a node type through its nested SignalName class. This is useful when, for example, you want to await on a signal (see await keyword).

To declare a custom event in your C# script, use the [Signal] attribute on a public delegate type. Note that the name of this delegate needs to end with EventHandler.

Once this is done, Godot will create the appropriate events automatically behind the scenes. You can then use said events as you'd do for any other Godot signal. Note that events are named using your delegate's name minus the final EventHandler part.

If you want to connect to these signals in the editor, you will need to (re)build the project to see them appear.

You can click the Build button in the upper-right corner of the editor to do so.

To emit signals, use the EmitSignal method. Note that, as for signals defined by the engine, your custom signal names are listed under the nested SignalName class.

In contrast with other C# events, you cannot use Invoke to raise events tied to Godot signals.

Signals support arguments of any Variant-compatible type.

Consequently, any Node or RefCounted will be compatible automatically, but custom data objects will need to inherit from GodotObject or one of its subclasses.

Sometimes you'll want to bind values to a signal when the connection is established, rather than (or in addition to) when the signal is emitted. To do so, you can use an anonymous function like in the following example.

Here, the Button.Pressed signal does not take any argument. But we want to use the same ModifyValue for both the "plus" and "minus" buttons. So we bind the modifier value at the time we're connecting the signals.

Finally, you can create custom signals directly while your game is running. Use the AddUserSignal method for that. Be aware that it should be executed before any use of said signals (either connecting to them or emitting them). Also, note that signals created this way won't be visible through the SignalName nested class.

In general, it isn't recommended to use Connect() and Disconnect(). These APIs don't provide as much type safety as the events. However, they're necessary for connecting to signals defined by GDScript and passing ConnectFlags.

In the following example, pressing the button for the first time prints Greetings!. OneShot disconnects the signal, so pressing the button again does nothing.

Normally, when any GodotObject is freed (such as any Node), Godot automatically disconnects all connections associated with that object. This happens for both signal emitters and signal receivers.

For example, a node with this code will print "Hello!" when the button is pressed, then free itself. Freeing the node disconnects the signal, so pressing the button again doesn't do anything:

When a signal receiver is freed while the signal emitter is still alive, in some cases automatic disconnection won't happen:

The signal is connected to a lambda expression that captures a variable.

The signal is a custom signal.

The following sections explain these cases in more detail and include suggestions for how to disconnect manually.

Automatic disconnection is totally reliable if a signal emitter is freed before any of its receivers are freed. With a project style that prefers this pattern, the above limits may not be a concern.

If you connect to a lambda expression that captures variables, Godot can't tell that the lambda is associated with the instance that created it. This causes this example to have potentially unexpected behavior:

On tick 4, the lambda expression tries to access the Name property of the node, but the node has already been freed. This causes the exception.

To disconnect, keep a reference to the delegate created by the lambda expression and pass that to -=. For example, this node connects and disconnects using the _EnterTree and _ExitTree lifecycle methods:

In this example, Free causes the node to leave the tree, which calls _ExitTree. _ExitTree disconnects the signal, so _tick is never called again.

The lifecycle methods to use depend on what the node does. Another option is to connect to signals in _Ready and disconnect in Dispose.

Godot uses Delegate.Target to determine what instance a delegate is associated with. When a lambda expression doesn't capture a variable, the generated delegate's Target is the instance that created the delegate. When a variable is captured, the Target instead points at a generated type that stores the captured variable. This is what breaks the association. If you want to see if a delegate will be automatically cleaned up, try checking its Target.

Callable.From doesn't affect the Delegate.Target, so connecting a lambda that captures variables using Connect doesn't work any better than +=.

Connecting to a custom signal using += doesn't disconnect automatically when the receiving node is freed.

To disconnect, use -= at an appropriate time. For example:

Another solution is to use Connect, which does disconnect automatically with custom signals:

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (javascript):
```javascript
Timer myTimer = GetNode<Timer>("Timer");
myTimer.Timeout += () => GD.Print("Timeout!");
```

Example 2 (unknown):
```unknown
await ToSignal(GetTree(), SceneTree.SignalName.ProcessFrame);
```

Example 3 (unknown):
```unknown
[Signal]
public delegate void MySignalEventHandler();

[Signal]
public delegate void MySignalWithArgumentEventHandler(string myString);
```

Example 4 (javascript):
```javascript
public override void _Ready()
{
    MySignal += () => GD.Print("Hello!");
    MySignalWithArgument += SayHelloTo;
}

private void SayHelloTo(string name)
{
    GD.Print($"Hello {name}!");
}
```

---

## C# style guide — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_style_guide.html

**Contents:**
- C# style guide
- Language specification
- Formatting
  - General guidelines
  - Line breaks and blank lines
  - Using spaces
- Naming conventions
- Member variables
- Local variables
- Implicitly typed local variables

Having well-defined and consistent coding conventions is important for every project, and Godot is no exception to this rule.

This page contains a coding style guide, which is followed by developers of and contributors to Godot itself. As such, it is mainly intended for those who want to contribute to the project, but since the conventions and guidelines mentioned in this article are those most widely adopted by the users of the language, we encourage you to do the same, especially if you do not have such a guide yet.

This article is by no means an exhaustive guide on how to follow the standard coding conventions or best practices. If you feel unsure of an aspect which is not covered here, please refer to more comprehensive documentation, such as C# Coding Conventions or Framework Design Guidelines.

Godot currently uses C# version 12.0 in its engine and example source code, as this is the version supported by .NET 8.0 (the current baseline requirement). So, before we move to a newer version, care must be taken to avoid mixing language features only available in C# 13.0 or later.

For detailed information on C# features in different versions, please see What's New in C#.

Use line feed (LF) characters to break lines, not CRLF or CR.

Use one line feed character at the end of each file, except for csproj files.

Use UTF-8 encoding without a byte order mark.

Use 4 spaces instead of tabs for indentation (which is referred to as "soft tabs").

Consider breaking a line into several if it's longer than 100 characters.

For a general indentation rule, follow the "Allman Style" which recommends placing the brace associated with a control statement on the next line, indented to the same level:

However, you may choose to omit line breaks inside brackets:

For simple property accessors.

For simple object, array, or collection initializers.

For abstract auto property, indexer, or event declarations.

After a list of using statements.

Between method, properties, and inner type declarations.

At the end of each file.

Field and constant declarations can be grouped together according to relevance. In that case, consider inserting a blank line between the groups for easier reading.

Avoid inserting a blank line:

After {, the opening brace.

Before }, the closing brace.

After a comment block or a single-line comment.

Adjacent to another blank line.

Around a binary and ternary operator.

Between an opening parenthesis and if, for, foreach, catch, while, lock or using keywords.

Before and within a single line accessor block.

Between accessors in a single line accessor block.

After a comma which is not at the end of a line.

After a semicolon in a for statement.

After a colon in a single line case statement.

Around a colon in a type declaration.

Around a lambda arrow.

After a single-line comment symbol (//), and before it if used at the end of a line.

After the opening brace, and before the closing brace in a single line initializer.

After type cast parentheses.

The following example shows a proper use of spaces, according to some of the above mentioned conventions:

Use PascalCase for all namespaces, type names and member level identifiers (i.e. methods, properties, constants, events), except for private fields:

Use camelCase for all other identifiers (i.e. local variables, method arguments), and use an underscore (_) as a prefix for private fields (but not for methods or properties, as explained above):

There's an exception with acronyms which consist of two letters, like UI, which should be written in uppercase letters where PascalCase would be expected, and in lowercase letters otherwise.

Note that id is not an acronym, so it should be treated as a normal identifier:

It is generally discouraged to use a type name as a prefix of an identifier, like string strText or float fPower, for example. An exception is made, however, for interfaces, which should, in fact, have an uppercase letter I prefixed to their names, like IInventoryHolder or IDamageable.

Lastly, consider choosing descriptive names and do not try to shorten them too much if it affects readability.

For instance, if you want to write code to find a nearby enemy and hit it with a weapon, prefer:

Don't declare member variables if they are only used locally in a method, as it makes the code more difficult to follow. Instead, declare them as local variables in the method's body.

Declare local variables as close as possible to their first use. This makes it easier to follow the code, without having to scroll too much to find where the variable was declared.

Consider using implicitly typing (var) for declaration of a local variable, but do so only when the type is evident from the right side of the assignment:

Use explicit access modifiers.

Use properties instead of non-private fields.

Use modifiers in this order: public/protected/private/internal/virtual/override/abstract/new/static/readonly.

Avoid using fully-qualified names or this. prefix for members when it's not necessary.

Remove unused using statements and unnecessary parentheses.

Consider omitting the default initial value for a type.

Consider using null-conditional operators or type initializers to make the code more compact.

Use safe cast when there is a possibility of the value being a different type, and use direct cast otherwise.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
// Use this style:
if (x > 0)
{
    DoSomething();
}

// NOT this:
if (x > 0) {
    DoSomething();
}
```

Example 2 (csharp):
```csharp
// You may put the brackets in a single line in following cases:
public interface MyInterface
{
    int MyProperty { get; set; }
}

public class MyClass : ParentClass
{
    public int Value
    {
        get { return 0; }
        set
        {
            ArrayValue = new [] {value};
        }
    }
}
```

Example 3 (javascript):
```javascript
using System;
using Godot;
                                          // Blank line after `using` list.
public class MyClass
{                                         // No blank line after `{`.
    public enum MyEnum
    {
        Value,
        AnotherValue                      // No blank line before `}`.
    }
                                          // Blank line around inner types.
    public const int SomeConstant = 1;
    public const int AnotherConstant = 2;

    private Vector3 _x;                  // Related constants or fields can be
    private Vector3 _y;                  // grouped together.

    private float _width;
    private float _height;

    public int MyProperty { get; set; }
                                          // Blank line around properties.
    public void MyMethod()
    {
        // Some comment.
        AnotherMethod();                  // No blank line after a comment.
    }
                                          // Blank line around methods.
    public void AnotherMethod()
    {
    }
}
```

Example 4 (csharp):
```csharp
public class MyClass<A, B> : Parent<A, B>
{
    public float MyProperty { get; set; }

    public float AnotherProperty
    {
        get { return MyProperty; }
    }

    public void MyMethod()
    {
        int[] values = { 1, 2, 3, 4 };
        int sum = 0;

        // Single line comment.
        for (int i = 0; i < values.Length; i++)
        {
            switch (i)
            {
                case 3: return;
                default:
                    sum += i > 2 ? 0 : 1;
                    break;
            }
        }

        i += (int)MyProperty; // No space after a type cast.
    }
}
```

---

## C# Variant — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/c_sharp_variant.html

**Contents:**
- C# Variant
- Variant-compatible types
- Using Variant in a generic context
- User-contributed notes

For a detailed explanation of Variant in general, see the Variant documentation page.

Godot.Variant is used to represent Godot's native Variant type. Any Variant-compatible type can be converted from/to it. We recommend avoiding Godot.Variant unless it is necessary to interact with untyped engine APIs. Take advantage of C#'s type safety when possible.

Converting from a Variant-compatible C# type to Godot.Variant can be done using implicit conversions. There are also CreateFrom method overloads and the generic Variant.From<T> methods. Only the syntax is different: the behavior is the same.

Implicit conversions to Godot.Variant make passing variants as method arguments very convenient. For example, the third argument of tween_property specifying the final color of the tween is a Godot.Variant.

Converting from Godot.Variant to a C# type can be done using explicit conversions. There are also Variant.As{TYPE} methods and the generic Variant.As<T> method. All of these behave the same.

The Variant.As{TYPE} methods are typically named after C# types (Int32), not C# keywords (int).

If the Variant type doesn't match the conversion target type, the consequences vary depending on the source and target values.

The conversion may examine the value and return a similar but potentially unexpected value of the target type. For example, the string "42a" may be converted to the integer 42.

The default value of the target type may be returned.

An empty array may be returned.

An exception may be thrown.

Converting to the correct type avoids complicated behavior and should be preferred.

The Variant.Obj property returns a C# object with the correct value for any variant. This may be useful when the type of Variant is completely unknown. However, when possible, prefer more specific conversions. Variant.Obj evaluates a switch on Variant.VariantType and it may not be necessary. Also, if the result is a value type, it is boxed.

For example, if the potential for Variant.As<MyNode>() to throw an invalid cast exception isn't acceptable, consider using a Variant.As<GodotObject>() is MyNode n type pattern instead.

Since the Variant type in C# is a struct, it can't be null. To create a "null" Variant, use the default keyword or the Godot.Variant parameterless constructor.

A Variant-compatible type can be converted to and from a Godot.Variant. These C# types are Variant-compatible:

All the built-in value types, except decimal, nint and nuint.

Classes derived from GodotObject.

Collections types defined in the Godot.Collections namespace.

Full list of Variant types and their equivalent C# type:

long (Godot stores 64-bit integers in Variant)

double (Godot stores 64-bit floats in Variant)

Godot.GodotObject or any derived type.

Godot.Collections.Dictionary

Godot.Collections.Array

Godot uses 64-bit integers and floats in Variant. Smaller integer and float types such as int, short and float are supported since they can fit in the bigger type. Be aware that when a conversion is performed, using the wrong type will result in potential precision loss.

Enums are supported by Godot.Variant since their underlying type is an integer type which are all compatible. However, implicit conversions don't exist, enums must be manually converted to their underlying integer type before they can converted to/from Godot.Variant or use the generic Variant.As<T> and Variant.From<T> methods to convert them.

When using generics, you may be interested in restricting the generic T type to be only one of the Variant-compatible types. This can be achieved using the [MustBeVariant] attribute.

Combined with the generic Variant.From<T> allows you to obtain an instance of Godot.Variant from an instance of a generic T type. Then it can be used in any API that only supports the Godot.Variant struct.

In order to invoke a method with a generic parameter annotated with the [MustBeVariant] attribute, the value must be a Variant-compatible type or a generic T type annotated with the [MustBeVariant] attribute as well.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
int x = 42;
Variant numberVariant = x;
Variant helloVariant = "Hello, World!";

Variant numberVariant2 = Variant.CreateFrom(x);
Variant numberVariant3 = Variant.From(x);
```

Example 2 (unknown):
```unknown
Tween tween = CreateTween();
tween.TweenProperty(GetNode("Sprite"), "modulate", Colors.Red, 1.0f);
```

Example 3 (unknown):
```unknown
int number = (int)numberVariant;
string hello = (string)helloVariant;

int number2 = numberVariant.As<int>();
int number3 = numberVariant.AsInt32();
```

Example 4 (unknown):
```unknown
enum MyEnum { A, B, C }

Variant variant1 = (int)MyEnum.A;
MyEnum enum1 = (MyEnum)(int)variant1;

Variant variant2 = Variant.From(MyEnum.A);
MyEnum enum2 = variant2.As<MyEnum>();
```

---

## Debugger panel — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/debug/debugger_panel.html

**Contents:**
- Debugger panel
- Stack Trace
- Errors
- Evaluator
- Profiler
- Visual Profiler
- Network Profiler
- Monitors
- Video RAM
- Misc

Many of Godot's debugging tools, including the debugger, can be found in the debugger panel at the bottom of the screen. Click on Debugger to open it.

The debugger panel is split into several tabs, each focusing on a specific task.

The Stack Trace tab opens automatically when the GDScript compiler reaches a breakpoint in your code.

It gives you a stack trace, information about the state of the object, and buttons to control the program's execution. When the debugger breaks on a breakpoint, a green triangle arrow is visible in the script editor's gutter. This arrow indicates the line of code the debugger broke on.

You can create a breakpoint by clicking the gutter in the left of the script editor (on the left of the line numbers). When hovering this gutter, you will see a transparent red dot appearing, which turns into an opaque red dot after the breakpoint is placed by clicking. Click the red dot again to remove the breakpoint. Breakpoints created this way persist across editor restarts, even if the script wasn't saved when exiting the editor.

You can also use the breakpoint keyword in GDScript to create a breakpoint that is stored in the script itself. Unlike breakpoints created by clicking in the gutter, this keyword-based breakpoint is persistent across different machines when using version control.

You can use the buttons in the top-right corner to:

Skip all breakpoints. That way, you can save breakpoints for future debugging sessions.

Copy the current error message.

Step Into the code. This button takes you to the next line of code, and if it's a function, it steps line-by-line through the function.

Step Over the code. This button goes to the next line of code, but it doesn't step line-by-line through functions.

Break. This button pauses the game's execution.

Continue. This button resumes the game after a breakpoint or pause.

Using the debugger and breakpoints on tool scripts is not currently supported. Breakpoints placed in the script editor or using the breakpoint keyword are ignored. You can use print statements to display the contents of variables instead.

This is where error and warning messages are printed while running the game.

You can disable specific warnings in Project Settings > Debug > GDScript.

This tab contains an expression evaluator, also known as a REPL. This is a more powerful complement to the Stack Variables tree available in the Stack Trace tab.

When the project is interrupted in the debugger (due to a breakpoint or script error), you can enter an expression in the text field at the top. If the project is running, the expression field won't be editable, so you will need to set a breakpoint first. Expressions can be persisted across runs by unchecking Clear on Run, although they will be lost when the editor quits.

Expressions are evaluated using Godot's expression language, which allows you to perform arithmetic and call some functions within the expression. Expressions can refer to member variables, or local variables within the same scope as the line the breakpoint is on. You can also enter constant values, which makes it usable as a built-in calculator.

Consider the following script:

If the debugger breaks on the first line containing breakpoint, the following expressions return non-null values:

Constant expression: 2 * PI + 5

Member variable: counter, counter ** 2, sqrt(counter)

Local variable or function parameter: delta, text, text.to_upper()

If the debugger breaks on the second line containing breakpoint, the following expressions return non-null values:

Constant expression: 2 * PI + 5

Member variable: counter, counter ** 2, sqrt(counter)

Local variable or function parameter: delta, other_text, other_text.to_upper()

The profiler is used to see what code is running while your project is in use, and how that effects performance.

A detailed explanation of how to use the profiler can be found in the dedicated The Profiler page.

The Visual Profiler can be used to monitor what is taking the most time when rendering a frame on the CPU and GPU respectively. This allows tracking sources of potential CPU and GPU bottlenecks caused by rendering.

The Visual Profiler only measures CPU time taken for rendering tasks, such as performing draw calls. The Visual Profiler does not include CPU time taken for other tasks such as scripting and physics. Use the standard Profiler tab to track non-rendering-related CPU tasks.

To use the visual profiler, run the project, switch to the Visual Profiler tab within the Debugger bottom panel, then click Start:

Visual Profiler tab after clicking Start, waiting for a few seconds, then clicking Stop

You can also check Autostart, which will make the visual profiler automatically start when the project is run the next time. Note that the Autostart checkbox's state is not preserved across editor sessions.

You will see categories and results appearing as the profiler is running. Graph lines also appear, with the left side being a CPU framegraph and the right side being a GPU framegraph.

Click Stop to finish profiling, which will keep the results visible but frozen in place. Results remain visible after stopping the running project, but not after exiting the editor.

Click on result categories on the left to highlight them in the CPU and GPU graphs on the right. You can also click on the graph to move the cursor to a specific frame number and highlight the selected data type in the result categories on the left.

You can switch the result display between a time value (in milliseconds per frame) or a percentage of the target frametime (which is currently hardcoded to 16.67 milliseconds, or 60 FPS).

If framerate spikes occur during profiling, this can cause the graph to be poorly scaled. Disable Fit to Frame so that the graph will zoom onto the 60 FPS+ portion.

Remember that Visual Profiler results can vary heavily based on viewport resolution, which is determined by the window size if using the disabled or canvas_items stretch modes.

When comparing results across different runs, make sure to use the same viewport size for all runs.

Visual Profiler is supported when using any rendering method (Forward+, Mobile or Compatibility), but the reported categories will vary depending on the current rendering method as well as the enabled graphics features. For example, when using Forward+, a simple 2D scene with shadow-casting lights will result in the following categories appearing:

Example results from a 2D scene in the Visual Profiler

To give another example with Forward+, a 3D scene with shadow-casting lights and various effects enabled will result in the following categories enabled:

Example results from a 3D scene in the Visual Profiler

Notice how in the 3D example, several of the categories have (Parallel) appended to their name. This hints that multiple tasks are being performed in parallel on the GPU. This generally means that disabling only one of the features involved won't improve performance as much as anticipated, as the other task still needs to be performed sequentially.

The Visual Profiler is not supported when using the Compatibility renderer on macOS, due to platform limitations.

The Network Profiler contains a list of all the nodes that communicate over the multiplayer API and, for each one, some counters on the amount of incoming and outgoing network interactions. It also features a bandwidth meter that displays the total bandwidth usage at any given moment.

The bandwidth meter does not take the High-level multiplayer API's own compression system into account. This means that changing the compression algorithm used will not change the metrics reported by the bandwidth meter.

The monitors are graphs of several aspects of the game while it's running such as FPS, memory usage, how many nodes are in a scene and more. All monitors keep track of stats automatically, so even if one monitor isn't open while the game is running, you can open it later and see how the values changed.

In addition to the default performance monitors, you can also create custom performance monitors to track arbitrary values in your project.

The Video RAM tab shows the video RAM usage of the game while it is running. It provides a list of every resource using video RAM by resource path, the type of resource it is, what format it is in, and how much Video RAM that resource is using. There is also a total video RAM usage number at the top right of the panel.

The Misc tab contains tools to identify the control nodes you are clicking at runtime:

Clicked Control tells you where the clicked node is in the scene tree.

Clicked Control Type tells you the type of the node you clicked is.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
var counter = 0

func _process(delta):
    counter += 1
    if counter == 5:
        var text = "Some text"
        breakpoint
    elif counter >= 6:
        var other_text = "Some other text"
        breakpoint
```

---

## Debug — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/debug/index.html

**Contents:**
- Debug

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Evaluating expressions — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/evaluating_expressions.html

**Contents:**
- Evaluating expressions
- Basic usage
- Passing variables to an expression
- Setting a base instance for the expression
- Example script
- Built-in functions
- User-contributed notes

Godot provides an Expression class you can use to evaluate expressions.

An expression can be:

A mathematical expression such as (2 + 4) * 16/4.0.

A boolean expression such as true && false.

A built-in method call like deg_to_rad(90).

A method call on a user-provided script like update_health(), if base_instance is set to a value other than null when calling Expression.execute().

The Expression class is independent from GDScript. It's available even if you compile Godot with the GDScript module disabled.

To evaluate a mathematical expression, use:

The following operators are available:

Can also be used to concatenate strings and arrays: - "hello" + " world" = hello world - [1, 2] + [3, 4] = [1, 2, 3, 4]

Performs and integer division if both operands are integers. If at least one of them is a floating-point number, returns a floating-point value.

Returns the remainder of an integer division (modulo). The result will always have the sign of the dividend.

Returns the result of a boolean AND.

Returns the result of a boolean OR.

Returns the result of a boolean NOT.

Spaces around operators are optional. Also, keep in mind the usual order of operations applies. Use parentheses to override the order of operations if needed.

All the Variant types supported in Godot can be used: integers, floating-point numbers, strings, arrays, dictionaries, colors, vectors, …

Arrays and dictionaries can be indexed like in GDScript:

You can pass variables to an expression. These variables will then become available in the expression's "context" and will be substituted when used in the expression:

Both the variable names and variable values must be specified as an array, even if you only define one variable. Also, variable names are case-sensitive.

By default, an expression has a base instance of null. This means the expression has no base instance associated to it.

When calling Expression.execute(), you can set the value of the base_instance parameter to a specific object instance such as self, another script instance or even a singleton:

Associating a base instance allows doing the following:

Reference the instance's constants (const) in the expression.

Reference the instance's member variables (var) in the expression.

Call methods defined in the instance and use their return values in the expression.

Setting a base instance to a value other than null allows referencing constants, member variables, and calling all methods defined in the script attached to the instance. Allowing users to enter expressions may allow cheating in your game, or may even introduce security vulnerabilities if you allow arbitrary clients to run expressions on other players' devices.

The script below demonstrates what the Expression class is capable of:

The output from the script will be:

All methods in the Global Scope are available in the Expression class, even if no base instance is bound to the expression. The same parameters and return types are available.

However, unlike GDScript, parameters are always required even if they're specified as being optional in the class reference. In contrast, this restriction on arguments doesn't apply to user-made functions when you bind a base instance to the expression.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
var expression = Expression.new()
expression.parse("20 + 10*2 - 5/2.0")
var result = expression.execute()
print(result)  # 37.5
```

Example 2 (unknown):
```unknown
# Returns 1.
[1, 2][0]

# Returns 3. Negative indices can be used to count from the end of the array.
[1, 3][-1]

# Returns "green".
{"favorite_color": "green"}["favorite_color"]

# All 3 lines below return 7.0 (Vector3 is floating-point).
Vector3(5, 6, 7)[2]
Vector3(5, 6, 7)["z"]
Vector3(5, 6, 7).z
```

Example 3 (unknown):
```unknown
var expression = Expression.new()
# Define the variable names first in the second parameter of `parse()`.
# In this example, we use `x` for the variable name.
expression.parse("20 + 2 * x", ["x"])
# Then define the variable values in the first parameter of `execute()`.
# Here, `x` is assigned the integer value 5.
var result = expression.execute([5])
print(result)  # 30
```

Example 4 (gdscript):
```gdscript
func double(number):
    return number * 2


func _ready():
    var expression = Expression.new()
    expression.parse("double(10)")

    # This won't work since we're not passing the current script as the base instance.
    var result = expression.execute([], null)
    print(result)  # null

    # This will work since we're passing the current script (i.e. self)
    # as the base instance.
    result = expression.execute([], self)
    print(result)  # 20
```

---

## File system — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/filesystem.html

**Contents:**
- File system
- Introduction
- Implementation
- project.godot
- Path delimiter
- Resource path
- User path
- Host file system
- Drawbacks
- User-contributed notes

A file system manages how assets are stored and how they are accessed. A well-designed file system also allows multiple developers to edit the same source files and assets while collaborating. Godot stores all assets as files in its file system.

The file system stores resources on disk. Anything, from a script, to a scene or a PNG image is a resource to the engine. If a resource contains properties that reference other resources on disk, the paths to those resources are also included. If a resource has sub-resources that are built-in, the resource is saved in a single file together with all the bundled sub-resources. For example, a font resource is often bundled together with the font textures.

The Godot file system avoids using metadata files. Existing asset managers and VCSs are better than anything we can implement, so Godot tries its best to play along with Subversion, Git, Mercurial, etc.

Example of file system contents:

The project.godot file is the project description file, and it is always found at the root of the project. In fact, its location defines where the root is. This is the first file that Godot looks for when opening a project.

This file contains the project configuration in plain text, using the win.ini format. Even an empty project.godot can function as a basic definition of a blank project.

Godot only supports / as a path delimiter. This is done for portability reasons. All operating systems support this, even Windows, so a path such as C:\project\project.godot needs to be typed as C:/project/project.godot.

When accessing resources, using the host OS file system layout can be cumbersome and non-portable. To solve this problem, the special path res:// was created.

The path res:// will always point at the project root (where project.godot is located, so res://project.godot is always valid).

This file system is read-write only when running the project locally from the editor. When exported or when running on different devices (such as phones or consoles, or running from DVD), the file system will become read-only and writing will no longer be permitted.

Writing to disk is still needed for tasks such as saving game state or downloading content packs. To this end, the engine ensures that there is a special path user:// that is always writable. This path resolves differently depending on the OS the project is running on. Local path resolution is further explained in File paths in Godot projects.

Alternatively host file system paths can also be used, but this is not recommended for a released product as these paths are not guaranteed to work on all platforms. However, using host file system paths can be useful when writing development tools in Godot.

There are some drawbacks to this file system design. The first issue is that moving assets around (renaming them or moving them from one path to another inside the project) will break existing references to these assets. These references will have to be re-defined to point at the new asset location.

To avoid this, do all your move, delete and rename operations from within Godot, on the FileSystem dock. Never move assets from outside Godot, or dependencies will have to be fixed manually (Godot detects this and helps you fix them anyway, but why go the hard route?).

The second is that, under Windows and macOS, file and path names are case insensitive. If a developer working in a case insensitive host file system saves an asset as myfile.PNG, but then references it as myfile.png, it will work fine on their platform, but not on other platforms, such as Linux, Android, etc. This may also apply to exported binaries, which use a compressed package to store all files.

It is recommended that your team clearly define a naming convention for files when working with Godot. One fool-proof convention is to only allow lowercase file and path names.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
/project.godot
/enemy/enemy.tscn
/enemy/enemy.gd
/enemy/enemysprite.png
/player/player.gd
```

---

## GD0001: Missing partial modifier on declaration of type that derives from GodotObject — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0001.html

**Contents:**
- GD0001: Missing partial modifier on declaration of type that derives from GodotObject
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

A type that derives from GodotObject is not declared partial.

Godot source generators add generated code to user-defined types to implement the integration with the engine. Source generators can't add generated code to types that aren't declared partial.

To fix a violation of this rule, add the partial keyword to the type declaration.

Do not suppress a warning from this rule. Types that derive from GodotObject but aren't partial can't be enhanced by the source generators, resulting in unexpected runtime errors.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (csharp):
```csharp
// The source generators can't enhance this type to work with Godot.
public class InvalidNode : Node { }

// The source generators can enhance this type to work with Godot.
public partial class ValidNode { }
```

---

## GD0002: Missing partial modifier on declaration of type which contains nested classes that derive from GodotObject — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0002.html

**Contents:**
- GD0002: Missing partial modifier on declaration of type which contains nested classes that derive from GodotObject
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

A type that derives from GodotObject is contained in a non-partial type declaration.

Godot source generators add generated code to user-defined types to implement the integration with the engine. Source generators can't add generated code to types that aren't declared partial.

To fix a violation of this rule, add the partial keyword to the type declaration.

Do not suppress a warning from this rule. Types that derive from GodotObject but aren't partial can't be enhanced by the source generators, resulting in unexpected runtime errors.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (csharp):
```csharp
public class InvalidParentType
{
    // MyNode is contained in a non-partial type so the source generators
    // can't enhance this type to work with Godot.
    public partial class MyNode : Node { }
}

public partial class ValidParentType
{
    // MyNode is contained in a partial type so the source generators
    // can enhance this type to work with Godot.
    public partial class MyNode : Node { }
}
```

---

## GD0003: Found multiple classes with the same name in the same script file — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0003.html

**Contents:**
- GD0003: Found multiple classes with the same name in the same script file
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

A script file contains multiple types that derives from GodotObject with a name that matches the script file. Only one type in the script file should match the file name.

Godot requires scripts to have a unique path so every type must be defined on its own file and the type name must match the file name.

To fix a violation of this rule, move each type declaration to a different file.

Do not suppress a warning from this rule. Types that derive from GodotObject must have a unique path otherwise the engine can't load the script by path, resulting in unexpected runtime errors.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (csharp):
```csharp
public partial class MyNode : Node { }

namespace DifferentNamespace
{
    // Invalid because there's already a type with the name MyNode in this file.
    public partial class MyNode : Node { }
}

// Invalid because there's already a type with the name MyNode in this file.
public partial class MyNode<T> : Node { }
```

---

## GD0101: The exported member is static — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0101.html

**Contents:**
- GD0101: The exported member is static
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

Breaking - If the static keyword is removed

Non-breaking - If the [Export] attribute is removed

A static member is annotated with the [Export] attribute. Static members can't be exported.

Godot doesn't allow exporting static members.

To fix a violation of this rule, remove the [Export] attribute or remove the static keyword.

Do not suppress a warning from this rule. Static members can't be exported so they will be ignored by Godot, resulting in runtime errors.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (csharp):
```csharp
// Static members can't be exported.
[Export]
public static int InvalidProperty { get; set; }

// Instance members can be exported.
[Export]
public int ValidProperty { get; set; }
```

---

## GD0102: The type of the exported member is not supported — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0102.html

**Contents:**
- GD0102: The type of the exported member is not supported
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

Breaking - If the member type is changed

Non-breaking - If the [Export] attribute is removed

An unsupported type is specified for a member annotated with the [Export] attribute when a Variant-compatible type is expected.

Every exported member must be Variant-compatible so it can be marshalled by the engine.

To fix a violation of this rule, change the member's type to be Variant-compatible or remove the [Export] attribute.

Do not suppress a warning from this rule. Members with types that can't be marshalled will result in runtime errors.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (csharp):
```csharp
class SomeType { }

// SomeType is not a valid member type because it doesn't derive from GodotObject,
// so it's not compatible with Variant.
[Export]
public SomeType InvalidProperty { get; set; }

// System.Int32 is a valid type because it's compatible with Variant.
[Export]
public int ValidProperty { get; set; }
```

---

## GD0103: The exported member is read-only — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0103.html

**Contents:**
- GD0103: The exported member is read-only
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

A read-only member is annotated with the [Export] attribute. Read-only members can't be exported.

Godot doesn't allow exporting read-only members.

To fix a violation of this rule for fields, remove the readonly keyword or remove the [Export] attribute.

To fix a violation of this rule for properties, make sure the property declares both a getter and a setter, or remove the [Export] attribute.

Do not suppress a warning from this rule. Read-only members can't be exported so they will be ignored by Godot, resulting in runtime errors.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (csharp):
```csharp
// Read-only fields can't be exported.
[Export]
public readonly int invalidField;

// This field can be exported because it's not declared 'readonly'.
[Export]
public int validField;

// Read-only properties can't be exported.
[Export]
public int InvalidProperty { get; }

// This property can be exported because it has both a getter and a setter.
[Export]
public int ValidProperty { get; set; }
```

---

## GD0104: The exported property is write-only — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0104.html

**Contents:**
- GD0104: The exported property is write-only
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

A write-only property is annotated with the [Export] attribute. Write-only properties can't be exported.

Godot doesn't allow exporting write-only properties.

To fix a violation of this rule, make sure the property declares both a getter and a setter, or remove the [Export] attribute.

Do not suppress a warning from this rule. Write-only members can't be exported so they will be ignored by Godot, resulting in runtime errors.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (javascript):
```javascript
private int _backingField;

// Write-only properties can't be exported.
[Export]
public int InvalidProperty { set => _backingField = value; }

// This property can be exported because it has both a getter and a setter.
[Export]
public int ValidProperty { get; set; }
```

---

## GD0105: The exported property is an indexer — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0105.html

**Contents:**
- GD0105: The exported property is an indexer
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

An indexer is annotated with the [Export] attribute. Indexers can't be exported.

Godot doesn't allow exporting indexer properties.

To fix a violation of this rule, remove the [Export] attribute.

Do not suppress a warning from this rule. Indexers can't be exported so they will be ignored by Godot, resulting in runtime errors.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (javascript):
```javascript
private int[] _backingField;

// Indexers can't be exported.
[Export]
public int this[int index]
{
    get => _backingField[index];
    set => _backingField[index] = value;
}
```

---

## GD0106: The exported property is an explicit interface implementation — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0106.html

**Contents:**
- GD0106: The exported property is an explicit interface implementation
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

An explicit interface property implementation is annotated with the [Export] attribute. Properties that implement an interface explicitly can't be exported.

Godot doesn't allow exporting explicit interface property implementations. When an interface member is implemented explicitly, the member is hidden and consumers can't access them unless the type is converted to the interface first. Explicitly implemented members can also share the same name of other members in the type, so it could create naming conflicts with other exported members.

To fix a violation of this rule, implement the interface implicitly or remove the [Export] attribute.

Do not suppress a warning from this rule. Explicit interface property implementations can't be exported so they will be ignored by Godot, resulting in runtime errors.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (csharp):
```csharp
public interface MyInterface
{
    public int MyProperty { get; set; }
}

public class MyNode1 : Node, MyInterface
{
    // The property can be exported because it implements the interface implicitly.
    [Export]
    public int MyProperty { get; set; }
}

public class MyNode2 : Node, MyInterface
{
    // The property can't be exported because it implements the interface explicitly.
    [Export]
    int MyInterface.MyProperty { get; set; }
}
```

---

## GD0107: Types not derived from Node should not export Node members — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0107.html

**Contents:**
- GD0107: Types not derived from Node should not export Node members
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

A type that doesn't derive from Node contains an exported field or property of a type that derives from Node.

Exported nodes are serialized as NodePath. Only types derived from Node are able to get the node instance from the NodePath.

To fix a violation of this rule, avoid exporting Node members on a type that doesn't derive from Node, or consider exporting a NodePath.

Do not suppress a warning from this rule. Types that don't derive from Node will be unable to retrieve the right node instance for exported Node members, resulting in unexpected runtime errors.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## GD0108: The exported tool button is not in a tool class — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0108.html

**Contents:**
- GD0108: The exported tool button is not in a tool class
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

A property is annotated with the [ExportToolButton] attribute in a class that is not annotated with the [Tool] attribute.

The [ExportToolButton] is used to create clickable buttons in the inspector so, like every other script that runs in the editor, it needs to be annotated with the [Tool] attribute.

To fix a violation of this rule, add the [Tool] attribute to the class that contains the member annotated with the [ExportToolButton] attribute.

Do not suppress a warning from this rule. The clickable buttons in the inspector won't be functional if their script is not annotated with the [Tool] attribute.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (javascript):
```javascript
[Tool]
public partial class MyNode : Node
{
    [ExportToolButton("Click me!")]
    public Callable ClickMeButton => Callable.From(ClickMe);

    private static void ClickMe()
    {
        GD.Print("Hello world!");
    }
}
```

---

## GD0109: The '[ExportToolButton]' attribute cannot be used with another '[Export]' attribute — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0109.html

**Contents:**
- GD0109: The '[ExportToolButton]' attribute cannot be used with another '[Export]' attribute
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

A property is annotated with both the [ExportToolButton] and the [Export] attributes.

The [ExportToolButton] attribute already implies exporting the member, so the [Export] is unnecessary.

To fix a violation of this rule, remove the [Export] attribute.

Do not suppress a warning from this rule. Multiple export attributes may lead to duplicated members, resulting in unexpected runtime errors.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## GD0110: The exported tool button is not a Callable — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0110.html

**Contents:**
- GD0110: The exported tool button is not a Callable
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

Breaking - If the property's type is changed to Callable

Non-breaking - If the [ExportToolButton] is replaced with [Export]

A property of a type different from Callable is annotated with the [ExportToolButton] attribute.

The [ExportToolButton] attribute is used to create clickable buttons in the inspector so, the property must be a Callable that will be executed when clicking the button.

To fix a violation of this rule, change the type of the property to Callable. Alternatively, if you intended to export a normal property, replace the [ExportToolButton] attribute with [Export].

Do not suppress a warning from this rule. The exported property must be a Callable so it can executed in the editor when clicking the button in the inspector.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## GD0111: The exported tool button must be an expression-bodied property — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0111.html

**Contents:**
- GD0111: The exported tool button must be an expression-bodied property
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

A property is annotated with the [ExportToolButton] attribute but it's not an expression-bodied property.

When reloading the .NET assembly, Godot will attempt to serialize exported members to preserve their values. A field or a property with a backing field that stores a Callable may prevent the unloading of the assembly.

An expression-bodied property doesn't have a backing field and won't store the Callable, so Godot won't attempt to serialize it, which should result in the successful reloading of the .NET assembly.

To fix a violation of this rule, replace the property implementation with an expression-bodied property.

Do not suppress a warning from this rule. Callable instances may prevent the .NET assembly from unloading.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (javascript):
```javascript
[ExportToolButton("Click me!")]
public Callable ValidClickMeButton => Callable.From(ClickMe);

// Invalid because the Callable will be stored in the property's backing field.
[ExportToolButton("Click me!")]
public Callable InvalidClickMeButton { get; } = Callable.From(ClickMe);
```

---

## GD0201: The name of the delegate must end with 'EventHandler' — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0201.html

**Contents:**
- GD0201: The name of the delegate must end with 'EventHandler'
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

A delegate annotated with the [Signal] attribute has a name that doesn't end with 'EventHandler'.

Godot source generators will generate C# events using the name of the delegate with the 'EventHandler' suffix removed. Adding the 'EventHandler' suffix to the name of delegates used in events is a .NET naming convention.

Using a suffix for the delegate allows the generated event to use the name without the suffix avoiding a naming conflict.

Take a look at the C# signals documentation for more information about how to declare and use signals.

To fix a violation of this rule, add 'EventHandler' to the end of the delegate name.

Do not suppress a warning from this rule. Signal delegates without the suffix will be ignored by the source generator, so the signal won't be registered.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
// This delegate is invalid since the name doesn't end with 'EventHandler'.
[Signal]
public void InvalidSignal();

// This delegate is valid since the name ends with 'EventHandler'.
[Signal]
public void ValidSignalEventHandler();
```

---

## GD0202: The parameter of the delegate signature of the signal is not supported — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0202.html

**Contents:**
- GD0202: The parameter of the delegate signature of the signal is not supported
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

Breaking - If the parameter type is changed

Non-breaking - If the [Signal] attribute is removed

An unsupported type is specified for a parameter of a delegate annotated with the [Signal] attribute when a Variant-compatible type is expected.

Every signal parameter must be Variant-compatible so it can be marshalled when emitting the signal and invoking the callbacks.

Take a look at the C# signals documentation for more information about how to declare and use signals.

To fix a violation of this rule, change the parameter type to be Variant-compatible or remove the [Signal] attribute from the delegate. Note that removing the attribute will mean the signal is not registered.

If the signal doesn't need to interact with Godot, consider using C# events directly. Pure C# events allow you to use any C# type for its parameters.

Do not suppress a warning from this rule. Signal delegates with parameters that can't be marshalled will result in runtime errors when emitting the signal or invoking the callbacks.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
class SomeType { }

// SomeType is not a valid parameter type because it doesn't derive from GodotObject,
// so it's not compatible with Variant.
public void InvalidSignalEventHandler(SomeType someType);

// System.Int32 is a valid type because it's compatible with Variant.
public void ValidSignalEventHandler(int someInt);
```

---

## GD0203: The delegate signature of the signal must return void — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0203.html

**Contents:**
- GD0203: The delegate signature of the signal must return void
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

Breaking - If the return type is changed

Non-breaking - If the [Signal] attribute is removed

A delegate annotated with the [Signal] attribute has a return type when void was expected.

Every signal must return void. There can be multiple callbacks registered for each signal, if signal callbacks could return something it wouldn't be possible to determine which of the returned values to use.

Take a look at the C# signals documentation for more information about how to declare and use signals.

To fix a violation of this rule, change the delegate to return void or remove the [Signal] attribute from the delegate. Note that removing the attribute will mean the signal is not registered.

If the signal doesn't need to interact with Godot, consider using C# events directly. Pure C# events allow you to use any C# type for its parameters.

Do not suppress a warning from this rule. Signal delegates that return something will result in unexpected runtime errors.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
// This signal delegate is invalid because it doesn't return void.
public int InvalidSignalEventHandler();

// This signal delegate is valid because it returns void.
public void ValidSignalEventHandler();
```

---

## GD0301: The generic type argument must be a Variant compatible type — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0301.html

**Contents:**
- GD0301: The generic type argument must be a Variant compatible type
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

An unsupported type is specified for a generic type argument when a Variant-compatible type is expected.

When a generic type parameter is annotated with the [MustBeVariant] attribute, the generic type is required to be a Variant-compatible type. For example, the generic Godot.Collections.Array<T> type only supports items of a type that can be converted to Variant.

To fix a violation of this rule, change the generic type argument to be a Variant-compatible type or use a different API that doesn't require the generic type argument to be a Variant-compatible type.

Do not suppress a warning from this rule. API that contains generic type arguments annotated with the [MustBeVariant] attribute usually has this requirement because the values will be passed to the engine, if the type can't be marshalled it will result in runtime errors.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
class SomeType { }

// SomeType is not a valid type because it doesn't derive from GodotObject,
// so it's not compatible with Variant.
var invalidArray = new Godot.Collections.Array<SomeType>();

// System.Int32 is a valid type because it's compatible with Variant.
var validArray = new Godot.Collections.Array<int>();
```

---

## GD0302: The generic type parameter must be annotated with the '[MustBeVariant]' attribute — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0302.html

**Contents:**
- GD0302: The generic type parameter must be annotated with the '[MustBeVariant]' attribute
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

A generic type is specified for a generic type argument when a Variant-compatible type is expected, but the specified generic type is not annotated with the [MustBeVariant] attribute.

When a generic type parameter is annotated with the [MustBeVariant] attribute, the generic type is required to be a Variant-compatible type. When the type used is also a generic type, this generic type must be annotated with the [MustBeVariant] attribute as well. For example, the generic Godot.Collections.Array<T> type only supports items of a type that can be converted to Variant, a generic type can be specified if it's properly annotated.

To fix a violation of this rule, add the [MustBeVariant] attribute to the generic type that is used as a generic type argument that must be Variant-compatible.

Do not suppress a warning from this rule. API that contains generic type arguments annotated with the [MustBeVariant] attribute usually has this requirement because the values will be passed to the engine, if the type can't be marshalled it will result in runtime errors.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
public void Method1<T>()
{
    // T is not valid here because it may not a Variant-compatible type.
    var invalidArray = new Godot.Collections.Array<T>();
}

public void Method2<[MustBeVariant] T>()
{
    // T is guaranteed to be a Variant-compatible type because it's annotated
    // with the [MustBeVariant] attribute, so it can be used here.
    var validArray = new Godot.Collections.Array<T>();
}
```

---

## GD0303: The parent symbol of a type argument that must be Variant compatible was not handled — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0303.html

**Contents:**
- GD0303: The parent symbol of a type argument that must be Variant compatible was not handled
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

This is a bug in the engine and must be reported.

The MustBeVariantAnalyzer has found an unhandled case in the user source code. Please, open an issue and attach a minimal reproduction project so it can be fixed.

Violations of this rule can't be fixed.

Suppressing a warning from this rule may result in unexpected errors, since the case found by the analyzer may need to be handled by the user to prevent types that are not Variant-compatible from reaching the engine. Attempting to marshal incompatible types will result in runtime errors.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## GD0401: The class must derive from Godot.GodotObject or a derived class — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0401.html

**Contents:**
- GD0401: The class must derive from Godot.GodotObject or a derived class
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

Breaking - If changing the inheritance chain

Non-breaking - If removing the [GlobalClass] attribute

A type annotated with the [GlobalClass] attribute does not derive from GodotObject.

The [GlobalClass] has no effect for types that don't derive from GodotObject. Every global class must ultimately derive from GodotObject so it can be marshalled.

To fix a violation of this rule, change the type to derive from GodotObject or remove the [GlobalClass] attribute.

Do not suppress a warning from this rule. Adding the [GlobalClass] to a type that doesn't derive from GodotObject is an easy mistake to make and this warning helps users realize that it may result in unexpected errors.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
// This type is not registered as a global class because it doesn't derive from GodotObject.
[GlobalClass]
class SomeType { }

// This type is a global class because it derives from Godot.Node
// which ultimately derives from GodotObject.
[GlobalClass]
class MyNode : Node { }

// This type is a global class because it derives from Godot.Resource
// which ultimately derives from GodotObject.
[GlobalClass]
class MyResource : Resource { }
```

---

## GD0402: The class must not be generic — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/c_sharp/diagnostics/GD0402.html

**Contents:**
- GD0402: The class must not be generic
- Cause
- Rule description
- How to fix violations
- When to suppress warnings
- User-contributed notes

Fix is breaking or non-breaking

A generic type is annotated with the [GlobalClass] attribute.

The Godot editor assumes every global class is instantiable, but generic types can't be instantiated because the type parameters are unbound.

To fix a violation of this rule, change the type to remove the generic type parameters or remove the [GlobalClass] attribute.

Do not suppress a warning from this rule. Adding the [GlobalClass] to a generic type is an easy mistake to make and this warning helps users realize that it may result in unexpected errors.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
// This type is a valid global class because it's not generic.
[GlobalClass]
class SomeType : Node { }

// This type is not a valid global class because it's generic.
[GlobalClass]
class SomeGenericType<T> { }
```

---

## GDExtension C example — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/gdextension/gdextension_c_example.html

**Contents:**
- GDExtension C example
- Introduction
- Setting up the project
- File structure
- Buildsystem
- Initializing the extension
- A basic class
- A wrapper API
- A demo project
- Custom methods

This is a simple example on how to work with GDExtension directly with C code. Note that the API is not meant to be used directly, so this will definitely be quite verbose and require a lot of steps even for a small example. However, it serves as a reference for creating bindings for a different language. It is still possible to use the API directly if you prefer, which might be convenient when only binding a third-party library.

In this example we will create a custom node that moves a sprite on the screen based on the user's parameters. While very simple, it serves to show how to do some of the things with GDExtension, like registering custom classes with methods, properties, and signals. It gives an insight on the GDExtension API.

There are a few prerequisites you'll need:

a Godot 4.2 (or later) executable,

SCons as a build tool.

Since this is using the API directly, there's no need to use the godot-cpp repository.

To organize our files, we're gonna split into mainly two folders:

We also need a copy of the gdextension_interface.h header from the Godot source code, which can be obtained directly from the Godot executable by running the following command:

This creates the header in the current folder, so you can just copy it to the src folder in the example project.

Lastly, there's another source of information we need to refer to, which is the JSON file with the Godot API reference. This file won't be used by the code directly, we will only use it to extract some information manually.

To get this JSON file, just call the Godot executable:

The resulting extension_api.json file will be created in the current folder. You can copy this file to the example folder to have it handy.

This extension is targeting Godot 4.2, but it should work on later versions as well. If you want to target a different minimal version, make sure to get the header and the JSON from the version Godot version you are targeting.

Using a buildsystem makes our life a lot easier when dealing with C code. For the sake of convenience, we'll use SCons since it's the same as what Godot itself uses.

The following SConstruct file is a simple one that will build your extension to the current platform that you are using, be it Linux, macOS, or Windows. This will be a non-optimized build for debugging purposes. It also assumes a 64-bit build, which is relevant for some parts of the example code. Making other build types and cross-compilation is out of the scope of this tutorial. Save this file to the root folder.

This will include all C files in the src folder, so we don't need to change this file when adding new source files.

The first bit of code will be responsible for initializing the extension. This is what makes Godot aware of what our GDExtension provides, such as classes and plugins.

Create the file init.h in the src folder, with the following contents:

The functions declared here have the signatures expected by the GDExtension API.

Note the inclusion of the defs.h file. This is one of our helpers to simplify writing the extension code. For now it will only contain the definition of GDE_EXPORT, a macro that makes the function public in the shared library so Godot can properly call it. This macro helps abstracting what each compiler expects.

Create the defs.h file in the src folder with the following contents:

We also include some standard headers to make things easier. Now we only have to include defs.h and those will come as a bonus.

Now, let's implement the functions we just declared. Create a file called init.c in the src folder and add this code:

What this does is set up the initialization data that Godot expects. The functions to initialize and deinitialize are set so Godot will call then when needed. It also sets the initialization level which varies per extension. Since we plan to add a custom node, the SCENE level is enough.

We will fill the initialize_gdexample_module() function later to register our custom class.

In order to make an actual node, first we'll create a C struct to hold data and functions that will act as methods. The plan is to make this a custom node that inherits from Sprite2D.

Create a file called gdexample.h in the src folder with the following contents:

Noteworthy here is the object field, which holds a pointer to the Godot object, and the gdexample_class_bind_methods() function, which will register the metadata of our custom class (properties, methods, and signals). The latter is not entirely necessary, as we can do it when registering the class, but it makes clearer to separate the concerns and let our class register its own metadata.

The object field is necessary because our class will inherit a Godot class. Since we can't inherit it directly, as we are not interacting with the source code (and C doesn't even have classes), we instead tell Godot to create an object of a type it knows and attach our extension to it. We will need the reference to such objects when calling methods on the parent class, for instance.

Let's create the source counterpart of this header. Create the file gdexample.c in the src folder and add the following code to it:

As we don't have anything to do with those functions yet, they'll stay empty for a while.

The next step is registering our class. However, in order to do so we need to create a StringName and for that we have to get a function from the GDExtension API. Since we'll need this a few times and we'll also need other things, let's create a wrapper API to facilitate this kind of chore.

We'll start by creating an api.h file in the src folder:

This file will include many other helpers as we fill our extension with something useful. For now it only has a pointer to a function that creates a StringName from a C string (in Latin-1 encoding) and another to destruct a StringName, which we'll need to use to avoid leaking memory, as well as the function to register a class, which is our initial goal.

We also keep a reference to the class_library here. This is something that Godot provides to us when initializing the extension and we'll need to use it when registering the things we create so Godot can tell which extension is making the call.

There's also a function to load those function pointers from the GDExtension API.

Let's work on the source counterpart of this header. Create the api.c file in the src folder, adding the following code:

The first important thing here is p_get_proc_address. This a function from the GDExtension API that is passed during initialization. You can use this function to request specific functions from the API by their name. Here we are caching the results so we don't have to keep a reference for p_get_proc_address everywhere and use our wrapper instead.

At the start we request the variant_get_ptr_destructor() function. This is not going to be used outside of this function, so we don't add to our wrapper and only cache it locally. The cast is necessary to silence compiler warnings.

Then we get the function that creates a StringName from a C string, exactly what we mentioned before as a needed function. We store that in our constructors struct.

Next, we use the variant_get_ptr_destructor() function we just got to query for the destructor for StringName, using the enum value from gdextension_interface.h API as a parameter. We could get destructors for other types in a similar manner, but we'll limit ourselves to what is needed for the example.

Lastly, we get the classdb_register_extension_class2() function, which we'll need in order to register our custom class.

You may wonder why the 2 is there in the function name. This means it's the second version of this function. The old version is kept to ensure backwards compatibility with older extensions, but since we have the second version available, it's best to use the new one, because we don't intend to support older Godot versions in this example.

The gdextension_interface.h header documents in which Godot version each function was introduced.

We also define the class_library variable here, which will be set during initialization.

Speaking of initialization, now we have to change the init.c file in order to fill the things we just added:

Here we set the class_library as needed and call our new load_api() function. Don't forget to also include the new headers at the top of this file:

Since we are here, we can register our new custom class. Let's fill the initialize_gdexample_module() function:

The struct with the class information is the biggest thing here. None of its fields are required with the exception of create_instance_func and free_instance_func. We haven't made those functions yet, so we'll have to work on them soon. Note that we skip the initialization if it isn't at the SCENE level. This function may be called multiple times, once for each level, but we only want to register our class once.

The other undefined thing here is StringName. This will be an opaque struct meant to hold the data of a Godot StringName in our extension. We'll define it in the appropriately named defs.h file:

As mentioned in the comment, the sizes can be found in the extension_api.json file that we generated earlier, under the builtin_class_sizes property. The BUILD_32 is never defined, as we assume we are working with a 64-bits build of Godot here, but if you need it you can add env.Append(CPPDEFINES=["BUILD_32"]) to your SConstruct file.

The // Types. comment foreshadows that we'll be adding more types to this file. Let's leave that for later.

The StringName struct here is just to hold Godot data, so we don't really care what is inside of it. Though, in this case, it is just a pointer to the data in the heap. We'll use this struct when we need to allocate data for a StringName ourselves, like we are doing when registering our class.

Back to registering, we need to work on our create and free functions. Let's include them in gdexample.h since they're specific to the custom class:

Before we can implement those function, we'll need a few more things in our API. We need a way to allocate and free memory. While we could do this with good ol' malloc(), we can instead make use of Godot's memory management functions. We'll also need a way to create a Godot object and set it with our custom instance.

So let's change the api.h to include these new functions:

Then we change the load_api() function in api.c to grab these new functions:

Now we can go back to gdexample.c and define the new functions, without forgetting to include the api.h header:

When instantiating an object, first we create a new Sprite2D object, since that's the parent of our class. Then we allocate memory for our custom struct and call its constructor. We save the pointer to the Godot object in the struct as well like we mentioned earlier.

Then we set our custom struct as the instance data. This will make Godot know that the object is an instance of our custom class and properly call our custom methods for instance, as well as passing this data back.

Note that we return the Godot object we created, not our custom struct.

For the gdextension_free_instance() function, we only call the destructor and free the memory we allocated for the custom data. It is not necessary to destruct the Godot object since that will be taken care of by the engine itself.

Now that we can create and free our custom object, we should be able to try it out in an actual project. For this, you need to open Godot and create a new project on the demo folder. The project manager may warn you the folder isn't empty if you have compiled the extension before, you can safely ignore this warning this time.

If you didn't compile the extension yet, it is the time to do it now. To do that, open a terminal or command prompt, navigate to the root folder of the extension and run scons. It should compile quickly since the extension is very simple.

Then, create a file called gdexample.gdextension inside the demo folder. This is a Godot resource that describes the extension, allowing the engine to properly load it. Put the following content in this file:

As you can see, gdexample_library_init() is the same name of the function we defined in our init.c file. It is important that the names match because it is how Godot calls the entry point of the extension.

We also set the compatibility minimum to 4.2, since we are targeting this version. It should still work on later versions. If you are using a later Godot version and rely on the new features, you need to increase this value to a version number that has everything you use. See Version compatibility for more information.

In the [libraries] section we set up the paths to the shared library on different platforms. Here there's only the debug versions since that's what we are working on for the example. Using feature tags you can fine tune this to also provide release versions, add more target operating systems, as well as providing 32-bit and 64-bit binaries.

You can also add library dependencies and custom icons for your classes in this file, but this is out of the scope for this tutorial.

After saving the file, go back to the editor. Godot should automatically load the extension. Nothing will be seen because our extension only registers a new class. To use this class add a Node2D as a root of the scene. Move it to the middle of viewport for better visibility. Then add a new child node to the root and in the Create New Node dialog search for "GDExample", the name of our class, as it should be listed there. If it isn't, it means that Godot didn't load the extension properly, so try restarting the editor and retrace the steps to see if anything went missing.

Our custom class is derived from Sprite2D, so it has a Texture property in the Inspector. Set this to the icon.svg file that Godot handily created for us when making the project. Save this scene as main.tscn and run it. You may want to set it as the main scene for convenience.

Voilà! We have a custom node running in Godot. However, it does not do anything and has nothing different than a regular Sprite2D node. We will fix that next by adding custom methods and properties.

A common thing in extensions is creating methods for the custom classes and exposing those to the Godot API. We are going to create a couple of getters and setters which are need for binding the properties afterwards.

First, let's add the new fields in our struct to hold the values for amplitude and speed, which we will use later on when creating the behavior for the node. Add them to the gdexample.h file, changing the GDExample struct:

In the same file, add the declaration for the getters and setters, right after the destructor.

In the gdexample.c file, we will initialize these values in the constructor and add the implementations for those new functions, which are quite trivial:

To make those simple functions work when called by Godot, we will need some wrappers to help us properly convert the data to and from the engine.

First, we will create wrappers for ptrcall. This is what Godot uses when the types of the values are known to be exact, which avoids using Variant. We're gonna need two of those: one for the functions that take no arguments and return a double (for the getters) and another for the functions that take a single double argument and return nothing (for the setters).

Add the declarations to the api.h file:

Those two functions follow the GDExtensionClassMethodPtrCall type, as defined in the gdextension_interface.h. We use float as a name here because in Godot the float type has double precision, so we keep this convention.

Then we implement those functions in the api.c file:

The method_userdata argument is a custom value that we give to Godot, in this case we will set as the function pointer for the one we want to call. So first we convert it to the function type, then we just call it by passing the arguments when needed, or setting the return value.

The p_instance argument contains the custom instance of our class, which we gave with object_set_instance() when creating the object.

p_args is an array of arguments. Note this contains pointers to the values. That's why we dereference it when passing to our functions. The number of arguments will be declared when binding the function (which we will do soon) and it will always include default ones if those exist.

Finally, the r_ret is a pointer to the variable where the return value needs to be set. Like the arguments, it will be the correct type as declared. For the function that does not return, we have to avoid setting it.

Note how the type and argument counts are exact, so if we needed different types, for example, we would have to create more wrappers. This could be automated using some code generation, but this is out of the scope for this tutorial.

While the ptrcall functions are used when types are exact, sometimes Godot cannot know if that's the case (when the call comes from a dynamically typed language, such as GDScript). In those situations it uses regular call functions, so we need to provide those as well when binding.

Let's create two new wrappers in the api.h file:

These follow the GDExtensionClassMethodCall type, which is a bit different. First, you receive pointers to Variants instead of exact types. There's also the amount of arguments and an error struct that you can set if something goes wrong.

In order to check the type and also extract interact with Variant, we will need a few more functions from the GDExtension API. So let's expand our wrapper structs:

The names say all about what those do. We have a couple of constructors to create and extract a floating point value to and from a Variant. We also have a couple of helpers to actually get those constructors, as well as a function to find out the type of a Variant.

Let's get those from the API, like we did before, by changing the load_api() function in the api.c file:

Now that we have these set, we can implement our call wrappers in the same file:

These functions are a bit longer but easy to follow. First they check if the argument count is as expected and if not they set the error struct and return. For the one that has one parameter, it also checks if the argument type is correct. This is important because mismatched types when extracting from Variant can cause crashes.

Then it proceeds to extract the argument using the constructor we setup before. The one with no arguments instead sets the return value after calling the function. Note how they use a pointer to a double variable, since this is what those constructors expect.

Before we can actually bind our methods, we need a way to create GDExtensionPropertyInfo instances. While we could do them inside the binding functions that we'll implement afterwards, it's easier to have a helper for it since we'll need it multiple times, including for when we bind properties.

Let's create these two functions in the api.h file:

The first one is a simplified version of the second since we usually don't need all the arguments for the property and are okay with the defaults. Then we also have a function to destruct the PropertyInfo since we need to create Strings and StringNames that need to be properly disposed of.

Speaking of which, we also need a way to create and destruct Strings, so we'll make an addition to existing structs in this same file. We'll also get a new API function for actually binding our custom method.

Before implementing those, let's do a quick stop in the defs.h file and include the size of the String type and a couple of enums:

While it's the same size as StringName, it is more clear to use a different name for it.

The enums here are just helpers to give names to the numbers they represent. The information about them is present in the extension_api.json file. Here we just set up the ones we need for the tutorial, to keep it more concise.

Going now to the api.c, we need to load the pointers to the new functions we added to the API.

Then we can also implement the functions to create the PropertyInfo struct.

The simple version of make_property() just calls the more complete one with a some default arguments. What those values mean exactly is out of the scope of this tutorial, check the page about the Object class for more details about binding methods and properties.

The complete version is more involved. First, it creates String's and StringName's for the needed fields, by allocating memory and calling their constructors. Then it creates a GDExtensionPropertyInfo struct and sets all the fields with the arguments provided. Finally it returns this created struct.

The destruct_property() function is straightforward, it simply calls the destructors for the created objects and frees their allocated memory.

Let's go back again to the header api.h to create the functions that will actually bind the methods:

Then switch back to the api.c file to implement these:

Both functions are very similar. First, they create a StringName with the method name. This is created in the stack since we don't need to keep it after the function ends. Then they create local variables to hold the call_func and ptrcall_func, pointing to the helper functions we defined earlier.

In the next step they diverge a bit. The first one creates a property for the return value, which has an empty name since it's not needed. The other creates an array of properties for the arguments, which in this case has a single element. This one also has an array of metadata, which can be used if there's something special about the argument (e.g. if an int value is 32 bits long instead of the default of 64 bits).

Afterwards, they create the GDExtensionClassMethodInfo with the required fields for each case. Then they make a StringName for the class name, in order to associate the method with the class. Next, they call the API function to actually bind this method to the class. Finally, we destruct the objects we created since they aren't needed anymore.

The bind helpers here use the call helpers we created earlier, so do note that those call helpers only accept the Godot FLOAT type (which is equivalent to double in C). If you intend to use this for other types, you would need to check the type of the arguments and return type and select an appropriate function callback. This is avoided here only to keep the example from becoming even longer.

Now that we have the means to bind methods, we can actually do so in our custom class. Go to the gdexample.c file and fill up the gdexample_class_bind_methods() function:

Since this function is already being called by the initialization process, we can stop here. This function is much more straightforward after we created all the infrastructure to make this work. You can see that implementing the binding functions inline here would take some space and also be quite repetitive. This also makes it easier to add another method in the future.

If you compile the code and reopen the demo project, nothing will be different at first, since we only added two new methods. To ensure those are registered properly, you can search for GDExample in the editor help and verify they are present in the documentation page.

Since we now have the getter and setter for our properties already bound, we can move forward to create actual properties that will be displayed in the Godot editor inspector.

Given our extensive setup in the previous section, there are only a few things needed to enable us to bind properties. First, let's get a new API function in the api.h file:

Let's also declare a function here to bind properties:

In the api.c file, we can load the new API function:

Then we can implement our new helper function in this same file:

This function is similar to the one for binding methods. The main difference is that we don't need an extra struct since we can simply use the GDExtensionPropertyInfo that is created by our helper function, so it's more straightforward. It only creates the StringName values from the C strings, creates a property info struct using our helper, calls the API function to register the property in the class and then destructs all the objects we created.

With this done, we can extend the gdexample_class_bind_methods() function in the gdexample.c file:

If you build the extension with scons, you'll see in the Godot editor the new property shown not only on the documentation page for the custom class but also in the Inspector dock when the GDExample node is selected.

Our custom node now has properties to influence how it operates, but it still doesn't do anything. In this section, we will bind the virtual method _process() and make our custom sprite move a little bit.

In the gdexample.h file, let's add a function that represents the custom _process() method:

We'll also add a "private" field to keep track of the time passed in our custom struct. This is "private" only in the sense that it won't be bound to the Godot API, even though it is public in the C side, given the language lacks access modifiers.

On the counterpart source file gdexample.c we need to initialize the new field in the constructor:

Then we can create the simplest implementation for the _process method:

For now it will do nothing but update the private field we created. We'll come back to this after the method is properly bound.

Virtual methods are a bit different from the regular bindings. Instead of explicitly registering the method itself, we'll register a special function that Godot will call to ask if a particular virtual method is implemented in our extension. The engine will pass a StringName as an argument so, following the spirit of this tutorial, we'll create a helper function to check if it is equal to a C string.

Let's add the declaration to the api.h file:

We'll also add a new struct to this file, to hold function pointers for custom operators:

Then in the api.c file we'll load the function pointer from the API:

As you can see we need a new local helper here in order to grab the function pointer for the operator.

With this handy, we can easily create our comparison function in the same file:

This function creates a StringName from the argument, compares with the other one using the operator function pointer, and returns the result. Note that the return value for the operator is passed as an out reference, this is a common thing in the API.

Let's go back to the gdexample.h file and add a couple of functions that will be used as the callbacks for the Godot API:

There are actually two ways of registering virtual methods. Only one has the get part, in which you give Godot a properly crafted function pointer which will be called. For this we would need to create another helper for each virtual method, something that is not very convenient. Instead, we use the second method which allows us to return any data, and then Godot will call a second callback and give us back this data along with the call information. We can simply give our own function pointer as custom data and then have a single callback for all virtual methods. Although in this example we will only use it for one method, this way is simpler to expand.

So let's implement those two functions in the gdexample.c file:

Those functions are also quite straightforward after making all the helpers previously.

For the first one, we simply check if the function name requested is _process and if it is we return a function pointer to our implementation of it. Otherwise we return NULL, signaling that the method is not being overridden. We don't use the p_class_userdata here since this function is meant only for one class and we don't have any data associated with it.

The second one is similar. If it is the _process() method, it uses the given function pointer to call the ptrcall helper, passing the call arguments forward. Otherwise it simply does nothing, since we don't have any other virtual methods being implemented.

The only thing missing is using those callbacks when the class is registered. Go to the init.c file and change the class_info initialization to include those, replacing the NULL value used previously:

This is enough to bind the virtual method. If you build the extension and run the demo project again, the _process() function will be called. You just won't be able to tell since the function itself does nothing visible. We will solve this now by making the custom node move following a pattern.

In order to make our node do stuff, we'll need to call Godot methods. Not only the GDExtension API functions as we've being doing so far, but actual engine methods, as we would do with scripting. This naturally requires some extra setup.

First, let's add Vector2 to our defs.h file, so we can use it in our method:

The REAL_T_IS_DOUBLE define is only needed if your Godot version was built with double precision support, which is not the default.

Now, in the api.h file, we'll add few things to the API structs, including a new one for holding engine methods to call.

Then in the api.c file we can grab the function pointers from Godot:

The only noteworthy part here is the Vector2 constructor, for which we request the index 3. Since there are multiple constructors with different kinds of arguments, we need to specify which one we want. In this case we're getting the one that takes two float numbers as the x and y coordinates, hence the name. This index can be retrieved from the extension_api.json file. Note we also need a new local helper to get it.

Be aware that we don't get anything for the methods struct here. This is because this function is called too early in the initialization process, so classes won't be properly registered yet.

Instead, we're gonna use the initialization level callback to grab those when we are registering our custom class. Add this to the init.c file:

Here we create StringName's for the class and method we want to get, then use the GDExtension API to retrieve their MethodBind, which is an object that represents the bound method. We get the set_position method from Node2D since this is where it was registered, even though we're going to use it in a Sprite2D, a derived class.

The seemingly random number for getting the bind is actually a hash of the method signature. This allows Godot to match the method you're requesting even if in a future Godot version this signature changes, by providing a compatibility method that matches what you're asking for. This is one of the systems that allow the engine to load extensions made for previous versions. You can get the value of this hash from the extension_api.json file.

With all that, we can finally implement our custom _process() method in the gdexample.c file:

After updating the time passed scaled by the speed property, it creates x and y values based on that, also modulated by the amplitude property. This is what will give the pattern effect. The math.h header is needed for the sin() and cos() functions used here.

Then it sets up an array of arguments to construct a Vector2, followed by calling the constructor. It sets up another array of arguments and use it to call the set_position() method via the bind we acquired previously.

Since nothing here allocates any memory, there's not a need to cleanup.

Now we can build the extension again and reopen Godot. Even in the editor you'll see the custom sprite moving.

Try changing the Speed and Amplitude properties and see how the sprite react.

To complete this tutorial, let's see how you can register a custom signal and emit it when appropriate. As you might have guessed, we'll need a few more function pointers from the API and more helper functions.

In the api.h file we're adding two things. One is an API function to register a signal, the other is a helper function to wrap the signal binding.

In this case we only have a version for one argument, since it's what we're going to use.

Moving to the api.c file, we can load this new function pointer and implement the helper:

This one is very similar to the function to bind methods. The main difference is that we don't need to fill another struct, we just pass the needed names and the array of arguments. The 1 at the end means the amount of arguments the signal provides.

With this we can bind the signal in gdexample.c:

In order to emit a signal, we need to call the emit_signal() method on our custom node. Since this is a vararg function (meaning it takes any amount of arguments), we cannot use ptrcall. To do a regular call, we have to create Variants, which require a few more steps of plumbing to get done.

First, in the defs.h file we create a definition for Variant:

We first set the size of Variant together with the size of Vector2 that we added before. Then we use it to create an opaque struct that is enough to hold the Variant data. Again, we set the size for double precision builds as a fallback, since by the official Godot builds use single precision.

The emit_signal() function will be called with two arguments. The first is the name of the signal to be emitted and the second is the argument we're passing to the signal connections, which is a Vector2 as we declared when binding it. So we're gonna create a helper function that can call a MethodBind with these types. Even though it does return something (an error code), we don't need to deal with it, so for now we're just going to ignore it.

In the api.h, we're adding a few things to the existing structs, plus a new helper function for the call:

Now let's switch to the api.c file to load these new function pointers and implement the helper function.

This helper function has some boilerplate code but is quite straightforward. It sets up the two arguments inside stack allocated Variants, then creates an array with pointers to those. It also sets up another Variant to keep the return value, which we don't need to construct since the call expects it to be uninitialized.

Then it actually calls the MethodBind using the instance we provided and the arguments. The NULL at the end would be a pointer to a GDExtensionCallError struct. This can be used to treat potential errors when calling the functions (such as wrong arguments). For the sake of simplicity we're not gonna handle that here.

At the end we need to destruct the Variants we created. While technically the Vector2 one does not require destructing, it is clearer to cleanup everything.

We also need to load the MethodBind, which we'll do in the init.c file, right after loading the one for the set_position method we did before:

Note that we reuse the native_class_name and method_name variables here, so we don't need to declare new ones.

Now go to the gdexample.h file where we're going to add a couple of fields:

The first one will store the time passed since the last signal was emitted, since we'll be doing so at regular intervals. The other is just to cache the signal name so we don't need to create a new StringName every time.

In the source gdexample.c file we can change the constructor and destructor to deal with the new fields:

It is important to destruct the StringName to avoid memory leaks.

Now we can add to the gdexample_class_process() function to actually emit the signal:

This updates the time passed for the signal emission and, if it is over one second it calls the emit_signal() function on the current instance, passing the name of the signal and the new position as arguments.

Now we're done with our C GDExtension. Build it once more and reopen the demo project in the editor.

In the documentation page for GDExample you can see the new signal we bound:

To check it's working, let's add a small script to the root node, parent of our custom one, that prints the position to the output every time it receives the signal:

Run the project and you can observe the values being printed in the Output dock in the editor:

This tutorial shows a basic extension with custom methods, properties, and signals. While it does require a good amount of boilerplate, it can scale well by creating helper functions to handle the tedious tasks.

This should serve as a good basis to understand the GDExtension API and as a starting point to create custom binding generators. In fact, it would be possible to create bindings for C using such type of generator, making the actual coding look more like the gdexample.c file in this example, which is quite straightforward and not very verbose.

If you want to create actual extensions, it is preferred to use the C++ bindings instead, as it takes away all of the boilerplate from your code. Check the godot-cpp documentation to see how you can do this.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
gdextension_c_example/
|
+--demo/                  # game example/demo to test the extension
|
+--src/                   # source code of the extension we are building
```

Example 2 (unknown):
```unknown
godot --dump-gdextension-interface
```

Example 3 (unknown):
```unknown
godot --dump-extension-api
```

Example 4 (python):
```python
#!/bin/env python
from SCons.Script import Environment
from os import path
import sys

env = Environment()

# Set the target path and name.
target_path = "demo/bin/"
target_name = "libgdexample"

# Set the compiler and flags.
env.Append(CPPPATH=["src"])  # Add the src folder to the include path.
env.Append(CFLAGS=["-O0", "-g"])  # Make it a debug build.

# Use Clang on macOS.
if sys.platform == "darwin":
    env["CC"] = "clang"

# Add all C files in "src" folder as sources.
sources = env.Glob("src/*.c")

# Create a shared library.
library = env.SharedLibrary(
    target=path.join(target_path, target_name),
    source=sources,
)

# Set the library as the default target.
env.Default(library)
```

---

## GDScript documentation comments — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_documentation_comments.html

**Contents:**
- GDScript documentation comments
- Documenting a script
  - Tags
- Documenting script members
  - Tags
- Complete script example
- @deprecated and @experimental tags
- BBCode and class reference
- User-contributed notes

In GDScript, comments can be used to document your code and add descriptions to the members of a script. There are two differences between a normal comment and a documentation comment. Firstly, a documentation comment should start with double hash symbols ##. Secondly, it must immediately precede a script member, or for script descriptions, be placed at the top of the script. If an exported variable is documented, its description is used as a tooltip in the editor. This documentation can be generated as XML files by the editor.

Comments documenting a script must come before any member documentation. A suggested format for script documentation can be divided into three parts.

A brief description of the script.

Detailed description.

Tutorials and deprecated/experimental marks.

To separate these from each other, the documentation comments use special tags. The tag must be at the beginning of a line (ignoring preceding white space) and must have the format @, followed by the keyword.

No tag. Lives at the very beginning of the documentation section.

No tag. Use one blank line to separate the description from the brief.

If there is any space in between the tag name and colon, for example @tutorial :, it won't be treated as a valid tag and will be ignored.

When the description spans multiple lines, the preceding and trailing white spaces will be stripped and joined with a single space. To preserve the line break use [br]. See also BBCode and class reference below.

Members that are applicable for documentation:

Documentation of a script member must immediately precede the member or its annotations if it has any. The description can have more than one line but every line must start with the double hash symbol ## to be considered as part of the documentation.

Alternatively, you can use inline documentation comments:

The script documentation will update in the editor help window every time the script is updated. If any member variable or function name starts with an underscore, it will be treated as private. It will not appear in the documentation and will be ignored in the help window.

You can mark a class or any of its members as deprecated or experimental. This will add the corresponding indicator in the built-in documentation viewer. Optionally, you can provide a short message explaining why the API is not recommended. This can be especially useful for plugin and library creators.

Deprecated marks a non-recommended API that is subject to removal or incompatible change in a future major release. Usually the API is kept for backwards compatibility.

Experimental marks a new unstable API that may be changed or removed in the current major branch. Using this API is not recommended in production code.

While technically you can use both @deprecated and @experimental tags on the same class/member, this is not recommended as it is against common conventions.

Godot's class reference supports BBCode-like tags. They add nice formatting to the text which could also be used in the documentation. See also class reference bbcode. Note that this is slightly different from the RichTextLabel BBCode.

Whenever you link to a member of another class, you need to specify the class name. For links to the same class, the class name is optional and can be omitted.

Here's the list of available tags:

See [annotation @GDScript.@rpc].

See [constant Color.RED].

See [enum Mesh.ArrayType].

Get [member Node2D.scale].

Call [method Node3D.hide].

Use [constructor Color.Color].

Use [operator Color.operator *].

Use Color.operator *.

Emit [signal Node.renamed].

See [theme_item Label.font].

Takes [param size] for the size.

Takes size for the size.

[lb]b[rb]text[lb]/b[rb]

Do [b]not[/b] call this method.

Do not call this method.

Returns the [i]global[/i] position.

Returns the global position.

[u]Always[/u] use this method.

[s]Outdated information.[/s]

[color=red]Error![/color]

[font=res://mono.ttf]LICENSE[/font]

[img width=32]res://icon.svg[/img]

[center]2 + 2 = 4[/center]

Press [kbd]Ctrl + C[/kbd].

Returns [code]true[/code].

Currently only @GDScript has annotations.

[kbd] disables BBCode until the parser encounters [/kbd].

[code] disables BBCode until the parser encounters [/code].

[codeblock] disables BBCode until the parser encounters [/codeblock].

Use [codeblock] for pre-formatted code blocks. Inside [codeblock], always use four spaces for indentation (the parser will delete tabs).

By default, [codeblock] highlights GDScript syntax. You can change it using the lang attribute. Currently supported options are:

[codeblock lang=text] disables syntax highlighting;

[codeblock lang=gdscript] highlights GDScript syntax;

[codeblock lang=csharp] highlights C# syntax (only in .NET version).

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
extends Node2D
## A brief description of the class's role and functionality.
##
## The description of the script, what it can do,
## and any further detail.
##
## @tutorial:             https://example.com/tutorial_1
## @tutorial(Tutorial 2): https://example.com/tutorial_2
## @experimental
```

Example 2 (unknown):
```unknown
## The description of the variable.
## @deprecated: Use [member other_var] instead.
var my_var
```

Example 3 (javascript):
```javascript
signal my_signal ## My signal.

enum MyEnum { ## My enum.
    VALUE_A = 0, ## Value A.
    VALUE_B = 1, ## Value B.
}

const MY_CONST = 1 ## My constant.

var my_var ## My variable.


func my_func(): ## My func.
    pass


class MyClass: ## My class.
    pass
```

Example 4 (javascript):
```javascript
extends Node2D
## A brief description of the class's role and functionality.
##
## The description of the script, what it can do,
## and any further detail.
##
## @tutorial:             https://example.com/tutorial_1
## @tutorial(Tutorial 2): https://example.com/tutorial_2
## @experimental

## The description of a signal.
signal my_signal

## This is a description of the below enum.
enum Direction {
    ## Direction up.
    UP = 0,
    ## Direction down.
    DOWN = 1,
    ## Direction left.
    LEFT = 2,
    ## Direction right.
    RIGHT = 3,
}

## The description of a constant.
const GRAVITY = 9.8

## The description of the variable v1.
var v1

## This is a multiline description of the variable v2.[br]
## The type information below will be extracted for the documentation.
var v2: int

## If the member has any annotation, the annotation should
## immediately precede it.
@export
var v3 := some_func()


## As the following function is documented, even though its name starts with
## an underscore, it will appear in the help window.
func _fn(p1: int, p2: String) -> int:
    return 0


# The below function isn't documented and its name starts with an underscore
# so it will treated as private and will not be shown in the help window.
func _internal() -> void:
    pass


## Documenting an inner class.
##
## The same rules apply here. The documentation must
## immediately precede the class definition.
##
## @tutorial: https://example.com/tutorial
## @experimental
class Inner:

    ## Inner class variable v4.
    var v4


    ## Inner class function fn.
    func fn(): pass
```

---

## GDScript exported properties — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_exports.html

**Contents:**
- GDScript exported properties
- Basic use
- Grouping exports
- Strings as paths
- Limiting editor input ranges
- Adding suffixes and handling degrees/radians
- Floats with easing hint
- Colors
- Nodes
- Resources

In Godot, class members can be exported. This means their value gets saved along with the resource (such as the scene) they're attached to, and get transferred over when using RPCs. They will also be available for editing in the property editor. Exporting is done by using the @export annotation.

In that example the value 5 will be saved and visible in the property editor.

An exported variable must be initialized to a constant expression or have a type specifier in the variable. Some of the export annotations have a specific type and don't need the variable to be typed (see the Examples section below).

One of the fundamental benefits of exporting member variables is to have them visible and editable in the editor. This way, artists and game designers can modify values that later influence how the program runs. For this, a special export syntax is provided.

Exporting properties can also be done in other languages such as C#. The syntax varies depending on the language. See C# exported properties for information on C# exports.

If the exported value assigns a constant or constant expression, the type will be inferred and used in the editor.

If there's no default value, you can add a type to the variable.

Resources and nodes can be exported.

Even if a script is not executed in the editor, exported properties can still be edited. However, getters and setters will only be used if the script is in Tool mode.

It is possible to group your exported properties inside the Inspector with the @export_group annotation. Every exported property after this annotation will be added to the group. Start a new group or use @export_group("") to break out.

The second argument of the annotation can be used to only group properties with the specified prefix.

Groups cannot be nested, use @export_subgroup to create subgroups within a group.

You can also change the name of your main category, or create additional categories in the property list with the @export_category annotation.

The list of properties is organized based on the class inheritance and new categories break that expectation. Use them carefully, especially when creating projects for public use.

String as a path to a file. See @export_file.

String as a path to a directory. See @export_dir.

String as a path to a file, custom filter provided as hint. See again @export_file.

Using paths in the global filesystem is also possible, but only in scripts in tool mode.

String as a path to a PNG file in the global filesystem. See @export_global_file.

String as a path to a directory in the global filesystem. See @export_global_dir.

The multiline annotation tells the editor to show a large input field for editing over multiple lines. See @export_multiline.

See @export_range for all of the following.

Allow integer values from 0 to 20.

Allow integer values from -10 to 20.

Allow floats from -10 to 20 and snap the value to multiples of 0.2.

The limits can be made to affect only the slider if you add the hints "or_less" and/or "or_greater". If either these hints are used, it will be possible for the user to enter any value or drag the value with the mouse when not using the slider, even if outside the specified range.

The "exp" hint can be used to make a value have an exponential slider instead of a linear slider. This means that when dragging the slider towards the right, changes will become progressively faster when dragging the mouse. This is useful to make editing values that can be either very small or very large easier, at the cost of being less intuitive.

For values that are meant to represent an easing factor, use Floats with easing hint instead.

The "hide_slider" hint can be used to hide the horizontal bar that appears below float properties, or the up/down arrows that appear besides int properties:

A suffix can also be defined to make the value more self-explanatory in the inspector. For example, to define a value that is meant to be configured as "meters" (m) by the user:

For angles that are stored in radians but displayed as degrees to the user, use the "radians_as_degrees" hint:

This performs automatic conversion when the value is displayed or modified in the inspector and also displays a degree (°) suffix. This approach is used by Godot's own rotation properties throughout the editor.

If the angle is stored in degrees instead, use the "degrees" hint to display the degree symbol while disabling the automatic degrees-to-radians conversion when the value is modified from the inspector.

Display a visual representation of the ease() function when editing. See @export_exp_easing.

Regular color given as red-green-blue-alpha value.

Color given as red-green-blue value (alpha will always be 1). See @export_color_no_alpha.

Since Godot 4.0, nodes can be directly exported as properties in a script without having to use NodePaths:

Exporting NodePaths like in Godot 3.x is still possible, in case you need it:

If you want to limit the types of nodes for NodePaths, you can use the @export_node_path annotation:

In the Inspector, you can then drag and drop a resource file from the FileSystem dock into the variable slot.

Opening the inspector dropdown may result in an extremely long list of possible classes to create, however. Therefore, if you specify an extension of Resource such as:

The drop-down menu will be limited to AnimationNode and all its derived classes.

Integers used as bit flags can store multiple true/false (boolean) values in one property. By using the @export_flags annotation, they can be set from the editor:

You must provide a string description for each flag. In this example, Fire has value 1, Water has value 2, Earth has value 4 and Wind corresponds to value 8. Usually, constants should be defined accordingly (e.g. const ELEMENT_WIND = 8 and so on).

You can add explicit values using a colon:

Only power of 2 values are valid as bit flags options. The lowest allowed value is 1, as 0 means that nothing is selected. You can also add options that are a combination of other flags:

Export annotations are also provided for the physics, render, and navigation layers defined in the project settings:

Using bit flags requires some understanding of bitwise operations. If in doubt, use boolean variables instead.

Properties can be exported with a type hint referencing an enum to limit their values to the values of the enumeration. The editor will create a widget in the Inspector, enumerating the following as "Thing 1", "Thing 2", "Another Thing". The value will be stored as an integer.

Integer and string properties can also be limited to a specific list of values using the @export_enum annotation. The editor will create a widget in the Inspector, enumerating the following as Warrior, Magician, Thief. The value will be stored as an integer, corresponding to the index of the selected option (i.e. 0, 1, or 2).

You can add explicit values using a colon:

If the type is String, the value will be stored as a string.

If you want to set an initial value, you must specify it explicitly:

Exported arrays can have initializers, but they must be constant expressions.

If the exported array specifies a type which inherits from Resource, the array values can be set in the inspector by dragging and dropping multiple files from the FileSystem dock at once.

The default value must be a constant expression.

Exported arrays can specify type (using the same hints as before).

You can omit the default value, but it would then be null if not assigned.

Arrays with specified types which inherit from resource can be set by drag-and-dropping multiple files from the FileSystem dock.

Packed type arrays also work, but only initialized empty:

Other export variants can also be used when exporting arrays:

By default, exporting a property has two effects:

makes the property stored in the scene/resource file (PROPERTY_USAGE_STORAGE);

adds a field to the Inspector (PROPERTY_USAGE_EDITOR).

However, sometimes you may want to make a property serializable, but not display it in the editor to prevent unintentional changes and cluttering the interface.

To do this you can use @export_storage. This can be useful for @tool scripts. Also the property value is copied when Resource.duplicate() or Node.duplicate() is called, unlike non-exported variables.

If you need more control than what's exposed with the built-in @export annotations, you can use @export_custom instead. This allows defining any property hint, hint string and usage flags, with a syntax similar to the one used by the editor for built-in nodes.

For example, this exposes the altitude property with no range limits but an m (meter) suffix defined:

The above is normally not feasible with the standard @export_range syntax, since it requires defining a range.

See the class reference for a list of parameters and their allowed values.

When using @export_custom, GDScript does not perform any validation on the syntax. Invalid syntax may have unexpected behavior in the inspector.

If you need to create a clickable inspector button, you can use @export_tool_button. This exports a Callable property as a clickable button. When the button is pressed, the callable is called.

You can specify a custom icon name, which must match one of the icon file names from the editor/icons folder of the Godot source repository (case-sensitive). You can also browse the editor icons using the Godot editor icons website.

For example, if you wish to use Node2D.svg from that folder, you must specify "Node2D" as the second parameter of @export_tool_button. It is not currently possible to use custom icons from the project folder; only built-in editor icons can be used.

This exports a button with label "Hello" and icon "Callable" (which is the default if no icon is specified). When you press it, it will print "Hello world!".

When changing an exported variable's value from a script in Tool mode, the value in the inspector won't be updated automatically. To update it, call notify_property_list_changed() after setting the exported variable's value.

Not every type of export can be provided on the level of the language itself to avoid unnecessary design complexity. The following describes some more or less common exporting features which can be implemented with a low-level API.

Before reading further, you should get familiar with the way properties are handled and how they can be customized with _set(), _get(), and _get_property_list() methods as described in Accessing data or logic from an object.

For binding properties using the above methods in C++, see Binding properties using _set/_get/_get_property_list.

The script must operate in the @tool mode so the above methods can work from within the editor.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
@export var number: int = 5
```

Example 2 (unknown):
```unknown
@export var number = 5
```

Example 3 (unknown):
```unknown
@export var number: int
```

Example 4 (unknown):
```unknown
@export var resource: Resource
@export var node: Node
```

---

## GDScript format strings — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_format_string.html

**Contents:**
- GDScript format strings
- Format strings
- Multiple placeholders
- Format specifiers
  - Placeholder types
  - Placeholder modifiers
- Padding
  - Dynamic padding
- Escape sequence
- String format method

Godot offers multiple ways to dynamically change the contents of strings:

Format strings: var string = "I have %s cats." % "3"

The String.format() method: var string = "I have {0} cats.".format([3])

String concatenation: var string = "I have " + str(3) + " cats."

This page explains how to use format strings, and briefly explains the format() method and string concatenation.

Format strings are a way to reuse text templates to succinctly create different but similar strings.

Format strings are just like normal strings, except they contain certain placeholder character sequences such as %s. These placeholders can then be replaced by parameters handed to the format string.

Examine this concrete GDScript example:

Placeholders always start with a %, but the next character or characters, the format specifier, determines how the given value is converted to a string.

The %s seen in the example above is the simplest placeholder and works for most use cases: it converts the value by the same method by which an implicit String conversion or str() would convert it. Strings remain unchanged, booleans turn into either "True" or "False", an int or float becomes a decimal, and other types usually return their data in a human-readable string.

There are other format specifiers.

Format strings may contain multiple placeholders. In such a case, the values are handed in the form of an array, one value per placeholder (unless using a format specifier with *, see dynamic padding):

Note the values are inserted in order. Remember all placeholders must be replaced at once, so there must be an appropriate number of values.

There are format specifiers other than s that can be used in placeholders. They consist of one or more characters. Some of them work by themselves like s, some appear before other characters, some only work with certain values or characters.

One and only one of these must always appear as the last character in a format specifier. Apart from s, these require certain types of parameters.

Simple conversion to String by the same method as implicit String conversion.

A single Unicode character. Accepts a Unicode code point (integer) or a single-character string. Supports values beyond 255.

A decimal integer. Expects an integer or a real number (will be floored).

An octal integer. Expects an integer or a real number (will be floored).

A hexadecimal integer with lower-case letters. Expects an integer or a real number (will be floored).

A hexadecimal integer with upper-case letters. Expects an integer or a real number (will be floored).

A decimal real number. Expects an integer or a real number.

A vector. Expects any float or int-based vector object ( Vector2, Vector3, Vector4, Vector2i, Vector3i or Vector4i). Will display the vector coordinates in parentheses, formatting each coordinate as if it was an %f, and using the same modifiers.

These characters appear before the above. Some of them work only under certain conditions.

In number specifiers, show + sign if positive.

Set padding. Padded with spaces or with zeroes if integer starts with 0 in an integer or real number placeholder. The leading 0 is ignored if - is present. When used after ., see ..

Before f or v, set precision to 0 decimal places. Can be followed up with numbers to change. Padded with zeroes.

Pad to the right rather than the left.

Dynamic padding, expects additional integer parameter to set padding or precision after ., see dynamic padding.

The . (dot), * (asterisk), - (minus sign) and digit (0-9) characters are used for padding. This allows printing several values aligned vertically as if in a column, provided a fixed-width font is used.

To pad a string to a minimum length, add an integer to the specifier:

If the integer starts with 0, integer values are padded with zeroes instead of white space:

Precision can be specified for real numbers by adding a . (dot) with an integer following it. With no integer after ., a precision of 0 is used, rounding to integer values. The integer to use for padding must appear before the dot.

The - character will cause padding to the right rather than the left, useful for right text alignment:

By using the * (asterisk) character, the padding or precision can be set without modifying the format string. It is used in place of an integer in the format specifier. The values for padding and precision are then passed when formatting:

It is still possible to pad with zeroes in integer placeholders by adding 0 before *:

To insert a literal % character into a format string, it must be escaped to avoid reading it as a placeholder. This is done by doubling the character:

There is also another way to format text in GDScript, namely the String.format() method. It replaces all occurrences of a key in the string with the corresponding value. The method can handle arrays or dictionaries for the key/value pairs.

Arrays can be used as key, index, or mixed style (see below examples). Order only matters when the index or mixed style of Array is used.

A quick example in GDScript:

The following are some examples of how to use the various invocations of the String.format() method.

"Hi, {name} v{version}!".format({"name":"Godette", "version":"3.0"})

"Hi, {0} v{1}!".format({"0":"Godette", "1":"3.0"})

"Hi, {0} v{version}!".format({"0":"Godette", "version":"3.0"})

"Hi, {name} v{version}!".format([["version","3.0"], ["name","Godette"]])

"Hi, {0} v{1}!".format(["Godette","3.0"])

"Hi, {name} v{0}!".format(["3.0", ["name","Godette"]])

"Hi, {} v{}!".format(["Godette", "3.0"], "{}")

Placeholders can also be customized when using String.format, here's some examples of that functionality.

"Hi, {0} v{1}".format(["Godette", "3.0"], "{_}")

"Hi, 0% v1%".format(["Godette", "3.0"], "_%")

"Hi, %0 v%1".format(["Godette", "3.0"], "%_")

Combining both the String.format method and the % operator could be useful, as String.format does not have a way to manipulate the representation of numbers.

"Hi, {0} v{version}".format({0:"Godette", "version":"%0.2f" % 3.114})

You can also combine strings by concatenating them together, using the + operator.

When using string concatenation, values that are not strings must be converted using the str() function. There is no way to specify the string format of converted values.

Because of these limitations, format strings or the format() method are often a better choice. In many cases, string concatenation is also less readable.

In Godot's C++ code, GDScript format strings can be accessed using the vformat() helper function in the Variant header.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
# Define a format string with placeholder '%s'
var format_string = "We're waiting for %s."

# Using the '%' operator, the placeholder is replaced with the desired value
var actual_string = format_string % "Godot"

print(actual_string)
# Output: "We're waiting for Godot."
```

Example 2 (unknown):
```unknown
var format_string = "%s was reluctant to learn %s, but now he enjoys it."
var actual_string = format_string % ["Estragon", "GDScript"]

print(actual_string)
# Output: "Estragon was reluctant to learn GDScript, but now he enjoys it."
```

Example 3 (unknown):
```unknown
print("%10d" % 12345)
# output: "     12345"
# 5 leading spaces for a total length of 10
```

Example 4 (unknown):
```unknown
print("%010d" % 12345)
# output: "0000012345"
```

---

## GDScript — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/index.html

**Contents:**
- GDScript

See GDScript grammar if you are interested in writing a third-party tool that interacts with GDScript, such as a linter or formatter.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## @GDScript — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/classes/class_%40gdscript.html

**Contents:**
- @GDScript
- Description
- Tutorials
- Methods
- Constants
- Annotations
- Method Descriptions
- User-contributed notes

Built-in GDScript constants, functions, and annotations.

A list of utility functions and annotations accessible from any script written in GDScript.

For the list of global functions and constants that can be accessed in any scripting language, see @GlobalScope.

Color8(r8: int, g8: int, b8: int, a8: int = 255)

assert(condition: bool, message: String = "")

convert(what: Variant, type: Variant.Type)

dict_to_inst(dictionary: Dictionary)

inst_to_dict(instance: Object)

is_instance_of(value: Variant, type: Variant)

preload(path: String)

print_debug(...) vararg

type_exists(type: StringName)

PI = 3.14159265358979 🔗

Constant that represents how many times the diameter of a circle fits around its perimeter. This is equivalent to TAU / 2, or 180 degrees in rotations.

TAU = 6.28318530717959 🔗

The circle constant, the circumference of the unit circle in radians. This is equivalent to PI * 2, or 360 degrees in rotations.

Positive floating-point infinity. This is the result of floating-point division when the divisor is 0.0. For negative infinity, use -INF. Dividing by -0.0 will result in negative infinity if the numerator is positive, so dividing by 0.0 is not the same as dividing by -0.0 (despite 0.0 == -0.0 returning true).

Warning: Numeric infinity is only a concept with floating-point numbers, and has no equivalent for integers. Dividing an integer number by 0 will not result in INF and will result in a run-time error instead.

"Not a Number", an invalid floating-point value. It is returned by some invalid operations, such as dividing floating-point 0.0 by 0.0.

NAN has special properties, including that != always returns true, while other comparison operators always return false. This is true even when comparing with itself (NAN == NAN returns false and NAN != NAN returns true). Due to this, you must use @GlobalScope.is_nan() to check whether a number is equal to NAN.

Warning: "Not a Number" is only a concept with floating-point numbers, and has no equivalent for integers. Dividing an integer 0 by 0 will not result in NAN and will result in a run-time error instead.

Marks a class or a method as abstract.

An abstract class is a class that cannot be instantiated directly. Instead, it is meant to be inherited by other classes. Attempting to instantiate an abstract class will result in an error.

An abstract method is a method that has no implementation. Therefore, a newline or a semicolon is expected after the function header. This defines a contract that inheriting classes must conform to, because the method signature must be compatible when overriding.

Inheriting classes must either provide implementations for all abstract methods, or the inheriting class must be marked as abstract. If a class has at least one abstract method (either its own or an unimplemented inherited one), then it must also be marked as abstract. However, the reverse is not true: an abstract class is allowed to have no abstract methods.

Mark the following property as exported (editable in the Inspector dock and saved to disk). To control the type of the exported property, use the type hint notation.

Note: Custom resources and nodes should be registered as global classes using class_name, since the Inspector currently only supports global classes. Otherwise, a less specific type will be exported instead.

Note: Node export is only supported in Node-derived classes and has a number of other limitations.

@export_category(name: String) 🔗

Define a new category for the following exported properties. This helps to organize properties in the Inspector dock.

See also @GlobalScope.PROPERTY_USAGE_CATEGORY.

Note: Categories in the Inspector dock's list usually divide properties coming from different classes (Node, Node2D, Sprite, etc.). For better clarity, it's recommended to use @export_group and @export_subgroup, instead.

@export_color_no_alpha() 🔗

Export a Color, Array[Color], or PackedColorArray property without allowing its transparency (Color.a) to be edited.

See also @GlobalScope.PROPERTY_HINT_COLOR_NO_ALPHA.

@export_custom(hint: PropertyHint, hint_string: String, usage: BitField[PropertyUsageFlags] = 6) 🔗

Allows you to set a custom hint, hint string, and usage flags for the exported property. Note that there's no validation done in GDScript, it will just pass the parameters to the editor.

Note: Regardless of the usage value, the @GlobalScope.PROPERTY_USAGE_SCRIPT_VARIABLE flag is always added, as with any explicitly declared script variable.

Export a String, Array[String], or PackedStringArray property as a path to a directory. The path will be limited to the project folder and its subfolders. See @export_global_dir to allow picking from the entire filesystem.

See also @GlobalScope.PROPERTY_HINT_DIR.

@export_enum(names: String, ...) vararg 🔗

Export an int, String, Array[int], Array[String], PackedByteArray, PackedInt32Array, PackedInt64Array, or PackedStringArray property as an enumerated list of options (or an array of options). If the property is an int, then the index of the value is stored, in the same order the values are provided. You can add explicit values using a colon. If the property is a String, then the value is stored.

See also @GlobalScope.PROPERTY_HINT_ENUM.

If you want to set an initial value, you must specify it explicitly:

If you want to use named GDScript enums, then use @export instead:

@export_exp_easing(hints: String = "", ...) vararg 🔗

Export a floating-point property with an easing editor widget. Additional hints can be provided to adjust the behavior of the widget. "attenuation" flips the curve, which makes it more intuitive for editing attenuation properties. "positive_only" limits values to only be greater than or equal to zero.

See also @GlobalScope.PROPERTY_HINT_EXP_EASING.

@export_file(filter: String = "", ...) vararg 🔗

Export a String, Array[String], or PackedStringArray property as a path to a file. The path will be limited to the project folder and its subfolders. See @export_global_file to allow picking from the entire filesystem.

If filter is provided, only matching files will be available for picking.

See also @GlobalScope.PROPERTY_HINT_FILE.

Note: The file will be stored and referenced as UID, if available. This ensures that the reference is valid even when the file is moved. You can use ResourceUID methods to convert it to path.

@export_file_path(filter: String = "", ...) vararg 🔗

Same as @export_file, except the file will be stored as a raw path. This means that it may become invalid when the file is moved. If you are exporting a Resource path, consider using @export_file instead.

@export_flags(names: String, ...) vararg 🔗

Export an integer property as a bit flag field. This allows to store several "checked" or true values with one property, and comfortably select them from the Inspector dock.

See also @GlobalScope.PROPERTY_HINT_FLAGS.

You can add explicit values using a colon:

You can also combine several flags:

Note: A flag value must be at least 1 and at most 2 ** 32 - 1.

Note: Unlike @export_enum, the previous explicit value is not taken into account. In the following example, A is 16, B is 2, C is 4.

You can also use the annotation on Array[int], PackedByteArray, PackedInt32Array, and PackedInt64Array

@export_flags_2d_navigation() 🔗

Export an integer property as a bit flag field for 2D navigation layers. The widget in the Inspector dock will use the layer names defined in ProjectSettings.layer_names/2d_navigation/layer_1.

See also @GlobalScope.PROPERTY_HINT_LAYERS_2D_NAVIGATION.

@export_flags_2d_physics() 🔗

Export an integer property as a bit flag field for 2D physics layers. The widget in the Inspector dock will use the layer names defined in ProjectSettings.layer_names/2d_physics/layer_1.

See also @GlobalScope.PROPERTY_HINT_LAYERS_2D_PHYSICS.

@export_flags_2d_render() 🔗

Export an integer property as a bit flag field for 2D render layers. The widget in the Inspector dock will use the layer names defined in ProjectSettings.layer_names/2d_render/layer_1.

See also @GlobalScope.PROPERTY_HINT_LAYERS_2D_RENDER.

@export_flags_3d_navigation() 🔗

Export an integer property as a bit flag field for 3D navigation layers. The widget in the Inspector dock will use the layer names defined in ProjectSettings.layer_names/3d_navigation/layer_1.

See also @GlobalScope.PROPERTY_HINT_LAYERS_3D_NAVIGATION.

@export_flags_3d_physics() 🔗

Export an integer property as a bit flag field for 3D physics layers. The widget in the Inspector dock will use the layer names defined in ProjectSettings.layer_names/3d_physics/layer_1.

See also @GlobalScope.PROPERTY_HINT_LAYERS_3D_PHYSICS.

@export_flags_3d_render() 🔗

Export an integer property as a bit flag field for 3D render layers. The widget in the Inspector dock will use the layer names defined in ProjectSettings.layer_names/3d_render/layer_1.

See also @GlobalScope.PROPERTY_HINT_LAYERS_3D_RENDER.

@export_flags_avoidance() 🔗

Export an integer property as a bit flag field for navigation avoidance layers. The widget in the Inspector dock will use the layer names defined in ProjectSettings.layer_names/avoidance/layer_1.

See also @GlobalScope.PROPERTY_HINT_LAYERS_AVOIDANCE.

@export_global_dir() 🔗

Export a String, Array[String], or PackedStringArray property as an absolute path to a directory. The path can be picked from the entire filesystem. See @export_dir to limit it to the project folder and its subfolders.

See also @GlobalScope.PROPERTY_HINT_GLOBAL_DIR.

@export_global_file(filter: String = "", ...) vararg 🔗

Export a String, Array[String], or PackedStringArray property as an absolute path to a file. The path can be picked from the entire filesystem. See @export_file to limit it to the project folder and its subfolders.

If filter is provided, only matching files will be available for picking.

See also @GlobalScope.PROPERTY_HINT_GLOBAL_FILE.

@export_group(name: String, prefix: String = "") 🔗

Define a new group for the following exported properties. This helps to organize properties in the Inspector dock. Groups can be added with an optional prefix, which would make group to only consider properties that have this prefix. The grouping will break on the first property that doesn't have a prefix. The prefix is also removed from the property's name in the Inspector dock.

If no prefix is provided, then every following property will be added to the group. The group ends when then next group or category is defined. You can also force end a group by using this annotation with empty strings for parameters, @export_group("", "").

Groups cannot be nested, use @export_subgroup to add subgroups within groups.

See also @GlobalScope.PROPERTY_USAGE_GROUP.

@export_multiline() 🔗

Export a String, Array[String], PackedStringArray, Dictionary or Array[Dictionary] property with a large TextEdit widget instead of a LineEdit. This adds support for multiline content and makes it easier to edit large amount of text stored in the property.

See also @GlobalScope.PROPERTY_HINT_MULTILINE_TEXT.

@export_node_path(type: String = "", ...) vararg 🔗

Export a NodePath or Array[NodePath] property with a filter for allowed node types.

See also @GlobalScope.PROPERTY_HINT_NODE_PATH_VALID_TYPES.

Note: The type must be a native class or a globally registered script (using the class_name keyword) that inherits Node.

@export_placeholder(placeholder: String) 🔗

Export a String, Array[String], or PackedStringArray property with a placeholder text displayed in the editor widget when no value is present.

See also @GlobalScope.PROPERTY_HINT_PLACEHOLDER_TEXT.

@export_range(min: float, max: float, step: float = 1.0, extra_hints: String = "", ...) vararg 🔗

Export an int, float, Array[int], Array[float], PackedByteArray, PackedInt32Array, PackedInt64Array, PackedFloat32Array, or PackedFloat64Array property as a range value. The range must be defined by min and max, as well as an optional step and a variety of extra hints. The step defaults to 1 for integer properties. For floating-point numbers this value depends on your EditorSettings.interface/inspector/default_float_step setting.

If hints "or_greater" and "or_less" are provided, the editor widget will not cap the value at range boundaries. The "exp" hint will make the edited values on range to change exponentially. The "hide_slider" hint will hide the slider element of the editor widget.

Hints also allow to indicate the units for the edited value. Using "radians_as_degrees" you can specify that the actual value is in radians, but should be displayed in degrees in the Inspector dock (the range values are also in degrees). "degrees" allows to add a degree sign as a unit suffix (the value is unchanged). Finally, a custom suffix can be provided using "suffix:unit", where "unit" can be any string.

See also @GlobalScope.PROPERTY_HINT_RANGE.

Export a property with @GlobalScope.PROPERTY_USAGE_STORAGE flag. The property is not displayed in the editor, but it is serialized and stored in the scene or resource file. This can be useful for @tool scripts. Also the property value is copied when Resource.duplicate() or Node.duplicate() is called, unlike non-exported variables.

@export_subgroup(name: String, prefix: String = "") 🔗

Define a new subgroup for the following exported properties. This helps to organize properties in the Inspector dock. Subgroups work exactly like groups, except they need a parent group to exist. See @export_group.

See also @GlobalScope.PROPERTY_USAGE_SUBGROUP.

Note: Subgroups cannot be nested, but you can use the slash separator (/) to achieve the desired effect:

@export_tool_button(text: String, icon: String = "") 🔗

Export a Callable property as a clickable button with the label text. When the button is pressed, the callable is called.

If icon is specified, it is used to fetch an icon for the button via Control.get_theme_icon(), from the "EditorIcons" theme type. If icon is omitted, the default "Callable" icon is used instead.

Consider using the EditorUndoRedoManager to allow the action to be reverted safely.

See also @GlobalScope.PROPERTY_HINT_TOOL_BUTTON.

Note: The property is exported without the @GlobalScope.PROPERTY_USAGE_STORAGE flag because a Callable cannot be properly serialized and stored in a file.

Note: In an exported project neither EditorInterface nor EditorUndoRedoManager exist, which may cause some scripts to break. To prevent this, you can use Engine.get_singleton() and omit the static type from the variable declaration:

Note: Avoid storing lambda callables in member variables of RefCounted-based classes (e.g. resources), as this can lead to memory leaks. Use only method callables and optionally Callable.bind() or Callable.unbind().

@icon(icon_path: String) 🔗

Add a custom icon to the current script. The icon specified at icon_path is displayed in the Scene dock for every node of that class, as well as in various editor dialogs.

Note: Only the script can have a custom icon. Inner classes are not supported.

Note: As annotations describe their subject, the @icon annotation must be placed before the class definition and inheritance.

Note: Unlike most other annotations, the argument of the @icon annotation must be a string literal (constant expressions are not supported).

Mark the following property as assigned when the Node is ready. Values for these properties are not assigned immediately when the node is initialized (Object._init()), and instead are computed and stored right before Node._ready().

@rpc(mode: String = "authority", sync: String = "call_remote", transfer_mode: String = "unreliable", transfer_channel: int = 0) 🔗

Mark the following method for remote procedure calls. See High-level multiplayer.

If mode is set as "any_peer", allows any peer to call this RPC function. Otherwise, only the authority peer is allowed to call it and mode should be kept as "authority". When configuring functions as RPCs with Node.rpc_config(), each of these modes respectively corresponds to the MultiplayerAPI.RPC_MODE_AUTHORITY and MultiplayerAPI.RPC_MODE_ANY_PEER RPC modes. See RPCMode. If a peer that is not the authority tries to call a function that is only allowed for the authority, the function will not be executed. If the error can be detected locally (when the RPC configuration is consistent between the local and the remote peer), an error message will be displayed on the sender peer. Otherwise, the remote peer will detect the error and print an error there.

If sync is set as "call_remote", the function will only be executed on the remote peer, but not locally. To run this function locally too, set sync to "call_local". When configuring functions as RPCs with Node.rpc_config(), this is equivalent to setting call_local to true.

The transfer_mode accepted values are "unreliable", "unreliable_ordered", or "reliable". It sets the transfer mode of the underlying MultiplayerPeer. See MultiplayerPeer.transfer_mode.

The transfer_channel defines the channel of the underlying MultiplayerPeer. See MultiplayerPeer.transfer_channel.

The order of mode, sync and transfer_mode does not matter, but values related to the same argument must not be used more than once. transfer_channel always has to be the 4th argument (you must specify 3 preceding arguments).

Note: Methods annotated with @rpc cannot receive objects which define required parameters in Object._init(). See Object._init() for more details.

Make a script with static variables to not persist after all references are lost. If the script is loaded again the static variables will revert to their default values.

Note: As annotations describe their subject, the @static_unload annotation must be placed before the class definition and inheritance.

Warning: Currently, due to a bug, scripts are never freed, even if @static_unload annotation is used.

Mark the current script as a tool script, allowing it to be loaded and executed by the editor. See Running code in the editor.

Note: As annotations describe their subject, the @tool annotation must be placed before the class definition and inheritance.

@warning_ignore(warning: String, ...) vararg 🔗

Mark the following statement to ignore the specified warning. See GDScript warning system.

See also @warning_ignore_start and @warning_ignore_restore.

@warning_ignore_restore(warning: String, ...) vararg 🔗

Stops ignoring the listed warning types after @warning_ignore_start. Ignoring the specified warning types will be reset to Project Settings. This annotation can be omitted to ignore the warning types until the end of the file.

Note: Unlike most other annotations, arguments of the @warning_ignore_restore annotation must be string literals (constant expressions are not supported).

@warning_ignore_start(warning: String, ...) vararg 🔗

Starts ignoring the listed warning types until the end of the file or the @warning_ignore_restore annotation with the given warning type.

Note: To suppress a single warning, use @warning_ignore instead.

Note: Unlike most other annotations, arguments of the @warning_ignore_start annotation must be string literals (constant expressions are not supported).

Color Color8(r8: int, g8: int, b8: int, a8: int = 255) 🔗

Deprecated: Use Color.from_rgba8() instead.

Returns a Color constructed from red (r8), green (g8), blue (b8), and optionally alpha (a8) integer channels, each divided by 255.0 for their final value. Using Color8() instead of the standard Color constructor is useful when you need to match exact color values in an Image.

Note: Due to the lower precision of Color8() compared to the standard Color constructor, a color created with Color8() will generally not be equal to the same color created with the standard Color constructor. Use Color.is_equal_approx() for comparisons to avoid issues with floating-point precision error.

void assert(condition: bool, message: String = "") 🔗

Asserts that the condition is true. If the condition is false, an error is generated. When running from the editor, the running project will also be paused until you resume it. This can be used as a stronger form of @GlobalScope.push_error() for reporting errors to project developers or add-on users.

An optional message can be shown in addition to the generic "Assertion failed" message. You can use this to provide additional details about why the assertion failed.

Warning: For performance reasons, the code inside assert() is only executed in debug builds or when running the project from the editor. Don't include code that has side effects in an assert() call. Otherwise, the project will behave differently when exported in release mode.

Note: assert() is a keyword, not a function. So you cannot access it as a Callable or use it inside expressions.

String char(code: int) 🔗

Returns a single character (as a String of length 1) of the given Unicode code point code.

This is the inverse of ord(). See also String.chr() and String.unicode_at().

Variant convert(what: Variant, type: Variant.Type) 🔗

Deprecated: Use @GlobalScope.type_convert() instead.

Converts what to type in the best way possible. The type uses the Variant.Type values.

Object dict_to_inst(dictionary: Dictionary) 🔗

Deprecated: Consider using JSON.to_native() or Object.get_property_list() instead.

Converts a dictionary (created with inst_to_dict()) back to an Object instance. Can be useful for deserializing.

Returns an array of dictionaries representing the current call stack.

Starting from _ready(), bar() would print:

See also print_debug(), print_stack(), and Engine.capture_script_backtraces().

Note: By default, backtraces are only available in editor builds and debug builds. To enable them for release builds as well, you need to enable ProjectSettings.debug/settings/gdscript/always_track_call_stacks.

Dictionary inst_to_dict(instance: Object) 🔗

Deprecated: Consider using JSON.from_native() or Object.get_property_list() instead.

Returns the passed instance converted to a Dictionary. Can be useful for serializing.

Note: This function can only be used to serialize objects with an attached GDScript stored in a separate file. Objects without an attached script, with a script written in another language, or with a built-in script are not supported.

Note: This function is not recursive, which means that nested objects will not be represented as dictionaries. Also, properties passed by reference (Object, Dictionary, Array, and packed arrays) are copied by reference, not duplicated.

bool is_instance_of(value: Variant, type: Variant) 🔗

Returns true if value is an instance of type. The type value must be one of the following:

A constant from the Variant.Type enumeration, for example @GlobalScope.TYPE_INT.

An Object-derived class which exists in ClassDB, for example Node.

A Script (you can use any class, including inner one).

Unlike the right operand of the is operator, type can be a non-constant value. The is operator supports more features (such as typed arrays). Use the operator instead of this method if you do not need to check the type dynamically.

Note: If value and/or type are freed objects (see @GlobalScope.is_instance_valid()), or type is not one of the above options, this method will raise a runtime error.

See also @GlobalScope.typeof(), type_exists(), Array.is_same_typed() (and other Array methods).

int len(var: Variant) 🔗

Returns the length of the given Variant var. The length can be the character count of a String or StringName, the element count of any array type, or the size of a Dictionary. For every other Variant type, a run-time error is generated and execution is stopped.

Resource load(path: String) 🔗

Returns a Resource from the filesystem located at the absolute path. Unless it's already referenced elsewhere (such as in another script or in the scene), the resource is loaded from disk on function call, which might cause a slight delay, especially when loading large scenes. To avoid unnecessary delays when loading something multiple times, either store the resource in a variable or use preload(). This method is equivalent of using ResourceLoader.load() with ResourceLoader.CACHE_MODE_REUSE.

Note: Resource paths can be obtained by right-clicking on a resource in the FileSystem dock and choosing "Copy Path", or by dragging the file from the FileSystem dock into the current script.

Important: Relative paths are not relative to the script calling this method, instead it is prefixed with "res://". Loading from relative paths might not work as expected.

This function is a simplified version of ResourceLoader.load(), which can be used for more advanced scenarios.

Note: Files have to be imported into the engine first to load them using this function. If you want to load Images at run-time, you may use Image.load(). If you want to import audio files, you can use the snippet described in AudioStreamMP3.data.

Note: If ProjectSettings.editor/export/convert_text_resources_to_binary is true, load() will not be able to read converted files in an exported project. If you rely on run-time loading of files present within the PCK, set ProjectSettings.editor/export/convert_text_resources_to_binary to false.

int ord(char: String) 🔗

Returns an integer representing the Unicode code point of the given character char, which should be a string of length 1.

This is the inverse of char(). See also String.chr() and String.unicode_at().

Resource preload(path: String) 🔗

Returns a Resource from the filesystem located at path. During run-time, the resource is loaded when the script is being parsed. This function effectively acts as a reference to that resource. Note that this function requires path to be a constant String. If you want to load a resource from a dynamic/variable path, use load().

Note: Resource paths can be obtained by right-clicking on a resource in the Assets Panel and choosing "Copy Path", or by dragging the file from the FileSystem dock into the current script.

Note: preload() is a keyword, not a function. So you cannot access it as a Callable.

void print_debug(...) vararg 🔗

Like @GlobalScope.print(), but includes the current stack frame when running with the debugger turned on.

The output in the console may look like the following:

See also print_stack(), get_stack(), and Engine.capture_script_backtraces().

Note: By default, backtraces are only available in editor builds and debug builds. To enable them for release builds as well, you need to enable ProjectSettings.debug/settings/gdscript/always_track_call_stacks.

Prints a stack trace at the current code location.

The output in the console may look like the following:

See also print_debug(), get_stack(), and Engine.capture_script_backtraces().

Note: By default, backtraces are only available in editor builds and debug builds. To enable them for release builds as well, you need to enable ProjectSettings.debug/settings/gdscript/always_track_call_stacks.

Array range(...) vararg 🔗

Returns an array with the given range. range() can be called in three ways:

range(n: int): Starts from 0, increases by steps of 1, and stops before n. The argument n is exclusive.

range(b: int, n: int): Starts from b, increases by steps of 1, and stops before n. The arguments b and n are inclusive and exclusive, respectively.

range(b: int, n: int, s: int): Starts from b, increases/decreases by steps of s, and stops before n. The arguments b and n are inclusive and exclusive, respectively. The argument s can be negative, but not 0. If s is 0, an error message is printed.

range() converts all arguments to int before processing.

Note: Returns an empty array if no value meets the value constraint (e.g. range(2, 5, -1) or range(5, 5, 1)).

To iterate over an Array backwards, use:

To iterate over float, convert them in the loop.

bool type_exists(type: StringName) 🔗

Returns true if the given Object-derived class exists in ClassDB. Note that Variant data types are not registered in ClassDB.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
@abstract class Shape:
    @abstract func draw()

class Circle extends Shape:
    func draw():
        print("Drawing a circle.")

class Square extends Shape:
    func draw():
        print("Drawing a square.")
```

Example 2 (unknown):
```unknown
extends Node

enum Direction {LEFT, RIGHT, UP, DOWN}

# Built-in types.
@export var string = ""
@export var int_number = 5
@export var float_number: float = 5

# Enums.
@export var type: Variant.Type
@export var format: Image.Format
@export var direction: Direction

# Resources.
@export var image: Image
@export var custom_resource: CustomResource

# Nodes.
@export var node: Node
@export var custom_node: CustomNode

# Typed arrays.
@export var int_array: Array[int]
@export var direction_array: Array[Direction]
@export var image_array: Array[Image]
@export var node_array: Array[Node]
```

Example 3 (unknown):
```unknown
@export_category("Statistics")
@export var hp = 30
@export var speed = 1.25
```

Example 4 (unknown):
```unknown
@export_color_no_alpha var dye_color: Color
@export_color_no_alpha var dye_colors: Array[Color]
```

---

## GDScript grammar — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/file_formats/gdscript_grammar.html

**Contents:**
- GDScript grammar
- User-contributed notes

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

This is the formal grammar of GDScript written in EBNF, for reference purposes.

This grammar is descriptive only, derived from the reference documentation and current implementation. The GDScript parser is not generated from a grammar definition. Inconsistencies here likely mean an error in this grammar, not a bug in GDScript.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
(* GDScript EBNF grammar.
   Uppercase words are terminals generated by the tokenizer.
   INDENT/DEDENT are not generated by the tokenizer yet, but they are added
   here for reading convenience.
   Naturally, this only cover syntax. Semantics can't be inferred from this
   description.
*)

program = [ inheritance NEWLINE ] [ className ] { topLevelDecl } ;

inheritance = "extends" ( IDENTIFIER | STRING ) { "." IDENTIFIER } ;
className = "class_name" IDENTIFIER [ "," STRING ] NEWLINE ;

topLevelDecl
    = classVarDecl
    | constDecl
    | signalDecl
    | enumDecl
    | methodDecl
    | constructorDecl
    | innerClass
    | "tool"
    ;

classVarDecl = [ "onready" ] [ export ] "var" IDENTIFIER [ ":" typeHint ]
    [ "=" expression ] [ setget ] NEWLINE ;
setget = "setget" [ IDENTIFIER ] [ "," IDENTIFIER] ;
export = "export" [ "(" [ BUILTINTYPE | IDENTIFIER { "," literal } ] ")" ] ;
typeHint = BUILTINTYPE | IDENTIFIER ;

constDecl = "const" IDENTIFIER [ ":" typeHint ] "=" expression NEWLINE ;

signalDecl = "signal" IDENTIFIER [ signalParList ] NEWLINE ;
signalParList = "(" [ IDENTIFIER { "," IDENTIFIER } ] ")" ;

enumDecl = "enum" [ IDENTIFIER ] "{" [ IDENTIFIER [ "=" INTEGER ]
    { "," IDENTIFIER [ "=" INTEGER ] } [ "," ] ] "}" NEWLINE ;

methodDecl = [ rpc ] [ "static" ] "func" IDENTIFIER "(" [ parList ] ")"
    [ "->" typeHint] ":" stmtOrSuite ;
parList = parameter { "," parameter } ;
parameter = [ "var" ] IDENTIFIER [ ":" typeHint ] [ "=" expression ] ;
rpc = "remote" | "master" | "puppet"
    | "remotesync" | "mastersync"  | "puppetsync";

constructorDecl = "func" IDENTIFIER "(" [ parList ] ")"
    [ "." "(" [ argList ] ")" ] ":" stmtOrSuite ;
argList = expression { "," expression } ;

innerClass = "class" IDENTIFIER [ inheritance ] ":" NEWLINE
    INDENT [ inheritance NEWLINE ] topLevelDecl { topLevelDecl } DEDENT ;

stmtOrSuite = stmt | NEWLINE INDENT suite DEDENT ;
suite = stmt { stmt };

stmt
    = varDeclStmt
    | ifStmt
    | forStmt
    | whileStmt
    | matchStmt
    | flowStmt
    | assignmentStmt
    | exprStmt
    | assertStmt
    | yieldStmt
    | preloadStmt
    | "breakpoint" stmtEnd
    | "pass" stmtEnd
    ;
stmtEnd = NEWLINE | ";" ;

ifStmt = "if" expression ":" stmtOrSuite { "elif" expression ":" stmtOrSuite }
    [ "else" ":" stmtOrSuite ] ;
whileStmt = "while" expression ":" stmtOrSuite;
forStmt = "for" IDENTIFIER "in" expression ":" stmtOrSuite ;

matchStmt = "match" expression ":" NEWLINE INDENT matchBlock DEDENT;
matchBlock = patternList ":" stmtOrSuite { patternList ":" stmtOrSuite };
patternList = pattern { "," pattern } ;
(* Note: you can't have a binding in a pattern list, but to not complicate the
grammar more it won't be restricted syntactically *)
pattern = literal | BUILTINTYPE | CONSTANT | "_" | bindingPattern
    | arrayPattern | dictPattern ;
bindingPattern = "var" IDENTIFIER ;
arrayPattern = "[" [ pattern { "," pattern } [ ".." ] ] "]" ;
dictPattern = "{" [ keyValuePattern ] { "," keyValuePattern } [ ".." ] "}" ;
keyValuePattern = STRING [ ":" pattern ] ;

flowStmt
    = "continue" stmtEnd
    | "break" stmtEnd
    | "return" [ expression ] stmtEnd
    ;

assignmentStmt = subscription ( "=" | "+=" | "-=" | "*=" | "/="
| "%=" | "&=" | "|=" | "^=" ) expression stmtEnd;
varDeclStmt = "var" IDENTIFIER [ "=" expression ] stmtEnd;

assertStmt = "assert" "(" expression [ "," STRING ] ")" stmtEnd ;
yieldStmt = "yield" "(" [ expression "," expression ] ")" ;
preloadStmt = "preload" "(" CONSTANT ")" ;

(* This expression grammar encodes precedence. Items later in the list have
higher precedence than the ones before. *)
exprStmt = expression stmtEnd ;
expression = cast [ "[" expression "]" ] ;
cast = ternaryExpr [ "as" typeHint ];
ternaryExpr = logicOr [ "if" logicOr "else" logicOr ] ;
logicOr = logicAnd { ( "or" | "||" ) logicAnd } ;
logicAnd = logicNot { ( "and" | "&&" ) logicNot };
logicNot = ( "!" | "not" ) logicNot | in;
in = comparison { "in" comparison };
comparison = bitOr { ( "<" | ">" | "<=" | ">=" | "==" | "!=" ) bitOr } ;
bitOr = bitXor { "|" bitXor } ;
bitXor = bitAnd { "^" bitAnd } ;
bitAnd = bitShift { "&" bitShift } ;
bitShift = minus { ( "<<" | ">>" ) minus } ;
minus = plus { "-" plus } ;
plus = factor { "+" factor } ;
factor = sign { ( "*" | "/" | "%" ) sign } ;
sign = ( "-" | "+" ) sign | bitNot ;
bitNot = "~" bitNot | is ;
is = call [ "is" ( IDENTIFIER | BUILTINTYPE ) ] ;
call
    = (attribute [ "(" [ argList ] ")" ])
    | "." IDENTIFIER "(" [ argList ] ")"
    | "$" ( STRING | IDENTIFIER { '/' IDENTIFIER } );
attribute = subscription { "." IDENTIFIER } ;
subscription = primary [ "[" expression "]" ] ;
primary = "true" | "false" | "null" | "self" | literal | arrayDecl
    | dictDecl | "(" expression ")" ;

literal = STRING | NUMBER | IDENTIFIER | BUILTINTYPE
    | "PI" | "TAU" | "NAN" | "INF" ;
arrayDecl = "[" [ expression { "," expression } "," ] "]" ;
dictDecl = "{" [ keyValue { "," keyValue } "," ] "}" ;
keyValue
    = expression ":" expression
    | IDENTIFIER "=" expression
    ;
```

---

## GDScript reference — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_basics.html

**Contents:**
- GDScript reference
- History
- Example of GDScript
- Identifiers
- Keywords
- Operators
- Literals
- Annotations
  - @onready annotation
- Comments

GDScript is a high-level, object-oriented, imperative, and gradually typed programming language built for Godot. It uses an indentation-based syntax similar to languages like Python. Its goal is to be optimized for and tightly integrated with Godot Engine, allowing great flexibility for content creation and integration.

GDScript is entirely independent from Python and is not based on it.

Documentation about GDScript's history has been moved to the Frequently Asked Questions.

Some people can learn better by taking a look at the syntax, so here's an example of how GDScript looks.

If you have previous experience with statically typed languages such as C, C++, or C# but never used a dynamically typed one before, it is advised you read this tutorial: GDScript: An introduction to dynamic languages.

Any string that restricts itself to alphabetic characters (a to z and A to Z), digits (0 to 9) and _ qualifies as an identifier. Additionally, identifiers must not begin with a digit. Identifiers are case-sensitive (foo is different from FOO).

Identifiers may also contain most Unicode characters part of UAX#31. This allows you to use identifier names written in languages other than English. Unicode characters that are considered "confusable" for ASCII characters and emoji are not allowed in identifiers.

The following is the list of keywords supported by the language. Since keywords are reserved words (tokens), they can't be used as identifiers. Operators (like in, not, and or or) and names of built-in types as listed in the following sections are also reserved.

Keywords are defined in the GDScript tokenizer in case you want to take a look under the hood.

Used by pattern guards in match statements.

Exits the execution of the current for or while loop.

Immediately skips to the next iteration of the for or while loop.

Used where a statement is required syntactically but execution of code is undesired, e.g. in empty functions.

Returns a value from a function.

Defines an inner class. See Inner classes.

Defines the script as a globally accessible class with the specified name. See Registering named classes.

Defines what class to extend with the current class.

Tests whether a variable extends a given class, or is of a given built-in type.

Tests whether a value is within a string, array, range, dictionary, or node. When used with for, it iterates through them instead of testing.

Cast the value to a given type if possible.

Refers to current class instance. See self.

Resolves the scope of the parent method. See Inheritance.

Defines a signal. See Signals.

Defines a function. See Functions.

Defines a static function or a static member variable.

Defines a constant. See Constants.

Defines an enum. See Enums.

Defines a variable. See Variables.

Editor helper for debugger breakpoints. Unlike breakpoints created by clicking in the gutter, breakpoint is stored in the script itself. This makes it persistent across different machines when using version control.

Preloads a class or variable. See Classes as resources.

Waits for a signal or a coroutine to finish. See Awaiting signals or coroutines.

Previously used for coroutines. Kept as keyword for transition.

Asserts a condition, logs error on failure. Ignored in non-debug builds. See Assert keyword.

Used to represent that a function does not return any value.

Infinity constant. Used for comparisons and as result of calculations.

NAN (not a number) constant. Used as impossible result from calculations.

The following is the list of supported operators and their precedence. All binary operators are left-associative, including the ** operator. This means that 2 ** 2 ** 3 is equal to (2 ** 2) ** 3. Use parentheses to explicitly specify precedence you need, for example 2 ** (2 ** 3). The ternary if/else operator is right-associative.

Grouping (highest priority)

Parentheses are not really an operator, but allow you to explicitly specify the precedence of an operation.

Awaiting signals or coroutines

See also is_instance_of() function.

Multiplies x by itself y times, similar to calling pow() function.

Multiplication / Division / Remainder

The % operator is additionally used for format strings.

Note: These operators have the same behavior as C++, which may be unexpected for users coming from Python, JavaScript, etc. See a detailed note after the table.

Addition (or Concatenation) / Subtraction

See a detailed note after the table.

in is also used with the for keyword as part of the syntax.

Boolean NOT and its unrecommended alias

Boolean AND and its unrecommended alias

Boolean OR and its unrecommended alias

true_expr if cond else false_expr

Assignment (lowest priority)

You cannot use an assignment operator inside an expression.

The behavior of some operators may differ from what you expect:

If both operands of the / operator are int, then integer division is performed instead of fractional. For example 5 / 2 == 2, not 2.5. If this is not desired, use at least one float literal (x / 2.0), cast (float(x) / y), or multiply by 1.0 (x * 1.0 / y).

The % operator is only available for ints, for floats use the fmod() function.

For negative values, the % operator and fmod() use truncation instead of rounding towards negative infinity. This means that the remainder has a sign. If you need the remainder in a mathematical sense, use the posmod() and fposmod() functions instead.

The == and != operators sometimes allow you to compare values of different types (for example, 1 == 1.0 is true), but in other cases it can cause a runtime error. If you're not sure about the types of the operands, you can safely use the is_same() function (but note that it is more strict about types and references). To compare floats, use the is_equal_approx() and is_zero_approx() functions instead.

Base 16 (hexadecimal) integer

Base 2 (binary) integer

Floating-point number (real)

"""Hello""", '''Hi'''

Triple-quoted regular strings

r"""Hello""", r'''Hi'''

Triple-quoted raw strings

There are also two constructs that look like literals, but actually are not:

Shorthand for get_node("NodePath")

Shorthand for get_node("%UniqueNode")

Integers and floats can have their numbers separated with _ to make them more readable. The following ways to write numbers are all valid:

Regular string literals can contain the following escape sequences:

Horizontal tab character

Vertical tab character

UTF-16 Unicode codepoint XXXX (hexadecimal, case-insensitive)

UTF-32 Unicode codepoint XXXXXX (hexadecimal, case-insensitive)

There are two ways to represent an escaped Unicode character above 0xFFFF:

as a UTF-16 surrogate pair \uXXXX\uXXXX.

as a single UTF-32 codepoint \UXXXXXX.

Also, using \ followed by a newline inside a string will allow you to continue it in the next line, without inserting a newline character in the string itself.

A string enclosed in quotes of one type (for example ") can contain quotes of another type (for example ') without escaping. Triple-quoted strings allow you to avoid escaping up to two consecutive quotes of the same type (unless they are adjacent to the string edges).

Raw string literals always encode the string as it appears in the source code. This is especially useful for regular expressions. A raw string literal doesn't process escape sequences, however it does recognize \\ and \" (\') and replaces them with themselves. Thus, a string can have a quote that matches the opening one, but only if it's preceded by a backslash.

Some strings cannot be represented using raw string literals: you cannot have an odd number of backslashes at the end of a string or have an unescaped opening quote inside the string. However, in practice this doesn't matter since you can use a different quote type or use concatenation with a regular string literal.

GDScript also supports format strings.

Annotations are special tokens in GDScript that act as modifiers to a script or its code and may affect how the script is treated by the Godot engine or editor.

Every annotation starts with the @ character and is specified by a name. A detailed description and example for each annotation can be found inside the GDScript class reference.

For instance, you can use it to export a value to the editor:

For more information about exporting properties, read the GDScript exports article.

Any constant expression compatible with the required argument type can be passed as an annotation argument value:

Annotations can be specified one per line or all in the same line. They affect the next statement that isn't an annotation. Annotations can have arguments sent between parentheses and separated by commas.

Both of these are the same:

When using nodes, it's common to desire to keep references to parts of the scene in a variable. As scenes are only warranted to be configured when entering the active scene tree, the sub-nodes can only be obtained when a call to Node._ready() is made.

This can get a little cumbersome, especially when nodes and external references pile up. For this, GDScript has the @onready annotation, that defers initialization of a member variable until _ready() is called. It can replace the above code with a single line:

Applying @onready and any @export annotation to the same variable doesn't work as you might expect. The @onready annotation will cause the default value to be set after the @export takes effect and will override it:

Therefore, the ONREADY_WITH_EXPORT warning is generated, which is treated as an error by default. We do not recommend disabling or ignoring it.

Anything from a # to the end of the line is ignored and is considered a comment.

In the Godot script editor, special keywords are highlighted within comments to bring the user's attention to specific comments:

Critical (appears in red): ALERT, ATTENTION, CAUTION, CRITICAL, DANGER, SECURITY

Warning (appears in yellow): BUG, DEPRECATED, FIXME, HACK, TASK, TBD, TODO, WARNING

Notice (appears in green): INFO, NOTE, NOTICE, TEST, TESTING

These keywords are case-sensitive, so they must be written in uppercase for them to be recognized:

The list of highlighted keywords and their colors can be changed in the Text Editor > Theme > Comment Markers section of the Editor Settings.

Use two hash symbols (##) instead of one (#) to add a documentation comment, which will appear in the script documentation and in the inspector description of an exported variable. Documentation comments must be placed directly above a documentable item (such as a member variable), or at the top of a file. Dedicated formatting options are also available. See GDScript documentation comments for details.

Code regions are special types of comments that the script editor understands as foldable regions. This means that after writing code region comments, you can collapse and expand the region by clicking the arrow that appears at the left of the comment. This arrow appears within a purple square to be distinguishable from standard code folding.

The syntax is as follows:

To create a code region quickly, select several lines in the script editor, right-click the selection then choose Create Code Region. The region description will be selected automatically for editing.

It is possible to nest code regions within other code regions.

Here's a concrete usage example of code regions:

This can be useful to organize large chunks of code into easier to understand sections. However, remember that external editors generally don't support this feature, so make sure your code is easy to follow even when not relying on folding code regions.

Individual functions and indented sections (such as if and for) can always be collapsed in the script editor. This means you should avoid using a code region to contain a single function or indented section, as it won't bring much of a benefit. Code regions work best when they're used to group multiple elements together.

A line of code in GDScript can be continued on the next line by using a backslash (\). Add one at the end of a line and the code on the next line will act like it's where the backslash is. Here is an example:

A line can be continued multiple times like this:

Built-in types are stack-allocated. They are passed as values. This means a copy is created on each assignment or when passing them as arguments to functions. The exceptions are Object, Array, Dictionary, and packed arrays (such as PackedByteArray), which are passed by reference so they are shared. All arrays, Dictionary, and some objects (Node, Resource) have a duplicate() method that allows you to make a copy.

A variable in GDScript can be assigned to several built-in types.

null is an empty data type that contains no information and can not be assigned any other value.

Only types that inherit from Object can have a null value (Object is therefore called a "nullable" type). Variant types must have a valid value at all times, and therefore cannot have a null value.

Short for "boolean", it can only contain true or false.

Short for "integer", it stores whole numbers (positive and negative). It is stored as a 64-bit value, equivalent to int64_t in C++.

Stores real numbers, including decimals, using floating-point values. It is stored as a 64-bit value, equivalent to double in C++. Note: Currently, data structures such as Vector2, Vector3, and PackedFloat32Array store 32-bit single-precision float values.

A sequence of characters in Unicode format.

An immutable string that allows only one instance of each name. They are slower to create and may result in waiting for locks when multithreading. In exchange, they're very fast to compare, which makes them good candidates for dictionary keys.

A pre-parsed path to a node or a node property. It can be easily assigned to, and from, a String. They are useful to interact with the tree to get a node, or affecting properties like with Tweens.

2D vector type containing x and y fields. Can also be accessed as an array.

Same as a Vector2 but the components are integers. Useful for representing items in a 2D grid.

2D Rectangle type containing two vectors fields: position and size. Also contains an end field which is position + size.

3D vector type containing x, y and z fields. This can also be accessed as an array.

Same as Vector3 but the components are integers. Can be use for indexing items in a 3D grid.

3×2 matrix used for 2D transforms.

3D Plane type in normalized form that contains a normal vector field and a d scalar distance.

Quaternion is a datatype used for representing a 3D rotation. It's useful for interpolating rotations.

Axis-aligned bounding box (or 3D box) contains 2 vectors fields: position and size. Also contains an end field which is position + size.

3x3 matrix used for 3D rotation and scale. It contains 3 vector fields (x, y and z) and can also be accessed as an array of 3D vectors.

3D Transform contains a Basis field basis and a Vector3 field origin.

Color data type contains r, g, b, and a fields. It can also be accessed as h, s, and v for hue/saturation/value.

Resource ID (RID). Servers use generic RIDs to reference opaque data.

Base class for anything that is not a built-in type.

Generic sequence of arbitrary object types, including other arrays or dictionaries (see below). The array can resize dynamically. Arrays are indexed starting from index 0. Negative indices count from the end.

Godot 4.0 added support for typed arrays. On write operations, Godot checks that element values match the specified type, so the array cannot contain invalid values. The GDScript static analyzer takes typed arrays into account, however array methods like front() and back() still have the Variant return type.

Typed arrays have the syntax Array[Type], where Type can be any Variant type, native or user class, or enum. Nested array types (like Array[Array[int]]) are not supported.

Array and Array[Variant] are the same thing.

Arrays are passed by reference, so the array element type is also an attribute of the in-memory structure referenced by a variable in runtime. The static type of a variable restricts the structures that it can reference to. Therefore, you cannot assign an array with a different element type, even if the type is a subtype of the required type.

If you want to convert a typed array, you can create a new array and use the Array.assign() method:

The only exception was made for the Array (Array[Variant]) type, for user convenience and compatibility with old code. However, operations on untyped arrays are considered unsafe.

PackedArrays are generally faster to iterate on and modify compared to a typed Array of the same type (e.g. PackedInt64Array versus Array[int]) and consume less memory. In the worst case, they are expected to be as fast as an untyped Array. Conversely, non-Packed Arrays (typed or not) have extra convenience methods such as Array.map that PackedArrays lack. Consult the class reference for details on the methods available. Typed Arrays are generally faster to iterate on and modify than untyped Arrays.

While all Arrays can cause memory fragmentation when they become large enough, if memory usage and performance (iteration and modification speed) is a concern and the type of data you're storing is compatible with one of the Packed Array types, then using those may yield improvements. However, if you do not have such concerns (e.g. the size of your array does not reach the tens of thousands of elements) it is likely more helpful to use regular or typed Arrays, as they provide convenience methods that can make your code easier to write and maintain (and potentially faster if your data requires such operations a lot). If the data you will store is of a known type (including your own defined classes), prefer to use a typed Array as it may yield better performance in iteration and modification compared to an untyped Array.

PackedByteArray: An array of bytes (integers from 0 to 255).

PackedInt32Array: An array of 32-bit integers.

PackedInt64Array: An array of 64-bit integers.

PackedFloat32Array: An array of 32-bit floats.

PackedFloat64Array: An array of 64-bit floats.

PackedStringArray: An array of strings.

PackedVector2Array: An array of Vector2 values.

PackedVector3Array: An array of Vector3 values.

PackedVector4Array: An array of Vector4 values.

PackedColorArray: An array of Color values.

Associative container which contains values referenced by unique keys.

Lua-style table syntax is also supported. Lua-style uses = instead of : and doesn't use quotes to mark string keys (making for slightly less to write). However, keys written in this form can't start with a digit (like any GDScript identifier), and must be string literals.

To add a key to an existing dictionary, access it like an existing key and assign to it:

The bracket syntax can be used to access properties of any Object, not just Dictionaries. Keep in mind it will cause a script error when attempting to index a non-existing property. To avoid this, use the Object.get() and Object.set() methods instead.

Godot 4.4 added support for typed dictionaries. On write operations, Godot checks that element keys and values match the specified type, so the dictionary cannot contain invalid keys or values. The GDScript static analyzer takes typed dictionaries into account. However, dictionary methods that return values still have the Variant return type.

Typed dictionaries have the syntax Dictionary[KeyType, ValueType], where KeyType and ValueType can be any Variant type, native or user class, or enum. Both the key and value type must be specified, but you can use Variant to make either of them untyped. Nested typed collections (like Dictionary[String, Dictionary[String, int]]) are not supported.

Dictionary and Dictionary[Variant, Variant] are the same thing.

A signal is a message that can be emitted by an object to those who want to listen to it. The Signal type can be used for passing the emitter around.

Signals are better used by getting them from actual objects, e.g. $Button.button_up.

Contains an object and a function, which is useful for passing functions as values (e.g. when connecting to signals).

Getting a method as a member returns a callable. var x = $Sprite2D.rotate will set the value of x to a callable with $Sprite2D as the object and rotate as the method.

You can call it using the call method: x.call(PI).

Variables can exist as class members or local to functions. They are created with the var keyword and may, optionally, be assigned a value upon initialization.

Variables can optionally have a type specification. When a type is specified, the variable will be forced to have always that same type, and trying to assign an incompatible value will raise an error.

Types are specified in the variable declaration using a : (colon) symbol after the variable name, followed by the type.

If the variable is initialized within the declaration, the type can be inferred, so it's possible to omit the type name:

Type inference is only possible if the assigned value has a defined type, otherwise it will raise an error.

Built-in types (Array, Vector2, int, String, etc.).

Engine classes (Node, Resource, RefCounted, etc.).

Constant names if they contain a script resource (MyScript if you declared const MyScript = preload("res://my_script.gd")).

Other classes in the same script, respecting scope (InnerClass.NestedClass if you declared class NestedClass inside the class InnerClass in the same scope).

Script classes declared with the class_name keyword.

Autoloads registered as singletons.

While Variant is a valid type specification, it's not an actual type. It only means there's no set type and is equivalent to not having a static type at all. Therefore, inference is not allowed by default for Variant, since it's likely a mistake.

You can turn off this check, or make it only a warning, by changing it in the project settings. See GDScript warning system for details.

Member variables are initialized in the following order:

Depending on the variable's static type, the variable is either null (untyped variables and objects) or has a default value of the type (0 for int, false for bool, etc.).

The specified values are assigned in the order of the variables in the script, from top to bottom.

(Only for Node-derived classes) If the @onready annotation is applied to a variable, its initialization is deferred to step 5.

If defined, the _init() method is called.

When instantiating scenes and resources, the exported values are assigned.

(Only for Node-derived classes) @onready variables are initialized.

(Only for Node-derived classes) If defined, the _ready() method is called.

You can specify a complex expression as a variable initializer, including function calls. Make sure the variables are initialized in the correct order, otherwise your values may be overwritten. For example:

To fix this, move the _data variable definition above the a definition or remove the empty dictionary assignment (= {}).

A class member variable can be declared static:

Static variables belong to the class, not instances. This means that static variables share values between multiple instances, unlike regular member variables.

From inside a class, you can access static variables from any function, both static and non-static. From outside the class, you can access static variables using the class or an instance (the second is not recommended as it is less readable).

The @export and @onready annotations cannot be applied to a static variable. Local variables cannot be static.

The following example defines a Person class with a static variable named max_id. We increment the max_id in the _init() function. This makes it easy to keep track of the number of Person instances in our game.

In this code, we create two instances of our Person class and check that the class and every instance have the same max_id value, because the variable is static and accessible to every instance.

Static variables can have type hints, setters and getters:

A base class static variable can also be accessed via a child class:

When referencing a static variable from a tool script, the other script containing the static variable must also be a tool script. See Running code in the editor for details.

Since GDScript classes are resources, having static variables in a script prevents it from being unloaded even if there are no more instances of that class and no other references left. This can be important if static variables store large amounts of data or hold references to other project resources, such as scenes. You should clean up this data manually, or use the @static_unload annotation if static variables don't store important data and can be reset.

Currently, due to a bug, scripts are never freed, even if @static_unload annotation is used.

Note that @static_unload applies to the entire script (including inner classes) and must be placed at the top of the script, before class_name and extends:

See also Static functions and Static constructor.

Values assigned to typed variables must have a compatible type. If it's needed to coerce a value to be of a certain type, in particular for object types, you can use the casting operator as.

Casting between object types results in the same object if the value is of the same type or a subtype of the cast type.

If the value is not a subtype, the casting operation will result in a null value.

For built-in types, they will be forcibly converted if possible, otherwise the engine will raise an error.

Casting is also useful to have better type-safe variables when interacting with the scene tree:

Constants are values you cannot change when the game is running. Their value must be known at compile-time. Using the const keyword allows you to give a constant value a name. Trying to assign a value to a constant after it's declared will give you an error.

We recommend using constants whenever a value is not meant to change.

Although the type of constants is inferred from the assigned value, it's also possible to add explicit type specification:

Assigning a value of an incompatible type will raise an error.

You can also create constants inside a function, which is useful to name local magic values.

Enums are basically a shorthand for constants, and are pretty useful if you want to assign consecutive integers to some constant.

If you pass a name to the enum, it will put all the keys inside a constant Dictionary of that name. This means all constant methods of a dictionary can also be used with a named enum.

Keys in a named enum are not registered as global constants. They should be accessed prefixed by the enum's name (Name.KEY).

If not assigning a value to a key of an enum it will be assigned the previous value plus one, or 0 if it is the first entry in the enum. Multiple keys with the same value are allowed.

Functions always belong to a class. The scope priority for variable look-up is: local → class member → global. The self variable is always available and is provided as an option for accessing class members (see self), but is not always required (and should not be sent as the function's first argument, unlike Python).

A function can return at any point. The default return value is null.

If a function contains only one line of code, it can be written on one line:

Functions can also have type specification for the arguments and for the return value. Types for arguments can be added in a similar way to variables:

If a function argument has a default value, it's possible to infer the type:

The return type of the function can be specified after the arguments list using the arrow token (->):

Functions that have a return type must return a proper value. Setting the type as void means the function doesn't return anything. Void functions can return early with the return keyword, but they can't return any value.

Non-void functions must always return a value, so if your code has branching statements (such as an if/else construct), all the possible paths must have a return. E.g., if you have a return inside an if block but not after it, the editor will raise an error because if the block is not executed, the function won't have a valid value to return.

Functions are first-class values in terms of the Callable object. Referencing a function by name without calling it will automatically generate the proper callable. This can be used to pass functions as arguments.

Callables must be called with the call() method. You cannot use the () operator directly. This behavior is implemented to avoid performance issues on direct function calls.

Lambda functions allow you to declare functions that do not belong to a class. Instead, a Callable object is created and assigned to a variable directly. This can be useful to create callables to pass around without polluting the class scope.

To call the created lambda you can use the call() method:

Lambda functions can be named for debugging purposes (the name is displayed in the Debugger):

You can specify type hints for lambda functions in the same way as for regular ones:

Note that if you want to return a value from a lambda function, an explicit return is required (you can't omit return):

Lambda functions capture the local environment:

Local variables are captured by value once, when the lambda is created. So they won't be updated in the lambda if reassigned in the outer function:

Also, a lambda cannot reassign an outer local variable. After exiting the lambda, the variable will be unchanged, because the lambda capture implicitly shadows it:

However, if you use pass-by-reference data types (arrays, dictionaries, and objects), then the content changes are shared until you reassign the variable:

A function can be declared static. When a function is static, it has no access to the instance member variables or self. A static function has access to static variables. Also static functions are useful to make libraries of helper functions:

Lambda functions cannot be declared static.

See also Static variables and Static constructor.

A variadic function is a function that can take a variable number of arguments. Since Godot 4.5, GDScript supports variadic functions. To declare a variadic function, you need to use the rest parameter, which collects all the excess arguments into an array.

A function can have at most one rest parameter, which must be the last one in the parameter list. The rest parameter cannot have a default value. Static and lambda functions can also be variadic.

Static typing works for variadic functions too. However, typed arrays are currently not supported as a static type of the rest parameter:

Although you can declare functions as variadic using the rest parameter, unpacking parameters when calling a function using spread syntax that exists in some languages ​​(JavaScript, PHP) is currently not supported in GDScript. However, you can use callv() to call a function with an array of arguments:

See Abstract classes and methods.

Statements are standard and can be assignments, function calls, control flow structures, etc (see below). ; as a statement separator is entirely optional.

Expressions are sequences of operators and their operands in orderly fashion. An expression by itself can be a statement too, though only calls are reasonable to use as statements since other expressions don't have side effects.

Expressions return values that can be assigned to valid targets. Operands to some operator can be another expression. An assignment is not an expression and thus does not return any value.

Here are some examples of expressions:

Identifiers, attributes, and subscripts are valid assignment targets. Other expressions cannot be on the left side of an assignment.

self can be used to refer to the current instance and is often equivalent to directly referring to symbols available in the current script. However, self also allows you to access properties, methods, and other names that are defined dynamically (i.e. are expected to exist in subtypes of the current class, or are provided using _set() and/or _get()).

Beware that accessing members of child classes in the base class is often considered a bad practice, because this blurs the area of responsibility of any given piece of code, making the overall relationship between parts of your game harder to reason about. Besides that, one can simply forget that the parent class had some expectations about it's descendants.

Simple conditions are created by using the if/else/elif syntax. Parenthesis around conditions are allowed, but not required. Given the nature of the tab-based indentation, elif can be used instead of else/if to maintain a level of indentation.

Short statements can be written on the same line as the condition:

Sometimes, you might want to assign a different initial value based on a boolean expression. In this case, ternary-if expressions come in handy:

Ternary-if expressions can be nested to handle more than 2 cases. When nesting ternary-if expressions, it is recommended to wrap the complete expression over multiple lines to preserve readability:

You may also wish to check if a value is contained within something. You can use an if statement combined with the in operator to accomplish this:

Simple loops are created by using while syntax. Loops can be broken using break or continued using continue (which skips to the next iteration of the loop without executing any further code in the current iteration):

To iterate through a range, such as an array or table, a for loop is used. When iterating over an array, the current array element is stored in the loop variable. When iterating over a dictionary, the key is stored in the loop variable.

If you want to assign values on an array as it is being iterated through, it is best to use for i in array.size().

The loop variable is local to the for-loop and assigning to it will not change the value on the array. Objects passed by reference (such as nodes) can still be manipulated by calling methods on the loop variable.

A match statement is used to branch execution of a program. It's the equivalent of the switch statement found in many other languages, but offers some additional features.

match is more type strict than the == operator. For example 1 will not match 1.0. The only exception is String vs StringName matching: for example, the String "hello" is considered equal to the StringName &"hello".

Replace switch with match.

Change default to a single underscore.

The patterns are matched from top to bottom. If a pattern matches, the first corresponding block will be executed. After that, the execution continues below the match statement.

The special continue behavior in match supported in 3.x was removed in Godot 4.0.

The following pattern types are available:

Matches a constant expression, an identifier, or an attribute access (A.B):

This pattern matches everything. It's written as a single underscore.

It can be used as the equivalent of the default in a switch statement in other languages:

A binding pattern introduces a new variable. Like the wildcard pattern, it matches everything - and also gives that value a name. It's especially useful in array and dictionary patterns:

Matches an array. Every single element of the array pattern is a pattern itself, so you can nest them.

The length of the array is tested first, it has to be the same size as the pattern, otherwise the pattern doesn't match.

Open-ended array: An array can be bigger than the pattern by making the last subpattern ...

Every subpattern has to be comma-separated.

Works in the same way as the array pattern. Every key has to be a constant pattern.

The size of the dictionary is tested first, it has to be the same size as the pattern, otherwise the pattern doesn't match.

Open-ended dictionary: A dictionary can be bigger than the pattern by making the last subpattern ...

Every subpattern has to be comma separated.

If you don't specify a value, then only the existence of the key is checked.

A value pattern is separated from the key pattern with a :.

You can also specify multiple patterns separated by a comma. These patterns aren't allowed to have any bindings in them.

A pattern guard is an optional condition that follows the pattern list and allows you to make additional checks before choosing a match branch. Unlike a pattern, a pattern guard can be an arbitrary expression.

Only one branch can be executed per match. Once a branch is chosen, the rest are not checked. If you want to use the same pattern for multiple branches or to prevent choosing a branch with too general pattern, you can specify a pattern guard after the list of patterns with the when keyword:

If there is no matching pattern for the current branch, the pattern guard is not evaluated and the patterns of the next branch are checked.

If a matching pattern is found, the pattern guard is evaluated.

If it's true, then the body of the branch is executed and match ends.

If it's false, then the patterns of the next branch are checked.

By default, all script files are unnamed classes. In this case, you can only reference them using the file's path, using either a relative or an absolute path. For example, if you name a script file character.gd:

You can give your class a name to register it as a new type in Godot's editor. For that, you use the class_name keyword. You can optionally use the @icon annotation with a path to an image, to use it as an icon. Your class will then appear with its new icon in the editor:

SVG images that are used as custom node icons should have the Editor > Scale With Editor Scale and Editor > Convert Icons With Editor Theme import options enabled. This allows icons to follow the editor's scale and theming settings if the icons are designed with the same color palette as Godot's own icons.

Here's a class file example:

If you want to use extends too, you can keep both on the same line:

Named classes are globally registered, which means they become available to use in other scripts without the need to load or preload them:

Godot initializes non-static variables every time you create an instance, and this includes arrays and dictionaries. This is in the spirit of thread safety, since scripts can be initialized in separate threads without the user knowing.

The Godot editor will hide these custom classes with names that begin with the prefix "Editor" in the 'Create New Node' or 'Create New Scene' dialog windows. The classes are available for instantiation at runtime via their class names, but are automatically hidden by the editor windows along with the built-in editor nodes used by the Godot editor.

Since Godot 4.5, you can define abstract classes and methods using the @abstract annotation.

An abstract class is a class that cannot be instantiated directly. Instead, it is meant to be inherited by other classes. Attempting to instantiate an abstract class will result in an error.

An abstract method is a method that has no implementation. Therefore, a newline or a semicolon is expected after the function header. This defines a contract that inheriting classes must conform to, because the method signature must be compatible when overriding.

Inheriting classes must either provide implementations for all abstract methods, or the inheriting class must be marked as abstract. If a class has at least one abstract method (either its own or an unimplemented inherited one), then it must also be marked as abstract. However, the reverse is not true: an abstract class is allowed to have no abstract methods.

If you want to declare a method as optional to be overridden, you should use a non-abstract method and provide a default implementation.

For example, you could have an abstract class called Shape that defines an abstract method called draw(). You can then create subclasses like Circle and Square that implement the draw() method in their own way. This allows you to define a common interface for all shapes without having to implement all the details in the abstract class itself:

Both inner classes and classes created using class_name can be abstract. This example creates two abstract classes, one of which is a subclass of another abstract class:

Since an abstract class cannot be instantiated, it is not possible to attach an abstract class to a node. If you attempt to do so, the engine will print an error when running the scene:

Unnamed classes can also be defined as abstract, the @abstract annotation must precede extends:

A class (stored as a file) can inherit from:

An inner class inside another class file.

Multiple inheritance is not allowed.

Inheritance uses the extends keyword:

If inheritance is not explicitly defined, the class will default to inheriting RefCounted.

To check if a given instance inherits from a given class, the is keyword can be used:

To call a function in a super class (i.e. one extend-ed in your current class), use the super keyword:

This is especially useful because functions in extending classes replace functions with the same name in their super classes. If you still want to call them, you can use super:

If you need to call a different function from the super class, you can specify the function name with the attribute operator:

One of the common misconceptions is trying to override non-virtual engine methods such as get_class(), queue_free(), etc. This is not supported for technical reasons.

In Godot 3, you can shadow engine methods in GDScript, and it will work if you call this method in GDScript. However, the engine will not execute your code if the method is called inside the engine on some event.

In Godot 4, even shadowing may not always work, as GDScript optimizes native method calls. Therefore, we added the NATIVE_METHOD_OVERRIDE warning, which is treated as an error by default. We strongly advise against disabling or ignoring the warning.

Note that this does not apply to virtual methods such as _ready(), _process() and others (marked with the virtual qualifier in the documentation and the names start with an underscore). These methods are specifically for customizing engine behavior and can be overridden in GDScript. Signals and notifications can also be useful for these purposes.

The class constructor, called on class instantiation, is named _init. If you want to call the base class constructor, you can also use the super syntax. Note that every class has an implicit constructor that is always called (defining the default values of class variables). super is used to call the explicit constructor:

This is better explained through examples. Consider this scenario:

There are a few things to keep in mind here:

If the inherited class (state.gd) defines an _init constructor that takes arguments (e in this case), then the inheriting class (idle.gd) must define _init as well and pass appropriate parameters to _init from state.gd.

idle.gd can have a different number of arguments than the base class state.gd.

In the example above, e passed to the state.gd constructor is the same e passed in to idle.gd.

If idle.gd's _init constructor takes 0 arguments, it still needs to pass some value to the state.gd base class, even if it does nothing. This brings us to the fact that you can pass expressions to the base constructor as well, not just variables, e.g.:

A static constructor is a static function _static_init that is called automatically when the class is loaded, after the static variables have been initialized:

A static constructor cannot take arguments and must not return any value.

A class file can contain inner classes. Inner classes are defined using the class keyword. They are instanced using the ClassName.new() function.

Classes stored as files are treated as GDScripts. They must be loaded from disk to access them in other classes. This is done using either the load or preload functions (see below). Instancing of a loaded class resource is done by calling the new function on the class object:

Documentation about exports has been moved to GDScript exported properties.

Sometimes, you want a class' member variable to do more than just hold data and actually perform some validation or computation whenever its value changes. It may also be desired to encapsulate its access in some way.

For this, GDScript provides a special syntax to define properties using the set and get keywords after a variable declaration. Then you can define a code block that will be executed when the variable is accessed or assigned.

Unlike setget in previous Godot versions, set and get methods are always called (except as noted below), even when accessed inside the same class (with or without prefixing with self.). This makes the behavior consistent. If you need direct access to the value, use another variable for direct access and make the property code use that name.

Also there is another notation to use existing class functions if you want to split the code from the variable declaration or you need to reuse the code across multiple properties (but you can't distinguish which property the setter/getter is being called for):

This can also be done in the same line:

The setter and getter must use the same notation, mixing styles for the same variable is not allowed.

You cannot specify type hints for inline setters and getters. This is done on purpose to reduce the boilerplate. If the variable is typed, then the setter's argument is automatically of the same type, and the getter's return value must match it. Separated setter/getter functions can have type hints, and the type must match the variable's type or be a wider type.

When a variable is initialized, the value of the initializer will be written directly to the variable. Including if the @onready annotation is applied to the variable.

Using the variable's name to set it inside its own setter or to get it inside its own getter will directly access the underlying member, so it won't generate infinite recursion and saves you from explicitly declaring another variable:

This also applies to the alternative syntax:

The exception does not propagate to other functions called in the setter/getter. For example, the following code will cause an infinite recursion:

By default, scripts don't run inside the editor and only the exported properties can be changed. In some cases, it is desired that they do run inside the editor (as long as they don't execute game code or manually avoid doing so). For this, the @tool annotation exists and must be placed at the top of the file:

See Running code in the editor for more information.

Be cautious when freeing nodes with queue_free() or free() in a tool script (especially the script's owner itself). As tool scripts run their code in the editor, misusing them may lead to crashing the editor.

Godot implements reference counting to free certain instances that are no longer used, instead of a garbage collector, or requiring purely manual management. Any instance of the RefCounted class (or any class that inherits it, such as Resource) will be freed automatically when no longer in use. For an instance of any class that is not a RefCounted (such as Node or the base Object type), it will remain in memory until it is deleted with free() (or queue_free() for Nodes).

If a Node is deleted via free() or queue_free(), all of its children will also recursively be deleted.

To avoid reference cycles that can't be freed, a WeakRef function is provided for creating weak references, which allow access to the object without preventing a RefCounted from freeing. Here is an example:

Alternatively, when not using references, the is_instance_valid(instance) can be used to check if an object has been freed.

Signals are a tool to emit messages from an object that other objects can react to. To create custom signals for a class, use the signal keyword.

Signals are a Callback mechanism. They also fill the role of Observers, a common programming pattern. For more information, read the Observer tutorial in the Game Programming Patterns ebook.

You can connect these signals to methods the same way you connect built-in signals of nodes like Button or RigidBody3D.

In the example below, we connect the health_depleted signal from a Character node to a Game node. When the Character node emits the signal, the game node's _on_character_health_depleted is called:

You can emit as many arguments as you want along with a signal.

Here is an example where this is useful. Let's say we want a life bar on screen to react to health changes with an animation, but we want to keep the user interface separate from the player in our scene tree.

In our character.gd script, we define a health_changed signal and emit it with Signal.emit(), and from a Game node higher up our scene tree, we connect it to the Lifebar using the Signal.connect() method:

In the Game node, we get both the Character and Lifebar nodes, then connect the character, that emits the signal, to the receiver, the Lifebar node in this case.

This allows the Lifebar to react to health changes without coupling it to the Character node.

You can write optional argument names in parentheses after the signal's definition:

These arguments show up in the editor's node dock, and Godot can use them to generate callback functions for you. However, you can still emit any number of arguments when you emit signals; it's up to you to emit the correct values.

You can also create copies of GDScript Callable objects which accept additional arguments using Callable.bind(). This allows you to add extra information to the connection if the emitted signal itself doesn't give you access to all the data that you need.

When the signal is emitted, the callback method receives the bound values, in addition to those provided by the signal.

Building on the example above, let's say we want to display a log of the damage taken by each character on the screen, like Player1 took 22 damage.. The health_changed signal doesn't give us the name of the character that took damage. So when we connect the signal to the in-game console, we can add the character's name using the bind method:

Our BattleLog node receives each bound element as an extra argument:

The await keyword can be used to create coroutines which wait until a signal is emitted before continuing execution. Using the await keyword with a signal or a call to a function that is also a coroutine will immediately return the control to the caller. When the signal is emitted (or the called coroutine finishes), it will resume execution from the point on where it stopped.

For example, to stop execution until the user presses a button, you can do something like this:

In this case, the wait_confirmation becomes a coroutine, which means that the caller also needs to await it:

Note that requesting a coroutine's return value without await will trigger an error:

However, if you don't depend on the result, you can just call it asynchronously, which won't stop execution and won't make the current function a coroutine:

If you use await with an expression that isn't a signal nor a coroutine, the value will be returned immediately and the function won't give the control back to the caller:

This also means that returning a signal from a function that isn't a coroutine will make the caller await that signal:

Unlike yield in previous Godot versions, you cannot obtain the function state object. This is done to ensure type safety. With this type safety in place, a function cannot say that it returns an int while it actually returns a function state object during runtime.

The assert keyword can be used to check conditions in debug builds. These assertions are ignored in non-debug builds. This means that the expression passed as argument won't be evaluated in a project exported in release mode. Due to this, assertions must not contain expressions that have side effects. Otherwise, the behavior of the script would vary depending on whether the project is run in a debug build.

When running a project from the editor, the project will be paused if an assertion error occurs.

You can optionally pass a custom error message to be shown if the assertion fails:

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (javascript):
```javascript
# Everything after "#" is a comment.
# A file is a class!

# (optional) icon to show in the editor dialogs:
@icon("res://path/to/optional/icon.svg")

# (optional) class definition:
class_name MyClass

# Inheritance:
extends BaseClass


# Member variables.
var a = 5
var s = "Hello"
var arr = [1, 2, 3]
var dict = {"key": "value", 2: 3}
var other_dict = {key = "value", other_key = 2}
var typed_var: int
var inferred_type := "String"

# Constants.
const ANSWER = 42
const THE_NAME = "Charly"

# Enums.
enum {UNIT_NEUTRAL, UNIT_ENEMY, UNIT_ALLY}
enum Named {THING_1, THING_2, ANOTHER_THING = -1}

# Built-in vector types.
var v2 = Vector2(1, 2)
var v3 = Vector3(1, 2, 3)


# Functions.
func some_function(param1, param2, param3):
    const local_const = 5

    if param1 < local_const:
        print(param1)
    elif param2 > 5:
        print(param2)
    else:
        print("Fail!")

    for i in range(20):
        print(i)

    while param2 != 0:
        param2 -= 1

    match param3:
        3:
            print("param3 is 3!")
        _:
            print("param3 is not 3!")

    var local_var = param1 + 3
    return local_var


# Functions override functions with the same name on the base/super class.
# If you still want to call them, use "super":
func something(p1, p2):
    super(p1, p2)


# It's also possible to call another function in the super class:
func other_something(p1, p2):
    super.something(p1, p2)


# Inner class
class Something:
    var a = 10


# Constructor
func _init():
    print("Constructed!")
    var lv = Something.new()
    print(lv.a)
```

Example 2 (unknown):
```unknown
12_345_678  # Equal to 12345678.
3.141_592_7  # Equal to 3.1415927.
0x8080_0000_ffff  # Equal to 0x80800000ffff.
0b11_00_11_00  # Equal to 0b11001100.
```

Example 3 (unknown):
```unknown
print("\tchar=\"\\t\"")  # Prints `    char="\t"`.
print(r"\tchar=\"\\t\"") # Prints `\tchar=\"\\t\"`.
```

Example 4 (unknown):
```unknown
@export_range(1, 100, 1, "or_greater")
var ranged_var: int = 50
```

---

## GDScript style guide — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/gdscript_styleguide.html

**Contents:**
- GDScript style guide
- Formatting
  - Encoding and special characters
  - Indentation
  - Trailing comma
  - Blank lines
  - Line length
  - One statement per line
  - Format multiline statements for readability
  - Avoid unnecessary parentheses

This style guide lists conventions to write elegant GDScript. The goal is to encourage writing clean, readable code and promote consistency across projects, discussions, and tutorials. Hopefully, this will also support the development of auto-formatting tools.

Since GDScript is close to Python, this guide is inspired by Python's PEP 8 programming style guide.

Style guides aren't meant as hard rulebooks. At times, you may not be able to apply some of the guidelines below. When that happens, use your best judgment, and ask fellow developers for insights.

In general, keeping your code consistent in your projects and within your team is more important than following this guide to a tee.

Godot's built-in script editor uses a lot of these conventions by default. Let it help you.

Here is a complete class example based on these guidelines:

Use line feed (LF) characters to break lines, not CRLF or CR. (editor default)

Use one line feed character at the end of each file. (editor default)

Use UTF-8 encoding without a byte order mark. (editor default)

Use Tabs instead of spaces for indentation. (editor default)

Each indent level should be one greater than the block containing it.

Use 2 indent levels to distinguish continuation lines from regular code blocks.

Exceptions to this rule are arrays, dictionaries, and enums. Use a single indentation level to distinguish continuation lines:

Use a trailing comma on the last line in arrays, dictionaries, and enums. This results in easier refactoring and better diffs in version control as the last line doesn't need to be modified when adding new elements.

Trailing commas are unnecessary in single-line lists, so don't add them in this case.

Surround functions and class definitions with two blank lines:

Use one blank line inside functions to separate logical sections.

We use a single line between classes and function definitions in the class reference and in short code snippets in this documentation.

Keep individual lines of code under 100 characters.

If you can, try to keep lines under 80 characters. This helps to read the code on small displays and with two scripts opened side-by-side in an external text editor. For example, when looking at a differential revision.

Avoid combining multiple statements on a single line, including conditional statements, to adhere to the GDScript style guidelines for readability.

The only exception to that rule is the ternary operator:

When you have particularly long if statements or nested ternary expressions, wrapping them over multiple lines improves readability. Since continuation lines are still part of the same expression, 2 indent levels should be used instead of one.

GDScript allows wrapping statements using multiple lines using parentheses or backslashes. Parentheses are favored in this style guide since they make for easier refactoring. With backslashes, you have to ensure that the last line never contains a backslash at the end. With parentheses, you don't have to worry about the last line having a backslash at the end.

When wrapping a conditional expression over multiple lines, the and/or keywords should be placed at the beginning of the line continuation, not at the end of the previous line.

Avoid parentheses in expressions and conditional statements. Unless necessary for order of operations or wrapping over multiple lines, they only reduce readability.

Prefer the plain English versions of boolean operators, as they are the most accessible:

Use and instead of &&.

Use or instead of ||.

Use not instead of !.

You may also use parentheses around boolean operators to clear any ambiguity. This can make long expressions easier to read.

Regular comments (#) and documentation comments (##) should start with a space, but not code that you comment out. Additionally, code region comments (#region/#endregion) must follow that precise syntax, so they should not start with a space.

Using a space for regular and documentation comments helps differentiate text comments from disabled code.

In the script editor, to toggle commenting of the selected code, press Ctrl + K. This feature adds/removes a single # sign before any code on the selected lines.

Prefer writing comments on their own line as opposed to inline comments (comments written on the same line as code). Inline comments are best used for short comments, typically a few words at most:

Always use one space around operators and after commas. Also, avoid extra spaces in dictionary references and function calls. One exception to this is for single-line dictionary declarations, where a space should be added after the opening brace and before the closing brace. This makes the dictionary easier to visually distinguish from an array, as the [] characters look close to {} with most fonts.

Don't use spaces to align expressions vertically:

Use double quotes unless single quotes make it possible to escape fewer characters in a given string. See the examples below:

Don't omit the leading or trailing zero in floating-point numbers. Otherwise, this makes them less readable and harder to distinguish from integers at a glance.

Use lowercase for letters in hexadecimal numbers, as their lower height makes the number easier to read.

Take advantage of GDScript's underscores in literals to make large numbers more readable.

These naming conventions follow the Godot Engine style. Breaking these will make your code clash with the built-in naming conventions, leading to inconsistent code. As a summary table:

class_name YAMLParser

const MAX_SPEED = 200

{EARTH, WATER, AIR, FIRE}

Use snake_case for file names. For named classes, convert the PascalCase class name to snake_case:

This is consistent with how C++ files are named in Godot's source code. This also avoids case sensitivity issues that can crop up when exporting a project from Windows to other platforms.

Use PascalCase for class and node names:

Also use PascalCase when loading a class into a constant or a variable:

Use snake_case to name functions and variables:

Prepend a single underscore (_) to virtual methods functions the user must override, private functions, and private variables:

Use the past tense to name signals:

Write constants with CONSTANT_CASE, that is to say in all caps with an underscore (_) to separate words:

Use PascalCase for enum names and keep them singular, as they represent a type. Use CONSTANT_CASE for their members, as they are constants:

Write enums with each item on its own line. This allows adding documentation comments above each item more easily, and also makes for cleaner diffs in version control when items are added or removed.

This section focuses on code order. For formatting, see Formatting. For naming conventions, see Naming conventions.

We suggest to organize GDScript code this way:

And put the class methods and variables in the following order depending on their access modifiers:

We optimized the order to make it easy to read the code from top to bottom, to help developers reading the code for the first time understand how it works, and to avoid errors linked to the order of variable declarations.

This code order follows four rules of thumb:

Properties and signals come first, followed by methods.

Public comes before private.

Virtual callbacks come before the class's interface.

The object's construction and initialization functions, _init and _ready, come before functions that modify the object at runtime.

If the code is meant to run in the editor, place the @tool annotation on the first line of the script.

Follow with the optional @icon then the class_name if necessary. You can turn a GDScript file into a global type in your project using class_name. For more information, see Registering named classes. If the class is meant to be an abstract class, add @abstract before the class_name keyword.

Then, add the extends keyword if the class extends a built-in type.

Following that, you should have the class's optional documentation comments. You can use that to explain the role of your class to your teammates, how it works, and how other developers should use it, for example.

For inner classes, use single-line declarations:

Write signal declarations, followed by properties, that is to say, member variables, after the docstring.

Enums should come after signals, as you can use them as export hints for other properties.

Then, write constants, exported variables, public, private, and onready variables, in that order.

GDScript evaluates @onready variables right before the _ready callback. You can use that to cache node dependencies, that is to say, to get child nodes in the scene that your class relies on. This is what the example above shows.

Don't declare member variables if they are only used locally in a method, as it makes the code more difficult to follow. Instead, declare them as local variables in the method's body.

Declare local variables as close as possible to their first use. This makes it easier to follow the code, without having to scroll too much to find where the variable was declared.

After the class's properties come the methods.

Start with the _init() callback method, that the engine will call upon creating the object in memory. Follow with the _ready() callback, that Godot calls when it adds a node to the scene tree.

These functions should come first because they show how the object is initialized.

Other built-in virtual callbacks, like _unhandled_input() and _physics_process, should come next. These control the object's main loop and interactions with the game engine.

The rest of the class's interface, public and private methods, come after that, in that order.

GDScript supports optional static typing.

To declare a variable's type, use <variable>: <type>:

To declare the return type of a function, use -> <type>:

In most cases, you can let the compiler infer the type using :=. Prefer := when the type is written on the same line as the assignment, otherwise prefer writing the type explicitly.

Include the type hint when the type is ambiguous, and omit the type hint when it's redundant.

In some cases, the type must be stated explicitly, otherwise the behavior will not be as expected because the compiler will only be able to use the function's return type. For example, get_node() cannot infer a type unless the scene or file of the node is loaded in memory. In this case, you should set the type explicitly.

Alternatively, you can use the as keyword to cast the return type, and that type will be used to infer the type of the var.

This option is considered more type-safe than type hints, but also less null-safe as it silently casts the variable to null in case of a type mismatch at runtime, without an error/warning.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
class_name StateMachine
extends Node
## Hierarchical State machine for the player.
##
## Initializes states and delegates engine callbacks ([method Node._physics_process],
## [method Node._unhandled_input]) to the state.

signal state_changed(previous, new)

@export var initial_state: Node
var is_active = true:
    set = set_is_active

@onready var _state = initial_state:
    set = set_state
@onready var _state_name = _state.name


func _init():
    add_to_group("state_machine")


func _enter_tree():
    print("this happens before the ready method!")


func _ready():
    state_changed.connect(_on_state_changed)
    _state.enter()


func _unhandled_input(event):
    _state.unhandled_input(event)


func _physics_process(delta):
    _state.physics_process(delta)


func transition_to(target_state_path, msg={}):
    if not has_node(target_state_path):
        return

    var target_state = get_node(target_state_path)
    assert(target_state.is_composite == false)

    _state.exit()
    self._state = target_state
    _state.enter(msg)
    Events.player_state_changed.emit(_state.name)


func set_is_active(value):
    is_active = value
    set_physics_process(value)
    set_process_unhandled_input(value)
    set_block_signals(not value)


func set_state(value):
    _state = value
    _state_name = _state.name


func _on_state_changed(previous, new):
    print("state changed")
    state_changed.emit()


class State:
    var foo = 0

    func _init():
        print("Hello!")
```

Example 2 (unknown):
```unknown
for i in range(10):
    print("hello")
```

Example 3 (unknown):
```unknown
for i in range(10):
  print("hello")

for i in range(10):
        print("hello")
```

Example 4 (unknown):
```unknown
effect.interpolate_property(sprite, "transform/scale",
        sprite.get_scale(), Vector2(2.0, 2.0), 0.3,
        Tween.TRANS_QUAD, Tween.EASE_OUT)
```

---

## GDScript warning system — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/warning_system.html

**Contents:**
- GDScript warning system
- User-contributed notes

The GDScript warning system complements static typing (but it can work without static typing too). It's here to help you avoid mistakes that are hard to spot during development, and that may lead to runtime errors.

You can configure warnings in the Project Settings under the section called GDScript:

You must enable Advanced Settings in order to see the GDScript section in the sidebar. You can also search for "GDScript" when Advanced Settings is off.

You can find a list of warnings for the active GDScript file in the script editor's status bar. The example below has 2 warnings:

To ignore single warnings within a file, use the @warning_ignore annotation. You can click on the ignore link to the left of the warning's description. Godot will add an annotation above the corresponding line and the code won't trigger the corresponding warning anymore:

To ignore multiple warnings in a region within a file, use the @warning_ignore_start and @warning_ignore_restore annotations. You can omit @warning_ignore_restore if you want to ignore the specified warning types until the end of the file.

Warnings won't prevent the game from running, but you can turn them into errors if you'd like. This way your game won't compile unless you fix all warnings. Head to the GDScript section of the Project Settings to turn on this option to the warning that you want. Here's the same file as the previous example with the warning unused_variable as an error turned on:

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Getting started — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/cpp/gdextension_cpp_example.html

**Contents:**
- Getting started
- Workflow overview
- Example project
- Setting up the project
- Building the C++ bindings
- Creating a simple plugin
- Compiling the plugin
- Using the GDExtension module
- Adding properties
- Signals

As a GDExtension, godot-cpp is more complicated to use than GDScript and C#. If you decide to work with it, here's what to expect your workflow to look like:

Create a new godot-cpp project (from the template, or from scratch, as explained below).

Develop your code with your favorite IDE locally.

Build and test your code with the earliest compatible Godot version.

Create builds for all platforms you want to support (e.g. using GitHub Actions).

Optional: Publish on the Godot Asset Library.

For your first godot-cpp project, we recommend starting with this guide to understand the technology involved with godot-cpp. After you're done, you can use the godot-cpp template, which has better coverage of features, such as a GitHub action pipeline and useful SConstruct boilerplate code. However, the template does not explain itself to a high level of detail, which is why we recommend going through this guide first.

There are a few prerequisites you'll need:

A Godot 4 executable.

SCons as a build tool.

A copy of the godot-cpp repository.

See also Configuring an IDE and Compiling as the build tools are identical to the ones you need to compile Godot from source.

You can download the godot-cpp repository from GitHub or let Git do the work for you. Note that this repository has different branches for different versions of Godot. GDExtensions will not work in older versions of Godot (only Godot 4 and up) and vice versa, so make sure you download the correct branch.

To use GDExtension you need to use the godot-cpp branch that matches the version of Godot that you are targeting. For example, if you're targeting Godot 4.1, use the 4.1 branch. Throughout this tutorial we use 4.x, which will need to be replaced with the version of Godot you are targeting.

The master branch is the development branch which is updated regularly to work with Godot's master branch.

GDExtensions targeting an earlier version of Godot should work in later minor versions, but not vice-versa. For example, a GDExtension targeting Godot 4.2 should work just fine in Godot 4.3, but one targeting Godot 4.3 won't work in Godot 4.2.

There is one exception to this: extensions targeting Godot 4.0 will not work with Godot 4.1 and later (see Updating your GDExtension for 4.1).

If you are versioning your project using Git, it is recommended to add it as a Git submodule:

Alternatively, you can also clone it to the project folder:

If you decide to download the repository or clone it into your folder, make sure to keep the folder layout the same as we've setup here. Much of the code we'll be showcasing here assumes the project has this layout.

If you cloned the example from the link specified in the introduction, the submodules are not automatically initialized. You will need to execute the following commands:

This will initialize the repository in your project folder.

Now that we've downloaded our prerequisites, it is time to build the C++ bindings.

The repository contains a copy of the metadata for the current Godot release, but if you need to build these bindings for a newer version of Godot, call the Godot executable:

The resulting extension_api.json file will be created in the executable's directory. Copy it to the project folder and add custom_api_file=<PATH_TO_FILE> to the scons command below.

To generate and compile the bindings, use this command (replacing <platform> with windows, linux or macos depending on your OS):

The build process automatically detects the number of CPU threads to use for parallel builds. To specify a number of CPU threads to use, add -jN at the end of the SCons command line where N is the number of CPU threads to use.

This step will take a while. When it is completed, you should have static libraries that can be compiled into your project stored in godot-cpp/bin/.

You may need to add bits=64 to the command on Windows or Linux.

Now it's time to build an actual plugin. We'll start by creating an empty Godot project in which we'll place a few files.

Open Godot and create a new project. For this example, we will place it in a folder called demo inside our GDExtension's folder structure.

In our demo project, we'll create a scene containing a Node called "Main" and we'll save it as main.tscn. We'll come back to that later.

Back in the top-level GDExtension module folder, we're also going to create a subfolder called src in which we'll place our source files.

You should now have demo, godot-cpp, and src directories in your GDExtension module.

Your folder structure should now look like this:

In the src folder, we'll start with creating our header file for the GDExtension node we'll be creating. We will name it gdexample.h:

There are a few things of note to the above. We include sprite2d.hpp which contains bindings to the Sprite2D class. We'll be extending this class in our module.

We're using the namespace godot, since everything in GDExtension is defined within this namespace.

Then we have our class definition, which inherits from our Sprite2D through a container class. We'll see a few side effects of this later on. The GDCLASS macro sets up a few internal things for us.

After that, we declare a single member variable called time_passed.

In the next block we're defining our methods, we have our constructor and destructor defined, but there are two other functions that will likely look familiar to some, and one new method.

The first is _bind_methods, which is a static function that Godot will call to find out which methods can be called and which properties it exposes. The second is our _process function, which will work exactly the same as the _process function you're used to in GDScript.

Let's implement our functions by creating our gdexample.cpp file:

This one should be straightforward. We're implementing each method of our class that we defined in our header file.

Note our _process function, which keeps track of how much time has passed and calculates a new position for our sprite using a sine and cosine function.

There is one more C++ file we need; we'll name it register_types.cpp. Our GDExtension plugin can contain multiple classes, each with their own header and source file like we've implemented GDExample up above. What we need now is a small bit of code that tells Godot about all the classes in our GDExtension plugin.

The initialize_example_module and uninitialize_example_module functions get called respectively when Godot loads our plugin and when it unloads it. All we're doing here is parse through the functions in our bindings module to initialize them, but you might have to set up more things depending on your needs. We call the GDREGISTER_RUNTIME_CLASS macro for each of our classes in our library. This will make them run only in game, like the default for GDScript.

The important function is the third function called example_library_init. We first call a function in our bindings library that creates an initialization object. This object registers the initialization and termination functions of the GDExtension. Furthermore, it sets the level of initialization (core, servers, scene, editor, level).

At last, we need the header file for the register_types.cpp named register_types.h.

To compile the project we need to define how SCons using should compile it using an SConstruct file which references the one in godot-cpp. Writing it from scratch is outside the scope of this tutorial, but you can the SConstruct file we prepared. We'll cover a more customizable, detailed example on how to use these build files in a subsequent tutorial.

This SConstruct file was written to be used with the latest godot-cpp master, you may need to make small changes using it with older versions or refer to the SConstruct file in the Godot 4.x documentation.

Once you've downloaded the SConstruct file, place it in your GDExtension folder structure alongside godot-cpp, src and demo, then run:

You should now be able to find the module in demo/bin/<platform>.

When building for iOS, package the module as a static .xcframework, you can use following commands to do so:

Here, we've compiled both godot-cpp and our gdexample library as debug builds. For optimized builds, you should compile them using the target=template_release switch.

Before we jump back into Godot, we need to create one more file in demo/bin/.

This file lets Godot know what dynamic libraries should be loaded for each platform and the entry function for the module. It is called gdexample.gdextension.

This file contains a configuration section that controls the entry function of the module. You should also set the minimum compatible Godot version with compatibility_minimum, which prevents older version of Godot from trying to load your extension. The reloadable flag enables automatic reloading of your extension by the editor every time you recompile it, without needing to restart the editor. This only works if you compile your extension in debug mode (default).

The libraries section is the important bit: it tells Godot the location of the dynamic library in the project's filesystem for each supported platform. It will also result in just that file being exported when you export the project, which means the data pack won't contain libraries that are incompatible with the target platform.

Finally, the dependencies section allows you to name additional dynamic libraries that should be included as well. This is important when your GDExtension plugin implements someone else's library and requires you to supply a third-party dynamic library with your project.

Here is another overview to check the correct file structure:

Time to jump back into Godot. We load up the main scene we created way back in the beginning and now add a newly available GDExample node to the scene:

We're going to assign the Godot logo to this node as our texture, disable the centered property:

We're finally ready to run the project:

GDScript allows you to add properties to your script using the export keyword. In GDExtension you have to register the properties with a getter and setter function or directly implement the _get_property_list, _get and _set methods of an object (but that goes far beyond the scope of this tutorial).

Lets add a property that allows us to control the amplitude of our wave.

In our gdexample.h file we need to add a member variable and getter and setter functions:

In our gdexample.cpp file we need to make a number of changes, we will only show the methods we end up changing, don't remove the lines we're omitting:

Once you compile the module with these changes in place, you will see that a property has been added to our interface. You can now change this property and when you run your project, you will see that our Godot icon travels along a larger figure.

Let's do the same but for the speed of our animation and use a setter and getter function. Our gdexample.h header file again only needs a few more lines of code:

This requires a few more changes to our gdexample.cpp file, again we're only showing the methods that have changed so don't remove anything we're omitting:

Now when the project is compiled, we'll see another property called speed. Changing its value will make the animation go faster or slower. Furthermore, we added a property range which describes in which range the value can be. The first two arguments are the minimum and maximum value and the third is the step size.

For simplicity, we've only used the hint_range of the property method. There are a lot more options to choose from. These can be used to further configure how properties are displayed and set on the Godot side.

Last but not least, signals fully work in GDExtension as well. Having your extension react to a signal given out by another object requires you to call connect on that object. We can't think of a good example for our wobbling Godot icon, we would need to showcase a far more complete example.

This is the required syntax:

To connect our signal the_signal from some other node with our method my_method, we need to provide the connect method with the name of the signal and a Callable. The Callable holds information about an object on which a method can be called. In our case, it associates our current object instance this with the method my_method of the object. Then the connect method will add this to the observers of the_signal. Whenever the_signal is now emitted, Godot knows which method of which object it needs to call.

Note that you can only call my_method if you've previously registered it in your _bind_methods method. Otherwise Godot will not know about the existence of my_method.

To learn more about Callable, check out the class reference here: Callable.

Having your object sending out signals is more common. For our wobbling Godot icon, we'll do something silly just to show how it works. We're going to emit a signal every time a second has passed and pass the new location along.

In our gdexample.h header file, we need to define a new member time_emit:

This time, the changes in gdexample.cpp are more elaborate. First, you'll need to set time_emit = 0.0; in either our _init method or in our constructor. We'll look at the other 2 needed changes one by one.

In our _bind_methods method, we need to declare our signal. This is done as follows:

Here, our ADD_SIGNAL macro can be a single call with a MethodInfo argument. MethodInfo's first parameter will be the signal's name, and its remaining parameters are PropertyInfo types which describe the essentials of each of the method's parameters. PropertyInfo parameters are defined with the data type of the parameter, and then the name that the parameter will have by default.

So here, we add a signal, with a MethodInfo which names the signal "position_changed". The PropertyInfo parameters describe two essential arguments, one of type Object, the other of type Vector2, respectively named "node" and "new_pos".

Next, we'll need to change our _process method:

After a second has passed, we emit our signal and reset our counter. We can add our parameter values directly to emit_signal.

Once the GDExtension library is compiled, we can go into Godot and select our sprite node. In the Node dock, we can find our new signal and link it up by pressing the Connect button or double-clicking the signal. We've added a script on our main node and implemented our signal like this:

Every second, we output our position to the console.

We hope the above example showed you the basics. You can build upon this example to create full-fledged scripts to control nodes in Godot using C++!

Instead of basing your project off the above example setup, we recommend to restart now by cloning the godot-cpp template, and base your project off of that. It has better coverage of features, such as a GitHub build action and additional useful SConstruct boilerplate.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
mkdir gdextension_cpp_example
cd gdextension_cpp_example
git init
git submodule add -b 4.x https://github.com/godotengine/godot-cpp
cd godot-cpp
git submodule update --init
```

Example 2 (unknown):
```unknown
mkdir gdextension_cpp_example
cd gdextension_cpp_example
git clone -b 4.x https://github.com/godotengine/godot-cpp
```

Example 3 (unknown):
```unknown
cd gdextension_cpp_example
git submodule update --init
```

Example 4 (unknown):
```unknown
godot --dump-extension-api
```

---

## Groups — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/groups.html

**Contents:**
- Groups
- Managing groups
  - Using the Node dock
  - Using code
- User-contributed notes

Groups in Godot work like tags in other software. You can add a node to as many groups as you want. Then, in code, you can use the SceneTree to:

Get a list of nodes in a group.

Call a method on all nodes in a group.

Send a notification to all nodes in a group.

This is a useful feature to organize large scenes and decouple code.

Groups are created by adding a node to a new group name, and likewise they are removed by removing all nodes from a given group.

There are two ways to add/remove nodes to groups:

During design, by using the Node dock in the editor, or the Global Groups in project settings.

During execution, by calling Node.add_to_group() or Node.remove_from_group().

You can create new groups using the Groups tab in the Node dock.

Select a node in the Scene dock then click the add button with the + symbol.

You should now see the Create New Group modal appear. Write the group name in the field.

You can optionally mark the option "Global", which will make the group visible project-wide, and able to be reused in any project scene. This will also allow you to give it a description.

When done, press Ok to create it.

You should see the new groups appear in the Groups tab under Scene Groups if the Global option was unmarked, or under Global Groups if that option was marked.

A selected Node from the Scene dock can be added into groups by marking the checkbox on the left side of the groups in the Groups dock. The node you had selected when creating a new group will be automatically checked.

All groups present in the project that were marked as Global, created from any scene, will be visible under Global Groups.

Any other group derived from nodes in the current scene will appear under Scene Groups.

The same underlying logic is used for both Global and Scene groups. Groups with the same name are considered one and the same. This feature is purely organizational.

You can manage Global Groups in the Global Groups dock, inside Project Settings. There, you will be able to add new global groups, or change existing groups' names and descriptions.

You can also manage groups from scripts. The following code adds the node to which you attach the script to the guards group as soon as it enters the scene tree.

Imagine you're creating an infiltration game. When an enemy spots the player, you want all guards and robots to be on alert.

In the fictional example below, we use SceneTree.call_group() to alert all enemies that the player was spotted.

The above code calls the function enter_alert_mode on every member of the group guards.

To get the full list of nodes in the guards group as an array, you can call SceneTree.get_nodes_in_group():

The SceneTree class provides many more useful methods to interact with scenes, their node hierarchy, and groups. It allows you to switch scenes easily or reload them, quit the game or pause and unpause it. It also provides useful signals.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
func _ready():
    add_to_group("guards")
```

Example 2 (unknown):
```unknown
public override void _Ready()
{
    base._Ready();

    AddToGroup("guards");
}
```

Example 3 (unknown):
```unknown
func _on_player_spotted():
    get_tree().call_group("guards", "enter_alert_mode")
```

Example 4 (unknown):
```unknown
public void _OnPlayerDiscovered()
{
    GetTree().CallGroup("guards", "enter_alert_mode");
}
```

---

## How to read the Godot API — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/how_to_read_the_godot_api.html

**Contents:**
- How to read the Godot API
- Inheritance
- Brief Description
- Description
- Tutorials
- Properties
- Methods
- Signals
- Enumerations
- Constants

On this page, you'll learn how to read the class reference for the Godot API.

The API, or Application Programming Interface, is an index of what Godot offers users. It provides a brief summary of which classes exist, how they are related to each other, what features they have, and how to use them.

At the top of each file, you will see the name of the class.

The "Inherits" section lists each class the current one inherits. Here CanvasItem inherits Node and Node inherits Object.

The "Inherited By" section lists each class which directly inherits the current class. Here Control and Node2D both inherit CanvasItem.

Next a brief description of the class. This text appears in Godot Editor popups for creating Nodes, Resources, and other types.

Next a more detailed description the class, its features, and its use case(s).

Things you may find here:

Specifics of how the class works.

Code samples of common use cases.

Usage details which are shared between each of the class's methods.

Warnings about required dependencies or configuration.

Links to other related parts of the Godot API.

The page then provides links to parts of the manual which mention or make use of the current class.

The Properties table lists the variables which belong to each instance of the class, also known as the "properties."

The left column contains the data type of the property. The text is also a link to that data type's Godot API page.

The center column contains the name of the property. The text is also a link to that property's full description on the page. Use this name to get the property's data or set a new value to it.

The right column contains the default value of the property. To initialize it with a different value, you must set a different value via script or the Inspector.

The Methods table lists the functions which belong to each instance of the class, also known as the "methods."

The left column contains the data type of the method's return value.

The right column contains the name, parameters, and qualifiers of the method. The name is the text before the opening parenthesis. It is also a link to the method's full description on the page. Use this name to call the method.

For each parameter, the page details its data type, name, and default value, if any.

Possible qualifiers include...

const: the method does not change any data in the class instance.

virtual: the method does nothing but wait for a script to override it.

vararg: the method can accept an arbitrary number of arguments.

The Signals list details the names and parameters of events which "signal" a change in game state to other class instances.

Like the Methods table, any parameters will include their data type and name.

Each signal also has a detailed explanation of when the signal is emitted.

The Enumerations list details the enumerable data types associated with the current class.

For each enumeration, the page states its name and then lists its possible values.

For each enumeration value, the page states its name, its integer value, and an explanation of its use case(s) and/or affects.

The Constants list details named integer constants in the current class.

For each constant, the page states its name, its integer value, and an explanation of its use case(s) and/or affects.

NOTIFICATION_* constants' descriptions will state which engine event triggers the notification.

The Property Descriptions list details everything about each property.

It restates the data type and name of the property.

Every property in the Godot API is bound to a pair of setter and getter functions. Using either is equivalent. They are listed here.

Below that is a detailed summary of what the property's data represents, its use case(s) and/or the affects of changing it. It may include code samples and/or links to relevant parts of the Godot API.

Knowing the setter and getter names is useful when one must bind a method name or Callable to something.

The Method Descriptions list details everything about each method.

It restates the method's return data type, parameter names/types/defaults, and qualifiers.

Below that is a detailed summary of what the method does and its use case(s). It may include code samples and/or links to relevant parts of the Godot API.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Idle and Physics Processing — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/idle_and_physics_processing.html

**Contents:**
- Idle and Physics Processing
- User-contributed notes

Games run in a loop. Each frame, you need to update the state of your game world before drawing it on screen. Godot provides two virtual methods in the Node class to do so: Node._process() and Node._physics_process(). If you define either or both in a script, the engine will call them automatically.

There are two types of processing available to you:

Idle processing allows you to run code that updates a node every frame, as often as possible.

Physics processing happens at a fixed rate, 60 times per second by default. This is independent of your game's actual framerate, and keeps physics running smoothly. You should use it for anything that involves the physics engine, like moving a body that collides with the environment.

You can activate idle processing by defining the _process() method in a script. You can turn it off and back on by calling Node.set_process().

The engine calls this method every time it draws a frame:

Keep in mind that the frequency at which the engine calls _process() depends on your application's framerate, which varies over time and across devices.

The function's delta parameter is the time elapsed in seconds since the previous call to _process(). Use this parameter to make calculations independent of the framerate. For example, you should always multiply a speed value by delta to animate a moving object.

Physics processing works with a similar virtual function: _physics_process(). Use it for calculations that must happen before each physics step, like moving a character that collides with the game world. As mentioned above, _physics_process() runs at fixed time intervals as much as possible to keep the physics interactions stable. You can change the interval between physics steps in the Project Settings, under Physics -> Common -> Physics Fps. By default, it's set to run 60 times per second.

The engine calls this method before every physics step:

The function _process() is not synchronized with physics. Its rate depends on hardware and game optimization. It also runs after the physics step in single-threaded games.

You can see the _process() function at work by creating a scene with a single Label node, with the following script attached to it:

When you run the scene, you should see a counter increasing each frame.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
func _process(delta):
    # Do something...
    pass
```

Example 2 (unknown):
```unknown
public override void _Process(double delta)
{
    // Do something...
}
```

Example 3 (unknown):
```unknown
func _physics_process(delta):
    # Do something...
    pass
```

Example 4 (unknown):
```unknown
public override void _PhysicsProcess(double delta)
{
    // Do something...
}
```

---

## Instancing with signals — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/instancing_with_signals.html

**Contents:**
- Instancing with signals
- Shooting example
- User-contributed notes

Signals provide a way to decouple game objects, allowing you to avoid forcing a fixed arrangement of nodes. One sign that a signal might be called for is when you find yourself using get_parent(). Referring directly to a node's parent means that you can't easily move that node to another location in the scene tree. This can be especially problematic when you are instancing objects at runtime and may want to place them in an arbitrary location in the running scene tree.

Below we'll consider an example of such a situation: firing bullets.

Consider a player character that can rotate and shoot towards the mouse. Every time the mouse button is clicked, we create an instance of the bullet at the player's location. See Creating instances for details.

We'll use an Area2D for the bullet, which moves in a straight line at a given velocity:

However, if the bullets are added as children of the player, then they will remain "attached" to the player as it rotates:

Instead, we need the bullets to be independent of the player's movement - once fired, they should continue traveling in a straight line and the player can no longer affect them. Instead of being added to the scene tree as a child of the player, it makes more sense to add the bullet as a child of the "main" game scene, which may be the player's parent or even further up the tree.

You could do this by adding the bullet to the main scene directly:

However, this will lead to a different problem. Now if you try to test your "Player" scene independently, it will crash on shooting, because there is no parent node to access. This makes it a lot harder to test your player code independently and also means that if you decide to change your main scene's node structure, the player's parent may no longer be the appropriate node to receive the bullets.

The solution to this is to use a signal to "emit" the bullets from the player. The player then has no need to "know" what happens to the bullets after that - whatever node is connected to the signal can "receive" the bullets and take the appropriate action to spawn them.

Here is the code for the player using signals to emit the bullet:

In the main scene, we then connect the player's signal (it will appear in the "Node" tab of the Inspector)

Now the bullets will maintain their own movement independent of the player's rotation:

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
extends Area2D

var velocity = Vector2.RIGHT

func _physics_process(delta):
    position += velocity * delta
```

Example 2 (javascript):
```javascript
using Godot;

public partial class Bullet : Area2D
{
    public Vector2 Velocity { get; set; } = Vector2.Right;

    public override void _PhysicsProcess(double delta)
    {
        Position += Velocity * (float)delta;
    }
}
```

Example 3 (unknown):
```unknown
var bullet_instance = Bullet.instantiate()
get_parent().add_child(bullet_instance)
```

Example 4 (unknown):
```unknown
Node bulletInstance = Bullet.Instantiate();
GetParent().AddChild(bulletInstance);
```

---

## Logging — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/logging.html

**Contents:**
- Logging
- Printing messages
- Project settings
- Built-in file logging
- Script backtraces
- Crash backtraces
- Creating custom loggers
- User-contributed notes

Godot comes with several ways to organize and collect log messages.

See Printing messages for instructions on printing messages. The printed output is generally identical to the logged output.

When running a project from the editor, the editor will display logged text in the Output panel.

There are several project settings to control logging behavior in Godot:

Application > Run > Disable stdout: Disables logging to standard output entirely. This also affects what custom loggers receive. This can be controlled at runtime by setting Engine.print_to_stdout.

Application > Run > Disable stderr: Disables logging to standard error entirely. This also affects what custom loggers receive. This can be controlled at runtime by setting Engine.print_error_messages.

Debug > Settings > stdout > Verbose stdout: Enables verbose logging to standard output. Prints from print_verbose() are only visible if verbose mode is enabled.

Debug > Settings > stdout > Print FPS: Prints the frames per second every second, as well as the V-Sync status on startup (as it can effectively cap the maximum framerate).

Debug > Settings > stdout > Print GPU Profile: Prints a report of GPU utilization every second, using the same data source as the Visual Profiler.

Some of these project settings can also be overridden using command line arguments such as --quiet, --verbose, and --print-fps.

The engine's own file logging is also configurable, as described in the section below.

By default, Godot writes log files in user://logs/godot.log on desktop platforms. You can change this location by modifying the debug/file_logging/log_path project setting. Logs are rotated to keep older files available for inspection. Each session creates a new log file, with the old file renamed to contain the date at which it was rotated. Up to 5 log files are kept by default, which can be adjusted using the debug/file_logging/max_log_files project setting.

File logging can also be disabled completely using the debug/file_logging/enable_file_logging project setting.

When the project crashes, crash logs are written to the same file as the log file. The crash log will only contain a usable backtrace if the binary that was run contains debugging symbols, or if it can find a debug symbols file that matches the binary. Official binaries don't provide debugging symbols, so this requires a custom build to work. See Debugging symbols for guidance on compiling binaries with debugging symbols enabled.

Log files for print() statements are updated when standard output is flushed by the engine. Standard output is flushed on every print in debug builds only. In projects that are exported in release mode, standard output is only flushed when the project exits or crashes to improve performance, especially if the project is often printing text to standard output.

On the other hand, the standard error stream (used by printerr(), push_error(), and push_warning()) is always flushed on every print, even in projects exported in release mode.

For some use cases like dedicated servers, it can be preferred to have release builds always flush stdout on print, so that logging services like journald can collect logs while the process is running. This can be done by enabling application/run/flush_stdout_on_print in the Project Settings.

Since Godot 4.5, when GDScript code encounters an error, it will log a backtrace that points to the origin of the error, while also containing the call stack leading to it. This behavior is always enabled when running in the editor, or when the project is exported in debug mode.

In projects exported in release mode, backtraces are disabled by default for performance reasons. You can enable them by checking Debug > Settings > GDScript > Always Track Call Stacks in the Project Settings. If you use a custom logging system that reports exceptions to a remote service, it's recommended to enable this to make reported errors more actionable.

Crash backtraces are only useful if they were recorded in a build that contains debugging symbols. Official Godot binaries do not contain debugging symbols, so you must compile a custom editor or export template binary to get useful crash backtraces.

When the project crashes, a crash backtrace is printed to the standard error stream. This is what it can look like in a build with debug symbols:

On the other hand, without debug symbols, it will look like this instead:

This backtrace is also logged to the file for the current session, but it is not visible in the editor Output panel. Since the engine's scripting system is not running anymore when the engine is crashing, it is not possible to access it from scripting in the same session. However, you can still read the crash backtrace on the next session by loading log files and searching for the crash backtrace string (Program crashed with signal) using FileAccess. This allows you to access the backtrace information even after a crash, as long as the user restarts the project and file logging is enabled:

You can customize the message that appears at the top of the backtrace using the Debug > Settings > Crash Handler > Message project setting. This can be used to point to a URL or email address that users can report issues to.

Since Godot 4.5, it is possible to create custom loggers. This custom logging can be used for many purposes:

Show an in-game console with the same messages as printed by the engine, without requiring other scripts to be modified.

Report printed errors from the player's machine to a remote server. This can make it easier for developers to fix bugs when the game is already released, or during playtesting.

Integrate a dedicated server export with monitoring platforms.

A custom logger can be registered by creating a class that inherits from Logger, then passing an instance of this class to OS.add_logger, in a script's _init() method. A good place to do this is an autoload.

The class must define two methods: _log_message() and _log_error().

Here is a minimal working example of a custom logger, with the script added as an autoload:

Note that to avoid infinite recursion, you cannot effectively use print() and its related methods in _log_message(). You also can't effectively use push_error() or push_warning() in _log_error(). Attempting to do so will print a message to the same stream as the original message. This message is not available in the custom logger, which is what prevents infinite recursion from occurring:

You can find an example of an in-game console built with a custom logger in the Custom Logging demo project.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
================================================================
handle_crash: Program crashed with signal 4
Engine version: Godot Engine v4.5.beta.custom_build (6c9aa4c7d3b9b91cd50714c40eeb234874df7075)
Dumping the backtrace. Please include this when reporting the bug to the project developer.
[1] /lib64/libc.so.6(+0x1a070) [0x7f6e5e277070] (??:0)
[2] godot() [0x4da3358] (/path/to/godot/core/core_bind.cpp:336 (discriminator 2))
[3] godot() [0xdf5f2f] (/path/to/godot/modules/gdscript/gdscript.h:591)
[4] godot() [0xbffd46] (/path/to/godot/modules/gdscript/gdscript.cpp:2065 (discriminator 1))
[5] godot() [0x30f2ea4] (/path/to/godot/core/variant/variant.h:870)
[6] godot() [0x550d4e1] (/path/to/godot/core/object/object.cpp:933)
[7] godot() [0x30d996a] (/path/to/godot/scene/main/node.cpp:318 (discriminator 1))
[8] godot() [0x3131a7f] (/path/to/godot/core/templates/hash_map.h:465)
[9] godot() [0x424589] (/path/to/godot/platform/linuxbsd/os_linuxbsd.cpp:970)
[10] /lib64/libc.so.6(+0x3575) [0x7f6e5e260575] (??:0)
[11] /lib64/libc.so.6(__libc_start_main+0x88) [0x7f6e5e260628] (??:0)
[12] godot() [0x464df5] (??:?)
-- END OF C++ BACKTRACE --
================================================================
GDScript backtrace (most recent call first):
    [0] _ready (res://test.gd:5)
-- END OF GDSCRIPT BACKTRACE --
================================================================
```

Example 2 (unknown):
```unknown
================================================================
handle_crash: Program crashed with signal 4
Engine version: Godot Engine v4.5.beta.custom_build (6c9aa4c7d3b9b91cd50714c40eeb234874df7075)
Dumping the backtrace. Please include this when reporting the bug to the project developer.
[1] /lib64/libc.so.6(+0x1a070) [0x7fdfaf666070] (??:0)
[2] godot() [0x4da3358] (??:0)
[3] godot() [0xdf5f2f] (??:0)
[4] godot() [0xbffd46] (??:0)
[5] godot() [0x30f2ea4] (??:0)
[6] godot() [0x550d4e1] (??:0)
[7] godot() [0x30d996a] (??:0)
[8] godot() [0x3131a7f] (??:0)
[9] godot() [0x424589] (??:0)
[10] /lib64/libc.so.6(+0x3575) [0x7fdfaf64f575] (??:0)
[11] /lib64/libc.so.6(__libc_start_main+0x88) [0x7fdfaf64f628] (??:0)
[12] godot() [0x464df5] (??:0)
-- END OF C++ BACKTRACE --
================================================================
GDScript backtrace (most recent call first):
    [0] _ready (res://test.gd:5)
-- END OF GDSCRIPT BACKTRACE --
================================================================
```

Example 3 (gdscript):
```gdscript
# This script can be made an autoload, so that it runs when the project starts.
extends Node

func _ready() -> void:
  var log_dir: String = String(ProjectSettings.get_setting("debug/file_logging/log_path")).get_base_dir()
  # Get the last log file by alphabetical order.
  # Since the timestamp is featured in the file name, it should always be the most recent
  # log file that was rotated. The non-timestamped log file is for the current session,
  # so we don't want to read that one.
  var last_log_file: String = log_dir.path_join(DirAccess.get_files_at(log_dir)[-1])
  var last_long_contents: String = FileAccess.get_file_as_string(last_log_file)

  var crash_begin_idx: int = last_long_contents.find("Program crashed with signal")
  if crash_begin_idx != -1:
      print("The previous session has crashed with the following backtrace:\n")
      print(last_long_contents.substr(crash_begin_idx))
```

Example 4 (unknown):
```unknown
extends Node

class CustomLogger extends Logger:
    # Note that this method is not called for messages that use
    # `push_error()` and `push_warning()`, even though these are printed to stderr.
    func _log_message(message: String, error: bool) -> void:
        # Do something with `message`.
        # `error` is `true` for messages printed to the standard error stream (stderr) with `print_error()`.
        # Note that this method will be called from threads other than the main thread, possibly at the same
        # time, so you will need to have some kind of thread-safety as part of it, like a Mutex.
        pass

    func _log_error(
            function: String,
            file: String,
            line: int,
            code: String,
            rationale: String,
            editor_notify: bool,
            error_type: int,
            script_backtraces: Array[ScriptBacktrace]
    ) -> void:
        # Do something with the error. The error text is in `rationale`.
        # See the Logger class reference for details on other parameters.
        # Note that this method will be called from threads other than the main thread, possibly at the same
        # time, so you will need to have some kind of thread-safety as part of it, like a Mutex.
        pass

# Use `_init()` to initialize the logger as early as possible, which ensures that messages
# printed early are taken into account. However, even when using `_init()`, the engine's own
# initialization messages are not accessible.
func _init() -> void:
    OS.add_logger(CustomLogger.new())
```

---

## Nodes and scene instances — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/nodes_and_scene_instances.html

**Contents:**
- Nodes and scene instances
- Getting nodes
- Node paths
  - Syntactic sugar
- Creating nodes
- Instancing scenes
- User-contributed notes

This guide explains how to get nodes, create nodes, add them as a child, and instantiate scenes from code.

Check the Creating instances tutorial to learn about Godot's approach to scene instancing.

You can get a reference to a node by calling the Node.get_node() method. For this to work, the child node must be present in the scene tree. Getting it in the parent node's _ready() function guarantees that.

If, for example, you have a scene tree like this, and you want to get a reference to the Sprite2D and Camera2D nodes to access them in your script.

To do so, you can use the following code.

Note that you get nodes using their name, not their type. Above, "Sprite2D" and "Camera2D" are the nodes' names in the scene.

If you rename the Sprite2D node as Skin in the Scene dock, you have to change the line that gets the node to get_node("Skin") in the script.

When getting a reference to a node, you're not limited to getting a direct child. The get_node() function supports paths, a bit like when working with a file browser. Add a slash to separate nodes.

Take the following example scene, with the script attached to the UserInterface node.

To get the AnimationPlayer node, you would use the following code.

As with file paths, you can use ".." to get a parent node. The best practice is to avoid doing that though not to break encapsulation. You can also start the path with a forward slash to make it absolute, in which case your topmost node would be "/root", the application's predefined root viewport.

You can use two shorthands to shorten your code in GDScript. Firstly, putting the @onready annotation before a member variable makes it initialize right before the _ready() callback.

There is also a short notation for get_node(): the dollar sign, "$". You place it before the name or path of the node you want to get.

To create a node from code, call its new() method like for any other class-based datatype.

You can store the newly created node's reference in a variable and call add_child() to add it as a child of the node to which you attached the script.

To delete a node and free it from memory, you can call its queue_free() method. Doing so queues the node for deletion at the end of the current frame after it has finished processing. At that point, the engine removes the node from the scene and frees the object in memory.

Before calling sprite2d.queue_free(), the remote scene tree looks like this.

After the engine freed the node, the remote scene tree doesn't display the sprite anymore.

You can alternatively call free() to immediately destroy the node. You should do this with care as any reference to it will instantly become null. We recommend using queue_free() unless you know what you're doing.

When you free a node, it also frees all its children. Thanks to this, to delete an entire branch of the scene tree, you only have to free the topmost parent node.

Scenes are templates from which you can create as many reproductions as you'd like. This operation is called instancing, and doing it from code happens in two steps:

Loading the scene from the local drive.

Creating an instance of the loaded PackedScene resource.

Preloading the scene can improve the user's experience as the load operation happens when the compiler reads the script and not at runtime. This feature is only available with GDScript.

At that point, scene is a packed scene resource, not a node. To create the actual node, you need to call PackedScene.instantiate(). It returns a tree of nodes that you can use as a child of your current node.

The advantage of this two-step process is you can keep a packed scene loaded and create new instances on the fly. For example, to quickly instance several enemies or bullets.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
var sprite2d
var camera2d

func _ready():
    sprite2d = get_node("Sprite2D")
    camera2d = get_node("Camera2D")
```

Example 2 (unknown):
```unknown
private Sprite2D _sprite2D;
private Camera2D _camera2D;

public override void _Ready()
{
    base._Ready();

    _sprite2D = GetNode<Sprite2D>("Sprite2D");
    _camera2D = GetNode<Camera2D>("Camera2D");
}
```

Example 3 (gdscript):
```gdscript
var animation_player

func _ready():
    animation_player = get_node("ShieldBar/AnimationPlayer")
```

Example 4 (unknown):
```unknown
private AnimationPlayer _animationPlayer;

public override void _Ready()
{
    base._Ready();

    _animationPlayer = GetNode<AnimationPlayer>("ShieldBar/AnimationPlayer");
}
```

---

## Other languages — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/other_languages.html

**Contents:**
- Other languages
- User-contributed notes

The Godot developers officially support the following languages for Godot:

GDScript (all versions)

C++ (via GDExtension)

There are no plans to support additional languages officially. That said, the community offers several bindings for other languages (see below).

The bindings below are developed and maintained by the community:

Not all bindings mentioned here may be production-ready. Make sure to research options thoroughly before starting a project with one of those. Also, double-check whether the binding is compatible with the Godot version you're using.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Output panel — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/debug/output_panel.html

**Contents:**
- Output panel
- Message categories
- Filtering messages
- Clearing messages
- Printing messages
  - Printing rich text
- User-contributed notes

The output panel is found at the bottom of the screen. Click on Output to open it.

The output panel provides several features to make viewing text printed by the project (and editor) easier.

The output panel automatically opens when running a project by default. You can control this behavior by changing the Run > Bottom Panel > Action on Play editor setting.

Four message categories are available:

Log: Standard messages printed by the project. Displayed in white or black (depending on the editor theme).

Error: Messages printed by the project or editor that indicate a failure of some kind. Displayed in red.

Warning: Messages printed by the project or editor that report important information, but do not indicate a failure. Displayed in yellow.

Editor: Messages printed by the editor, typically intended to be traces of undo/redo actions. Displayed in gray.

By clicking on the buttons on the right, you can hide certain message categories. This can make it easier to find specific messages you're looking for.

You can also filter messages by their text content using the Filter Messages box at the bottom of the Output panel.

When running the project, existing messages are automatically cleared by default. This is controlled by the Run > Output > Always Clear Output on Play editor setting. Additionally, you can manually clear messages by clicking the "cleaning brush" icon in the top-right corner of the Output panel.

Several methods are available to print messages:

print(): Prints a message. This method accepts multiple arguments which are concatenated together upon printing. This method has variants that separate arguments with tabs and spaces respectively: printt() and prints().

print_rich(): Same as print(), but BBCode can be used to format the text that is printed (see below).

push_error(): Prints an error message. When an error is printed in a running project, it's displayed in the Debugger > Errors tab instead.

push_warning(): Prints a warning message. When a warning is printed in a running project, it's displayed in the Debugger > Errors tab instead.

For more complex use cases, these can be used:

print_verbose(): Same as print(), but only prints when verbose mode is enabled in the Project Settings or the project is run with the --verbose command line argument.

printerr(): Same as print(), but prints to the standard error stream instead of the standard output string. push_error() should be preferred in most cases.

printraw(): Same as print(), but prints without a blank line at the end. This is the only method that does not print to the editor Output panel. It prints to the standard output stream only, which means it's still included in file logging.

print_stack(): Print a stack trace from the current location. Only supported when running from the editor, or when the project is exported in debug mode.

print_tree(): Prints the scene tree relative to the current node. Useful for debugging node structures created at runtime.

print_tree_pretty(): Same as print_tree(), but with Unicode characters for a more tree-like appearance. This relies on box-drawing characters, so it may not render correctly with all fonts.

To get more advanced formatting capabilities, consider using GDScript format strings along with the above printing functions.

The engine's logging facilities are covered in the logging documentation.

Using print_rich(), you can print rich text to the editor Output panel and standard output (visible when the user runs the project from a terminal). This works by converting the BBCode to ANSI escape codes that the terminal understands.

In the editor output, all BBCode tags are recognized as usual. In the terminal output, only a subset of BBCode tags will work, as documented in the linked print_rich() method description above. In the terminal, the colors will look different depending on the user's theme, while colors in the editor will use the same colors as they would in the project.

ANSI escape code support varies across terminal emulators. The exact colors displayed in terminal output also depend on the terminal theme chosen by the user.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Overridable functions — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/overridable_functions.html

**Contents:**
- Overridable functions
- User-contributed notes

Godot's Node class provides virtual functions you can override to update nodes every frame or on specific events, like when they enter the scene tree.

This document presents the ones you'll use most often.

Under the hood, these functions rely on Godot's low-level notifications system. To learn more about it, see Godot notifications.

Two functions allow you to initialize and get nodes besides the class's constructor: _enter_tree() and _ready().

When the node enters the Scene Tree, it becomes active and the engine calls its _enter_tree() method. That node's children may not be part of the active scene yet. As you can remove and re-add nodes to the scene tree, this function may be called multiple times throughout a node's lifetime.

Most of the time, you'll use _ready() instead. This function is called only once in a node's lifetime, after _enter_tree(). _ready() ensures that all children have entered the scene tree first, so you can safely call get_node() on them.

To learn more about getting node references, read Nodes and scene instances.

Another related callback is _exit_tree(), which the engine calls every time a node is about to exit the scene tree. This can be when you call Node.remove_child() or when you free a node.

The two virtual methods _process() and _physics_process() allow you to update the node, every frame and every physics frame respectively. For more information, read the dedicated documentation: Idle and Physics Processing.

Two more essential built-in node callback functions are Node._unhandled_input() and Node._input(), which you use to both receive and process individual input events. The _unhandled_input() method receives every key press, mouse click, etc. that have not been handled already in an _input() callback or in a user interface component. You want to use it for gameplay input in general. The _input() callback allows you to intercept and process input events before _unhandled_input() gets them.

To learn more about inputs in Godot, see the Input section.

There are some more overridable functions like Node._get_configuration_warnings(). Specialized node types provide more callbacks like CanvasItem._draw() to draw programmatically or Control._gui_input() to handle clicks and input on UI elements.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
# Called every time the node enters the scene tree.
func _enter_tree():
    pass

# Called when both the node and its children have entered the scene tree.
func _ready():
    pass

# Called when the node is about to leave the scene tree, after all its
# children received the _exit_tree() callback.
func _exit_tree():
    pass
```

Example 2 (unknown):
```unknown
// Called every time the node enters the scene tree.
public override void _EnterTree()
{
    base._EnterTree();
}

// Called when both the node and its children have entered the scene tree.
public override void _Ready()
{
    base._Ready();
}

// Called when the node is about to leave the scene tree, after all its
// children.
public override void _ExitTree()
{
    base._ExitTree();
}
```

Example 3 (unknown):
```unknown
# Called every frame.
func _process(delta):
    pass

# Called every physics frame.
func _physics_process(delta):
    pass
```

Example 4 (unknown):
```unknown
public override void _Process(double delta)
{
    // Called every frame.
    base._Process(delta);
}

public override void _PhysicsProcess(double delta)
{
    // Called every physics frame.
    base._PhysicsProcess(delta);
}
```

---

## Overview of debugging tools — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/debug/overview_of_debugging_tools.html

**Contents:**
- Overview of debugging tools
- Output Panel
- Debugger Panel
- Debug menu options
  - Deploy with Remote Debug
  - Small Deploy with Network Filesystem
  - Visible Collision Shapes
  - Visible Paths
  - Visible Navigation
  - Visible Avoidance

This guide will give you an overview of the available debugging tools in the engine.

Godot comes with a powerful debugger and profilers to track down bugs, inspect your game at runtime, monitor essential metrics, and measure performances. It also offers options to visualize collision boxes and navigation polygons in the running game.

Finally, you have options to debug the game running on a remote device and to reload changes to your scenes or your code while the game is running.

The output panel allows you to see text printed by the project, but also by the editor (e.g. from @tool scripts). You can find information about in Output panel.

Many of Godot's debugging tools are part of the Debugger panel, which you can find information about in Debugger panel.

There are a few common debug options you can toggle on or off when running your game in the editor, which can help you in debugging your game.

You can find these options in the Debug editor menu.

Here are the descriptions of the options:

When this option is enabled, using one-click deploy will make the executable attempt to connect to this computer's IP so the running project can be debugged. This option is intended to be used for remote debugging (typically with a mobile device). You don't need to enable it to use the GDScript debugger locally.

This option speeds up testing for games with a large footprint on remote devices.

When Small Deploy with Network Filesystem is on, instead of exporting the full game, deploying the game builds a minimal executable. The editor then provides files from the project over the network.

Also, on Android, the game is deployed using the USB cable to speed up deployment.

When this option is enabled, collision shapes and raycast nodes (for 2D and 3D) will be visible in the running project.

When this option is enabled, curve resources used by path nodes will be visible in the running project.

When this option is enabled, navigation meshes, and polygons will be visible in the running project.

When this option is enabled, avoidance object shapes, radiuses, and velocities will be visible in the running project.

When this option is enabled, redraw requests of 2D objects will become visible (as a short flash) in the running project. This is useful to troubleshoot low processor mode.

When this option is enabled, any changes made to the scene in the editor will be replicated in the running project. When used remotely on a device, this is more efficient when the network filesystem option is enabled.

When this option is enabled, any changes made to the script in the editor will be reloaded in the running project. When used remotely on a device, this is more efficient with the network filesystem.

When this option is enabled, the editor debug server will stay open and listen for new sessions started outside of the editor itself.

This opens a dialog allowing you to tell Godot to run multiple instances of the game at once, and to specify the command line arguments for each instance. This is especially useful when building and debugging multiplayer games.

When this option is enabled, the editor will run multiple instances of the project at once when you Run Project.

Below this checkbox is a selector to pick how many instances to run.

Checking the box and setting this to only 1 is the same as not checking this box at all.

These are the arguments that will be passed to every instance of the project when you Run Project, unless you select "Enabled" under "Override Main Run Args" for a specific instance.

Note that these arguments are space-separated.

These arguments can be accessed in your script by using get_cmdline_args.

Even if you uncheck "Enable Multiple Instances" these arguments will be passed when you Run Project.

These are the feature tags that will be passed to every instance of the project when you Run Project, unless you select "Enabled" under "Override Main Tags" for a specific instance.

When this is enabled, the arguments in the "Main Run Args" field will not be passed to this specific instance of the project when you Run Project.

These are the arguments that will be passed to this specific instance of the project when you Run Project. They will be combined with the "Main Run Args" unless you select "Enabled" under "Override Main Run Args".

When this is enabled, the tags in the "Main Feature Tags" field will not be passed to this specific instance of the project when you Run Project.

These are the feature tags that will be passed to this specific instance of the project when you Run Project. They will be combined with the "Main Feature Tags" unless you select "Enabled" under "Override Main Tags".

If you want to pass "User" arguments, that can be accessed with get_cmdline_user_args then you must prefix them with two dashes and a space like -- one two three.

Be aware that these dashes will apply to arguments added later in the "Launch Arguments" on a per instance basis, which can cause some confusion when combining the Main Run Args and Launch Arguments.

If you place -- one two three in the "Main Run Args" and -- four five six in the "Launch Arguments" then the final command line arguments will be one two three -- four five six. This is because the -- is repeated in the "Launch Arguments".

The script editor has its own set of debug tools for use with breakpoints and two options. The breakpoint tools can also be found in the Debugger tab of the debugger.

You can create a breakpoint by clicking the gutter in the left of the script editor (on the left of the line numbers). When hovering this gutter, you will see a transparent red dot appearing, which turns into an opaque red dot after the breakpoint is placed by clicking. Click the red dot again to remove the breakpoint. Breakpoints created this way persist across editor restarts, even if the script wasn't saved when exiting the editor.

You can also use the breakpoint keyword in GDScript to create a breakpoint that is stored in the script itself. Unlike breakpoints created by clicking in the gutter, this keyword-based breakpoint is persistent across different machines when using version control.

The Break button causes a break in the script like a breakpoint would. Continue makes the game continue after pausing at a breakpoint. Step Over goes to the next line of code, and Step Into goes into a function if possible. Otherwise, it does the same thing as Step Over.

The Debug with External Editor option lets you debug your game with an external editor. You can set a shortcut for it in Editor Settings > Shortcuts > Debugger.

When the debugger breaks on a breakpoint, a green triangle arrow is visible in the script editor's gutter. This arrow indicates the line of code the debugger broke on.

In the project settings, there is a Debug category with subcategories which control different things. Enable Advanced Settings to change these settings.

These are some general settings such as printing the current FPS to the Output panel, the maximum amount of functions when profiling and others.

These settings allow you to log console output and error messages to files.

These settings allow you to toggle specific GDScript warnings, such as for unused variables. You can also turn off warnings completely. See GDScript warning system for more information.

These settings allow you to toggle specific shader warnings, such as for unused variables. You can also turn off warnings completely.

These settings are for canvas item redraw debugging.

Shapes are where you can adjust the color of shapes that only appear for debugging purposes, such as collision and navigation shapes.

When running a game in the editor two options appear at the top of the Scene dock, Remote and Local. While using Remote you can inspect or change the nodes' parameters in the running project.

Some editor settings related to debugging can be found inside the Editor Settings, under the Network > Debug and Debugger sections.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Pausing games and process mode — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/pausing_games.html

**Contents:**
- Pausing games and process mode
- Introduction
- How pausing works
- Process Modes
- Pause menu example
- User-contributed notes

In most games it is desirable to, at some point, interrupt the game to do something else, such as taking a break or changing options. Implementing a fine-grained control for what can be paused (and what cannot) is a lot of work, so a simple framework for pausing is provided in Godot.

To pause the game the pause state must be set. This is done by assigning true to the SceneTree.paused property:

Doing this will cause two things. First, 2D and 3D physics will be stopped for all nodes. Second, the behavior of certain nodes will stop or start depending on their process mode.

The physics servers can be made active while the game is paused by using their set_active methods.

Each node in Godot has a "Process Mode" that defines when it processes. It can be found and changed under a node's Node properties in the inspector.

You can also alter the property with code:

This is what each mode tells a node to do:

Inherit: Process depending on the state of the parent, grandparent, etc. The first parent that has a non-Inherit state.

Pausable: Process the node (and its children in Inherit mode) only when the game is not paused.

WhenPaused: Process the node (and its children in Inherit mode) only when the game is paused.

Always: Process the node (and its children in Inherit mode) no matter what. Paused or not, this node will process.

Disabled: The node (and its children in Inherit mode) will not process at all.

By default, all nodes have this property in the "Inherit" state. If the parent is set to "Inherit", then the grandparent will be checked and so on. If a state can't be found in any of the grandparents, the pause state in SceneTree is used. This means that, by default, when the game is paused every node will be paused. Several things happen when a node stops processing.

The _process, _physics_process, _input, and _input_event functions will not be called. However signals still work and cause their connected function to run, even if that function's script is attached to a node that is not currently being processed.

Animation nodes will pause their current animation, audio nodes will pause their current audio stream, and particles will pause. These resume automatically when the game is no longer paused.

It is important to note that even if a node is processing while the game is paused physics will NOT work for it by default. As stated earlier this is because the physics servers are turned off. The physics servers can be made active while the game is paused by using their set_active methods.

Start by creating a button that will be used to pause the game.

Create a menu containing a close button, set the Process Mode of the menu's root node to When Paused, then hide the menu. Since the process mode is set to When Paused on the root node, all its children and grandchildren will inherit that process mode. This way, all the nodes in the menu will start processing when the game is paused.

Attach a script to the menu's root node, connect the pause button created earlier to a new method in the script, and inside that method pause the game and show the pause menu.

Finally, connect the menu's close button to a new method in the script. Inside that method, unpause the game and hide the pause menu.

You should now have a working pause menu.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
get_tree().paused = true
```

Example 2 (unknown):
```unknown
GetTree().Paused = true;
```

Example 3 (unknown):
```unknown
func _ready():
    process_mode = Node.PROCESS_MODE_PAUSABLE
```

Example 4 (unknown):
```unknown
public override void _Ready()
{
    ProcessMode = Node.ProcessModeEnum.Pausable;
}
```

---

## Resources — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/resources.html

**Contents:**
- Resources
- Nodes and resources
- External vs built-in
- Loading resources from code
- Loading scenes
- Freeing resources
- Creating your own resources
- User-contributed notes

Up to this tutorial, we focused on the Node class in Godot as that's the one you use to code behavior and most of the engine's features rely on it. There is another datatype that is just as important: Resource.

Nodes give you functionality: they draw sprites, 3D models, simulate physics, arrange user interfaces, etc. Resources are data containers. They don't do anything on their own: instead, nodes use the data contained in resources.

Anything Godot saves or loads from disk is a resource. Be it a scene (a .tscn or a .scn file), an image, a script... Here are some Resource examples:

When the engine loads a resource from disk, it only loads it once. If a copy of that resource is already in memory, trying to load the resource again will return the same copy every time. As resources only contain data, there is no need to duplicate them.

Every object, be it a Node or a Resource, can export properties. There are many types of Properties, like String, integer, Vector2, etc., and any of these types can become a resource. This means that both nodes and resources can contain resources as properties:

There are two ways to save resources. They can be:

External to a scene, saved on the disk as individual files.

Built-in, saved inside the .tscn or the .scn file they're attached to.

To be more specific, here's a Texture2D in a Sprite2D node:

Clicking the resource preview allows us to view the resource's properties.

The path property tells us where the resource comes from. In this case, it comes from a PNG image called robi.png. When the resource comes from a file like this, it is an external resource. If you erase the path or this path is empty, it becomes a built-in resource.

The switch between built-in and external resources happens when you save the scene. In the example above, if you erase the path "res://robi.png" and save, Godot will save the image inside the .tscn scene file.

Even if you save a built-in resource, when you instance a scene multiple times, the engine will only load one copy of it.

There are two ways to load resources from code. First, you can use the load() function anytime:

You can also preload resources. Unlike load, this function will read the file from disk and load it at compile-time. As a result, you cannot call preload with a variable path: you need to use a constant string.

Scenes are also resources, but there is a catch. Scenes saved to disk are resources of type PackedScene. The scene is packed inside a Resource.

To get an instance of the scene, you have to use the PackedScene.instantiate() method.

This method creates the nodes in the scene's hierarchy, configures them, and returns the root node of the scene. You can then add it as a child of any other node.

The approach has several advantages. As the PackedScene.instantiate() function is fast, you can create new enemies, bullets, effects, etc. without having to load them again from disk each time. Remember that, as always, images, meshes, etc. are all shared between the scene instances.

When a Resource is no longer in use, it will automatically free itself. Since, in most cases, Resources are contained in Nodes, when you free a node, the engine frees all the resources it owns as well if no other node uses them.

Like any Object in Godot, users can also script Resources. Resource scripts inherit the ability to freely translate between object properties and serialized text or binary data (*.tres, *.res). They also inherit the reference-counting memory management from the RefCounted type.

This comes with many distinct advantages over alternative data structures, such as JSON, CSV, or custom TXT files. Users can only import these assets as a Dictionary (JSON) or as a FileAccess to parse. What sets Resources apart is their inheritance of Object, RefCounted, and Resource features:

They can define constants, so constants from other data fields or objects are not needed.

They can define methods, including setter/getter methods for properties. This allows for abstraction and encapsulation of the underlying data. If the Resource script's structure needs to change, the game using the Resource need not also change.

They can define signals, so Resources can trigger responses to changes in the data they manage.

They have defined properties, so users know 100% that their data will exist.

Resource auto-serialization and deserialization is a built-in Godot Engine feature. Users do not need to implement custom logic to import/export a resource file's data.

Resources can even serialize sub-Resources recursively, meaning users can design even more sophisticated data structures.

Users can save Resources as version-control-friendly text files (*.tres). Upon exporting a game, Godot serializes resource files as binary files (*.res) for increased speed and compression.

Godot Engine's Inspector renders and edits Resource files out-of-the-box. As such, users often do not need to implement custom logic to visualize or edit their data. To do so, double-click the resource file in the FileSystem dock or click the folder icon in the Inspector and open the file in the dialog.

They can extend other resource types besides just the base Resource.

Godot makes it easy to create custom Resources in the Inspector.

Create a new Resource object in the Inspector. This can even be a type that derives Resource, so long as your script is extending that type.

Set the script property in the Inspector to be your script.

The Inspector will now display your Resource script's custom properties. If one edits those values and saves the resource, the Inspector serializes the custom properties too! To save a resource from the Inspector, click the save icon at the top of the Inspector, and select "Save" or "Save As...".

If the script's language supports script classes, then it streamlines the process. Defining a name for your script alone will add it to the Inspector's creation dialog. This will auto-add your script to the Resource object you create.

Let's see some examples. Create a Resource and name it bot_stats. It should appear in your file tab with the full name bot_stats.tres. Without a script, it's useless, so let's add some data and logic! Attach a script to it named bot_stats.gd (or just create a new script, and then drag it to it).

To make the new resource class appear in the Create Resource GUI you need to provide a class name for GDScript, or use the [GlobalClass] attribute in C#.

Now, create a CharacterBody3D, name it Bot, and add the following script to it:

Now, select the CharacterBody3D node which we named bot, and drag&drop the bot_stats.tres resource onto the Inspector. It should print 10! Obviously, this setup can be used for more advanced features than this, but as long you really understand how it all worked, you should figure out everything else related to Resources.

Resource scripts are similar to Unity's ScriptableObjects. The Inspector provides built-in support for custom resources. If desired though, users can even design their own Control-based tool scripts and combine them with an EditorPlugin to create custom visualizations and editors for their data.

Unreal Engine's DataTables and CurveTables are also easy to recreate with Resource scripts. DataTables are a String mapped to a custom struct, similar to a Dictionary mapping a String to a secondary custom Resource script.

Instead of inlining the Dictionary values, one could also, alternatively:

Import a table of values from a spreadsheet and generate these key-value pairs.

Design a visualization within the editor and create a plugin that adds it to the Inspector when you open these types of Resources.

CurveTables are the same thing, except mapped to an Array of float values or a Curve/Curve2D resource object.

Beware that resource files (*.tres/*.res) will store the path of the script they use in the file. When loaded, they will fetch and load this script as an extension of their type. This means that trying to assign an inner class of a script (i.e. using the class keyword in GDScript) won't work. Godot will not serialize the custom properties on the script inner class properly.

In the example below, Godot would load the Node script, see that it doesn't extend Resource, and then determine that the script failed to load for the Resource object since the types are incompatible.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
func _ready():
    # Godot loads the Resource when it reads this very line.
    var imported_resource = load("res://robi.png")
    $sprite.texture = imported_resource
```

Example 2 (unknown):
```unknown
public override void _Ready()
{
    // Godot loads the Resource when it executes this line.
    var texture = GD.Load<Texture>("res://Robi.png");
    var sprite = GetNode<Sprite2D>("sprite");
    sprite.Texture = texture;
}
```

Example 3 (gdscript):
```gdscript
func _ready():
    # Godot loads the resource at compile-time
    var imported_resource = preload("res://robi.png")
    get_node("sprite").texture = imported_resource
```

Example 4 (unknown):
```unknown
// 'preload()' is unavailable in C Sharp.
```

---

## Scene Unique Nodes — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/scene_unique_nodes.html

**Contents:**
- Scene Unique Nodes
- Introduction
- Creation and usage
- Same-scene limitation
- Alternatives
- User-contributed notes

Using get_node() to reference nodes from a script can sometimes be fragile. If you move a button in a UI scene from one panel to another, the button's node path changes, and if a script uses get_node() with a hard-coded node path, the script will not be able to find the button anymore.

In situations like this, the node can be turned into a scene unique node to avoid having to update the script every time the node's path is changed.

There are two ways to create a scene unique node.

In the Scene tree dock, right-click on a node and select Access as Unique Name in the context menu.

After selecting the option, the node will now have a percent symbol (%) next to its name in the scene tree:

You can also do this while renaming the node by adding "%" to the beginning of the name. Once you confirm, the percent symbol will appear next to its name.

You can now use the node in your script. For example, you can reference it with a get_node() method call by typing the % symbol, followed by the node's name:

A scene unique node can only be retrieved by a node inside the same scene. To demonstrate this limitation, consider this example Player scene that instances a Sword scene:

Here are the results of get_node() calls inside the Player script:

get_node("%Eyes") returns the Eyes node.

get_node("%Hilt") returns null.

These are the results of get_node() calls inside the Sword script:

get_node("%Eyes") returns null.

get_node("%Hilt") returns the Hilt node.

If a script has access to a node in another scene, it can call get_node() on that node to get scene unique nodes from that node's scene. This also works in a node path, which avoids multiple get_node() calls. Here are two ways to get the Hilt node from the Player script using scene unique nodes:

get_node("Hand/Sword").get_node("%Hilt") returns the Hilt node.

get_node("Hand/Sword/%Hilt") also returns the Hilt node.

Scene unique names don't only work at the end of a node path. They can be used in the middle to navigate from one node to another. For example, the Sword node is marked as a scene unique node in the Player scene, so this is possible:

get_node("%Sword/%Hilt") returns the Hilt node.

Scene unique nodes are a useful tool to navigate a scene. However, there are some situations where other techniques may be better.

A Group allows locating a node (or a group of many nodes) from any other node, no matter what scene the two nodes are located in.

A Singleton (Autoload) is an always loaded node that can be accessed directly by any node regardless of the scene. These are useful when some data or functionality is shared globally.

Node.find_child() finds a node by name without knowing its full path. This seems similar to a scene unique node, but this method is able to find nodes in nested scenes, and doesn't require marking the node in the scene editor in any way. However, this method is slow. Scene unique nodes are cached by Godot and are fast to retrieve, but each time the method is called, find_child() needs to check every descendant (every child, grandchild, and so on).

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
get_node("%RedButton").text = "Hello"
%RedButton.text = "Hello" # Shorter syntax
```

Example 2 (unknown):
```unknown
GetNode<Button>("%RedButton").Text = "Hello";
```

---

## Scripting development — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/architecture/scripting_development.html

**Contents:**
- Scripting development
- GDScript
  - Annotation guidelines
- User-contributed notes

Create annotations for modifiers that act on the script or its code. Additionally, create annotations for behavior that is specific to the Godot engine and editor; if the primary purpose is to affect the way that the engine or editor treats or interacts with the script, implement the token as an annotation.

Do not create annotations for general programming language features.

For historical reasons, some existing annotations and keywords do not strictly follow these guidelines. Choosing between implementing a feature as an annotation or as a language keyword is a nuanced decision that should be made through discussion with other GDScript developers.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
# Affects how the editor treats this script.
@icon("res://path/to/class/icon.svg")

# Affects how the engine interacts with this script.
@onready var character_name = $Label

# static is a general programming language feature.
static var num_players = 2
```

---

## Scripting — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/index.html

**Contents:**
- Scripting
- Programming languages
- Core features

This section covers programming languages and core features to code your games in Godot.

Here, you will find information that is not already covered in more specific sections. For instance, to learn about inputs, we recommend you to read Inputs.

The sections below each focus on a given programming language.

Some features are specific to the engine and are available in all supported languages. Whether you code in GDScript, C#, or another language, the pages below will help you make the most of Godot.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Script Editor — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/editor/script_editor.html

**Contents:**
- Script Editor
- Introduction
- Features
- Usage
  - Script Panel
  - Menus
  - Coding area
- User-contributed notes

Godot Engine's script editor is a powerful and fully-integrated text editor that not only streamlines the process of writing and debugging code written in GDScript but also allows for working with plain text files, providing developers with a seamless environment for scripting game logic and behaviors. It can highlight your code, automatically indent it, perform syntax checks, and much more. You can also create breakpoints to debug your project without switching to another window. The text editor also serves as an offline class reference viewer, which can be accessed in several ways as described in the Integrated class reference.

Some of the key features of the text editor are listed below:

Fully-integrated code editor for GDScript.

Syntax highlighting support for GDScript and JSON files.

Syntax checking for GDScript and JSON files.

Bookmark and breakpoint support.

Automatic indentation.

Multiple carets, which can be enabled using Alt + Left Click.

Auto-completion of variables, functions, constants, etc.

Inline refactoring of symbols by selecting them and using Ctrl + D.

Mass find and replace across project files.

If you are using GDScript in your project, the built-in text editor in Godot provides everything you need, serving as a one-stop location to fully utilize the Godot Engine. Nearly all parameters that can be adjusted via the user interface can also be modified directly through code.

If you would like to use an external text editor or prefer to use C# in your project, see Using an external text editor and Configuring an external editor.

Similar to many parts of the Godot's interface, the text editor can also be customized by changing its settings to your liking. You can access these settings by opening Editor > Editor Settings and going to the Text Editor group.

You can open the Script Editor using the Script button in the workspace selector, located at the top center of Godot's interface. Alternatively, you can use the Open Script button next to a node in the Scene Tree dock, or double-click on a .gd file or a recognized text file in the FileSystem dock to open it directly in the Script Editor.

Once it is open, you will see the text editor menus at the top, below the scene switcher. Next to the menus, you'll find buttons to open the online documentation or search within the built-in class reference. To the right of these buttons are two navigation arrows that allow you to navigate through your viewing history. Finally, you can use the float button to separate the text editor from Godot's window, which is useful if you are working with multiple monitors.

Underneath the menus on the left, you will see the script panel. In the center, adjacent to the script panel, is the coding area. Beneath the coding area is the status bar, which displays the error and warning count in the code. Clicking on the error or warning icons will show the list of errors with the line numbers. Clicking on one will jump to that line. You can also choose to ignore warnings by opening the list and clicking Ignore. The status bar also lets you change the zoom level of the code by clicking the percentage value. You can also use Ctrl + Mouse Wheel (Cmd + Mouse Wheel on Mac) to achieve the same effect. The status bar also shows the current position of the caret in terms of line and column, and whether the indentation is done using tabs, or spaces.

Many of the actions performed in the text editor can also be executed using shortcuts. The actions show their corresponding shortcuts next to them. For a complete shortcut list, see the text editor shortcuts.

In the next sections, we will go through different aspects of the text editor. You can also select a section below to jump to a specific topic:

Below the menus, on the left panel, you will see a list of opened files and documentation pages. Depending on the file type, this list will have an icon next to the file name. For example, the icon means that it is a GDScript. the means it is a C# script. The means that this is a built-in class reference. Finally, the means it is a currently running script (See tool annotation for more on this). Hovering a file will show a tooltip with its relative location in the project folder.

On the status bar, clicking the left arrow hides the script panel, clicking on the right arrow shows it.

If you did not change any settings, the file names may also have a different coloring. This helps you identify the recently edited files by highlighting them. This behavior can be changed in the Editor > Editor Settings by adjusting the Script Temperature properties in the Text Editor section.

The filter bar above the file names introduces a handy case-insensitive search to find a specific file. Even if you just type the letters of a file name into the bar, files containing these letters in order will also appear. Assume that there is a file named button.gd in the list. If you type btn into the filter bar, this file will appear in the results. To reset the filter, clear the filter bar.

An asterisk (*) next to a file name indicates that the file has unsaved changes.

If you just enter "*" in the filter bar, you can display all unsaved files.

You can drag a file to change the ordering. Middle-clicking on a file closes it. Right-clicking on a file provides several options to save or close files, or to copy the relative path of the file. On this menu:

You can also use Move Up and Move Down to change the order of the file, or use Sort to sort all files alphabetically. Toggle Scripts Panel hides the panel, which can be displayed again using the right arrow on the status bar. Close Docs closes all opened in-class reference documents leaving only script files open. Show in FileSystem finds and highlights the file in the FileSystem dock.

Below the file list, you'll see the name of the currently open file. The button next to this switches the ordering of the methods defined in this file between alphabetical and as they appear. Under this is the outline of the file. If this is a script file, it will contain the list of defined methods. If, however, a class reference page is open, this area will show the table of contents of this document. Clicking on an item in this list will jump to the respective function or section in the file. Similarly, the Filter Methods bar lets you search for a specific function or section within the selected document with the same behavior as filtering scripts.

The text editor's menus lie below the scene switcher and allow you to access a variety of tools and options, such as file management, search and replace, debugging controls, and code formatting features.

An asterisk (*) next to an action means that this operation is also available in the context menu, which can be opened by right-clicking in the code editor.

The File menu provides the following options:

New Script...: Opens the new script dialog to create and add the script to the project. If creation is successful, it will directly open it in the text editor. Depending on the version of Godot (with C# support or not), you can choose .gd or .cs as the extension.

New Text File...: Opens the file dialog to create a plain text file with one of the recognized formats. Godot can also highlight json files.

Open...: Opens the file dialog to let you browse inside your computer and choose any recognized text file to open it.

Reopen Closed Script: Reopens the last closed scripts. You can use this option multiple times to reopen other closed scripts if you closed more than one.

Open Recent: Provides a list of last opened scripts. You can also clear the list using the provided option at the bottom of the list.

Save: Saves the currently selected script.

Save As...: Opens the file dialog to save the currently open script with a different name.

Save All: Saves all unsaved open scripts in the text editor. Scripts with unsaved changes will have an asterisk (*) next to their names in the script list.

Soft Reload Tool Script: If the selected script is a tool, reloads the script to execute it again.

Copy Script Path: Copies the currently selected script's relative path in the project using the res:// prefix.

Show in FileSystem: Finds and highlights the selected file in the FileSystem dock.

History Previous: Changes the active script to the one that was previously opened. This is useful when you have multiple scripts open and want to quickly navigate back to the last script you were editing. If you also changed the caret position more than 10 lines, you will first move it to its previous location in the same file.

History Next: After using History Previous to go back to an earlier script, this feature allows you to move forward through the script history, switching to scripts that were previously accessed. Similar to above, if you also changed the caret position more than 10 lines, you will first move it to its next location in the same file.

Theme: Provides options to import an existing theme, save, or reload it. Changing theme settings is performed via Editor Settings.

Close: Closes the active script.

Close All: Closes all open scripts and prompts to save if there are unsaved changes.

Close Other Tabs: Closes all open scripts except the selected one.

Close Docs: Closes the class reference documentation pages, leaving only the scripts.

Run: If the script extends EditorScript and intended to be executed without running the project, this option runs the script. See Running one-off scripts using EditorScript for more.

Toggle Scripts Panel: Shows or hides the script panel located on the left side of the text editor, allowing you to expand the available coding area. More on the Scripts Panel is explained above.

The Edit menu provides several options for line operations:

Undo*: Allows you to reverse the most recent action or series of actions, restoring document or code to its previous state before the changes were made.

Redo*: Allows you to reapply an action that was previously undone, effectively redoing the last action that was reversed by the Undo function.

Cut*: Cuts the selection to the clipboard.

Copy*: Copies the selection to the clipboard.

Paste*: Pastes the content of the clipboard if it contains text.

Select All*: Selects the all code in the text editor.

Duplicate Selection: Copies the selection and appends it next to the selection.

Duplicate Lines: Duplicates the current line and adds it as a new line below the current line.

Evaluate Selection*: Computes the values of the selected text if it contains only a mathematical expression, such as 83 * 3 or pow(2,3).

Toggle Word Wrap: Disables the horizontal scrollbar by wrapping the long lines to the next line. Note that this is just a visual change and no new linebreaks are added.

Line: Provides a set of line operations. Depending on the opened file, the options might also be directly in the Edit menu, instead of a submenu.

Move Up: Moves the current line or the selected line(s) one line up.

Move Down: Moves the current line or the selected line(s) one line down.

Indent*: Indents the text from the caret or the selected line(s), following the indentation setting.

Unindent*: Unindents the text from the caret or the selected line(s), following the indentation setting.

Delete Line: Deletes the current line or the selected line(s).

Toggle Comment*: Comments and uncomments the current line or the selected line(s). You can perform the same action by selecting line(s) and choosing the same action after right-clicking on the selected text.

Folding: Provides a set of folding options for the selected text. Depending on the opened file, the options might also be directly in the Edit menu, instead of a submenu.

Fold/Unfold Line*: If the code in the current line has a code block or code region beneath it, it hides this block by collapsing the lines. You can then unfold it using this option again, using the ">" arrow next to the line number in the coding area, or clicking on the ellipsis "..." icon at the end of the folded line.

Fold All Lines: Folds all code blocks or code regions in the open document.

Unfold All Lines: Unfolds all code blocks and code regions in the open document.

Create Code Region*: Wraps the selected text in a foldable code region to improve the readability of larger scripts. See Built-in types for more.

Completion Query: Suggests from built-in or user created symbols to auto-complete the partially written code. Up and Down arrows navigate up and down, pressing Enter or Tab accepts and adds the highlighted symbol to the code. Tab will also replace existing text to the right of the caret.

Trim Trailing Whitespaces: Removes extra spacing at the end of each line in the file.

Trim Final Newlines: Removes the extra new lines at the end of the file.

Indentation: Provides options for the indentation of the open file. Depending on the opened file, the options might also be directly in the Edit menu, instead of a submenu.

Convert Indent to Spaces: Converts all indentation in the file to spaces.

Convert Indent to Tabs: Converts all indentation in the file to tabs.

Auto Indent: Converts the indentation of the selected lines (or the entire file) following the indentation setting.

Convert Case: Changes the case of the selected text to Upper Case*, Lower Case*, or capitalizes each initial letter of the words.

Syntax Highlighter: Allows you to choose the syntax highlighter.

Plain Text: Disables highlighting.

Standard: Default highlighting for C# scripts.

JSON: Syntax highlighting for JSON files.

GDScript: Syntax highlighting for GDScript files.

The Search menu provides the following options:

Find...: Opens the quick-find bar under the status bar to search for text in the open file. You can navigate to the next match and previous match using the up and down arrows, respectively. Checking Match Case makes the search case-sensitive. Checking Whole Words means that the text must not have any letters or numbers next to it, only symbols and whitespace.

Find Next: Similar to the down arrow, shows the next occurrence.

Find Previous: Similar to the up arrow, shows the previous occurrence.

Replace...: Opens the find and replace bar under the status bar to find text and replace it in the open file. You can choose to replace them one at a time or all at once. Additionally, you can limit the replacement to the selected text by checking the Selection Only checkbox in the find and replace bar. You can also use Ctrl + D to additionally select the next instance of the currently selected text, allowing you to perform an in-line replacement on multiple occurrences.

Find in Files...: Opens a window to search for text within the files in the project folder. Selecting "Find..." starts with the chosen folder, and includes the file extensions checked in the filters. The results are shown in the bottom panel with the number of matches and total number of files found, in the Search Results tab. Clicking on a result opens the file and jumps to the respective line.

Replace in Files...: Opens a window to search and replace text with different text within the found files in the project folder. After clicking Replace..., you can select in which files to replace using the Search Results tab in the bottom panel by (un)checking them and using Replace All button.

Note that "Replace in Files" operation cannot be undone!

Both the Find in Files and Replace in Files windows share the Search... and Replace... buttons. The only difference in the latter window is an additional text field that automatically fills in the search results panel when the Replace... button is clicked. The replacement operation is only executed if you click the Replace All button in this bottom panel, allowing you to also edit the word to replace later within this panel.

Contextual Help*: Opens the list of built-in class reference similar to pressing F1 on a symbol, or choosing Lookup Symbol from the context menu.

The Go To menu lets you navigate within the code at ease with these options:

Go to Function...: Opens the function list to jump to. You can achieve the same result by typing in the filter methods bar in the script panel.

Go to Line...: Jumps to the entered line number in the code editor.

Bookmarks: Contains actions for the bookmark functionality, which you can use to find your way through your code easier, such as an incomplete section. Bookmarked lines will have a blue bookmark symbol left of the line number.

Toggle Bookmark*: Adds or removes the bookmark on the line where the caret is. You can also right click on a line to achieve this.

Remove All Bookmarks: Removes all bookmarks in the open document.

Go to Next Bookmark: Jumps to the next bookmark in the open document.

Go to Previous Bookmark: Jumps to the previous bookmark in the open document.

Bookmarks menu will also contain the list of bookmarked lines, including their line number and displaying the partial content in that line.

Breakpoints: Breakpoints are helpful while debugging your code. Similar to Bookmarks menu, this menu lets you add or remove breakpoints, navigate between them and directly jump to a specific breakpoint. An easy way to add a breakpoint is hovering over the blank area left of a line number. It will show a faded red circle. Clicking it will add a breakpoint and the circle will stay there. Clicking on a circle removes the breakpoint.

Debug menu offers actions which can be used while debugging. See Script editor debug tools and options for more.

This section will only cover the basics of the coding area in terms of the user interface. To learn more about scripting in Godot, refer to the GDScript or Scripting documentation.

The coding area is where you will type your scripts if you are using the built-in text editor. It offers highlighting and auto-completion features to help you while you code.

The coding area shows line numbers on the left side. Below the navigation arrows on the right side, there is a clickable minimap that provides an overview of the entire script, allowing you to scroll through it.

If a line of code is long enough (more than 80 characters, by default), the text editor will display a vertical line that can be used as a soft guideline. For a hard guideline, this value is set to 100 characters, by default. Both values can be changed, or the display of the line can be toggled in the "Appearance" settings of the text editor.

In the script, to the left of function definitions, you might see additional icons. The icon indicates that this function is an override of an existing function. Clicking it opens the documentation of the original function. The icon means that it is a receiving method of a signal. Clicking it shows where the signal is coming from. A icon to the left of the line denotes a foldable block. You can click to collapse or expand it. Alternatively, the ellipsis (...) icon can also be clicked to expand a folded block.

The example below summarizes the paragraph above. Lines 52, 56, and 58 are foldable blocks, line 57 is a code region with the name "New Code Region," which you can also fold, and line 62 is a folded block. Line 53 is a bookmark, which can quickly be jumped to using the Go To > Bookmarks menu. Line 55 is a breakpoint that can be used in debugging.

Many of the colors of the text editor such as highlighting colors, or even breakpoint or bookmark icon colors can be customized. You can experiment them by opening the text editor settings navigating to Editor > Editor Settings > Text Editor section.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Singletons (Autoload) — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/singletons_autoload.html

**Contents:**
- Singletons (Autoload)
- Introduction
- Autoload
- Custom scene switcher
  - Creating the script
- User-contributed notes

Godot's scene system, while powerful and flexible, has a drawback: there is no method for storing information (e.g. a player's score or inventory) that is needed by more than one scene.

It's possible to address this with some workarounds, but they come with their own limitations:

You can use a "master" scene that loads and unloads other scenes as its children. However, this means you can no longer run those scenes individually and expect them to work correctly.

Information can be stored to disk in user:// and then loaded by scenes that require it, but frequently saving and loading data is cumbersome and may be slow.

The Singleton pattern is a useful tool for solving the common use case where you need to store persistent information between scenes. In our case, it's possible to reuse the same scene or class for multiple singletons as long as they have different names.

Using this concept, you can create objects that:

Are always loaded, no matter which scene is currently running.

Can store global variables such as player information.

Can handle switching scenes and between-scene transitions.

Act like a singleton, since GDScript does not support global variables by design.

Autoloading nodes and scripts can give us these characteristics.

Godot won't make an Autoload a "true" singleton as per the singleton design pattern. It may still be instanced more than once by the user if desired.

If you're creating an autoload as part of an editor plugin, consider registering it automatically in the Project Settings when the plugin is enabled.

You can create an Autoload to load a scene or a script that inherits from Node.

When autoloading a script, a Node will be created and the script will be attached to it. This node will be added to the root viewport before any other scenes are loaded.

To autoload a scene or script, start from the menu and navigate to Project > Project Settings > Globals > Autoload.

Here you can add any number of scenes or scripts. Each entry in the list requires a name, which is assigned as the node's name property. The order of the entries as they are added to the global scene tree can be manipulated using the up/down arrow keys. Like regular scenes, the engine will read these nodes in top-to-bottom order.

If the Enable column is checked (which is the default), then the singleton can be accessed directly in GDScript:

The Enable column has no effect in C# code. However, if the singleton is a C# script, a similar effect can be achieved by including a static property called Instance and assigning it in _Ready():

This allows the singleton to be accessed from C# code without GetNode() and without a typecast:

Note that autoload objects (scripts and/or scenes) are accessed just like any other node in the scene tree. In fact, if you look at the running scene tree, you'll see the autoloaded nodes appear:

Autoloads must not be removed using free() or queue_free() at runtime, or the engine will crash.

This tutorial will demonstrate building a scene switcher using autoloads. For basic scene switching, you can use the SceneTree.change_scene_to_file() method (see Using SceneTree for details). However, if you need more complex behavior when changing scenes, this method provides more functionality.

To begin, download the template from here: singleton_autoload_starter.zip and open it in Godot.

A window notifying you that the project was last opened in an older Godot version may appear, that's not an issue. Click Ok to open the project.

The project contains two scenes: scene_1.tscn and scene_2.tscn. Each scene contains a label displaying the scene name and a button with its pressed() signal connected. When you run the project, it starts in scene_1.tscn. However, pressing the button does nothing.

Open the Script window and create a new script called global.gd. Make sure it inherits from Node:

The next step is to add this script to the autoLoad list. Starting from the menu, open Project > Project Settings > Globals > Autoload and select the script by clicking the browse button or typing its path: res://global.gd. Press Add to add it to the autoload list and name it "Global", which is required for scripts to access it by the name "Global":

Now whenever we run any scene in the project, this script will always be loaded.

Returning to the script, it needs to fetch the current scene in the _ready() function. Both the current scene (the one with the button) and global.gd are children of root, but autoloaded nodes are always first. This means that the last child of root is always the loaded scene.

Now we need a function for changing the scene. This function needs to free the current scene and replace it with the requested one.

Using Object.call_deferred(), the second function will only run once all code from the current scene has completed. Thus, the current scene will not be removed while it is still being used (i.e. its code is still running).

Finally, we need to fill the empty callback functions in the two scenes:

Run the project and test that you can switch between scenes by pressing the button.

When scenes are small, the transition is instantaneous. However, if your scenes are more complex, they may take a noticeable amount of time to appear. To learn how to handle this, see the next tutorial: Background loading.

Alternatively, if the loading time is relatively short (less than 3 seconds or so), you can display a "loading plaque" by showing some kind of 2D element just before changing the scene. You can then hide it just after the scene is changed. This can be used to indicate to the player that a scene is being loaded.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
PlayerVariables.health -= 10
```

Example 2 (csharp):
```csharp
public partial class PlayerVariables : Node
{
    public static PlayerVariables Instance { get; private set; }

    public int Health { get; set; }

    public override void _Ready()
    {
        Instance = this;
    }
}
```

Example 3 (unknown):
```unknown
PlayerVariables.Instance.Health -= 10;
```

Example 4 (gdscript):
```gdscript
extends Node

var current_scene = null

func _ready():
    var root = get_tree().root
    # Using a negative index counts from the end, so this gets the last child node of `root`.
    current_scene = root.get_child(-1)
```

---

## Static typing in GDScript — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/gdscript/static_typing.html

**Contents:**
- Static typing in GDScript
- A brief look at static typing
- How to use static typing
  - What can be a type hint
  - Specify the return type of a function with the arrow ->
  - Covariance and contravariance
  - Specify the element type of an Array
  - Specify the element type of a Dictionary
  - Type casting
    - Safe lines

In this guide, you will learn:

how to use static typing in GDScript;

that static types can help you avoid bugs;

that static typing improves your experience with the editor.

Where and how you use this language feature is entirely up to you: you can use it only in some sensitive GDScript files, use it everywhere, or don't use it at all.

Static types can be used on variables, constants, functions, parameters, and return types.

With static typing, GDScript can detect more errors without even running the code. Also type hints give you and your teammates more information as you're working, as the arguments' types show up when you call a method. Static typing improves editor autocompletion and documentation of your scripts.

Imagine you're programming an inventory system. You code an Item class, then an Inventory. To add items to the inventory, the people who work with your code should always pass an Item to the Inventory.add() method. With types, you can enforce this:

Static types also give you better code completion options. Below, you can see the difference between a dynamic and a static typed completion options.

You've probably encountered a lack of autocomplete suggestions after a dot:

This is due to dynamic code. Godot cannot know what value type you're passing to the function. If you write the type explicitly however, you will get all methods, properties, constants, etc. from the value:

If you prefer static typing, we recommend enabling the Text Editor > Completion > Add Type Hints editor setting. Also consider enabling some warnings that are disabled by default.

Also, typed GDScript improves performance by using optimized opcodes when operand/argument types are known at compile time. More GDScript optimizations are planned in the future, such as JIT/AOT compilation.

Overall, typed programming gives you a more structured experience. It helps prevent errors and improves the self-documenting aspect of your scripts. This is especially helpful when you're working in a team or on a long-term project: studies have shown that developers spend most of their time reading other people's code, or scripts they wrote in the past and forgot about. The clearer and the more structured the code, the faster it is to understand, the faster you can move forward.

To define the type of a variable, parameter, or constant, write a colon after the name, followed by its type. E.g. var health: int. This forces the variable's type to always stay the same:

Godot will try to infer types if you write a colon, but you omit the type:

There is no difference between = and := for constants.

You don't need to write type hints for constants, as Godot sets it automatically from the assigned value. But you can still do so to make the intent of your code clearer. Also, this is useful for typed arrays (like const A: Array[int] = [1, 2, 3]), since untyped arrays are used by default.

Here is a complete list of what can be used as a type hint:

Variant. Any type. In most cases this is not much different from an untyped declaration, but increases readability. As a return type, forces the function to explicitly return some value.

(Only return type) void. Indicates that the function does not return any value.

Native classes (Object, Node, Area2D, Camera2D, etc.).

Global, native and custom named enums. Note that an enum type is just an int, there is no guarantee that the value belongs to the set of enum values.

Constants (including local ones) if they contain a preloaded class or enum.

You can use any class, including your custom classes, as types. There are two ways to use them in scripts. The first method is to preload the script you want to use as a type in a constant:

The second method is to use the class_name keyword when you create. For the example above, your rifle.gd would look like this:

If you use class_name, Godot registers the Rifle type globally in the editor, and you can use it anywhere, without having to preload it into a constant:

To define the return type of a function, write a dash and a right angle bracket -> after its declaration, followed by the return type:

The type void means the function does not return anything. You can use any type, as with variables:

You can also use your own classes as return types:

When inheriting base class methods, you should follow the Liskov substitution principle.

Covariance: When you inherit a method, you can specify a return type that is more specific (subtype) than the parent method.

Contravariance: When you inherit a method, you can specify a parameter type that is less specific (supertype) than the parent method.

To define the type of an Array, enclose the type name in [].

An array's type applies to for loop variables, as well as some operators like [], [...] = (assignment), and +. Array methods (such as push_back) and other operators (such as ==) are still untyped. Built-in types, native and custom classes, and enums may be used as element types. Nested array types (like Array[Array[int]]) are not supported.

Since Godot 4.2, you can also specify a type for the loop variable in a for loop. For instance, you can write:

The array will remain untyped, but the name variable within the for loop will always be of String type.

To define the type of a Dictionary's keys and values, enclose the type name in [] and separate the key and value type with a comma.

A dictionary's value type applies to for loop variables, as well as some operators like [] and [...] = (assignment). Dictionary methods that return values and other operators (such as ==) are still untyped. Built-in types, native and custom classes, and enums may be used as element types. Nested typed collections (like Dictionary[String, Dictionary[String, int]]) are not supported.

Type casting is an important concept in typed languages. Casting is the conversion of a value from one type to another.

Imagine an Enemy in your game, that extends Area2D. You want it to collide with the Player, a CharacterBody2D with a script called PlayerController attached to it. You use the body_entered signal to detect the collision. With typed code, the body you detect is going to be a generic PhysicsBody2D, and not your PlayerController on the _on_body_entered callback.

You can check if this PhysicsBody2D is your Player with the as keyword, and using the colon : again to force the variable to use this type. This forces the variable to stick to the PlayerController type:

As we're dealing with a custom type, if the body doesn't extend PlayerController, the player variable will be set to null. We can use this to check if the body is the player or not. We will also get full autocompletion on the player variable thanks to that cast.

The as keyword silently casts the variable to null in case of a type mismatch at runtime, without an error/warning. While this may be convenient in some cases, it can also lead to bugs. Use the as keyword only if this behavior is intended. A safer alternative is to use the is keyword:

You can also simplify the code by using the is not operator:

Alternatively, you can use the assert() statement:

If you try to cast with a built-in type and it fails, Godot will throw an error.

You can also use casting to ensure safe lines. Safe lines are a tool to tell you when ambiguous lines of code are type-safe. As you can mix and match typed and dynamic code, at times, Godot doesn't have enough information to know if an instruction will trigger an error or not at runtime.

This happens when you get a child node. Let's take a timer for example: with dynamic code, you can get the node with $Timer. GDScript supports duck-typing, so even if your timer is of type Timer, it is also a Node and an Object, two classes it extends. With dynamic GDScript, you also don't care about the node's type as long as it has the methods you need to call.

You can use casting to tell Godot the type you expect when you get a node: ($Timer as Timer), ($Player as CharacterBody2D), etc. Godot will ensure the type works and if so, the line number will turn green at the left of the script editor.

Unsafe line (line 7) vs Safe Lines (line 6 and 8)

Safe lines do not always mean better or more reliable code. See the note above about the as keyword. For example:

Even though node_2 declaration is marked as an unsafe line, it is more reliable than node_1 declaration. Because if you change the node type in the scene and accidentally forget to change it in the script, the error will be detected immediately when the scene is loaded. Unlike node_1, which will be silently cast to null and the error will be detected later.

You can turn off safe lines or change their color in the editor settings.

Typed GDScript and dynamic GDScript can coexist in the same project. But it's recommended to stick to either style for consistency in your codebase, and for your peers. It's easier for everyone to work together if you follow the same guidelines, and faster to read and understand other people's code.

Typed code takes a little more writing, but you get the benefits we discussed above. Here's an example of the same, empty script, in a dynamic style:

And with static typing:

As you can see, you can also use types with the engine's virtual methods. Signal callbacks, like any methods, can also use types. Here's a body_entered signal in a dynamic style:

And the same callback, with type hints:

Detailed documentation about the GDScript warning system has been moved to GDScript warning system.

Godot gives you warnings about your code as you write it. The engine identifies sections of your code that may lead to issues at runtime, but lets you decide whether or not you want to leave the code as it is.

We have a number of warnings aimed specifically at users of typed GDScript. By default, these warnings are disabled, you can enable them in Project Settings (Debug > GDScript, make sure Advanced Settings is enabled).

You can enable the UNTYPED_DECLARATION warning if you want to always use static types. Additionally, you can enable the INFERRED_DECLARATION warning if you prefer a more readable and reliable, but more verbose syntax.

UNSAFE_* warnings make unsafe operations more noticeable, than unsafe lines. Currently, UNSAFE_* warnings do not cover all cases that unsafe lines cover.

The following global scope methods are not statically typed, but they have typed counterparts available. These methods return statically typed values:

Statically typed equivalents

When using static typing, use the typed global scope methods whenever possible. This ensures you have safe lines and benefit from typed instructions for better performance.

In this example, we aim to set a property and call a method on an object that has a script attached with class_name MyScript and that extends Node2D. If we have a reference to the object as a Node2D (for instance, as it was passed to us by the physics system), we can first check if the property and method exist and then set and call them if they do:

However, this code will produce UNSAFE_PROPERTY_ACCESS and UNSAFE_METHOD_ACCESS warnings as the property and method are not present in the referenced type - in this case a Node2D. To make these operations safe, you can first check if the object is of type MyScript using the is keyword and then declare a variable with the type MyScript on which you can set its properties and call its methods:

Alternatively, you can declare a variable and use the as operator to try to cast the object. You'll then want to check whether the cast was successful by confirming that the variable was assigned:

In this example, we would like the label connected to an object entering our collision area to show the area's name. Once the object enters the collision area, the physics system sends a signal with a Node2D object, and the most straightforward (but not statically typed) solution to do what we want could be achieved like this:

This piece of code produces an UNSAFE_PROPERTY_ACCESS warning because label is not defined in Node2D. To solve this, we could first check if the label property exist and cast it to type Label before settings its text property like so:

However, this produces an UNSAFE_CAST warning because body.label is of a Variant type. To safely get the property in the type you want, you can use the Object.get() method which returns the object as a Variant value or returns null if the property doesn't exist. You can then determine whether the property contains an object of the right type using the is keyword, and finally declare a statically typed variable with the object:

To wrap up this introduction, let's mention cases where you can't use type hints. This will trigger a syntax error.

You can't specify the type of individual elements in an array or a dictionary:

Nested types are not currently supported:

Typed GDScript is a powerful tool. It helps you write more structured code, avoid common errors, and create scalable and reliable systems. Static types improve GDScript performance and more optimizations are planned for the future.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
class_name Inventory


func add(reference: Item, amount: int = 1):
    var item := find_item(reference)
    if not item:
        item = _instance_item_from_db(reference)
    item.amount += amount
```

Example 2 (javascript):
```javascript
var damage: float = 10.5
const MOVE_SPEED: float = 50.0
func sum(a: float = 0.0, b: float = 0.0) -> float:
    return a + b
```

Example 3 (javascript):
```javascript
var damage := 10.5
const MOVE_SPEED := 50.0
func sum(a := 0.0, b := 0.0) -> float:
    return a + b
```

Example 4 (javascript):
```javascript
const Rifle = preload("res://player/weapons/rifle.gd")
var my_rifle: Rifle
```

---

## The .gdextension file — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/gdextension/gdextension_file.html

**Contents:**
- The .gdextension file
- Introduction
- Configuration section
- Libraries section
  - Running system
  - Build
  - Architecture
- Icons section
- Dependencies section
- User-contributed notes

The .gdextension file in your project contains the instructions for how to load the GDExtension. The instructions are separated into specific sections. This page should give you a quick overview of the different options available to you. For an introduction how to get started with C++ (godot-cpp), take a look at the GDExtension C++ Example.

Name of the entry function for initializing the GDExtension. This function should be defined in the register_types.cpp file when using godot-cpp. Adding this is necessary for the extension to work.

compatibility_minimum

Minimum compatible version. This prevents older versions of Godot from loading extensions that depend on features from newer versions of Godot. Only supported in Godot 4.1 or later

compatibility_maximum

Maximum compatible version. This prevents newer versions of Godot from loading the extension. Only supported in Godot 4.3 or later

Reloads the extension upon recompilation. Reloading is supported for the godot-cpp binding in Godot 4.2 or later. Other language bindings may or may not support it as well. This flag should be mainly used for developing or debugging an extension.

The GDExtension is part of a v2 Android plugin. During export this flag will indicate to the editor that the GDExtension native shared libraries are exported by the Android plugin AAR binaries.

In this section you can set the paths to the compiled binaries of your GDExtension libraries. By specifying feature flags you can filter which version should be loaded and exported with your game depending on which feature flags are active. Every feature flag must match to Godot's feature flags or your custom export flags to be loaded in an exported game. For instance macos.debug means that it will be loaded if Godot has both the macos and debug flag active. Each line of the section is evaluated from top to bottom.

Here is an example of what that can look like:

Entries are matched in order, so if two sets of feature tags could match the same system, be sure to put the more specific ones first:

Here are lists of some of the available built-in options (for more look at the feature tags):

Windows operating system

Linux operating system

Linux or BSD operating system

Android operating system

Build with debug symbols

Optimized build without debug symbols

double-precision build

single-precision build

RISC-V build (any bitness)

32-bit WebAssembly build

By default, Godot uses the Node icon in the scene dock for GDExtension nodes. A custom icon can be set by reference to its name and resource path of an SVG file.

The path should point to a 16 by 16 pixel SVG image. Read the guide for creating icons for more information.

In this section you set the paths of the GDExtension dependencies. This is used internally to export the dependencies when exporting your game executable. You are able to set which dependency is loaded depending on the feature flags of the exported executable. In addition, you are able to set an optional subdirectory to move your dependencies into. If no path is supplied Godot will move the libraries into the same directory as your game executable.

In MacOS it is necessary to have shared libraries inside a folder called Frameworks with a directory structure like this: Game.app/Contents/Frameworks.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
[libraries]

macos.debug = "res://bin/libgdexample.macos.template_debug.framework"
macos.release = "res://bin/libgdexample.macos.template_release.framework"
windows.debug.x86_32 = "res://bin/libgdexample.windows.template_debug.x86_32.dll"
windows.release.x86_32 = "res://bin/libgdexample.windows.template_release.x86_32.dll"
windows.debug.x86_64 = "res://bin/libgdexample.windows.template_debug.x86_64.dll"
windows.release.x86_64 = "res://bin/libgdexample.windows.template_release.x86_64.dll"
linux.debug.x86_64 = "res://bin/libgdexample.linux.template_debug.x86_64.so"
linux.release.x86_64 = "res://bin/libgdexample.linux.template_release.x86_64.so"
linux.debug.arm64 = "res://bin/libgdexample.linux.template_debug.arm64.so"
linux.release.arm64 = "res://bin/libgdexample.linux.template_release.arm64.so"
linux.debug.rv64 = "res://bin/libgdexample.linux.template_debug.rv64.so"
linux.release.rv64 = "res://bin/libgdexample.linux.template_release.rv64.so"
```

Example 2 (unknown):
```unknown
[libraries]

linux.release.editor.x86_64 = "res://bin/libgdexample.linux.template_release.x86_64.so"
linux.release.x86_64 = "res://bin/libgdexample.linux.noeditor.template_release.x86_64.so"
```

Example 3 (unknown):
```unknown
[icons]

GDExample = "res://icons/gd_example.svg"
```

Example 4 (unknown):
```unknown
[dependencies]

macos.debug = {
    "res://bin/libdependency.macos.template_debug.framework" : "Contents/Frameworks"
}
macos.release = {
    "res://bin/libdependency.macos.template_release.framework" : "Contents/Frameworks"
}
windows.debug = {
    "res://bin/libdependency.windows.template_debug.x86_64.dll" : "",
    "res://bin/libdependency.windows.template_debug.x86_32.dll" : ""
}
windows.release = {
    "res://bin/libdependency.windows.template_release.x86_64.dll" : "",
    "res://bin/libdependency.windows.template_release.x86_32.dll" : ""
}
linux.debug = {
    "res://bin/libdependency.linux.template_debug.x86_64.so" : "",
    "res://bin/libdependency.linux.template_debug.arm64.so" : "",
    "res://bin/libdependency.linux.template_debug.rv64.so" : ""
}
linux.release = {
    "res://bin/libdependency.linux.template_release.x86_64.so" : "",
    "res://bin/libdependency.linux.template_release.arm64.so" : "",
    "res://bin/libdependency.linux.template_release.rv64.so" : ""
}
```

---

## The GDExtension system — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/gdextension/index.html

**Contents:**
- The GDExtension system

GDExtension is a Godot-specific technology that lets the engine interact with native shared libraries at runtime. You can use it to run native code without compiling it with the engine.

GDExtension is not a scripting language and has no relation to GDScript.

This section describes how GDExtension works, and is generally aimed at people wanting to make a GDExtension from scratch, for example to create language bindings. If you want to use existing language bindings, please refer to other articles instead, such as the articles about C++ (godot-cpp) or one of the community-made ones.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## The Profiler — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/debug/the_profiler.html

**Contents:**
- The Profiler
- An overview of the profiler
- The measured data
- Scope of measurement and measurement windows
- Debugging slow code with the profiler
- Measuring manually in microseconds
- User-contributed notes

You run your game from Godot and play around. It's fun, it's becoming feature complete, and you feel it's getting close to release.

But then, you open the skill tree, and it grinds to a halt as something snags in your code. Watching the skill tree scroll by like it's a slide show is unacceptable. What went wrong? Is it positioning the skill tree elements, the UI, or rendering?

You could try to optimize everything and run the game repeatedly, but you can be smarter about this and narrow down the possibilities. Enter Godot's profiler.

You can open the profiler by opening the Debugger panel and clicking on the Profiler tab.

Godot's profiler does not automatically run because profiling is performance-intensive. It has to continually measure everything happening in the game and report back to the debugger, so it's off by default.

To begin profiling, run your game then focus back on the editor. Click on the Start button in the top-left corner of the Profiler tab. You can also check Autostart, which will make the profiler automatically start when the project is run the next time. Note that the Autostart checkbox's state is not preserved across editor sessions.

The profiler does not currently support C# scripts. C# scripts can be profiled using JetBrains Rider and JetBrains dotTrace with the Godot support plugin.

You can clear the data by clicking the Clear button anytime. Use the Measure drop-down menu to change the type of data you measure. The measurements panel and the graph will update accordingly.

The profiler's interface is split into two. There is a list of functions on the left and the performance graph on the right.

The main measurements are frame time, physics frame, idle time, and physics time.

The frame time is the time it takes Godot to execute all the logic for an entire image, from physics to rendering.

Physics frame is the time Godot has allocated between physics updates. In an ideal scenario, the frame time is whatever you chose: 16.66 milliseconds by default, which corresponds to 60FPS. It's a frame of reference you can use for everything else around it.

Idle time is the time Godot took to update logic other than physics, such as code that lives in _process or timers and cameras set to update on Idle.

Physics time is the time Godot took to update physics tasks, like _physics_process and built-in nodes set to Physics update.

Frame Time includes rendering time. Say you find a mysterious spike of lag in your game, but your physics and scripts are all running fast. The delay could be due to the appearance of particles or visual effects!

By default, Godot ticks on Frame Time and Physics Time. This gives you an overview of how long each frame takes relative to the allocated desired physics FPS. You can toggle functions on and off by clicking the checkboxes on the left. Other facilities make appearances as you go down the list, like Physics 2D, Physics, and Audio, before reaching Script functions, where your code appears.

If you click on the graph, you change which frame's information appears on the left. In the top right, there is also a frame counter where you can manually adjust the frame you are looking at more granularly.

You can change what measurement you are looking at using the Measure drop-down menu. By default, it starts with Frame Time and lists the time it takes to go through the frame in milliseconds. The average time is the average time any given function took when called more than once. For example, a function that took 0.05 milliseconds to run five times should give you an average of 0.01 milliseconds.

If accurate milliseconds count is not important, and you want to see proportions of time relative to the rest of the frame, use percentage measurements. Frame % is relative to Frame Time, and Physics % is relative to Physics Time.

The last option is the scope of the time. Inclusive measures the time a function took with any nested function calls. For example:

get_neighbors, find_nearest_neighbor and move_subject all took a lot of time. You could be fooled into thinking that this is because all three of them are slow.

But when changed to Self, Godot measures the time spent in the function body without considering function calls it made itself.

You can see that get_neighbors and move_subject have lost a lot of their importance. In effect, that means that get_neighbors and move_subject have spent more time waiting for some other function call to finish than not, and find_nearest_neighbor is actually slow.

Finding slow code with the profiler boils down to running your game and watching the performance graph as it draws. When an unacceptable spike occurs in the frame time, you can click on the graph to pause your game and narrow the _Frame #_ to the spike's start. You may need to jump back and forth between frames and functions to find the root cause.

Under the Script functions, turn on the checkboxes for some functions to find which take time. These are the functions you need to review and optimize.

If your function is complex, it could be challenging to figure out which part needs optimization. Is it your math or the way you access other pieces of data to do the math with? Is it the for loop? The if statements?

You can narrow down the measurement by manually counting ticks as the code runs with some temporary functions. The two functions are part of the Time class object. They are get_ticks_msec and get_ticks_usec. The first measures in milliseconds (1,000 per second), and the second measures in microseconds (1,000,000 per second).

Either one returns the amount of time since the game engine started in their respective time frame.

If you wrap a piece of code with a start and end count of microseconds, the difference between the two is the amount of time it took to run that piece of code.

As you become a more experienced programmer, this technique becomes less necessary. You begin to learn what parts of a running program are slow. Knowing that loops and branches can be slow comes from experience, and you gain experience by measuring and doing research.

But between the profiler and the ticks functions, you should have enough to get started finding which parts of your code need optimization.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
# Measuring the time it takes for worker_function() to run
var start = Time.get_ticks_usec()
worker_function()
var end = Time.get_ticks_usec()
var worker_time = (end-start)/1000000.0

# Measuring the time spent running a calculation over each element of an array
start = Time.get_ticks_usec()
for calc in calculations:
    result = pow(2, calc.power) * calc.product
end = Time.get_ticks_usec()
var loop_time = (end-start)/1000000.0

print("Worker time: %s\nLoop time: %s" % [worker_time, loop_time])
```

---

## Using SceneTree — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/scene_tree.html

**Contents:**
- Using SceneTree
- Introduction
- MainLoop
- SceneTree
- Root viewport
- Scene tree
- Tree order
- "Becoming active" by entering the Scene Tree
- Changing current scene
- User-contributed notes

In previous tutorials, everything revolved around the concept of nodes. Scenes are collections of nodes. They become active once they enter the scene tree.

The way Godot works internally is as follows. There is the OS class, which is the only instance that runs at the beginning. Afterwards, all drivers, servers, scripting languages, scene system, etc are loaded.

When initialization is complete, OS needs to be supplied a MainLoop to run. Up to this point, all this is internals working (you can check main/main.cpp file in the source code if you are ever interested to see how this works internally).

The user program, or game, starts in the MainLoop. This class has a few methods, for initialization, idle (frame-synchronized callback), fixed (physics-synchronized callback), and input. Again, this is low level and when making games in Godot, writing your own MainLoop seldom makes sense.

One of the ways to explain how Godot works is that it's a high-level game engine over a low-level middleware.

The scene system is the game engine, while the OS and servers are the low-level API.

The scene system provides its own main loop to OS, SceneTree. This is automatically instanced and set when running a scene, no need to do any extra work.

It's important to know that this class exists because it has a few important uses:

It contains the root Viewport, to which a scene is added as a child when it's first opened to become part of the Scene Tree (more on that next).

It contains information about the groups and has the means to call all nodes in a group or get a list of them.

It contains some global state functionality, such as setting pause mode or quitting the process.

When a node is part of the Scene Tree, the SceneTree singleton can be obtained by calling Node.get_tree().

The root Viewport is always at the top of the scene. From a node, it can be obtained in two different ways:

This node contains the main viewport. Anything that is a child of a Viewport is drawn inside of it by default, so it makes sense that the top of all nodes is always a node of this type otherwise nothing would be seen.

While other viewports can be created in the scene (for split-screen effects and such), this one is the only one that is never created by the user. It's created automatically inside SceneTree.

When a node is connected, directly or indirectly, to the root viewport, it becomes part of the scene tree.

This means that as explained in previous tutorials, it will get the _enter_tree() and _ready() callbacks (as well as _exit_tree()).

When nodes enter the Scene Tree, they become active. They get access to everything they need to process, get input, display 2D and 3D visuals, receive and send notifications, play sounds, etc. When they are removed from the scene tree, they lose these abilities.

Most node operations in Godot, such as drawing 2D, processing, or getting notifications are done in tree order, or top to bottom as seen in the editor (also known as pre-order traversal):

For example, the top node in a scene has its _process() function called first, then the node below it has its _process() function called, then the node below that and so on.

An important exception is the _ready() function: each parent node has its _ready() function called only after all its child nodes have their _ready() functions called, so that the parent knows its children are completely ready to be accessed. This is also known as post-order traversal. In the above image, NameLabel would be notified first (but only after its children, if it had any!), followed by Name, etc., and Panel would be notified last.

The order of operations can also be overridden using the process_priority node property. Nodes with a lower number are called first. For example, nodes with the priorities "0, 1, 2, 3" would be called in that order from left to right.

A scene is loaded from disk or created by scripting.

The root node of that scene (only one root, remember?) is added as either a child of the "root" Viewport (from SceneTree), or to any of its descendants.

Every node of the newly added scene will receive the "enter_tree" notification ( _enter_tree() callback in GDScript) in top-to-bottom order (pre-order traversal).

Every node will receive the "ready" notification ( _ready() callback in GDScript) for convenience, once all its children have received the "ready" notification (post-order traversal).

When a scene (or part of it) is removed, they receive the "exit scene" notification ( _exit_tree() callback in GDScript) in bottom-to-top order (the exact reverse of top-to-bottom order).

After a scene is loaded, you may want to change this scene for another one. One way to do this is to use the SceneTree.change_scene_to_file() function:

Rather than using file paths, one can also use ready-made PackedScene resources using the equivalent function SceneTree.change_scene_to_packed(PackedScene scene):

These are quick and useful ways to switch scenes but have the drawback that the game will stall until the new scene is loaded and running. At some point in the development of your game, it may be preferable to create proper loading screens with progress bar, animated indicators or threaded (background) loading. This must be done manually using Singletons (Autoload) and Background loading.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
get_tree().root # Access via scene main loop.
get_node("/root") # Access via absolute path.
```

Example 2 (unknown):
```unknown
GetTree().Root // Access via scene main loop.
GetNode("/root"); // Access via absolute path.
```

Example 3 (unknown):
```unknown
func _my_level_was_completed():
    get_tree().change_scene_to_file("res://levels/level2.tscn")
```

Example 4 (unknown):
```unknown
public void _MyLevelWasCompleted()
{
    GetTree().ChangeSceneToFile("res://levels/level2.tscn");
}
```

---

## What is GDExtension? — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/scripting/gdextension/what_is_gdextension.html

**Contents:**
- What is GDExtension?
- Version compatibility
- User-contributed notes

GDExtension is a Godot-specific technology that lets the engine interact with native shared libraries at runtime. You can use it to run native code without compiling it with the engine.

There are three primary methods with which this is achieved:

gdextension_interface.h: A set of C functions that Godot and a GDExtension can use to communicate.

extension_api.json: A list of C functions that are exposed from Godot APIs (Core Features).

*.gdextension: A file format read by Godot to load a GDExtension.

Most people create GDExtensions with some existing language binding, such as godot-cpp (for C++), or one of the community-made ones.

See godot-cpp Version Compatibility, which applies to all GDExtensions.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---
