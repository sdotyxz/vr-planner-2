# Godot_Docs - Other

**Pages:** 205

---

## About the Asset Library — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/community/asset_library/what_is_assetlib.html

**Contents:**
- About the Asset Library
- Types of assets
- Frequently asked questions
  - Can paid assets be uploaded to the asset library?
- User-contributed notes

The Godot Asset Library, otherwise known as the AssetLib, is a repository of user-submitted Godot addons, scripts, tools, and other resources, collectively referred to as assets. They're available to all Godot users for download directly from within the engine, but it can also be accessed at Godot's official website.

On the surface, the Asset Library might look and function similar to asset stores available for other engines, such as Unity's Asset Store, or Unreal Engine's Marketplace, where you can submit both freely-available assets, as well as paid, commercial ones. In addition, often times such assets are distributed under non-free, proprietary licenses, limiting what you can do with them.

The Asset Library is different - all assets are distributed free of charge, and under a host of open source licenses (such as the MIT license, the GPL, and the Boost Software License). This makes the AssetLib more similar to the software repositories of a Linux distribution.

This set of pages will cover how to use the AssetLib (both from inside Godot, and on the website), how you can submit your own assets, and what the guidelines for submission are.

Please note that the AssetLib is relatively young - it may have various pain points, bugs, and usability issues. As with all Godot projects, the code repository is available on GitHub, where you can submit pull requests and issues, so please do not hesitate to visit it!

Be aware that there are, broadly, two different types of assets you can post.

Assets labeled as "Templates", "Projects", or "Demos" appear under the "Asset Library" tab in the Godot Project Manager. These assets are standalone Godot projects that can run by themselves.

Other assets show up inside of the Godot editor under the "Asset Library" main screen tab, next to "2D", "3D", and "Script". These assets are meant to be downloaded and placed into an existing Godot project.

Not to the official one, though in the future, there might be other asset libraries which allow it. That said, you are allowed to monetize and sell Godot assets outside the Asset Library.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Advanced vector math — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/math/vectors_advanced.html

**Contents:**
- Advanced vector math
- Planes
  - Distance to plane
  - Away from the origin
  - Constructing a plane in 2D
  - Some examples of planes
- Collision detection in 3D
- More information
- User-contributed notes

The dot product has another interesting property with unit vectors. Imagine that perpendicular to that vector (and through the origin) passes a plane. Planes divide the entire space into positive (over the plane) and negative (under the plane), and (contrary to popular belief) you can also use their math in 2D:

Unit vectors that are perpendicular to a surface (so, they describe the orientation of the surface) are called unit normal vectors. Though, usually they are just abbreviated as normals. Normals appear in planes, 3D geometry (to determine where each face or vertex is siding), etc. A normal is a unit vector, but it's called normal because of its usage. (Just like we call (0,0) the Origin!).

The plane passes by the origin and the surface of it is perpendicular to the unit vector (or normal). The side the vector points to is the positive half-space, while the other side is the negative half-space. In 3D this is exactly the same, except that the plane is an infinite surface (imagine an infinite, flat sheet of paper that you can orient and is pinned to the origin) instead of a line.

Now that it's clear what a plane is, let's go back to the dot product. The dot product between a unit vector and any point in space (yes, this time we do dot product between vector and position), returns the distance from the point to the plane:

But not just the absolute distance, if the point is in the negative half space the distance will be negative, too:

This allows us to tell which side of the plane a point is.

I know what you are thinking! So far this is nice, but real planes are everywhere in space, not only passing through the origin. You want real plane action and you want it now.

Remember that planes not only split space in two, but they also have polarity. This means that it is possible to have perfectly overlapping planes, but their negative and positive half-spaces are swapped.

With this in mind, let's describe a full plane as a normal N and a distance from the origin scalar D. Thus, our plane is represented by N and D. For example:

For 3D math, Godot provides a Plane built-in type that handles this.

Basically, N and D can represent any plane in space, be it for 2D or 3D (depending on the amount of dimensions of N) and the math is the same for both. It's the same as before, but D is the distance from the origin to the plane, travelling in N direction. As an example, imagine you want to reach a point in the plane, you will just do:

This will stretch (resize) the normal vector and make it touch the plane. This math might seem confusing, but it's actually much simpler than it seems. If we want to tell, again, the distance from the point to the plane, we do the same but adjusting for distance:

The same thing, using a built-in function:

This will, again, return either a positive or negative distance.

Flipping the polarity of the plane can be done by negating both N and D. This will result in a plane in the same position, but with inverted negative and positive half spaces:

Godot also implements this operator in Plane. So, using the format below will work as expected:

So, remember, the plane's main practical use is that we can calculate the distance to it. So, when is it useful to calculate the distance from a point to a plane? Let's see some examples.

Planes clearly don't come out of nowhere, so they must be built. Constructing them in 2D is easy, this can be done from either a normal (unit vector) and a point, or from two points in space.

In the case of a normal and a point, most of the work is done, as the normal is already computed, so calculate D from the dot product of the normal and the point.

For two points in space, there are actually two planes that pass through them, sharing the same space but with normal pointing to the opposite directions. To compute the normal from the two points, the direction vector must be obtained first, and then it needs to be rotated 90 degrees to either side:

The rest is the same as the previous example. Either point_a or point_b will work, as they are in the same plane:

Doing the same in 3D is a little more complex and is explained further down.

Here is an example of what planes are useful for. Imagine you have a convex polygon. For example, a rectangle, a trapezoid, a triangle, or just any polygon where no faces bend inwards.

For every segment of the polygon, we compute the plane that passes by that segment. Once we have the list of planes, we can do neat things, for example checking if a point is inside the polygon.

We go through all planes, if we can find a plane where the distance to the point is positive, then the point is outside the polygon. If we can't, then the point is inside.

Code should be something like this:

Pretty cool, huh? But this gets much better! With a little more effort, similar logic will let us know when two convex polygons are overlapping too. This is called the Separating Axis Theorem (or SAT) and most physics engines use this to detect collision.

With a point, just checking if a plane returns a positive distance is enough to tell if the point is outside. With another polygon, we must find a plane where all the other polygon points return a positive distance to it. This check is performed with the planes of A against the points of B, and then with the planes of B against the points of A:

Code should be something like this:

As you can see, planes are quite useful, and this is the tip of the iceberg. You might be wondering what happens with non convex polygons. This is usually just handled by splitting the concave polygon into smaller convex polygons, or using a technique such as BSP (which is not used much nowadays).

This is another bonus bit, a reward for being patient and keeping up with this long tutorial. Here is another piece of wisdom. This might not be something with a direct use case (Godot already does collision detection pretty well) but it's used by almost all physics engines and collision detection libraries :)

Remember that converting a convex shape in 2D to an array of 2D planes was useful for collision detection? You could detect if a point was inside any convex shape, or if two 2D convex shapes were overlapping.

Well, this works in 3D too, if two 3D polyhedral shapes are colliding, you won't be able to find a separating plane. If a separating plane is found, then the shapes are definitely not colliding.

To refresh a bit a separating plane means that all vertices of polygon A are in one side of the plane, and all vertices of polygon B are in the other side. This plane is always one of the face-planes of either polygon A or polygon B.

In 3D though, there is a problem to this approach, because it is possible that, in some cases a separating plane can't be found. This is an example of such situation:

To avoid it, some extra planes need to be tested as separators, these planes are the cross product between the edges of polygon A and the edges of polygon B

So the final algorithm is something like:

For more information on using vector math in Godot, see the following article:

Matrices and transforms

If you would like additional explanation, you should check out 3Blue1Brown's excellent video series Essence of Linear Algebra.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
var distance = normal.dot(point)
```

Example 2 (unknown):
```unknown
var distance = normal.Dot(point);
```

Example 3 (unknown):
```unknown
var point_in_plane = N*D
```

Example 4 (unknown):
```unknown
var pointInPlane = N * D;
```

---

## Android — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/platform/android/index.html

**Contents:**
- Android

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Android in-app purchases — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/platform/android/android_in_app_purchases.html

**Contents:**
- Android in-app purchases
- Usage
  - Getting started
  - Initialize the plugin
  - Query available items
  - Query user purchases
  - Purchase an item
  - Processing a purchase item
  - Check purchase state
  - Consumables

Godot offers a first-party GodotGooglePlayBilling Android plugin compatible with Godot 4.2+ which uses the Google Play Billing library.

Make sure you have enabled and successfully set up Android Gradle Builds. Follow the installation instructions on the GodotGooglePlayBilling github page.

To use the GodotGooglePlayBilling API:

Access the BillingClient.

Connect to its signals to receive billing results.

Call start_connection.

Initialization example:

The API must be in a connected state prior to use. The connected signal is sent when the connection process succeeds. You can also use is_ready() to determine if the plugin is ready for use. The get_connection_state() function returns the current connection state of the plugin.

Return values for get_connection_state():

Once the API has connected, query product IDs using query_product_details(). You must successfully complete a product details query before calling the purchase(), purchase_subscription(), or update_subscription() functions, or they will return an error. query_product_details() takes two parameters: an array of product ID strings and the type of product being queried. The product type should be BillingClient.ProductType.INAPP for normal in-app purchases or BillingClient.ProductType.SUBS for subscriptions. The ID strings in the array should match the product IDs defined in the Google Play Console entry for your app.

Example use of query_product_details():

To retrieve a user's purchases, call the query_purchases() function passing a product type to query. The product type should be BillingClient.ProductType.INAPP for normal in-app purchases or BillingClient.ProductType.SUBS for subscriptions. The query_purchases_response signal is sent with the result. The signal has a single parameter: a Dictionary with a response code and either an array of purchases or a debug message. Only active subscriptions and non-consumed one-time purchases are included in the purchase array.

Example use of query_purchases():

To launch the billing flow for an item: Use purchase() for in-app products, passing the product ID string. Use purchase_subscription() for subscriptions, passing the product ID and base plan ID. You may also optionally provide an offer ID.

For both purchase() and purchase_subscription(), you can optionally pass a boolean to indicate whether offers are personallised

Reminder: you must query the product details for an item before you can pass it to purchase(). This method returns a dictionary indicating whether the billing flow was successfully launched. It includes a response code and either an array of purchases or a debug message.

Example use of purchase():

The result of the purchase will be sent through the on_purchases_updated signal.

The query_purchases_response and on_purchases_updated signals provide an array of purchases in Dictionary format. The purchase Dictionary includes keys that map to values of the Google Play Billing Purchase class.

Check the purchase_state value of a purchase to determine if a purchase was completed or is still pending.

PurchaseState values:

If a purchase is in a PENDING state, you should not award the contents of the purchase or do any further processing of the purchase until it reaches the PURCHASED state. If you have a store interface, you may wish to display information about pending purchases needing to be completed in the Google Play Store. For more details on pending purchases, see Handling pending transactions in the Google Play Billing Library documentation.

If your in-app item is not a one-time purchase but a consumable item (e.g. coins) which can be purchased multiple times, you can consume an item by calling consume_purchase() passing the purchase_token value from the purchase dictionary. Calling consume_purchase() automatically acknowledges a purchase. Consuming a product allows the user to purchase it again, it will no longer appear in subsequent query_purchases() calls unless it is repurchased.

Example use of consume_purchase():

If your in-app item is a one-time purchase, you must acknowledge the purchase by calling the acknowledge_purchase() function, passing the purchase_token value from the purchase dictionary. If you do not acknowledge a purchase within three days, the user automatically receives a refund, and Google Play revokes the purchase. If you are calling comsume_purchase() it automatically acknowledges the purchase and you do not need to call acknowledge_purchase().

Example use of acknowledge_purchase():

Subscriptions work mostly like regular in-app items. Use BillingClient.ProductType.SUBS as the second argument to query_product_details() to get subscription details. Pass BillingClient.ProductType.SUBS to query_purchases() to get subscription purchase details.

You can check is_auto_renewing in the a subscription purchase returned from query_purchases() to see if a user has cancelled an auto-renewing subscription.

You need to acknowledge new subscription purchases, but not automatic subscription renewals.

If you support upgrading or downgrading between different subscription levels, you should use update_subscription() to use the subscription update flow to change an active subscription. Like purchase(), results are returned by the on_purchases_updated signal. These are the parameters of update_subscription():

old_purchase_token: The purchase token of the currently active subscription

replacement_mode: The replacement mode to apply to the subscription

product_id: The product ID of the new subscription to switch to

base_plan_id: The base plan ID of the target subscription

offer_id: The offer ID under the base plan (optional)

is_offer_personalized: Whether to enable personalized pricing (optional)

The replacement modes values are defined as:

Default behavior is WITH_TIME_PRORATION.

Example use of update_subscription:

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
var billing_client: BillingClient
func _ready():
    billing_client = BillingClient.new()
    billing_client.connected.connect(_on_connected) # No params
    billing_client.disconnected.connect(_on_disconnected) # No params
    billing_client.connect_error.connect(_on_connect_error) # response_code: int, debug_message: String
    billing_client.query_product_details_response.connect(_on_query_product_details_response) # response: Dictionary
    billing_client.query_purchases_response.connect(_on_query_purchases_response) # response: Dictionary
    billing_client.on_purchase_updated.connect(_on_purchase_updated) # response: Dictionary
    billing_client.consume_purchase_response.connect(_on_consume_purchase_response) # response: Dictionary
    billing_client.acknowledge_purchase_response.connect(_on_acknowledge_purchase_response) # response: Dictionary

    billing_client.start_connection()
```

Example 2 (unknown):
```unknown
# Matches BillingClient.ConnectionState in the Play Billing Library.
# Access in your script as: BillingClient.ConnectionState.CONNECTED
enum ConnectionState {
    DISCONNECTED, # This client was not yet connected to billing service or was already closed.
    CONNECTING, # This client is currently in process of connecting to billing service.
    CONNECTED, # This client is currently connected to billing service.
    CLOSED, # This client was already closed and shouldn't be used again.
}
```

Example 3 (unknown):
```unknown
func _on_connected():
  billing_client.query_product_details(["my_iap_item"], BillingClient.ProductType.INAPP) # BillingClient.ProductType.SUBS for subscriptions.

func _on_query_product_details_response(query_result: Dictionary):
    if query_result.response_code == BillingClient.BillingResponseCode.OK:
        print("Product details query success")
        for available_product in query_result.product_details:
            print(available_product)
    else:
        print("Product details query failed")
        print("response_code: ", query_result.response_code, "debug_message: ", query_result.debug_message)
```

Example 4 (unknown):
```unknown
func _query_purchases():
    billing_client.query_purchases(BillingClient.ProductType.INAPP) # Or BillingClient.ProductType.SUBS for subscriptions.

func _on_query_purchases_response(query_result: Dictionary):
    if query_result.response_code == BillingClient.BillingResponseCode.OK:
        print("Purchase query success")
        for purchase in query_result.purchases:
            _process_purchase(purchase)
    else:
        print("Purchase query failed")
        print("response_code: ", query_result.response_code, "debug_message: ", query_result.debug_message)
```

---

## Android Studio — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/configuring_an_ide/android_studio.html

**Contents:**
- Android Studio
- Importing the project
- Android Studio project layout
- Building & debugging the editor module
- Building & debugging the app module
- User-contributed notes

Android Studio is a free IDE for Android development made by Google and JetBrains. It's based on IntelliJ IDEA and has a feature-rich editor which supports Java and C/C++. It can be used to work on Godot's core engine as well as the Android platform codebase.

From the Android Studio's welcome window select Open.

Android Studio's welcome window.

Navigate to <Godot root directory>/platform/android/java and select the settings.gradle file.

Android Studio will import and index the project.

The project is organized using Android Studio's modules:

the Godot java and native code and make it available as a reusable dependency / artifact.

The artifact generated by this module is made available for other Android modules / projects to use as a dependency, via MavenCentral.

the source code for the Android port of the Godot Editor.

This module has a dependency on the lib module.

the source code for the Android build templates.

This module has a dependency on the lib module.

Select the Run/Debug Configurations drop down and select editor.

Select Run > Run 'editor' from the top menu or click the Run icon.

Open the Build Variants window using View > Tools Windows > Build Variants from the top menu.

In the Build Variants window, make sure that in the Active Build Variant column, the :editor entry is set to one of the Dev variants.

Open the Run/Debug Configurations window by clicking on Run > Edit Configurations... on the top menu.

In the Run/Debug Configurations window, select the editor entry, and under Debugger make sure the Debug Type is set to Dual (Java + Native)

Click the + sign under the Symbol Directories section, and add the lib module directory: platform/android/java/lib

Select Run > Debug 'editor' from the top menu or click the Debug icon.

The app module requires the presence of a Godot project in its assets directory (<Godot root directory>/platform/android/java/app/assets) to run. This is usually handled by the Godot Editor during the export process. While developing in Android Studio, it's necessary to manually add a Godot project under that directory to replicate the export process. Once that's done, you can follow the instructions below to run/debug the app module:

Select the Run/Debug Configurations drop down and select app.

Select Run > Run 'app' from the top menu or click the Run icon.

Open the Build Variants window using View > Tools Windows > Build Variants from the top menu.

In the Build Variants window, make sure that in the Active Build Variant column, the :app entry is set to one of the Dev variants.

Open the Run/Debug Configurations window by clicking on Run > Edit Configurations... on the top menu.

In the Run/Debug Configurations window, select the app entry, and under Debugger make sure the Debug Type is set to Dual (Java + Native)

Click the + sign under the Symbol Directories section, and add the lib module directory: platform/android/java/lib

Select Run > Debug 'app' from the top menu or click the Debug icon.

If you run into any issues, ask for help in Godot's Android dev channel.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## AR / Passthrough — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/xr/ar_passthrough.html

**Contents:**
- AR / Passthrough
- Environment blend modes
- Configuring your background
- OpenXR specific
- Putting it together
- Shadow to opacity
- User-contributed notes

Augmented Reality is supported through various methods depending on the capabilities of the hardware.

Headsets such as the Magic Leap and glasses such as TiltFive show the rendered result on see-through displays allowing the user to see the real world.

Headsets such as the Quest, HTC Elite, and Lynx R1 implement this through a technique called video passthrough, where cameras record the real world and these images are used as the background on top of which our rendered result is used.

Passthrough is implemented very differently across platforms.

In Godot 4.3 we have implemented a unified approach that is explained on this help page so you don't need to worry about these differences, the XRInterface implementation is now responsible for applying the correct platform-dependent method [1].

For headsets such as the Meta Quest and HTC Elite you will need to use the OpenXR vendors plugin v3.0.0 or later to enable video passthrough.

For backwards compatibility the old API for passthrough is still available but it is recommended to follow the new instructions below.

The way we configure VR or AR functionality is through setting the environment blend mode. This mode determines how the (real world) environment is blended with the virtual world.

XR_ENV_BLEND_MODE_OPAQUE

The rendered image is opaque, we do not see the real world. We're in VR mode. This will turn off passthrough if video-passthrough is used.

XR_ENV_BLEND_MODE_ADDITIVE

The rendered image is added to the real world and will look semi transparent. This mode is generally used with see-through devices that are unable to obscure the real world. This will turn on passthrough if video-passthrough is used.

XR_ENV_BLEND_MODE_ALPHA_BLEND

The rendered image is alpha blended with the real world. On see-through devices that support this, the alpha will control the translucency of the optics. On video-passthrough devices alpha blending is applied with the video image. passthrough will also be enabled if applicable.

You can set the environment blend mode for your application through the environment_blend_mode property of the XRInterface instance.

You can query the supported blend modes on the hardware using the get_supported_environment_blend_modes property on the same instance.

When setting the blend mode to XR_ENV_BLEND_MODE_ALPHA_BLEND you must set the transparent_bg property on Viewport to true. When using the XR_ENV_BLEND_MODE_ADDITIVE blend mode you should set your background color to black.

Either solution will result in the background rendering not contributing to lighting. It is thus also recommended you adjust your environment settings accordingly and ensure there is adequate ambient light set to illuminate your scene.

Some AR SDKs do provide ambient lighting information or even provide a full radiance map to allow for real world reflections in your virtual objects. The core Godot XR functionality doesn't currently have support for this, however this functionality can be exposed through plugins.

In OpenXR you can configure the default blend mode you want to use. Godot will select this blend mode at startup if available. If not available Godot will default to the first supported blend mode provided by the XR runtime.

For passthrough devices OpenXR requires additional settings to be configured. These settings are platform-dependent and provided through the OpenXR vendors plugin.

For example, these are the settings required on Meta Quest:

The Passthrough setting defines whether passthrough is supported or even required.

The Boundary Mode allows you to define whether the guardian is needed, disabling this fully requires passthrough to be enabled at all times.

Putting the above together we can use the following code as a base:

Shadow to opacity is a render mode for Godot spatial shaders that was introduced in Godot 3 specifically for AR. It is a special render mode where the more a surface is in shadow, the more opaque the surface becomes. When a surface is fully lit, the surface becomes fully transparent and thus shows the real world.

However the surface is rendered during the opaque state effectively. This has two consequences:

As both the depth buffer and color buffer are written to, we occlude any geometry behind our surface even when fully transparent.

As we are making the surface opaque if in shadow, we can have virtual objects cast shadows on real world objects [2].

Image showing shadow to opacity being used to show the user's desk.

This enabled the following use cases:

You can render a box mesh around a real world table, this ensures the table remains visible even if a virtual object is placed underneath it. The virtual object will be correctly occluded. Placing a virtual object on top of the real world table, will result in a shadow being cast on the table.

You can use a shader with this render mode when render a hand mesh using the hand tracking functionality, and ensure your hands properly occlude virtual objects.

The following shader code is a good base for this functionality:

Restrictions may apply depending on XR interface implementation.

This feature is still being perfected.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
@onready var viewport : Viewport = get_viewport()
@onready var environment : Environment = $WorldEnvironment.environment

func switch_to_ar() -> bool:
    var xr_interface: XRInterface = XRServer.primary_interface
    if xr_interface:
        var modes = xr_interface.get_supported_environment_blend_modes()
        if XRInterface.XR_ENV_BLEND_MODE_ALPHA_BLEND in modes:
            xr_interface.environment_blend_mode = XRInterface.XR_ENV_BLEND_MODE_ALPHA_BLEND
            viewport.transparent_bg = true
        elif XRInterface.XR_ENV_BLEND_MODE_ADDITIVE in modes:
            xr_interface.environment_blend_mode = XRInterface.XR_ENV_BLEND_MODE_ADDITIVE
            viewport.transparent_bg = false
    else:
        return false

    environment.background_mode = Environment.BG_COLOR
    environment.background_color = Color(0.0, 0.0, 0.0, 0.0)
    environment.ambient_light_source = Environment.AMBIENT_SOURCE_COLOR
    return true

func switch_to_vr() -> bool:
    var xr_interface: XRInterface = XRServer.primary_interface
    if xr_interface:
        var modes = xr_interface.get_supported_environment_blend_modes()
        if XRInterface.XR_ENV_BLEND_MODE_OPAQUE in modes:
            xr_interface.environment_blend_mode = XRInterface.XR_ENV_BLEND_MODE_OPAQUE
        else:
            return false

    viewport.transparent_bg = false
    environment.background_mode = Environment.BG_SKY
    environment.ambient_light_source = Environment.AMBIENT_SOURCE_BG
    return true
```

Example 2 (unknown):
```unknown
shader_type spatial;
render_mode blend_mix, depth_draw_opaque, cull_back, shadow_to_opacity;

void fragment() {
    ALBEDO = vec3(0.0, 0.0, 0.0);
}
```

---

## Assets pipeline — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/assets_pipeline/index.html

**Contents:**
- Assets pipeline

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Asset Library — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/community/asset_library/index.html

**Contents:**
- Asset Library

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Audio buses — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/audio/audio_buses.html

**Contents:**
- Audio buses
- Introduction
- Decibel scale
- Audio buses
- Playback of audio through a bus
- Adding effects
- Automatic bus disabling
- Bus rearrangement
- Default bus layout
- User-contributed notes

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

Godot's audio processing code has been written with games in mind, with the aim of achieving an optimal balance between performance and sound quality.

Godot's audio engine allows any number of audio buses to be created and any number of effect processors can be added to each bus. Only the hardware of the device running your game will limit the number of buses and effects that can be used before performance starts to suffer.

Godot's sound interface is designed to meet the expectations of sound design professionals. To this end, it primarily uses the decibel scale.

For those unfamiliar with it, it can be explained with a few facts:

The decibel (dB) scale is a relative scale. It represents the ratio of sound power by using 20 times the base 10 logarithm of the ratio (20 × log10(P/P0)).

For every 6 dB, sound amplitude doubles or halves. 12 dB represents a factor of 4, 18 dB a factor of 8, 20 dB a factor of 10, 40 dB a factor of 100, etc.

Since the scale is logarithmic, true zero (no audio) can't be represented.

0 dB is the maximum amplitude possible in a digital audio system. This limit is not the human limit, but a limit from the sound hardware. Audio with amplitudes that are too high to be represented properly below 0 dB create a kind of distortion called clipping.

To avoid clipping, your sound mix should be arranged so that the output of the master bus (more on that later) never exceeds 0 dB.

Every 6 dB below the 0 dB limit, sound energy is halved. It means the sound volume at -6 dB is half as loud as 0dB. -12 dB is half as loud as -6 dB and so on.

When working with decibels, sound is considered no longer audible between -60 dB and -80 dB. This makes your working range generally between -60 dB and 0 dB.

This can take a bit getting used to, but it's friendlier in the end and will allow you to communicate better with audio professionals.

Audio buses can be found in the bottom panel of the Godot editor:

An audio bus (also called an audio channel) can be considered a place that audio is channeled through on the way to playback through a device's speakers. Audio data can be modified and re-routed by an audio bus. An audio bus has a VU meter (the bars that light up when sound is played) which indicates the amplitude of the signal passing through.

The leftmost bus is the master bus. This bus outputs the mix to your speakers so, as mentioned in the Decibel scale section above, make sure that your mix level doesn't reach 0 dB in this bus. The rest of the audio buses can be flexibly routed. After modifying the sound, they send it to another bus to the left. The destination bus can be specified for each of the non-master audio buses. Routing always passes audio from buses on the right to buses further to the left. This avoids infinite routing loops.

In the above image, the output of Bus 2 has been routed to the Master bus.

To test passing audio to a bus, create an AudioStreamPlayer node, load an AudioStream and select a target bus for playback:

Finally, toggle the Playing property to On and sound will flow.

You may also be interested in reading about Audio streams now.

This feature is not supported on the web platform if the AudioStreamPlayer's playback mode is set to Sample, which is the default. It will only work if the playback mode is set to Stream, at the cost of increased latency if threads are not enabled.

See Audio playback in the Exporting for the Web documentation for details.

Audio buses can contain all sorts of effects. These effects modify the sound in one way or another and are applied in order.

For information on what each effect does, see Audio effects.

There is no need to disable buses manually when not in use. Godot detects that the bus has been silent for a few seconds and disables it (including all effects).

Disabled buses have a blue VU meter instead of a red-green one.

Stream Players use bus names to identify a bus, which allows adding, removing and moving buses around while the reference to them is kept. However, if a bus is renamed, the reference will be lost and the Stream Player will output to Master. This system was chosen because rearranging buses is a more common process than renaming them.

The default bus layout is automatically saved to the res://default_bus_layout.tres file. Custom bus arrangements can be saved and loaded from disk.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Audio effects — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/audio/audio_effects.html

**Contents:**
- Audio effects
- Amplify
- BandLimit and BandPass
- Capture
- Chorus
- Compressor
- Delay
- Distortion
- EQ
- EQ6, EQ10, EQ21

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

Godot includes several audio effects that can be added to an audio bus to alter every sound file that goes through that bus.

Try them all out to get a sense of how they alter sound. Here follows a short description of the available effects:

Amplify changes the volume of the signal. Some care needs to be taken, though: setting the level too high can make the sound digitally clip, which can produce unpleasant crackles and pops.

These are resonant filters which block frequencies around the Cutoff point. BandPass can be used to simulate sound passing through an old telephone line or megaphone. Modulating the BandPass frequency can simulate the sound of a wah-wah guitar pedal, think of the guitar in Jimi Hendrix's Voodoo Child (Slight Return).

The Capture effect copies the audio frames of the audio bus that it is on into an internal buffer. This can be used to capture data from the microphone or to transmit audio over the network in real-time.

As the name of the effect implies, the Chorus effect makes a single audio sample sound like an entire chorus. It does this by duplicating a signal and very slightly altering the timing and pitch of each duplicate, and varying that over time via an LFO (low frequency oscillator). The duplicate(s) are then mixed back together with the original signal, producing a lush, wide, and large sound. Although chorus is traditionally used for voices, it can be desirable with almost any type of sound.

A dynamic range compressor automatically attenuates (ducks) the level of the incoming signal when its amplitude exceeds a certain threshold. The level of attenuation applied is proportional to how far the incoming audio exceeds the threshold. The compressor's Ratio parameter controls the degree of attenuation. One of the main uses of a compressor is to reduce the dynamic range of signals with very loud and quiet parts. Reducing the dynamic range of a signal can make it fit more comfortably in a mix.

The compressor has many uses. For example:

It can be used in the Master bus to compress the whole output prior to being hit by a limiter, making the effect of the limiter much more subtle.

It can be used in voice channels to ensure they sound as even as possible.

It can be sidechained by another sound source. This means it can reduce the sound level of one signal using the level of another audio bus for threshold detection. This technique is very common in video game mixing to "duck" the level of music or sound effects when in-game or multiplayer voices need to be fully audible.

It can accentuate transients by using a slower attack. This can make sound effects more punchy.

If your goal is to prevent a signal from exceeding a given amplitude altogether, rather than to reduce the dynamic range of the signal, a limiter is likely a better choice than a compressor for this purpose. However, applying compression before a limiter is still good practice.

Digital delay essentially duplicates a signal and repeats it at a specified speed with a volume level that decays for each repeat. Delay is great for simulating the acoustic space of a canyon or large room, where sound bounces have a lot of delay between their repeats. This is in contrast to reverb, which has a more natural and blurred sound to it. Using this in conjunction with reverb can create very natural sounding environments!

Makes the sound distorted. Godot offers several types of distortion:

Overdrive sounds like a guitar distortion pedal or megaphone. Sounds distorted with this sound like they're coming through a low-quality speaker or device.

Tan sounds like another interesting flavor of overdrive.

Bit crushing clamps the amplitude of the signal, making it sound flat and crunchy.

All three types of distortion can add higher frequency sounds to an original sound, making it stand out better in a mix.

EQ is what all other equalizers inherit from. It can be extended with Custom scripts to create an equalizer with a custom number of bands.

Godot provides three equalizers with different numbers of bands, which are represented in the title (6, 10, and 21 bands, respectively). An equalizer on the Master bus can be useful for cutting low and high frequencies that the device's speakers can't reproduce well. For example, phone or tablet speakers usually don't reproduce low frequency sounds well, and could make a limiter or compressor attenuate sounds that aren't even audible to the user anyway.

Note: The equalizer effect can be disabled when headphones are plugged in, giving the user the best of both worlds.

Filter is what all other filters inherit from and should not be used directly.

A limiter is similar to a compressor, but it's less flexible and designed to prevent a signal's amplitude exceeding a given dB threshold. Adding a limiter to the final point of the Master bus is good practice, as it offers an easy safeguard against clipping.

Cuts frequencies below a specific Cutoff frequency. HighPassFilter is used to reduce the bass content of a signal.

Reduces all frequencies above a specific Cutoff frequency.

This is the old limiter effect, and it is recommended to use the new HardLimiter effect instead.

Here is an example of how this effect works, if the ceiling is set to -12 dB, and the threshold is 0 dB, all samples going through get reduced by 12dB. This changes the waveform of the sound and introduces distortion.

This effect is being kept to preserve compatibility, however it should be considered deprecated.

Cuts frequencies above a specific Cutoff frequency and can also resonate (boost frequencies close to the Cutoff frequency). Low pass filters can be used to simulate "muffled" sound. For instance, underwater sounds, sounds blocked by walls, or distant sounds.

Reduces all frequencies below a specific Cutoff frequency.

The opposite of the BandPassFilter, it removes a band of sound from the frequency spectrum at a given Cutoff frequency.

The Panner allows the stereo balance of a signal to be adjusted between the left and right channels. Headphones are recommended when configuring in this effect.

This effect is formed by de-phasing two duplicates of the same sound so they cancel each other out in an interesting way. Phaser produces a pleasant whooshing sound that moves back and forth through the audio spectrum, and can be a great way to create sci-fi effects or Darth Vader-like voices.

This effect allows the adjustment of the signal's pitch independently of its speed. All frequencies can be increased/decreased with minimal effect on transients. PitchShift can be useful to create unusually high or deep voices. Do note that altering pitch can sound unnatural when pushed outside of a narrow window.

The Record effect allows the user to record sound from a microphone.

Reverb simulates rooms of different sizes. It has adjustable parameters that can be tweaked to obtain the sound of a specific room. Reverb is commonly outputted from Area3Ds (see Reverb buses), or to apply a "chamber" feel to all sounds.

This effect doesn't alter audio, instead, you add this effect to buses you want a spectrum analysis of. This would typically be used for audio visualization. Visualizing voices can be a great way to draw attention to them without just increasing their volume. A demo project using this can be found here.

This effect uses a few algorithms to enhance a signal's stereo width.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Audio — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/audio/index.html

**Contents:**
- Audio

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Audio streams — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/audio/audio_streams.html

**Contents:**
- Audio streams
- Introduction
- AudioStream
- AudioStreamPlayer
- AudioStreamPlayer2D
- AudioStreamPlayer3D
  - Reverb buses
  - Doppler
- User-contributed notes

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

As you might have already read in Audio buses, sound is sent to each bus via an AudioStreamPlayer node. There are different kinds of AudioStreamPlayers. Each one loads an AudioStream and plays it back.

An audio stream is an abstract object that emits sound. The sound can come from many places, but is most commonly loaded from the filesystem. Audio files can be loaded as AudioStreams and placed inside an AudioStreamPlayer. You can find information on supported formats and differences in Importing audio samples.

There are other types of AudioStreams, such as AudioStreamRandomizer. This one picks a different audio stream from a list of streams each time it's played back, and applies random pitch and volume shifting. This can be helpful for adding variation to sounds that are played back often.

This is the standard, non-positional stream player. It can play to any bus. In 5.1 sound setups, it can send audio to stereo mix or front speakers.

Playback Type is an experimental setting, and could change in future versions of Godot. It exists so Web exports use Web Audio-API based samples instead of streaming all sounds to the browser, unlike most platforms. This prevents the audio from being garbled in single-threaded Web exports. By default, only the Web platform will use samples. Changing this setting is not recommended, unless you have an explicit reason to. You can change the default playback type for the web and other platforms in the project settings under Audio > General (advanced settings must be turned on to see the setting).

This is a variant of AudioStreamPlayer, but emits sound in a 2D positional environment. When close to the left of the screen, the panning will go left. When close to the right side, it will go right.

Area2Ds can be used to divert sound from any AudioStreamPlayer2Ds they contain to specific buses. This makes it possible to create buses with different reverb or sound qualities to handle action happening in a particular parts of your game world.

This is a variant of AudioStreamPlayer, but emits sound in a 3D positional environment. Depending on the location of the player relative to the screen, it can position sound in stereo, 5.1 or 7.1 depending on the chosen audio setup.

Similar to AudioStreamPlayer2D, an Area3D can divert the sound to an audio bus.

Unlike for 2D, the 3D version of AudioStreamPlayer has a few more advanced options:

This feature is not supported on the web platform if the AudioStreamPlayer's playback mode is set to Sample, which is the default. It will only work if the playback mode is set to Stream, at the cost of increased latency if threads are not enabled.

See Audio playback in the Exporting for the Web documentation for details.

Godot allows for 3D audio streams that enter a specific Area3D node to send dry and wet audio to separate buses. This is useful when you have several reverb configurations for different types of rooms. This is done by enabling this type of reverb in the Reverb Bus section of the Area3D's properties:

At the same time, a special bus layout is created where each Area3D receives the reverb info from each Area3D. A Reverb effect needs to be created and configured in each reverb bus to complete the setup for the desired effect:

The Area3D's Reverb Bus section also has a parameter named Uniformity. Some types of rooms bounce sounds more than others (like a warehouse), so reverberation can be heard almost uniformly across the room even though the source may be far away. Playing around with this parameter can simulate that effect.

This feature is not supported on the web platform if the AudioStreamPlayer's playback mode is set to Sample, which is the default. It will only work if the playback mode is set to Stream, at the cost of increased latency if threads are not enabled.

See Audio playback in the Exporting for the Web documentation for details.

When the relative velocity between an emitter and listener changes, this is perceived as an increase or decrease in the pitch of the emitted sound. Godot can track velocity changes in the AudioStreamPlayer3D and Camera nodes. Both nodes have this property, which must be enabled manually:

Enable it by setting it depending on how objects will be moved: use Idle for objects moved using _process, or Physics for objects moved using _physics_process. The tracking will happen automatically.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Autoloads versus regular nodes — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/best_practices/autoloads_versus_internal_nodes.html

**Contents:**
- Autoloads versus regular nodes
- The cutting audio issue
- Managing shared functionality or data
- When you should use an Autoload
- User-contributed notes

Godot offers a feature to automatically load nodes at the root of your project, allowing you to access them globally, that can fulfill the role of a Singleton: Singletons (Autoload). These autoloaded nodes are not freed when you change the scene from code with SceneTree.change_scene_to_file.

In this guide, you will learn when to use the Autoload feature, and techniques you can use to avoid it.

Other engines can encourage the use of creating manager classes, singletons that organize a lot of functionality into a globally accessible object. Godot offers many ways to avoid global state thanks to the node tree and signals.

For example, let's say we are building a platformer and want to collect coins that play a sound effect. There's a node for that: the AudioStreamPlayer. But if we call the AudioStreamPlayer while it is already playing a sound, the new sound interrupts the first.

A solution is to code a global, autoloaded sound manager class. It generates a pool of AudioStreamPlayer nodes that cycle through as each new request for sound effects comes in. Say we call that class Sound, you can use it from anywhere in your project by calling Sound.play("coin_pickup.ogg"). This solves the problem in the short term but causes more problems:

Global state: one object is now responsible for all objects' data. If the Sound class has errors or doesn't have an AudioStreamPlayer available, all the nodes calling it can break.

Global access: now that any object can call Sound.play(sound_path) from anywhere, there's no longer an easy way to find the source of a bug.

Global resource allocation: with a pool of AudioStreamPlayer nodes stored from the start, you can either have too few and face bugs, or too many and use more memory than you need.

About global access, the problem is that any code anywhere could pass wrong data to the Sound autoload in our example. As a result, the domain to explore to fix the bug spans the entire project.

When you keep code inside a scene, only one or two scripts may be involved in audio.

Contrast this with each scene keeping as many AudioStreamPlayer nodes as it needs within itself and all these problems go away:

Each scene manages its own state information. If there is a problem with the data, it will only cause issues in that one scene.

Each scene accesses only its own nodes. Now, if there is a bug, it's easy to find which node is at fault.

Each scene allocates exactly the amount of resources it needs.

Another reason to use an Autoload can be that you want to reuse the same method or data across many scenes.

In the case of functions, you can create a new type of Node that provides that feature for an individual scene using the class_name keyword in GDScript.

When it comes to data, you can either:

Create a new type of Resource to share the data.

Store the data in an object to which each node has access, for example using the owner property to access the scene's root node.

GDScript supports the creation of static functions using static func. When combined with class_name, this makes it possible to create libraries of helper functions without having to create an instance to call them. The limitation of static functions is that they can't reference member variables, non-static functions or self.

Since Godot 4.1, GDScript also supports static variables using static var. This means you can now share variables across instances of a class without having to create a separate autoload.

Still, autoloaded nodes can simplify your code for systems with a wide scope. If the autoload is managing its own information and not invading the data of other objects, then it's a great way to create systems that handle broad-scoped tasks. For example, a quest or a dialogue system.

An autoload is not necessarily a singleton. Nothing prevents you from instantiating copies of an autoloaded node. An autoload is only a tool that makes a node load automatically as a child of the root of your scene tree, regardless of your game's node structure or which scene you run, e.g. by pressing the F6 key.

As a result, you can get the autoloaded node, for example an autoload called Sound, by calling get_node("/root/Sound").

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## A better XR start script — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/xr/a_better_xr_start_script.html

**Contents:**
- A better XR start script
- Signals for our script
- Variables for our script
- Our updated ready function
- On session begun
- On visible state
- On focussed state
- On stopping state
- On pose recentered
- User-contributed notes

In Setting up XR we introduced a startup script that initialises our setup which we used as our script on our main node. This script performs the minimum steps required for any given interface.

When using OpenXR there are a number of improvements we should do here. For this we've created a more elaborate starting script. You will find these used in our demo projects.

Alternatively, if you are using XR Tools (see Introducing XR tools) it contains a version of this script updated with some features related to XR tools.

Below we will detail out the script used in our demos and explain the parts that are added.

We are introducing 3 signals to our script so that our game can add further logic:

focus_lost is emitted when the player takes off their headset or when the player enters the menu system of the headset.

focus_gained is emitted when the player puts their headset back on or exits the menu system and returns to the game.

pose_recentered is emitted when the headset requests the player's position to be reset.

Our game should react accordingly to these signals.

We introduce a few new variables to our script as well:

maximum_refresh_rate will control the headsets refresh rate if this is supported by the headset.

xr_interface holds a reference to our XR interface, this already existed but we now type it to get full access to our XRInterface API.

xr_is_focussed will be set to true whenever our game has focus.

We add a few things to the ready function.

If we're using the mobile or forward+ renderer we set the viewport's vrs_mode to VRS_XR. On platforms that support this, this will enable foveated rendering.

If we're using the compatibility renderer, we check if the OpenXR foveated rendering settings are configured and if not, we output a warning. See OpenXR Settings for further details.

We hook up a number of signals that will be emitted by the XRInterface. We'll provide more detail about these signals as we implement them.

We also quit our application if we couldn't successfully initialise OpenXR. Now this can be a choice. If you are making a mixed mode game you setup the VR mode of your game on success, and setup the non-VR mode of your game on failure. However, when running a VR only application on a standalone headset, it is nicer to exit on failure than to hang the system.

This signal is emitted by OpenXR when our session is setup. This means the headset has run through setting everything up and is ready to begin receiving content from us. Only at this time various information is properly available.

The main thing we do here is to check our headset's refresh rate. We also check the available refresh rates reported by the XR runtime to determine if we want to set our headset to a higher refresh rate.

Finally we match our physics update rate to our headset update rate. Godot runs at a physics update rate of 60 updates per second by default while headsets run at a minimum of 72, and for modern headsets often up to 144 frames per second. Not matching the physics update rate will cause stuttering as frames are rendered without objects moving.

This signal is emitted by OpenXR when our game becomes visible but is not focused. This is a bit of a weird description in OpenXR but it basically means that our game has just started and we're about to switch to the focused state next, that the user has opened a system menu or the user has just took their headset off.

On receiving this signal we'll update our focused state, we'll change the process mode of our node to disabled which will pause processing on this node and its children, and emit our focus_lost signal.

If you've added this script to your root node, this means your game will automatically pause when required. If you haven't, you can connect a method to the signal that performs additional changes.

While your game is in visible state because the user has opened a system menu, Godot will keep rendering frames and head tracking will remain active so your game will remain visible in the background. However controller and hand tracking will be disabled until the user exits the system menu.

This signal is emitted by OpenXR when our game gets focus. This is done at the completion of our startup, but it can also be emitted when the user exits a system menu, or put their headset back on.

Note also that when your game starts while the user is not wearing their headset, the game stays in 'visible' state until the user puts their headset on.

It is thus important to keep your game paused while in visible mode. If you don't the game will keep on running while your user isn't interacting with your game. Also when the game returns to the focused mode, suddenly all controller and hand tracking is re-enabled and could have game breaking consequences if you do not react to this accordingly. Be sure to test this behavior in your game!

While handling our signal we will update the focuses state, unpause our node and emit our focus_gained signal.

This signal is emitted by OpenXR when we enter our stop state. There are some differences between platforms when this happens. On some platforms this is only emitted when the game is being closed. But on other platforms this will also be emitted every time the player takes off their headset.

For now this method is only a place holder.

This signal is emitted by OpenXR when the user requests their view to be recentered. Basically this communicates to your game that the user is now facing forward and you should re-orient the player so they are facing forward in the virtual world.

As doing so is dependent on your game, your game needs to react accordingly.

All we do here is emit the pose_recentered signal. You can connect to this signal and implement the actual recenter code. Often it is enough to call center_on_hmd().

And that finished our script. It was written so that it can be re-used over multiple projects. Just add it as the script on your main node (and extend it if needed) or add it on a child node specific for this script.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
extends Node3D

signal focus_lost
signal focus_gained
signal pose_recentered

...
```

Example 2 (unknown):
```unknown
using Godot;

public partial class MyNode3D : Node3D
{
    [Signal]
    public delegate void FocusLostEventHandler();

    [Signal]
    public delegate void FocusGainedEventHandler();

    [Signal]
    public delegate void PoseRecenteredEventHandler();

...
```

Example 3 (unknown):
```unknown
...

@export var maximum_refresh_rate : int = 90

var xr_interface : OpenXRInterface
var xr_is_focussed = false

...
```

Example 4 (csharp):
```csharp
...

    [Export]
    public int MaximumRefreshRate { get; set; } = 90;

    private OpenXRInterface _xrInterface;

    private bool _xrIsFocused;

...
```

---

## Background loading — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/io/background_loading.html

**Contents:**
- Background loading
- Using ResourceLoader
- Example
- User-contributed notes

Commonly, games need to load resources asynchronously. When switching the main scene of your game (e.g. going to a new level), you might want to show a loading screen with some indication that progress is being made, or you may want to load additional resources during gameplay.

The standard load method (ResourceLoader.load or GDScript's simpler load) blocks your thread, making your game appear unresponsive while the resource is being loaded.

One way around this is using ResourceLoader to load resources asynchronously in background threads.

Generally, you queue requests to load resources for a path using ResourceLoader.load_threaded_request, which will then be loaded in threads in the background.

You can check the status with ResourceLoader.load_threaded_get_status. Progress can be obtained by passing an array variable via progress which will return a one element array containing the percentage.

Finally, you retrieve loaded resources by calling ResourceLoader.load_threaded_get.

Once you call load_threaded_get(), either the resource finished loading in the background and will be returned instantly or the load will block at this point like load() would. If you want to guarantee this does not block, you either need to ensure there is enough time between requesting the load and retrieving the resource or you need to check the status manually.

This example demonstrates how to load a scene in the background. We will have a button spawn an enemy when pressed. The enemy will be Enemy.tscn which we will load on _ready and instantiate when pressed. The path will be "Enemy.tscn" which is located at res://Enemy.tscn.

First, we will start a request to load the resource and connect the button:

Now _on_button_pressed will be called when the button is pressed. This method will be used to spawn an enemy.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (javascript):
```javascript
const ENEMY_SCENE_PATH : String = "Enemy.tscn"

func _ready():
    ResourceLoader.load_threaded_request(ENEMY_SCENE_PATH)
    self.pressed.connect(_on_button_pressed)
```

Example 2 (javascript):
```javascript
using Godot;

public partial class MyButton : Button
{
    private const string EnemyScenePath = "Enemy.tscn";

    public override void _Ready()
    {
        ResourceLoader.LoadThreadedRequest(EnemyScenePath);
        Pressed += OnButtonPressed;
    }
}
```

Example 3 (gdscript):
```gdscript
func _on_button_pressed(): # Button was pressed.
    # Obtain the resource now that we need it.
    var enemy_scene = ResourceLoader.load_threaded_get(ENEMY_SCENE_PATH)
    # Instantiate the enemy scene and add it to the current scene.
    var enemy = enemy_scene.instantiate()
    add_child(enemy)
```

Example 4 (unknown):
```unknown
private void OnButtonPressed() // Button was pressed.
{
    // Obtain the resource now that we need it.
    var enemyScene = (PackedScene)ResourceLoader.LoadThreadedGet(EnemyScenePath);
    // Instantiate the enemy scene and add it to the current scene.
    var enemy = enemyScene.Instantiate();
    AddChild(enemy);
}
```

---

## Basic XR Locomotion — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/xr/basic_xr_locomotion.html

**Contents:**
- Basic XR Locomotion
- Adding our player body
- Adding a floor
- Direct movement
- Teleport
- More advanced movement features
- User-contributed notes

For basic locomotion we're going to continue using our Godot XR Tools library. The library contains both basic movement features as more advanced features.

The first step we need to do is to add a helper node to our XROrigin3D node. Because XR supports roomscale tracking you can't simply add your XR setup to a CharacterBody3D node and expect things to work. You will run into trouble when the user moves around their physical space and is no longer standing in the center of their room. Godot XR Tools embeds the needed logic into a helper node called PlayerBody.

Select your XROrigin3D node and click on the Instantiate Child Scene button to add a child scene. Select addons/godot-xr-tools/player/player_body.tscn and add this node.

This node governs the in game movement of your character and will immediately react to gravity. So to prevent our player from infinitely falling down we'll quickly add a floor to our scene.

We start by adding a StaticBody3D node to our root node and we rename this to Floor. We add a MeshInstance3D node as a child node for our Floor. Then create a new PlaneMesh as its mesh. For now we set the size of the mesh to 100 x 100 meters. Next we add a CollisionShape3D node as a child node for our Floor. Then create a BoxShape as our shape. We set the size of this box shape to 100 x 1 x 100 meters. We also need to move our collision shape down by 0.5 meters so the top of our box is flush with the floor.

To make it easier to see that we're actually moving around our world, a white floor isn't going to do it. Create a texture using Wahooneys excellent free texture generator. Once you've created the texture add it to your project. Then create a new material for the MeshInstance3D node, add your texture as the albedo, and enable Triplaner under UV1 in the material properties.

We're going to start adding some basic direct movement to our setup. This allows the user to move through the virtual world using joystick input.

It is important to note that moving through the virtual world while the player is standing still in the real world, can be nausea inducing especially for players who are new to VR. The default settings on our movement functions are fairly conservative. We advise you to stick to these defaults but offer features in game to enable less comfortable settings for more experienced users who are used to playing VR games.

We want to enable this on the right hand controller. We do this by adding a subscene to the right hand XRController3D node. Select addons/godot-xr-tools/functions/movement_direct.tscn as the scene to add.

This function adds forward and backwards movement to the player by using the joystick on the right hand controller. It has an option to also add left/right strafe but by default this is disabled.

Instead, we are going to add the ability for the player to also turn with this joystick. We will add another subscene to our controller node, select addons/godot-xr-tools/functions/movement_turn.tscn for this.

The turn system by default uses a snap turn approach. This means that turning happens in steps. This may seem jarring however it is a tried and tested method of combating motion sickness. You can easily switch to a mode that offers smooth turning by changing the mode property on the turn node.

If you run your game at this point in time you will find that you can move through the world freely using the right hand joystick.

An alternative to direct movement that some users find more pleasant is the ability to teleport to another location within your game world. Godot XR Tools supports this through the teleport function and we will be adding this to our left hand controller.

Add a new child scene to your left hand XRController3D node by selecting the addons/godot-xr-tools/functions/function_teleport.tscn scene.

With this scene added the player will be able to teleport around the world by pressing the trigger on the left hand controller, pointing where they want to go, and then releasing the trigger. The player can also adjust the orientation by using the left hand controller's joystick.

If you've followed all instructions correctly your scene should now look something like this:

Godot XR Tools adds many more movement features such as gliding, a grapple hook implementation, a jetpack, climbing mechanics, etc.

Most work similarly to the basic movement features we've handled so far, simply add the relevant subscene from the plugin to the controller that implements it.

We'll look at some of these in more detail later on in this tutorial where additional setup is required (such as climbing) but for others please look at Godot XR Tools own help pages for details.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## BBCode in RichTextLabel — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/ui/bbcode_in_richtextlabel.html

**Contents:**
- BBCode in RichTextLabel
- Introduction
- Using BBCode
- Handling user input safely
- Stripping BBCode tags
- Performance
- Using push_[tag]() and pop() functions instead of BBCode
- Reference
  - Paragraph options
  - Handling [url] tag clicks

Label nodes are great for displaying basic text, but they have limitations. If you want to change the color of the text, or its alignment, you can only do that to the entire label. You can't make a part of the text have another color, or have a part of the text centered. To get around these limitations, you would use a RichTextLabel.

RichTextLabel allows for complex formatting of text using a markup syntax or the built-in API. It uses BBCodes for the markup syntax, a system of tags that designate formatting rules for a part of the text. You may be familiar with them if you ever used forums (also known as bulletin boards, hence the "BB" in "BBCode").

Unlike Label, RichTextLabel also comes with its own vertical scrollbar. This scrollbar is automatically displayed if the text does not fit within the control's size. The scrollbar can be disabled by unchecking the Scroll Active property in the RichTextLabel inspector.

Note that the BBCode tags can also be used to some extent for other use cases:

BBCode can be used to format comments in the XML source of the class reference.

BBCode can be used in GDScript documentation comments.

BBCode can be used when printing rich text to the Output bottom panel.

You can see how BBCode in RichTextLabel works in action using the Rich Text Label with BBCode demo project.

By default, RichTextLabel functions like a normal Label. It has the property_text property, which you can edit to have uniformly formatted text. To be able to use BBCode for rich text formatting, you need to turn on the BBCode mode by setting bbcode_enabled. After that, you can edit the text property using available tags. Both properties are located at the top of the inspector after selecting a RichTextLabel node.

For example, BBCode [color=green]test[/color] would render the word "test" with a green color.

Most BBCodes consist of 3 parts: the opening tag, the content and the closing tag. The opening tag delimits the start of the formatted part, and can also carry some configuration options. Some opening tags, like the color one shown above, also require a value to work. Other opening tags may accept multiple options (separated by spaces within the opening tag). The closing tag delimits the end of the formatted part. In some cases, both the closing tag and the content can be omitted.

Unlike BBCode in HTML, leading/trailing whitespace is not removed by a RichTextLabel upon display. Duplicate spaces are also displayed as-is in the final output. This means that when displaying a code block in a RichTextLabel, you don't need to use a preformatted text tag.

RichTextLabel doesn't support entangled BBCode tags. For example, instead of using:

In a scenario where users may freely input text (such as chat in a multiplayer game), you should make sure users cannot use arbitrary BBCode tags that will be parsed by RichTextLabel. This is to avoid inappropriate use of formatting, which can be problematic if [url] tags are handled by your RichTextLabel (as players may be able to create clickable links to phishing sites or similar).

Using RichTextLabel's [lb] and/or [rb] tags, we can replace the opening and/or closing brackets of any BBCode tag in a message with those escaped tags. This prevents users from using BBCode that will be parsed as tags – instead, the BBCode will be displayed as text.

Example of unescaped user input resulting in BBCode injection (2nd line) and escaped user input (3rd line)

The above image was created using the following script:

For certain use cases, it can be desired to remove BBCode tags from the string. This is useful when displaying the RichTextLabel's text in another Control that does not support BBCode (such as a tooltip):

Removing BBCode tags entirely isn't advised for user input, as it can modify the displayed text without users understanding why part of their message was removed. Escaping user input should be preferred instead.

In most cases, you can use BBCode directly as-is since text formatting is rarely a heavy task. However, with particularly large RichTextLabels (such as console logs spanning thousands of lines), you may encounter stuttering during gameplay when the RichTextLabel's text is updated.

There are several ways to alleviate this:

Use the append_text() function instead of appending to the text property. This function will only parse BBCode for the added text, rather than parsing BBCode from the entire text property.

Use push_[tag]() and pop() functions to add tags to RichTextLabel instead of using BBCode.

Enable the Threading > Threaded property in RichTextLabel. This won't speed up processing, but it will prevent the main thread from blocking, which avoids stuttering during gameplay. Only enable threading if it's actually needed in your project, as threading has some overhead.

If you don't want to use BBCode for performance reasons, you can use functions provided by RichTextLabel to create formatting tags without writing BBCode in the text.

Every BBCode tag (including effects) has a push_[tag]() function (where [tag] is the tag's name). There are also a few convenience functions available, such as push_bold_italics() that combines both push_bold() and push_italics() into a single tag. See the RichTextLabel class reference for a complete list of push_[tag]() functions.

The pop() function is used to end any tag. Since BBCode is a tag stack, using pop() will close the most recently started tags first.

The following script will result in the same visual output as using BBCode [color=green]test [i]example[/i][/color]:

Do not set the text property directly when using formatting functions. Appending to the text property will erase all modifications made to the RichTextLabel using the append_text(), push_[tag]() and pop() functions.

Some of these BBCode tags can be used in tooltips for @export script variables as well as in the XML source of the class reference. For more information, see Class reference BBCode.

[center]{text}[/center]

[right]{text}[/right]

[indent]{text}[/indent]

[font_size={size}]{text}[/font_size]

[dropcap font={font} font_size={size} color={color} outline_size={size} outline_color={color} margins={left},{top},{right},{bottom}]{text}[/dropcap]

[lang={code}]{text}[/lang]

[color={code/name}]{text}[/color]

[bgcolor={code/name}]{text}[/bgcolor]

[fgcolor={code/name}]{text}[/fgcolor]

[ol type={type}]{items}[/ol]

Tags for bold ([b]) and italics ([i]) formatting work best if the appropriate custom fonts are set up in the RichTextLabelNode's theme overrides. If no custom bold or italic fonts are defined, faux bold and italic fonts will be generated by Godot. These fonts rarely look good in comparison to hand-made bold/italic font variants.

The monospaced ([code]) tag only works if a custom font is set up in the RichTextLabel node's theme overrides. Otherwise, monospaced text will use the regular font.

There are no BBCode tags to control vertical centering of text yet.

Options can be skipped for all tags.

left (or l), center (or c), right (or r), fill (or f)

Text horizontal alignment.

default (of d), uri (or u), file (or f), email (or e), list (or l), none (or n), custom (or c)

Structured text override.

justification_flags, jst

Comma-separated list of the following values (no space after each comma): kashida (or k), word (or w), trim (or tr), after_last_tab (or lt), skip_last (or sl), skip_last_with_chars (or sv), do_not_skip_single (or ns).

word,kashida,skip_last,do_not_skip_single

Justification (fill alignment) option. See TextServer for more details.

ltr (or l), rtl (or r), auto (or a)

ISO language codes. See Locale codes

Locale override. Some font files may contain script-specific substitutes, in which case they will be used.

List of floating-point numbers, e.g. 10.0,30.0

Width of the space character in the font

Overrides the horizontal offsets for each tab character. When the end of the list is reached, the tab stops will loop over. For example, if you set tab_stops to 10.0,30.0, the first tab will be at 10 pixels, the second tab will be at 10 + 30 = 40 pixels, and the third tab will be at 10 + 30 + 10 = 50 pixels from the origin of the RichTextLabel.

By default, [url] tags do nothing when clicked. This is to allow flexible use of [url] tags rather than limiting them to opening URLs in a web browser.

To handle clicked [url] tags, connect the RichTextLabel node's meta_clicked signal to a script function.

For example, the following method can be connected to meta_clicked to open clicked URLs using the user's default web browser:

For more advanced use cases, it's also possible to store JSON in a [url] tag's option and parse it in the function that handles the meta_clicked signal. For example:

Color name or color in HEX format

Color tint of the rule (modulation).

Target height of the rule in pixels, add % to the end of value to specify it as percentages of the control width instead of pixels.

Target width of the rule in pixels, add % to the end of value to specify it as percentages of the control width instead of pixels.

left (or l), center (or c), right (or r)

Horizontal alignment.

Color name or color in HEX format

Color tint of the image (modulation).

Target height of the image in pixels, add % to the end of value to specify it as percentages of the control width instead of pixels.

Target width of the image in pixels, add % to the end of value to specify it as percentages of the control width instead of pixels.

x,y,width,height in pixels

Region rect of the image. This can be used to display a single image from a spritesheet.

If set to true, and the image is smaller than the size specified by width and height, the image padding is added to match the size instead of upscaling.

When a vertical alignment value is provided with the [img] or [table] tag the image/table will try to align itself against the surrounding text. Alignment is performed using a vertical point of the image and a vertical point of the text. There are 3 possible points on the image (top, center, and bottom) and 4 possible points on the text and table (top, center, baseline, and bottom), which can be used in any combination.

To specify both points, use their full or short names as a value of the image/table tag:

You can also specify just one value (top, center, or bottom) to make use of a corresponding preset (top-top, center-center, and bottom-bottom respectively).

Short names for the values are t (top), c (center), l (baseline), and b (bottom).

A valid Font resource path.

Extra spacing for each glyph.

Extra spacing for the space character.

Extra spacing at the top of the line.

Extra spacing at the bottom of the line.

Floating-point number.

Font embolden strength, if it is not equal to zero, emboldens the font outlines. Negative values reduce the outline thickness.

An active face index in the TrueType / OpenType collection.

Floating-point number.

Font slant strength, positive values slant glyphs to the right. Negative values to the left.

opentype_variation, otv

Comma-separated list of the OpenType variation tags (no space after each comma).

Font OpenType variation coordinates. See OpenType variation tags.

Note: The value should be enclosed in " to allow using = inside it:

opentype_features, otf

Comma-separated list of the OpenType feature tags (no space after each comma).

Font OpenType features. See OpenType features tags.

Note: The value should be enclosed in " to allow using = inside it:

For tags that allow specifying a color by name, you can use names of the constants from the built-in Color class. Named classes can be specified in a number of styles using different casings: DARK_RED, DarkRed, and darkred will give the same exact result.

See this image for a list of color constants:

For opaque RGB colors, any valid 6-digit hexadecimal code is supported, e.g. [color=#ffffff]white[/color]. Shorthand RGB color codes such as #6f2 (equivalent to #66ff22) are also supported.

For transparent RGB colors, any RGBA 8-digit hexadecimal code can be used, e.g. [color=#ffffff88]translucent white[/color]. Note that the alpha channel is the last component of the color code, not the first one. Short RGBA color codes such as #6f28 (equivalent to #66ff2288) are supported as well.

Cell expansion ratio. This defines which cells will try to expand to proportionally to other cells and their expansion ratios.

Color name or color in HEX format

Color name or color in HEX format

Cell background color. For alternating odd/even row backgrounds, you can use bg=odd_color,even_color.

4 comma-separated floating-point numbers (no space after each comma)

Left, top, right, and bottom cell padding.

By default, the [ul] tag uses the U+2022 "Bullet" Unicode glyph as the bullet character. This behavior is similar to web browsers. The bullet character can be customized using [ul bullet={bullet}]. If provided, this {bullet} parameter must be a string with no enclosing quotes (for example, [bullet=*]). You can add trailing spaces after the bullet character to increase the spacing between the bullet and the list item text.

See Bullet (typography) on Wikipedia for a list of common bullet characters that you can paste directly in the bullet parameter.

Ordered lists can be used to automatically mark items with numbers or letters in ascending order. This tag supports the following type options:

1 - Numbers, using language specific numbering system if possible.

a, A - Lower and upper case Latin letters.

i, I - Lower and upper case Roman numerals.

BBCode can also be used to create different text effects that can optionally be animated. Five customizable effects are provided out of the box, and you can easily create your own. By default, animated effects will pause when the SceneTree is paused. You can change this behavior by adjusting the RichTextLabel's Process > Mode property.

All examples below mention the default values for options in the listed tag format.

Text effects that move characters' positions may result in characters being clipped by the RichTextLabel node bounds.

You can resolve this by disabling Control > Layout > Clip Contents in the inspector after selecting the RichTextLabel node, or ensuring there is enough margin added around the text by using line breaks above and below the line using the effect.

Pulse creates an animated pulsing effect that multiplies each character's opacity and color. It can be used to bring attention to specific text. Its tag format is [pulse freq=1.0 color=#ffffff40 ease=-2.0]{text}[/pulse].

freq controls the frequency of the half-pulsing cycle (higher is faster). A full pulsing cycle takes 2 * (1.0 / freq) seconds. color is the target color multiplier for blinking. The default mostly fades out text, but not entirely. ease is the easing function exponent to use. Negative values provide in-out easing, which is why the default is -2.0.

Wave makes the text go up and down. Its tag format is [wave amp=50.0 freq=5.0 connected=1]{text}[/wave].

amp controls how high and low the effect goes, and freq controls how fast the text goes up and down. A freq value of 0 will result in no visible waves, and negative freq values won't display any waves either. If connected is 1 (default), glyphs with ligatures will be moved together. If connected is 0, each glyph is moved individually even if they are joined by ligatures. This can work around certain rendering issues with font ligatures.

Tornado makes the text move around in a circle. Its tag format is [tornado radius=10.0 freq=1.0 connected=1]{text}[/tornado].

radius is the radius of the circle that controls the offset, freq is how fast the text moves in a circle. A freq value of 0 will pause the animation, while negative freq will play the animation backwards. If connected is 1 (default), glyphs with ligatures will be moved together. If connected is 0, each glyph is moved individually even if they are joined by ligatures. This can work around certain rendering issues with font ligatures.

Shake makes the text shake. Its tag format is [shake rate=20.0 level=5 connected=1]{text}[/shake].

rate controls how fast the text shakes, level controls how far the text is offset from the origin. If connected is 1 (default), glyphs with ligatures will be moved together. If connected is 0, each glyph is moved individually even if they are joined by ligatures. This can work around certain rendering issues with font ligatures.

Fade creates a static fade effect that multiplies each character's opacity. Its tag format is [fade start=4 length=14]{text}[/fade].

start controls the starting position of the falloff relative to where the fade command is inserted, length controls over how many characters should the fade out take place.

Rainbow gives the text a rainbow color that changes over time. Its tag format is [rainbow freq=1.0 sat=0.8 val=0.8 speed=1.0]{text}[/rainbow].

freq determines how many letters the rainbow extends over before it repeats itself, sat is the saturation of the rainbow, val is the value of the rainbow. speed is the number of full rainbow cycles per second. A positive speed value will play the animation forwards, a value of 0 will pause the animation, and a negative speed value will play the animation backwards.

Font outlines are not affected by the rainbow effect (they keep their original color). Existing font colors are overridden by the rainbow effect. However, CanvasItem's Modulate and Self Modulate properties will affect how the rainbow effect looks, as modulation multiplies its final colors.

You can extend the RichTextEffect resource type to create your own custom BBCode tags. Create a new script file that extends the RichTextEffect resource type and give the script a class_name so that the effect can be selected in the inspector. Add the @tool annotation to your GDScript file if you wish to have these custom effects run within the editor itself. The RichTextLabel does not need to have a script attached, nor does it need to be running in tool mode. The new effect can be registered in the Inspector by adding it to the Markup > Custom Effects array, or in code with the install_effect() method:

Selecting a custom RichTextEffect after saving a script that extends RichTextEffect with a class_name

If the custom effect is not registered within the RichTextLabel's Markup > Custom Effects property, no effect will be visible and the original tag will be left as-is.

There is only one function that you need to extend: _process_custom_fx(char_fx). Optionally, you can also provide a custom BBCode identifier by adding a member name bbcode. The code will check the bbcode property automatically or will use the name of the file to determine what the BBCode tag should be.

This is where the logic of each effect takes place and is called once per glyph during the draw phase of text rendering. This passes in a CharFXTransform object, which holds a few variables to control how the associated glyph is rendered:

outline is true if effect is called for drawing text outline.

range tells you how far into a given custom effect block you are in as an index.

elapsed_time is the total amount of time the text effect has been running.

visible will tell you whether the glyph is visible or not and will also allow you to hide a given portion of text.

offset is an offset position relative to where the given glyph should render under normal circumstances.

color is the color of a given glyph.

glyph_index and font is glyph being drawn and font data resource used to draw it.

Finally, env is a Dictionary of parameters assigned to a given custom effect. You can use get() with an optional default value to retrieve each parameter, if specified by the user. For example [custom_fx spread=0.5 color=#FFFF00]test[/custom_fx] would have a float spread and Color color parameters in its env Dictionary. See below for more usage examples.

The last thing to note about this function is that it is necessary to return a boolean true value to verify that the effect processed correctly. This way, if there's a problem with rendering a given glyph, it will back out of rendering custom effects entirely until the user fixes whatever error cropped up in their custom effect logic.

Here are some examples of custom effects:

This will add a few new BBCode commands, which can be used like so:

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
[tag]content[/tag]
[tag=value]content[/tag]
[tag option1=value1 option2=value2]content[/tag]
[tag][/tag]
[tag]
```

Example 2 (unknown):
```unknown
[b]bold[i]bold italic[/b]italic[/i]
```

Example 3 (unknown):
```unknown
[b]bold[i]bold italic[/i][/b][i]italic[/i]
```

Example 4 (unknown):
```unknown
extends RichTextLabel

func _ready():
    append_chat_line("Player 1", "Hello world!")
    append_chat_line("Player 2", "Hello [color=red]BBCode injection[/color] (no escaping)!")
    append_chat_line_escaped("Player 2", "Hello [color=red]BBCode injection[/color] (with escaping)!")


# Returns escaped BBCode that won't be parsed by RichTextLabel as tags.
func escape_bbcode(bbcode_text):
    # We only need to replace opening brackets to prevent tags from being parsed.
    return bbcode_text.replace("[", "[lb]")


# Appends the user's message as-is, without escaping. This is dangerous!
func append_chat_line(username, message):
    append_text("%s: [color=green]%s[/color]\n" % [username, message])


# Appends the user's message with escaping.
# Remember to escape both the player name and message contents.
func append_chat_line_escaped(username, message):
    append_text("%s: [color=green]%s[/color]\n" % [escape_bbcode(username), escape_bbcode(message)])
```

---

## Best practices — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/best_practices/index.html

**Contents:**
- Best practices

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Beziers, curves and paths — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/math/beziers_and_curves.html

**Contents:**
- Beziers, curves and paths
- Quadratic Bezier
- Cubic Bezier
- Adding control points
- Curve2D, Curve3D, Path and Path2D
- Evaluating
- Drawing
- Traversal
- User-contributed notes

Bezier curves are a mathematical approximation of natural geometric shapes. We use them to represent a curve with as little information as possible and with a high level of flexibility.

Unlike more abstract mathematical concepts, Bezier curves were created for industrial design. They are a popular tool in the graphics software industry.

They rely on interpolation, which we saw in the previous article, combining multiple steps to create smooth curves. To better understand how Bezier curves work, let's start from its simplest form: Quadratic Bezier.

Take three points, the minimum required for Quadratic Bezier to work:

To draw a curve between them, we first interpolate gradually over the two vertices of each of the two segments formed by the three points, using values ranging from 0 to 1. This gives us two points that move along the segments as we change the value of t from 0 to 1.

We then interpolate q0 and q1 to obtain a single point r that moves along a curve.

This type of curve is called a Quadratic Bezier curve.

(Image credit: Wikipedia)

Building upon the previous example, we can get more control by interpolating between four points.

We first use a function with four parameters to take four points as an input, p0, p1, p2 and p3:

We apply a linear interpolation to each couple of points to reduce them to three:

We then take our three points and reduce them to two:

Here is the full function:

The result will be a smooth curve interpolating between all four points:

(Image credit: Wikipedia)

Cubic Bezier interpolation works the same in 3D, just use Vector3 instead of Vector2.

Building upon Cubic Bezier, we can change the way two of the points work to control the shape of our curve freely. Instead of having p0, p1, p2 and p3, we will store them as:

point0 = p0: Is the first point, the source

control0 = p1 - p0: Is a vector relative to the first control point

control1 = p3 - p2: Is a vector relative to the second control point

point1 = p3: Is the second point, the destination

This way, we have two points and two control points which are relative vectors to the respective points. If you've used graphics or animation software before, this might look familiar:

This is how graphics software presents Bezier curves to the users, and how they work and look in Godot.

There are two objects that contain curves: Curve3D and Curve2D (for 3D and 2D respectively).

They can contain several points, allowing for longer paths. It is also possible to set them to nodes: Path3D and Path2D (also for 3D and 2D respectively):

Using them, however, may not be completely obvious, so following is a description of the most common use cases for Bezier curves.

Only evaluating them may be an option, but in most cases it's not very useful. The big drawback with Bezier curves is that if you traverse them at constant speed, from t = 0 to t = 1, the actual interpolation will not move at constant speed. The speed is also an interpolation between the distances between points p0, p1, p2 and p3 and there is not a mathematically simple way to traverse the curve at constant speed.

Let's do an example with the following pseudocode:

As you can see, the speed (in pixels per second) of the circle varies, even though t is increased at constant speed. This makes beziers difficult to use for anything practical out of the box.

Drawing beziers (or objects based on the curve) is a very common use case, but it's also not easy. For pretty much any case, Bezier curves need to be converted to some sort of segments. This is normally difficult, however, without creating a very high amount of them.

The reason is that some sections of a curve (specifically, corners) may require considerable amounts of points, while other sections may not:

Additionally, if both control points were 0, 0 (remember they are relative vectors), the Bezier curve would just be a straight line (so drawing a high amount of points would be wasteful).

Before drawing Bezier curves, tessellation is required. This is often done with a recursive or divide and conquer function that splits the curve until the curvature amount becomes less than a certain threshold.

The Curve classes provide this via the Curve2D.tessellate() function (which receives optional stages of recursion and angle tolerance arguments). This way, drawing something based on a curve is easier.

The last common use case for the curves is to traverse them. Because of what was mentioned before regarding constant speed, this is also difficult.

To make this easier, the curves need to be baked into equidistant points. This way, they can be approximated with regular interpolation (which can be improved further with a cubic option). To do this, just use the Curve3D.sample_baked() method together with Curve2D.get_baked_length(). The first call to either of them will bake the curve internally.

Traversal at constant speed, then, can be done with the following pseudo-code:

And the output will, then, move at constant speed:

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
func _quadratic_bezier(p0: Vector2, p1: Vector2, p2: Vector2, t: float):
    var q0 = p0.lerp(p1, t)
    var q1 = p1.lerp(p2, t)
```

Example 2 (unknown):
```unknown
private Vector2 QuadraticBezier(Vector2 p0, Vector2 p1, Vector2 p2, float t)
{
    Vector2 q0 = p0.Lerp(p1, t);
    Vector2 q1 = p1.Lerp(p2, t);
}
```

Example 3 (unknown):
```unknown
var r = q0.lerp(q1, t)
return r
```

Example 4 (unknown):
```unknown
Vector2 r = q0.Lerp(q1, t);
return r;
```

---

## Binding to external libraries — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/architecture/binding_to_external_libraries.html

**Contents:**
- Binding to external libraries
- Modules
- Using the module
- User-contributed notes

The Summator example in Custom modules in C++ is great for small, custom modules, but what if you want to use a larger, external library? Let's look at an example using Festival, a speech synthesis (text-to-speech) library written in C++.

To bind to an external library, set up a module directory similar to the Summator example:

Next, you will create a header file with a TTS class:

And then you'll add the cpp file.

Just as before, the new class needs to be registered somehow, so two more files need to be created:

These files must be in the top-level folder of your module (next to your SCsub and config.py files) for the module to be registered properly.

These files should contain the following:

Next, you need to create an SCsub file so the build system compiles this module:

You'll need to install the external library on your machine to get the .a library files. See the library's official documentation for specific instructions on how to do this for your operation system. We've included the installation commands for Linux below, for reference.

The voices that Festival uses (and any other potential external/3rd-party resource) all have varying licenses and terms of use; some (if not most) of them may be be problematic with Godot, even if the Festival Library itself is MIT License compatible. Please be sure to check the licenses and terms of use.

The external library will also need to be installed inside your module to make the source files accessible to the compiler, while also keeping the module code self-contained. The festival and speech_tools libraries can be installed from the modules/tts/ directory via git using the following commands:

If you don't want the external repository source files committed to your repository, you can link to them instead by adding them as submodules (from within the modules/tts/ directory), as seen below:

Please note that Git submodules are not used in the Godot repository. If you are developing a module to be merged into the main Godot repository, you should not use submodules. If your module doesn't get merged in, you can always try to implement the external library as a GDExtension.

To add include directories for the compiler to look at you can append it to the environment's paths:

If you want to add custom compiler flags when building your module, you need to clone env first, so it won't add those flags to whole Godot build (which can cause errors). Example SCsub with custom flags:

The final module should look like this:

You can now use your newly created module from any script:

And the output will be is_spoken: True if the text is spoken.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
godot/modules/tts/
```

Example 2 (cpp):
```cpp
#pragma once

#include "core/object/ref_counted.h"

class TTS : public RefCounted {
    GDCLASS(TTS, RefCounted);

protected:
    static void _bind_methods();

public:
    bool say_text(String p_txt);

    TTS();
};
```

Example 3 (cpp):
```cpp
#include "tts.h"

#include <festival.h>

bool TTS::say_text(String p_txt) {

    //convert Godot String to Godot CharString to C string
    return festival_say_text(p_txt.ascii().get_data());
}

void TTS::_bind_methods() {

    ClassDB::bind_method(D_METHOD("say_text", "txt"), &TTS::say_text);
}

TTS::TTS() {
    festival_initialize(true, 210000); //not the best way to do it as this should only ever be called once.
}
```

Example 4 (unknown):
```unknown
register_types.h
register_types.cpp
```

---

## Blender ESCN exporter — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/assets_pipeline/escn_exporter/index.html

**Contents:**
- Blender ESCN exporter

To export from Blender to Godot 4.x, use one of the available 3D formats.

The plugin Godot Blender Exporter is not maintained or supported in Godot 4.x. While not officially supported, the plugin may partially work for some Godot and Blender versions, particularly before Blender version 4.0. For complete docs on the Blender exporter, see the previous version of this page.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Building from source — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/compiling/index.html

**Contents:**
- Building from source
- Basics of building Godot
- Building for target platforms
- Other compilation targets and options

Godot prides itself on being very easy to build, by C++ project standards. Godot uses the SCons build system, and after the initial setup compiling the engine for your current platform should be as easy as running:

But you will probably need to use at least some of the available options to configure the build to match your specific needs, be it a custom engine fork, a lightweight build stripped of extra modules, or an executable targeting engine development.

The articles below should help you navigate configuration options available, as well as prerequisites required to compile Godot exactly the way you need.

Let's start with basics, and learn how to get Godot's source code, and then which options to use to compile it regardless of your target platform.

Below you can find instructions for compiling the engine for your specific target platform. Note that Godot supports cross-compilation, which means you can compile it for a target platform that doesn't match your current platform (say, target Linux while being on Windows). The guides will try their best to cover all possible situations.

Some additional universal compilation options require further setup. Namely, while Godot does have C#/.NET support as a part of its main codebase, it does not get compiled by default to reduce the executable size for users who don't need C# for their projects.

Articles below explain how to configure the buildsystem for cases like this, and also cover some optimization techniques.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## CLion — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/configuring_an_ide/clion.html

**Contents:**
- CLion
- Importing the project
- Compiling and debugging the project
- Ignoring object and library files
- User-contributed notes

CLion is a JetBrains IDE for C++ that's free for individual, non-commercial development.

CLion can import a project's compilation database file, commonly named compile_commands.json. To generate the compilation database file, open the terminal, change to the Godot root directory, and run:

Then, open the Godot root directory with CLion and wait for the project to be fully indexed. If code completion, parameter information, or refactoring are not enabled, you will need to load the project with CMake. To do this, find the CMakeLists.txt file in the platform\android\java\nativeSrcsConfigs directory, right click and select Load CMake Project. Once the project reloads, a godot build configuration will be added. This configuration can be safely deleted as the CMake file will not build the project and only exists for loading the project in JetBrains IDEs.

For compile_commands.json to load correctly in CLion, you must first have the Visual Studio toolchain configured for CLion.

Navigate to Preferences > Build, Execution, Deployment > Toolchains

Click the + button and select Visual Studio

CLion will attempt to detect your Visual Studio installation. If it is unsuccessful, use the file icon to the right of Toolset: to select the directory with your Visual Studio installation.

You may exit and reload CLion and it will reload compile_commands.json

CLion does not support compiling and debugging Godot via SCons out of the box. This can be achieved by creating a custom build target and run configuration in CLion. Before creating a custom build target, you must compile Godot once on the command line, to generate the Godot executable. Open the terminal, change into the Godot root directory, and execute:

To add a custom build target that invokes SCons for compilation:

Open CLion and navigate to Preferences > Build, Execution, Deployment > Custom Build Targets

Click Add target and give the target a name, e.g. Godot debug.

Click ... next to the Build: selectbox, then click the + button in the External Tools dialog to add a new external tool.

Give the tool a name, e.g. Build Godot debug, set Program to scons, set Arguments to the compilation settings you want (see compiling Godot), and set the Working directory to $ProjectFileDir$, which equals the Godot root directory. Click OK to create the tool.

CLion does not expand shell commands like scons -j$(nproc). Use concrete values instead, e.g. scons -j8.

Back in the External Tools dialog, click the + again to add a second external tool for cleaning the Godot build via SCons. Give the tool a name, e.g. Clean Godot debug, set Program to scons, set Arguments to -c (which will clean the build), and set the Working directory to $ProjectFileDir$. Click OK to create the tool.

Close the External Tools dialog. In the Custom Build Target dialog for the custom Godot debug build target, select the Build Godot debug tool from the Build select box, and select the Clean Godot debug tool from the Clean select box. Click OK to create the custom build target.

In the main IDE window, click Add Configuration.

In the Run/Debug Configuration dialog, click Add new..., then select Custom Build Application to create a new custom run/debug configuration.

Give the run/debug configuration a name, e.g. Godot debug, select the Godot debug custom build target as the Target. Select the Godot executable in the bin/ folder as the Executable, and set the Program arguments to --editor --path path-to-your-project/, where path-to-your-project/ should be a path pointing to an existing Godot project. If you omit the --path argument, you will only be able to debug the Godot Project Manager window. Click OK to create the run/debug configuration.

You can now build, run, debug, profile, and Valgrind check the Godot editor via the run configuration.

When playing a scene, the Godot editor will spawn a separate process. You can debug this process in CLion by going to Run > Attach to process..., typing godot, and selecting the Godot process with the highest pid (process ID), which will usually be the running project.

After building Godot in CLion, you may see the object and library files showing up in the Project view.

You can configure CLion to ignore those files:

Open CLion and navigate to Preferences > Editor > File Types > Ignored Files and Folders

Click the + button to add *.o and *.a to the list. In Windows, you would add *.obj and *.dll.

Now, the files should be ignored in the Project view.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
scons compiledb=yes
```

Example 2 (unknown):
```unknown
scons dev_build=yes
```

---

## Code::Blocks — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/configuring_an_ide/code_blocks.html

**Contents:**
- Code::Blocks
- Creating a new project
- Configuring the build
- Configuring the run
- Adding files to the project
- Code style configuration
- User-contributed notes

Code::Blocks is a free, open-source, cross-platform IDE.

From Code::Blocks' main screen, click Create a new project or select File > New > Project....

In the New from template window, from Projects, select Empty project, and click Go.

Click Next, to pass the welcome to the new empty project wizard.

The project file should be created in the root of the cloned project folder. To achieve this, first, ensure that the Project title is the same as the folder name that Godot was cloned into. Unless you cloned the project into a folder with a different name, this will be godot.

Second, ensure that the Folder to create project in is the folder you ran the Git clone command from, not the godot project folder. Confirm that the Resulting filename field will create the project file in the root of the cloned project folder.

The compiler and configuration settings are managed through SCons and will be configured later. However, it's worth deselecting the Create "Release" configuration option; so only a single build target is created before clicking Finish.

The first step is to change the project properties. Right-click on the new project and select Properties....

Check the This is a custom Makefile property. Click OK to save the changes.

The next step is to change the build options. Right-click on the new project and select Build Options....

Select the "Make" commands tab and remove all the existing commands for all the build targets. For each build target enter the SCons command for creating the desired build in the Build project/target field. The minimum is scons. For details on the SCons build options, see Introduction to the buildsystem. It's also useful to add the scons --clean command in the Clean project/target field to the project's default commands.

If you're using Windows, all the commands need to be preceded with cmd /c to initialize the command interpreter.

Code::Blocks should now be configured to build Godot; so either select Build > Build, click the gear button, or press Ctrl + F9.

Once SCons has successfully built the desired target, reopen the project Properties... and select the Build targets tab. In the Output filename field, browse to the bin folder and select the compiled file.

Deselect the Auto-generate filename prefix and Auto-generate filename extension options.

Code::Blocks should now be configured to run your compiled Godot executable; so either select Build > Run, click the green arrow button, or press Ctrl + F10.

There are two additional points worth noting. First, if required, the Execution working dir field can be used to test specific projects, by setting it to the folder containing the project.godot file. Second, the Build targets tab can be used to add and remove build targets for working with and creating different builds.

To add all the Godot code files to the project, right-click on the new project and select Add files recursively....

It should automatically select the project folder; so simply click Open. By default, all code files are included, so simply click OK.

Before editing any files, remember that all code needs to comply with the code style guidelines. One important difference with Godot is the use of tabs for indents. Therefore, the key default editor setting that needs to be changed in Code::Blocks is to enable tabs for indents. This setting can be found by selecting Settings > Editor.

Under General Settings, on the Editor Settings tab, under Tab Options check Use TAB character.

That's it. You're ready to start contributing to Godot using the Code::Blocks IDE. Remember to save the project file and the Workspace. If you run into any issues, ask for help in one of Godot's community channels.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Command line tutorial — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/editor/command_line_tutorial.html

**Contents:**
- Command line tutorial
- Command line reference
- Path
- Setting the project path
- Creating a project
- Running the editor
- Erasing a scene
- Running the game
- Debugging
- Exporting

Some developers like using the command line extensively. Godot is designed to be friendly to them, so here are the steps for working entirely from the command line. Given the engine relies on almost no external libraries, initialization times are pretty fast, making it suitable for this workflow.

On Windows and Linux, you can run a Godot binary in a terminal by specifying its relative or absolute path.

On macOS, the process is different due to Godot being contained within a .app bundle (which is a folder, not a file). To run a Godot binary from a terminal on macOS, you have to cd to the folder where the Godot application bundle is located, then run Godot.app/Contents/MacOS/Godot followed by any command line arguments. If you've renamed the application bundle from Godot to another name, make sure to edit this command line accordingly.

Available in editor builds, debug export templates and release export templates.

Available in editor builds and debug export templates only.

Only available in editor builds.

Note that unknown command line arguments have no effect whatsoever. The engine will not warn you when using a command line argument that doesn't exist with a given build type.

Display the list of command line options.

Display the version string.

Use verbose stdout mode.

Quiet mode, silences stdout messages. Errors are still displayed.

Do not print engine version and rendering method header on startup.

Separator for user-provided arguments. Following arguments are not used by the engine, but can be read from OS.get_cmdline_user_args().

Start the editor instead of running the scene.

-p, --project-manager

Start the Project Manager, even if a project is auto-detected.

"Start the editor in recovery mode, which disables features that can typically cause startup crashes, such as tool scripts, editor plugins, GDExtension addons, and others.

Start the editor debug server (<protocol>://<host/IP>[:<port>], e.g. tcp://127.0.0.1:6007)

Use the specified port for the GDScript Debug Adapter Protocol. Recommended port range [1024, 49151].

Use the specified port for the GDScript Language Server Protocol. Recommended port range [1024, 49151].

Quit after the first iteration.

Quit after the given number of iterations. Set to 0 to disable.

-l, --language <locale>

Use a specific locale. <locale> follows the format language_Script_COUNTRY_VARIANT where language is a 2 or 3-letter language code in lowercase and the rest is optional. See Locale codes for more details.

Path to a project (<directory> must contain a 'project.godot' file).

Path or UID of a scene in the project that should be started.

Scan folders upwards for 'project.godot' file.

Path to a pack (.pck) file to load.

--render-thread <mode>

Render thread mode ('unsafe', 'safe', 'separate'). See Thread Model for more details.

--remote-fs <address>

Remote filesystem (<host/IP>[:<port>] address).

--remote-fs-password <password>

Password for remote filesystem.

--audio-driver <driver>

Audio driver. Use --help first to display the list of available drivers.

--display-driver <driver>

Display driver (and rendering driver). Use --help first to display the list of available drivers.

--audio-output-latency <ms>

Override audio output latency in milliseconds (default is 15 ms). Lower values make sound playback more reactive but increase CPU usage, and may result in audio cracking if the CPU can't keep up

--rendering-method <renderer>

Renderer name. Requires driver support.

--rendering-driver <driver>

Rendering driver (depends on display driver). Use --help first to display the list of available drivers.

--gpu-index <device_index>

Use a specific GPU (run with --verbose to get available device list).

--text-driver <driver>

Text driver (Fonts, BiDi, shaping).

--tablet-driver <driver>

Pen tablet input driver.

Enable headless mode (--display-driver headless --audio-driver Dummy). Useful for servers and with --script.

Write output/error log to the specified path instead of the default location defined by the project. <file> path should be absolute or relative to the project directory.

Run the engine in a way that a movie is written (usually with .avi or .png extension). --fixed-fps is forced when enabled, but can be used to change movie FPS. --disable-vsync can speed up movie writing but makes interaction more difficult. --quit-after can be used to specify the number of frames to write.

Request fullscreen mode.

Request a maximized window.

Request windowed mode.

Request an always-on-top window.

Request window resolution.

Request window position.

Request window screen.

Use a single window (no separate subwindows).

Select XR mode ('default', 'off', 'on').

Request parented to window.

--accessibility <mode>

Select accessibility mode ['auto' (when screen reader is running, default), 'always', 'disabled'].

Debug (local stdout debugger).

Breakpoint list as source::line comma-separated pairs, no spaces (use %20 instead).

--ignore-error-breaks

If debugger is connected, prevents sending error breakpoints.

Enable profiling in the script debugger.

Show a GPU profile of the tasks that took the most time during frame rendering.

Enable graphics API validation layers for debugging.

Abort on GPU errors (usually validation layer errors), may help see the problem if your system freezes.

--generate-spirv-debug-info

Generate SPIR-V debug information. This allows source-level shader debugging with RenderDoc.

--extra-gpu-memory-tracking

Enables additional memory tracking (see class reference for RenderingDevice.get_driver_and_device_memory_report() and linked methods). Currently only implemented for Vulkan. Enabling this feature may cause crashes on some systems due to buggy drivers or bugs in the Vulkan Loader. See https://github.com/godotengine/godot/issues/95967

--accurate-breadcrumbs

Force barriers between breadcrumbs. Useful for narrowing down a command causing GPU resets. Currently only implemented for Vulkan.

Remote debug (<protocol>://<host/IP>[:<port>], e.g. tcp://127.0.0.1:6007).

--single-threaded-scene

Scene tree runs in single-threaded mode. Sub-thread groups are disabled and run on the main thread.

Show collision shapes when running the scene.

Show path lines when running the scene.

Show navigation polygons when running the scene.

Show navigation avoidance debug visuals when running the scene.

Print all StringName allocations to stdout when the engine quits.

--debug-canvas-item-redraw

Display a rectangle each time a canvas item requests a redraw (useful to troubleshoot low processor mode).

Set a maximum number of frames per second rendered (can be used to limit power usage). A value of 0 results in unlimited framerate.

Simulate high CPU load (delay each frame by <ms> milliseconds). Do not use as a FPS limiter; use --max-fps instead.

Force time scale (higher values are faster, 1.0 is normal speed).

Forces disabling of vertical synchronization, even if enabled in the project settings. Does not override driver-level V-Sync enforcement.

--disable-render-loop

Disable render loop so rendering only occurs when called explicitly from script.

--disable-crash-handler

Disable crash handler when supported by the platform code.

Force a fixed number of frames per second. This setting disables real-time synchronization.

--delta-smoothing <enable>

Enable or disable frame delta smoothing ('enable', 'disable').

Print the frames per second to the stdout.

--editor-pseudolocalization

Enable pseudolocalization for the editor and the project manager.

-s, --script <script>

Run a script. <script> must be a resource path relative to the project (myscript.gd will be interpreted as res://myscript.gd) or an absolute filesystem path (for example on Windows C:/tmp/myscript.gd)

--main-loop <main_loop_name>

Run a MainLoop specified by its global class name.

Only parse for errors and quit (use with --script).

Starts the editor, waits for any resources to be imported, and then quits. Implies --editor and --quit.

--export-release <preset> <path>

Export the project in release mode using the given preset and output path. The preset name should match one defined in 'export_presets.cfg'. <path> should be absolute or relative to the project directory, and include the filename for the binary (e.g. 'builds/game.exe'). The target directory must exist.

--export-debug <preset> <path>

Like --export-release, but use debug template. Implies --import.

--export-pack <preset> <path>

Like --export-release, but only export the game pack for the given preset. The <path> extension determines whether it will be in PCK or ZIP format. Implies --import.

--export-patch <preset> <path>

Export pack with changed files only. See --export-pack description for other considerations.

List of patches to use with --export-patch. The list is comma-separated.

--install-android-build-template

Install the Android build template. Used in conjunction with --export-release or --export-debug.

--convert-3to4 [<max_file_kb>] [<max_line_size>]

Convert project from Godot 3.x to Godot 4.x.

--validate-conversion-3to4 [<max_file_kb>] [<max_line_size>]

Show what elements will be renamed when converting project from Godot 3.x to Godot 4.x.

Dump the engine API reference to the given <path> in XML format, merging if existing files are found.

Disallow dumping the base types (used with --doctool).

--gdscript-docs <path>

Rather than dumping the engine API, generate API reference from the inline documentation in the GDScript files found in <path> (used with --doctool).

Build the scripting solutions (e.g. for C# projects). Implies --editor and requires a valid project to edit.

--dump-gdextension-interface

Generate GDExtension header file 'gdnative_interface.h' in the current folder. This file is the base file required to implement a GDExtension.

Generate JSON dump of the Godot API for GDExtension bindings named 'extension_api.json' in the current folder.

--validate-extension-api <path>

Validate an extension API file dumped (with the option above) from a previous version of the engine to ensure API compatibility. If incompatibilities or errors are detected, the return code will be non-zero.

Benchmark the run time and print it to console.

--benchmark-file <path>

Benchmark the run time and save it to a given file in JSON format. The path should be absolute.

Run unit tests. Use --test --help for more information.

It is recommended to place your Godot editor binary in your PATH environment variable, so it can be executed easily from any place by typing godot. You can do so on Linux by placing the Godot binary in /usr/local/bin and making sure it is called godot (case-sensitive).

To achieve this on Windows or macOS easily, you can install Godot using Scoop (on Windows) or Homebrew (on macOS). This will automatically make the copy of Godot installed available in the PATH:

Depending on where your Godot binary is located and what your current working directory is, you may need to set the path to your project for any of the following commands to work correctly.

When running the editor, this can be done by giving the path to the project.godot file of your project as either the first argument, like this:

For all commands, this can be done by using the --path argument:

For example, the full command for exporting your game (as explained below) might look like this:

When starting from a subdirectory of your project, use the --upwards argument for Godot to automatically find the project.godot file by recursively searching the parent directories.

For example, running a scene (as explained below) nested in a subdirectory might look like this when your working directory is in the same path:

Creating a project from the command line can be done by navigating the shell to the desired place and making a project.godot file.

The project can now be opened with Godot.

Running the editor is done by executing Godot with the -e flag. This must be done from within the project directory or by setting the project path as explained above, otherwise the command is ignored and the Project Manager appears.

When passing in the full path to the project.godot file, the -e flag may be omitted.

If a scene has been created and saved, it can be edited later by running the same code with that scene as argument.

Godot is friends with your filesystem and will not create extra metadata files. Use rm to erase a scene file. Make sure nothing references that scene. Otherwise, an error will be thrown upon opening the project.

To run the game, execute Godot within the project directory or with the project path as explained above.

Note that passing in the project.godot file will always run the editor instead of running the game.

When a specific scene needs to be tested, pass that scene to the command line.

Catching errors in the command line can be a difficult task because they scroll quickly. For this, a command line debugger is provided by adding -d. It works for running either the game or a single scene.

Exporting the project from the command line is also supported. This is especially useful for continuous integration setups.

Using the --headless command line argument is required on platforms that do not have GPU access (such as continuous integration). On platforms with GPU access, --headless prevents a window from spawning while the project is exporting.

The preset name must match the name of an export preset defined in the project's export_presets.cfg file. If the preset name contains spaces or special characters (such as "Windows Desktop"), it must be surrounded with quotes.

To export a debug version of the game, use the --export-debug switch instead of --export-release. Their parameters and usage are the same.

To export only a PCK file, use the --export-pack option followed by the preset name and output path, with the file extension, instead of --export-release or --export-debug. The output path extension determines the package's format, either PCK or ZIP.

When specifying a relative path as the path for --export-release, --export-debug or --export-pack, the path will be relative to the directory containing the project.godot file, not relative to the current working directory.

It is possible to run a .gd script from the command line. This feature is especially useful in large projects, e.g. for batch conversion of assets or custom import/export.

The script must inherit from SceneTree or MainLoop.

Here is an example sayhello.gd, showing how it works:

If no project.godot exists at the path, current path is assumed to be the current working directory (unless --path is specified).

The script path will be interpreted as a resource path relative to the project, here res://sayhello.gd. You can also use an absolute filesystem path instead, which is useful if the script is located outside of the project directory.

The first line of sayhello.gd above is commonly referred to as a shebang. If the Godot binary is in your PATH as godot, it allows you to run the script as follows in modern Linux distributions, as well as macOS:

If the above doesn't work in your current version of Linux or macOS, you can always have the shebang run Godot straight from where it is located as follows:

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
# Add "Extras" bucket
scoop bucket add extras

# Standard editor:
scoop install godot

# Editor with C# support (will be available as `godot-mono` in `PATH`):
scoop install godot-mono
```

Example 2 (unknown):
```unknown
# Standard editor:
brew install godot

# Editor with C# support (will be available as `godot-mono` in `PATH`):
brew install godot-mono
```

Example 3 (unknown):
```unknown
godot path_to_your_project/project.godot [other] [commands] [and] [args]
```

Example 4 (unknown):
```unknown
godot --path path_to_your_project [other] [commands] [and] [args]
```

---

## Community channels — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/community/channels.html

**Contents:**
- Community channels
- Language-based communities
- User-contributed notes

So, where is the Godot community and where can you ask questions and get help?

This page used to list the various official and user-supported Godot communities. That list is now available on the Godot website.

See the User groups page of the website for a list of local communities.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Compiling for Android — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/compiling/compiling_for_android.html

**Contents:**
- Compiling for Android
- Note
- Requirements
- Setting up the buildsystem
- Building the export templates
  - Adding support for x86 devices
  - Cleaning the generated export templates
- Using the export templates
  - Installing the templates
- Building the Godot editor

This page describes how to compile Android export template binaries from source. If you're looking to export your project to Android instead, read Exporting for Android.

In most cases, using the built-in deployer and export templates is good enough. Compiling the Android APK manually is mostly useful for custom builds or custom packages for the deployer.

Also, you still need to follow the steps mentioned in the Exporting for Android tutorial before attempting to build a custom export template.

For compiling under Windows, Linux or macOS, the following is required:

SCons 4.0+ build system.

Android SDK (command-line tools are sufficient).

Required SDK components will be automatically installed.

On Linux, do not use an Android SDK provided by your distribution's repositories as it will often be outdated.

On macOS, do not use an Android SDK provided by Homebrew as it will not be installed in a unified location.

Gradle (will be downloaded and installed automatically if missing).

JDK 17 (either OpenJDK or Oracle JDK).

You can download a build from Adoptium.

To get the Godot source code for compiling, see Getting the source.

For a general overview of SCons usage for Godot, see Introduction to the buildsystem.

Set the environment variable ANDROID_HOME to point to the Android SDK. If you downloaded the Android command-line tools, this would be the folder where you extracted the contents of the ZIP archive.

Windows: Press Windows + R, type "control system", then click on Advanced system settings in the left pane, then click on Environment variables on the window that appears.

Linux or macOS: Add the text export ANDROID_HOME="/path/to/android-sdk" to your .bashrc or .zshrc where /path/to/android-sdk points to the root of the SDK directories.

Install the necessary SDK components in this folder:

Accept the SDK component licenses by running the following command where android_sdk_path is the path to the Android SDK, then answering all the prompts with y:

Complete setup by running the following command where android_sdk_path is the path to the Android SDK.

After setting up the SDK and environment variables, be sure to restart your terminal to apply the changes. If you are using an IDE with an integrated terminal, you need to restart the IDE.

Run scons platform=android. If this fails, go back and check the steps. If you completed the setup correctly, the NDK will begin downloading. If you are trying to compile GDExtension, you need to first compile the engine to download the NDK, then you can compile GDExtension.

Godot needs three export templates for Android: the optimized "release" template (android_release.apk), the debug template (android_debug.apk), and the Gradle build template (android_source.zip). As Google requires all APKs to include ARMv8 (64-bit) libraries since August 2019, the commands below build templates containing both ARMv7 and ARMv8 libraries.

Compiling the standard export templates is done by calling SCons from the Godot root directory with the following arguments:

Release template (used when exporting with Debugging Enabled unchecked)

Debug template (used when exporting with Debugging Enabled checked)

(Optional) Dev template (used when troubleshooting)

The resulting templates will be located under the bin directory:

bin/android_release.apk for the release template

bin/android_debug.apk for the debug template

bin/android_dev.apk for the dev template

bin/android_source.zip for the Gradle build template

If you are changing the list of architectures you're building, remember to add generate_android_binaries=yes to the last architecture you're building, so that the template files are generated after the build.

To include debug symbols in the generated templates, add the debug_symbols=yes parameters to the SCons command.

Note that you can include separate_debug_symbols=yes to generate the debug symbols in a separate *-native-debug-symbols.zip file.

If you want to enable Vulkan validation layers, see Vulkan validation layers on Android.

If you also want to include support for x86 and x86_64 devices, run the SCons command a third and fourth time with the arch=x86_32, and arch=x86_64 arguments before building the APK with Gradle. For example, for the release template:

This will create template binaries that works on all platforms. The final binary size of exported projects will depend on the platforms you choose to support when exporting; in other words, unused platforms will be removed from the binary.

You can use the following commands to remove the generated export templates:

Godot needs release and debug binaries that were compiled against the same version/commit as the editor. If you are using official binaries for the editor, make sure to install the matching export templates, or build your own from the same version.

When exporting your game, Godot uses the templates as a base, and updates their content as needed.

The newly-compiled templates (android_debug.apk , android_release.apk, and android_source.zip) must be copied to Godot's templates folder with their respective names. The templates folder can be located in:

Windows: %APPDATA%\Godot\export_templates\<version>\

Linux: $HOME/.local/share/godot/export_templates/<version>/

macOS: $HOME/Library/Application Support/Godot/export_templates/<version>/

<version> is of the form major.minor[.patch].status using values from version.py in your Godot source repository (e.g. 4.1.3.stable or 4.2.dev). You also need to write this same version string to a version.txt file located next to your export templates.

However, if you are writing your custom modules or custom C++ code, you might instead want to configure your template binaries as custom export templates in the project export menu. You must have Advanced Options enabled to set this.

You don't even need to copy them, you can just reference the resulting file in the bin\ directory of your Godot source folder, so that the next time you build you will automatically have the custom templates referenced.

Compiling the editor is done by calling SCons from the Godot root directory with the following arguments:

You can add the dev_build=yes parameter to generate a dev build of the Godot editor.

You can add the debug_symbols=yes parameters to include the debug symbols in the generated build.

Note that you can include separate_debug_symbols=yes to generate the debug symbols in a separate *-native-debug-symbols.zip file.

You can skip certain architectures depending on your target device to speed up compilation.

Remember to add generate_android_binaries=yes to the last architecture you're building, so that binaries are generated after the build.

The resulting binaries will be located under bin/android_editor_builds/.

You can use the following commands to remove the generated editor binaries:

With an Android device with Developer Options enabled, connect the Android device to your computer via its charging cable to a USB/USB-C port. Open up a Terminal/Command Prompt and run the following commands from the root directory with the following arguments:

Double-check that you've set the ANDROID_HOME environment variable. This is required for the platform to appear in SCons' list of detected platforms. See Setting up the buildsystem for more information.

Android might complain the application is not correctly installed. If so:

Check that the debug keystore is properly generated.

Check that the jarsigner executable is from JDK 8.

If it still fails, open a command line and run logcat:

Then check the output while the application is installed; the error message should be presented there. Seek assistance if you can't figure it out.

If the application runs but exits immediately, this might be due to one of the following reasons:

Make sure to use export templates that match your editor version; if you use a new Godot version, you have to update the templates too.

libgodot_android.so is not in libs/<arch>/ where <arch> is the device's architecture.

The device's architecture does not match the exported one(s). Make sure your templates were built for that device's architecture, and that the export settings included support for that architecture.

In any case, adb logcat should also show the cause of the error.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
cmdline-tools/latest/bin/sdkmanager --sdk_root=<android_sdk_path> --licenses
```

Example 2 (unknown):
```unknown
cmdline-tools/latest/bin/sdkmanager --sdk_root=<android_sdk_path> "platform-tools" "build-tools;35.0.0" "platforms;android-35" "cmdline-tools;latest" "cmake;3.10.2.4988404" "ndk;28.1.13356709"
```

Example 3 (unknown):
```unknown
scons platform=android target=template_release arch=arm32
scons platform=android target=template_release arch=arm64 generate_android_binaries=yes
```

Example 4 (unknown):
```unknown
scons platform=android target=template_debug arch=arm32
scons platform=android target=template_debug arch=arm64 generate_android_binaries=yes
```

---

## Compiling for iOS — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/compiling/compiling_for_ios.html

**Contents:**
- Compiling for iOS
- Requirements
- Compiling
- Run
- Troubleshooting
  - Fatal error: 'cstdint' file not found
- User-contributed notes

This page describes how to compile iOS export template binaries from source. If you're looking to export your project to iOS instead, read Exporting for iOS.

SCons 4.0+ build system.

Launch Xcode once and install iOS support. If you have already launched Xcode and need to install iOS support, go to Xcode -> Settings... -> Platforms.

Go to Xcode -> Settings... -> Locations -> Command Line Tools and select an installed version. Even if one is already selected, re-select it.

Download and follow README instructions to build a static .xcframework from the MoltenVK SDK.

If you have Homebrew installed, you can easily install SCons using the following command:

Installing Homebrew will also fetch the Command Line Tools for Xcode automatically if you don't have them already.

Similarly, if you have MacPorts installed, you can easily install SCons using the following command:

To get the Godot source code for compiling, see Getting the source.

For a general overview of SCons usage for Godot, see Introduction to the buildsystem.

Open a Terminal, go to the root folder of the engine source code and type the following to compile a debug build:

To compile a release build:

To create an Xcode project like in the official builds, you need to use the template located in misc/dist/ios_xcode. The release and debug libraries should be placed in libgodot.ios.debug.xcframework and libgodot.ios.release.xcframework respectively. This process can be automated by using the generate_bundle=yes option on the last SCons command used to build export templates (so that all binaries can be included).

The MoltenVK static .xcframework folder must also be placed in the ios_xcode folder once it has been created. MoltenVK is always statically linked on iOS; there is no dynamic linking option available, unlike macOS.

Compiling for the iOS simulator is currently not supported as per GH-102149.

Apple Silicon Macs can run iOS apps natively, so you can run exported iOS projects directly on an Apple Silicon Mac without needing the iOS simulator.

To run on a device, follow these instructions: Exporting for iOS.

iOS exports can run directly on an Apple Silicon Mac. To run exported iOS project on Mac, open exported project in Xcode and select My Mac in the Run Destinations dropdown.

If you get a compilation error of this form early on, it's likely because the Xcode command line tools installation needs to be repaired after a macOS or Xcode update:

Run these two commands to reinstall Xcode command line tools (enter your administrator password as needed):

If it still does not work, try updating Xcode from the Mac App Store and try again.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
brew install scons
```

Example 2 (unknown):
```unknown
sudo port install scons
```

Example 3 (unknown):
```unknown
scons platform=ios target=template_debug generate_bundle=yes
```

Example 4 (unknown):
```unknown
scons platform=ios target=template_release generate_bundle=yes
```

---

## Compiling for Linux, *BSD — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/compiling/compiling_for_linuxbsd.html

**Contents:**
- Compiling for Linux, *BSD
- Requirements
  - Distro-specific one-liners
- Compiling
- Running a headless/server build
- Building export templates
- Cross-compiling for RISC-V devices
- Using Clang and LLD for faster development
- Using mold for faster development
- Using system libraries for faster development

This page describes how to compile Linux editor and export template binaries from source. If you're looking to export your project to Linux instead, read Exporting for Linux.

For compiling under Linux or other Unix variants, the following is required:

SCons 4.0+ build system.

pkg-config (used to detect the development libraries listed below).

Development libraries:

X11, Xcursor, Xinerama, Xi and XRandR.

Wayland and wayland-scanner.

Optional - libudev (build with udev=yes).

To get the Godot source code for compiling, see Getting the source.

For a general overview of SCons usage for Godot, see Introduction to the buildsystem.

For audio support, you can optionally install pulseaudio.

Start a terminal, go to the root dir of the engine source code and type:

Prior to Godot 4.0, the Linux/*BSD target was called x11 instead of linuxbsd. If you are looking to compile Godot 3.x, make sure to use the 3.x branch of this documentation.

If you are compiling Godot to make changes or contribute to the engine, you may want to use the SCons options dev_build=yes or dev_mode=yes. See Development and production aliases for more info.

If all goes well, the resulting binary executable will be placed in the "bin" subdirectory. This executable file contains the whole engine and runs without any dependencies. Executing it will bring up the Project Manager.

If you wish to compile using Clang rather than GCC, use this command:

Using Clang appears to be a requirement for OpenBSD, otherwise fonts would not build. For RISC-V architecture devices, use the Clang compiler instead of the GCC compiler.

If you are compiling Godot for production use, you can make the final executable smaller and faster by adding the SCons option production=yes. This enables additional compiler optimizations and link-time optimization.

LTO takes some time to run and requires about 7 GB of available RAM while compiling. If you're running out of memory with the above option, use production=yes lto=none or production=yes lto=thin for a lightweight but less effective form of LTO.

If you want to use separate editor settings for your own Godot builds and official releases, you can enable Self-contained mode by creating a file called ._sc_ or _sc_ in the bin/ folder.

To run in headless mode which provides editor functionality to export projects in an automated manner, use the normal build:

And then use the --headless command line argument:

To compile a debug server build which can be used with remote debugging tools, use:

To compile a server build which is optimized to run dedicated game servers, use:

Linux binaries usually won't run on distributions that are older than the distribution they were built on. If you wish to distribute binaries that work on most distributions, you should build them on an old distribution such as Ubuntu 20.04. You can use a virtual machine or a container to set up a suitable build environment.

To build Linux or *BSD export templates, run the build system with the following parameters:

Note that cross-compiling for the opposite bits (64/32) as your host platform is not always straight-forward and might need a chroot environment.

To create standard export templates, the resulting files in the bin/ folder must be copied to:

and named like this (even for *BSD which is seen as "Linux/X11" by Godot):

However, if you are writing your custom modules or custom C++ code, you might instead want to configure your binaries as custom export templates in the project export menu. You must have Advanced Options enabled to set this.

You don't even need to copy them, you can just reference the resulting files in the bin/ directory of your Godot source folder, so the next time you build, you automatically have the custom templates referenced.

To cross-compile Godot for RISC-V devices, we need to setup the following items:

riscv-gnu-toolchain. While we are not going to use this directly, it provides us with a sysroot, as well as header and libraries files that we will need. There are many versions to choose from, however, the older the toolchain, the more compatible our final binaries will be. If in doubt, use this version, and download riscv64-glibc-ubuntu-20.04-gcc-nightly-2023.07.07-nightly.tar.gz. Extract it somewhere and remember its path.

mold. This fast linker, is the only one that correctly links the resulting binary. Download it, extract it, and make sure to add its bin folder to your PATH. Run mold --help | grep support to check if your version of Mold supports RISC-V. If you don't see RISC-V, your Mold may need to be updated.

To make referencing our toolchain easier, we can set an environment variable like this:

This way, we won't have to manually set the directory location each time we want to reference it.

With all the above setup, we are now ready to build Godot.

Go to the root of the source code, and execute the following build command:

RISC-V GCC has bugs with its atomic operations which prevent it from compiling Godot correctly. That's why Clang is used instead. Make sure that it can compile to RISC-V. You can verify by executing this command clang -print-targets, make sure you see riscv64 on the list of targets.

The code above includes adding $RISCV_TOOLCHAIN_PATH/bin to the PATH, but only for the following scons command. Since riscv-gnu-toolchain uses its own Clang located in the bin folder, adding $RISCV_TOOLCHAIN_PATH/bin to your user's PATH environment variable may block you from accessing another version of Clang if one is installed. For this reason it's not recommended to make adding the bin folder permanent. You can also omit the PATH="$RISCV_TOOLCHAIN_PATH/bin:$PATH" line if you want to use scons with self-installed version of Clang, but it may have compatibility issues with riscv-gnu-toolchain.

The command is similar in nature, but with some key changes. ccflags and linkflags append additional flags to the build. --sysroot points to a folder simulating a Linux system, it contains all the headers, libraries, and .so files Clang will use. --gcc-toolchain tells Clang where the complete toolchain is, and -target riscv64-unknown-linux-gnu indicates to Clang the target architecture, and OS we want to build for.

If all went well, you should now see a bin directory, and within it, a binary similar to the following:

You can now copy this executable to your favorite RISC-V device, then launch it there by double-clicking, which should bring up the project manager.

If you later decide to compile the export templates, copy the above build command but change the value of target to template_debug for a debug build, or template_release for a release build.

You can also use Clang and LLD to build Godot. This has two upsides compared to the default GCC + GNU ld setup:

LLD links Godot significantly faster compared to GNU ld or gold. This leads to faster iteration times.

Clang tends to give more useful error messages compared to GCC.

To do so, install Clang and the lld package from your distribution's package manager then use the following SCons command:

After the build is completed, a new binary with a .llvm suffix will be created in the bin/ folder.

It's still recommended to use GCC for production builds as they can be compiled using link-time optimization, making the resulting binaries smaller and faster.

If this error occurs:

There are two solutions:

In your SCons command, add the parameter use_static_cpp=no.

Follow these instructions to configure, build, and install libatomic_ops. Then, copy /usr/lib/libatomic_ops.a to /usr/lib/libatomic.a, or create a soft link to libatomic_ops by command ln -s /usr/lib/libatomic_ops.a /usr/lib/libatomic.a. The soft link can ensure the latest libatomic_ops will be used without the need to copy it every time when it is updated.

For even faster linking compared to LLD, you can use mold. mold can be used with either GCC or Clang.

As of January 2023, mold is not readily available in Linux distribution repositories, so you will have to install its binaries manually.

Download mold binaries from its releases page.

Extract the .tar.gz file, then move the extracted folder to a location such as .local/share/mold.

Add $HOME/.local/share/mold/bin to your user's PATH environment variable. For example, you can add the following line at the end of your $HOME/.bash_profile file:

Open a new terminal (or run source "$HOME/.bash_profile"), then use the following SCons command when compiling Godot:

Godot bundles the source code of various third-party libraries. You can choose to use system versions of third-party libraries instead. This makes the Godot binary faster to link, as third-party libraries are dynamically linked. Therefore, they don't need to be statically linked every time you build the engine (even on small incremental changes).

However, not all Linux distributions have packages for third-party libraries available (or they may not be up-to-date).

Moving to system libraries can reduce linking times by several seconds on slow CPUs, but it requires manual testing depending on your Linux distribution. Also, you may not be able to use system libraries for everything due to bugs in the system library packages (or in the build system, as this feature is less tested).

To compile Godot with system libraries, install these dependencies on top of the ones listed in the Distro-specific one-liners:

After installing all required packages, use the following command to build Godot:

On Debian stable, you will need to remove builtin_embree=no as the system-provided Embree version is too old to work with Godot's latest master branch (which requires Embree 4).

You can view a list of all built-in libraries that have system alternatives by running scons -h, then looking for options starting with builtin_.

When using system libraries, the resulting binary is not portable across Linux distributions anymore. Do not use this approach for creating binaries you intend to distribute to others, unless you're creating a package for a Linux distribution.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
apk add \
  scons \
  pkgconf \
  gcc \
  g++ \
  libx11-dev \
  libxcursor-dev \
  libxinerama-dev \
  libxi-dev \
  libxrandr-dev \
  mesa-dev \
  eudev-dev \
  alsa-lib-dev \
  pulseaudio-dev
```

Example 2 (unknown):
```unknown
pacman -Sy --noconfirm --needed \
  scons \
  pkgconf \
  gcc \
  libxcursor \
  libxinerama \
  libxi \
  libxrandr \
  wayland-utils \
  mesa \
  glu \
  libglvnd \
  alsa-lib \
  pulseaudio
```

Example 3 (unknown):
```unknown
sudo apt-get update
sudo apt-get install -y \
  build-essential \
  scons \
  pkg-config \
  libx11-dev \
  libxcursor-dev \
  libxinerama-dev \
  libgl1-mesa-dev \
  libglu1-mesa-dev \
  libasound2-dev \
  libpulse-dev \
  libudev-dev \
  libxi-dev \
  libxrandr-dev \
  libwayland-dev
```

Example 4 (unknown):
```unknown
sudo dnf install -y \
  scons \
  pkgconfig \
  gcc-c++ \
  libstdc++-static \
  wayland-devel
```

---

## Compiling for macOS — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/compiling/compiling_for_macos.html

**Contents:**
- Compiling for macOS
- Requirements
- Compiling
  - Automatic .app bundle creation
  - Manual .app bundle creation
- Running a headless/server build
- Building export templates
- Cross-compiling for macOS from Linux
- Troubleshooting
  - Fatal error: 'cstdint' file not found

This page describes how to compile macOS editor and export template binaries from source. If you're looking to export your project to macOS instead, read Exporting for macOS.

For compiling under macOS, the following is required:

SCons 4.0+ build system.

Xcode (or the more lightweight Command Line Tools for Xcode).

Vulkan SDK for MoltenVK (macOS doesn't support Vulkan out of the box). The latest Vulkan SDK version can be installed quickly by running misc/scripts/install_vulkan_sdk_macos.sh within the Godot source repository.

If you have Homebrew installed, you can easily install SCons using the following command:

Installing Homebrew will also fetch the Command Line Tools for Xcode automatically if you don't have them already.

Similarly, if you have MacPorts installed, you can easily install SCons using the following command:

To get the Godot source code for compiling, see Getting the source.

For a general overview of SCons usage for Godot, see Introduction to the buildsystem.

Start a terminal, go to the root directory of the engine source code.

To compile for Intel (x86-64) powered Macs, use:

To compile for Apple Silicon (ARM64) powered Macs, use:

If you are compiling Godot to make changes or contribute to the engine, you may want to use the SCons options dev_build=yes or dev_mode=yes. See Development and production aliases for more info.

If all goes well, the resulting binary executable will be placed in the bin/ subdirectory. This executable file contains the whole engine and runs without any dependencies. Executing it will bring up the Project Manager.

Using a standalone editor executable is not recommended, it should be always packaged into a .app bundle to avoid UI activation issues.

If you want to use separate editor settings for your own Godot builds and official releases, you can enable Self-contained mode by creating a file called ._sc_ or _sc_ in the bin/ folder.

To automatically create a .app bundle like in the official builds, use the generate_bundle=yes option on the last SCons command used to build editor:

To support both architectures in a single "Universal 2" binary, run the above two commands and then use lipo to bundle them together:

To create a .app bundle, you need to use the template located in misc/dist/macos_tools.app. Typically, for an optimized editor binary built with dev_build=yes:

If you are building the master branch, you also need to include support for the MoltenVK Vulkan portability library. By default, it will be linked statically from your installation of the Vulkan SDK for macOS. You can also choose to link it dynamically by passing use_volk=yes and including the dynamic library in your .app bundle:

To run in headless mode which provides editor functionality to export projects in an automated manner, use the normal build:

And then use the --headless command line argument:

To compile a debug server build which can be used with remote debugging tools, use:

To compile a release server build which is optimized to run dedicated game servers, use:

To build macOS export templates, you have to compile using the targets without the editor: target=template_release (release template) and target=template_debug.

Official templates are Universal 2 binaries which support both ARM64 and Intel x86_64 architectures.

To support ARM64 (Apple Silicon) + Intel x86_64:

To support ARM64 (Apple Silicon) only (smaller file size, but less compatible with older hardware):

To create a .app bundle like in the official builds, you need to use the template located in misc/dist/macos_template.app. This process can be automated by using the generate_bundle=yes option on the last SCons command used to build export templates (so that all binaries can be included). This option also takes care of calling lipo to create a Universal 2 binary from two separate ARM64 and x86_64 binaries (if both were compiled beforehand).

You also need to include support for the MoltenVK Vulkan portability library. By default, it will be linked statically from your installation of the Vulkan SDK for macOS. You can also choose to link it dynamically by passing use_volk=yes and including the dynamic library in your .app bundle:

In most cases, static linking should be preferred as it makes distribution easier. The main upside of dynamic linking is that it allows updating MoltenVK without having to recompile export templates.

You can then zip the macos_template.app folder to reproduce the macos.zip template from the official Godot distribution:

It is possible to compile for macOS in a Linux environment (and maybe also in Windows using the Windows Subsystem for Linux). For that, you'll need to install OSXCross to be able to use macOS as a target. First, follow the instructions to install it:

Clone the OSXCross repository somewhere on your machine (or download a ZIP file and extract it somewhere), e.g.:

Follow the instructions to package the SDK: https://github.com/tpoechtrager/osxcross#packaging-the-sdk

Follow the instructions to install OSXCross: https://github.com/tpoechtrager/osxcross#installation

After that, you will need to define the OSXCROSS_ROOT as the path to the OSXCross installation (the same place where you cloned the repository/extracted the zip), e.g.:

Now you can compile with SCons like you normally would:

If you have an OSXCross SDK version different from the one expected by the SCons buildsystem, you can specify a custom one with the osxcross_sdk argument:

If you get a compilation error of this form early on, it's likely because the Xcode command line tools installation needs to be repaired after a macOS or Xcode update:

Run these two commands to reinstall Xcode command line tools (enter your administrator password as needed):

If it still does not work, try updating Xcode from the Mac App Store and try again.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
brew install scons
```

Example 2 (unknown):
```unknown
sudo port install scons
```

Example 3 (unknown):
```unknown
scons platform=macos arch=x86_64
```

Example 4 (unknown):
```unknown
scons platform=macos arch=arm64
```

---

## Compiling for the Web — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/compiling/compiling_for_web.html

**Contents:**
- Compiling for the Web
- Requirements
- Building export templates
- GDExtension
- Building the editor
- User-contributed notes

This page describes how to compile HTML5 editor and export template binaries from source. If you're looking to export your project to HTML5 instead, read Exporting for the Web.

To compile export templates for the Web, the following is required:

SCons 4.0+ build system.

To get the Godot source code for compiling, see Getting the source.

For a general overview of SCons usage for Godot, see Introduction to the buildsystem.

Before starting, confirm that emcc is available in your PATH. This is usually configured by the Emscripten SDK, e.g. when invoking emsdk activate and source ./emsdk_env.sh/emsdk_env.bat.

Open a terminal and navigate to the root directory of the engine source code. Then instruct SCons to build the Web platform. Specify target as either template_release for a release build or template_debug for a debug build:

By default, the JavaScriptBridge singleton will be built into the engine. Official export templates also have the JavaScript singleton enabled. Since eval() calls can be a security concern, the javascript_eval option can be used to build without the singleton:

By default, WebWorker threads support is enabled. To disable it and only use a single thread, the threads option can be used to build the web template without threads support:

The engine will now be compiled to WebAssembly by Emscripten. Once finished, the resulting file will be placed in the bin subdirectory. Its name is godot.web.template_release.wasm32.zip for release or godot.web.template_debug.wasm32.zip for debug.

Finally, rename the zip archive to web_release.zip for the release template:

And web_debug.zip for the debug template:

The default export templates do not include GDExtension support for performance and compatibility reasons. See the export page for more info.

You can build the export templates using the option dlink_enabled=yes to enable GDExtension support:

Once finished, the resulting file will be placed in the bin subdirectory. Its name will have _dlink added.

Finally, rename the zip archives to web_dlink_release.zip and web_dlink_release.zip for the release template:

It is also possible to build a version of the Godot editor that can run in the browser. The editor version is not recommended over the native build. You can build the editor with:

Once finished, the resulting file will be placed in the bin subdirectory. Its name will be godot.web.editor.wasm32.zip. You can upload the zip content to your web server and visit it with your browser to use the editor.

Refer to the export page for the web server requirements.

The Godot repository includes a Python script to host a local web server. This can be used to test the web editor locally.

After compiling the editor, extract the ZIP archive that was created in the bin/ folder, then run the following command in the Godot repository root:

This will serve the contents of the bin/ folder and open the default web browser automatically. In the page that opens, access godot.editor.html and you should be able to test the web editor this way.

Note that for production use cases, this Python-based web server should not be used. Instead, you should use an established web server such as Apache or nginx.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
scons platform=web target=template_release
scons platform=web target=template_debug
```

Example 2 (unknown):
```unknown
scons platform=web target=template_release javascript_eval=no
scons platform=web target=template_debug javascript_eval=no
```

Example 3 (unknown):
```unknown
scons platform=web target=template_release threads=no
scons platform=web target=template_debug threads=no
```

Example 4 (unknown):
```unknown
mv bin/godot.web.template_release.wasm32.zip bin/web_release.zip
```

---

## Compiling for visionOS — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/compiling/compiling_for_visionos.html

**Contents:**
- Compiling for visionOS
- User-contributed notes

This page describes how to compile visionOS export template binaries from source. If you're looking to export your project to visionOS instead, see Exporting for visionOS.

Compiling instructions for visionOS are currently identical to Compiling for iOS, except you should replace instances of platform=ios with platform=visionos in the SCons options. See the linked page for details.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Compiling for Windows — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/compiling/compiling_for_windows.html

**Contents:**
- Compiling for Windows
- Requirements
- Setting up SCons
- Downloading Godot's source
- Compiling
  - Selecting a compiler
  - Running SCons
- Compiling with support for Direct3D 12
- Compiling with ANGLE support
- Development in Visual Studio

This page describes how to compile Windows editor and export template binaries from source. If you're looking to export your project to Windows instead, read Exporting for Windows.

For compiling under Windows, the following is required:

A C++ compiler. Use one of the following:

Visual Studio Community, version 2019 or later. Visual Studio 2022 is recommended. Make sure to enable C++ in the list of workflows to install. If you've already installed Visual Studio without C++ support, run the installer again; it should present you a Modify button. Supports x86_64, x86_32, and arm64.

MinGW-w64 with GCC can be used as an alternative to Visual Studio. Be sure to install/configure it to use the posix thread model. Important: When using MinGW to compile the master branch, you need GCC 9 or later. Supports x86_64 and x86_32 only.

MinGW-LLVM with clang can be used as an alternative to Visual Studio and MinGW-w64. Supports x86_64, x86_32, and arm64.

Python 3.8+. Make sure to enable the option to add Python to the PATH in the installer.

SCons 4.0+ build system. Using the latest release is recommended, especially for proper support of recent Visual Studio releases.

If you have Scoop installed, you can easily install MinGW and other dependencies using the following command:

Scons will still need to be installed via pip

If you have MSYS2 installed, you can easily install MinGW and other dependencies using the following command:

For each MSYS2 MinGW subsystem, you should then run pip3 install scons in its shell.

To get the Godot source code for compiling, see Getting the source.

For a general overview of SCons usage for Godot, see Introduction to the buildsystem.

To install SCons, open the command prompt and run the following command:

If you are prompted with the message Defaulting to user installation because normal site-packages is not writeable, you may have to run that command again using elevated permissions. Open a new command prompt as an Administrator then run the command again to ensure that SCons is available from the PATH.

To check whether you have installed Python and SCons correctly, you can type python --version and scons --version into a command prompt (cmd.exe).

If the commands above don't work, make sure to add Python to your PATH environment variable after installing it, then check again. You can do so by running the Python installer again and enabling the option to add Python to the PATH.

If SCons cannot detect your Visual Studio installation, it might be that your SCons version is too old. Update it to the latest version with python -m pip install --upgrade scons.

Refer to Getting the source for detailed instructions.

The tutorial will assume from now on that you placed the source code in C:\godot.

To prevent slowdowns caused by continuous virus scanning during compilation, add the Godot source folder to the list of exceptions in your antivirus software.

For Windows Defender, hit the Windows key, type "Windows Security" then hit Enter. Click on Virus & threat protection on the left panel. Under Virus & threat protection settings click on Manage Settings and scroll down to Exclusions. Click Add or remove exclusions then add the Godot source folder.

SCons will automatically find and use an existing Visual Studio installation. If you do not have Visual Studio installed, it will attempt to use MinGW instead. If you already have Visual Studio installed and want to use MinGW-w64, pass use_mingw=yes to the SCons command line. Note that MSVC builds cannot be performed from the MSYS2 or MinGW shells. Use either cmd.exe or PowerShell instead. If you are using MinGW-LLVM, pass both use_mingw=yes and use_llvm=yes to the SCons command line.

During development, using the Visual Studio compiler is usually a better idea, as it links the Godot binary much faster than MinGW. However, MinGW can produce more optimized binaries using link-time optimization (see below), making it a better choice for production use. This is particularly the case for the GDScript VM which performs much better with MinGW compared to MSVC. Therefore, it's recommended to use MinGW to produce builds that you distribute to players.

All official Godot binaries are built in custom containers using MinGW.

After opening a command prompt, change to the root directory of the engine source code (using cd) and type:

When compiling with multiple CPU threads, SCons may warn about pywin32 being missing. You can safely ignore this warning.

If you are compiling Godot to make changes or contribute to the engine, you may want to use the SCons options dev_build=yes or dev_mode=yes. See Development and production aliases for more info.

If all goes well, the resulting binary executable will be placed in C:\godot\bin\ with the name godot.windows.editor.x86_32.exe or godot.windows.editor.x86_64.exe. By default, SCons will build a binary matching your CPU architecture, but this can be overridden using arch=x86_64, arch=x86_32, or arch=arm64.

This executable file contains the whole engine and runs without any dependencies. Running it will bring up the Project Manager.

If you are compiling Godot for production use, you can make the final executable smaller and faster by adding the SCons option production=yes. This enables additional compiler optimizations and link-time optimization.

LTO takes some time to run and requires up to 30 GB of available RAM while compiling (depending on toolchain). If you're running out of memory with the above option, use production=yes lto=none or production=yes lto=thin (LLVM only) for a lightweight but less effective form of LTO.

If you want to use separate editor settings for your own Godot builds and official releases, you can enable Self-contained mode by creating a file called ._sc_ or _sc_ in the bin/ folder.

By default, builds of Godot do not contain support for the Direct3D 12 graphics API.

You can install the required dependencies by running python misc/scripts/install_d3d12_sdk_windows.py in the Godot source repository. After running this script, add the d3d12=yes SCons option to enable Direct3D 12 support. This will use the default paths for the various dependencies, which match the ones used in the script.

You can find the detailed steps below if you wish to set up dependencies manually, but the above script handles everything for you (including the optional PIX and Agility SDK components).

godot-nir-static library. We compile the Mesa libraries you will need into a static library. Download it anywhere, unzip it and remember the path to the unzipped folder, you will need it below.

You can optionally build the godot-nir-static libraries yourself with the following steps:

Install the Python package mako which is needed to generate some files.

Clone the godot-nir-static directory and navigate to it.

Optionally, you can compile with the following for additional features:

PIX is a performance tuning and debugging application for Direct3D12 applications. If you compile-in support for it, you can get much more detailed information through PIX that will help you optimize your game and troubleshoot graphics bugs. To use it, download the WinPixEventRuntime package. You will be taken to a NuGet package page where you can click "Download package" to get it. Once downloaded, change the file extension to .zip and unzip the file to some path.

Agility SDK can be used to provide access to the latest Direct3D 12 features without relying on driver updates. To use it, download the latest Agility SDK package. You will be taken to a NuGet package page where you can click "Download package" to get it. Once downloaded, change the file extension to .zip and unzip the file to some path.

If you use a preview version of the Agility SDK, remember to enable developer mode in Windows; otherwise it won't be used.

If you want to use a PIX with MinGW build, navigate to PIX runtime directory and use the following commands to generate import library:

When building Godot, you will need to tell SCons to use Direct3D 12 and where to look for the additional libraries:

Or, with all options enabled:

For the Agility SDK's DLLs you have to explicitly choose the kind of workflow. Single-arch is the default (DLLs copied to bin/). If you pass agility_sdk_multi_arch=yes to SCons, you'll opt-in for multi-arch. DLLs will be copied to the appropriate bin/<arch>/ subdirectories and at runtime the right one will be loaded.

ANGLE provides a translation layer from OpenGL ES 3.x to Direct3D 11 and can be used to improve support for the Compatibility renderer on some older GPUs with outdated OpenGL drivers and on Windows for ARM.

By default, Godot is built with dynamically linked ANGLE, you can use it by placing libEGL.dll and libGLESv2.dll alongside the executable.

You can use dynamically linked ANGLE with export templates as well, rename aforementioned DLLs to libEGL.{architecture}.dll and libGLESv2.{architecture}.dll and place them alongside export template executables, and libraries will be automatically copied during the export process.

To compile Godot with statically linked ANGLE:

Download pre-built static libraries from godot-angle-static library, and unzip them.

When building Godot, add angle_libs={path} to tell SCons where to look for the ANGLE libraries:

You can optionally build the godot-angle-static libraries yourself with the following steps:

Clone the godot-angle-static directory and navigate to it.

Run the following command:

Using an IDE is not required to compile Godot, as SCons takes care of everything. But if you intend to do engine development or debugging of the engine's C++ code, you may be interested in configuring a code editor or an IDE.

Folder-based editors don't require any particular setup to start working with Godot's codebase. To edit projects with Visual Studio they need to be set up as a solution.

You can create a Visual Studio solution via SCons by running SCons with the vsproj=yes parameter, like this:

You will be able to open Godot's source in a Visual Studio solution now, and able to build Godot using Visual Studio's Build button.

See Visual Studio for further details.

If you get a compilation failure when using MSVC, make sure to apply the latest updates. You can do so by starting the Visual Studio IDE and using Continue without code, then Help > Check for Updates in the menu bar at the top. Install all updates, then try compiling again.

If you are a Linux or macOS user, you need to install MinGW-w64, which typically comes in 32-bit and 64-bit variants, or MinGW-LLVM, which comes as a single archive for all target architectures. The package names may differ based on your distribution, here are some known ones:

Before attempting the compilation, SCons will check for the following binaries in your PATH environment variable:

If the binaries are not located in the PATH (e.g. /usr/bin), you can define the following environment variable to give a hint to the build system:

Where /path/to/mingw is the path containing the bin directory where i686-w64-mingw32-gcc and x86_64-w64-mingw32-gcc are located (e.g. /opt/mingw-w64 if the binaries are located in /opt/mingw-w64/bin).

To make sure you are doing things correctly, executing the following in the shell should result in a working compiler (the version output may differ based on your system):

If you are building with MinGW-LLVM, add use_llvm=yes to the scons command.

When cross-compiling for Windows using MinGW-w64, keep in mind only x86_64 and x86_32 architectures are supported. MinGW-LLVM supports arm64 as well. Be sure to specify the right arch= option when invoking SCons if building from a different architecture.

Cross-compiling from some Ubuntu versions may lead to this bug, due to a default configuration lacking support for POSIX threading.

You can change that configuration following those instructions, for 64-bit:

Windows export templates are created by compiling Godot without the editor, with the following flags:

If you plan on replacing the standard export templates, copy these to the following location, replacing <version> with the version identifier (such as 4.2.1.stable or 4.3.dev):

With the following names:

However, if you are using custom modules or custom engine code, you may instead want to configure your binaries as custom export templates in the project export menu. You must have Advanced Options enabled to set this.

You don't need to copy them in this case, just reference the resulting files in the bin\ directory of your Godot source folder, so the next time you build, you will automatically have the custom templates referenced.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
scoop install python mingw
```

Example 2 (unknown):
```unknown
pacman -S mingw-w64-x86_64-gcc mingw-w64-i686-gcc make python-pip
```

Example 3 (unknown):
```unknown
python -m pip install scons
```

Example 4 (unknown):
```unknown
C:\godot> scons platform=windows
```

---

## Compiling with .NET — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/compiling/compiling_with_dotnet.html

**Contents:**
- Compiling with .NET
- Requirements
- Enable the .NET module
- Generate the glue
- Building the managed libraries
  - Build Platform
  - NuGet packages
  - Building without depending on deprecated features (NO_DEPRECATED)
  - Double Precision Support (REAL_T_IS_DOUBLE)
- Examples

You can use dotnet --info to check which .NET SDK versions are installed.

C# support for Godot has historically used the Mono runtime instead of the .NET Runtime and internally many things are still named mono instead of dotnet or otherwise referred to as mono.

By default, the .NET module is disabled when building. To enable it, add the option module_mono_enabled=yes to the SCons command line, while otherwise following the instructions for building the desired Godot binaries.

Parts of the sources of the managed libraries are generated from the ClassDB. These source files must be generated before building the managed libraries. They can be generated by any .NET-enabled Godot editor binary by running it with the parameters --headless --generate-mono-glue followed by the path to an output directory. This path must be modules/mono/glue in the Godot directory:

This command will tell Godot to generate the C# bindings for the Godot API at modules/mono/glue/GodotSharp/GodotSharp/Generated, and the C# bindings for the editor tools at modules/mono/glue/GodotSharp/GodotSharpEditor/Generated. Once these files are generated, you can build Godot's managed libraries for all the desired targets without having to repeat this process.

<godot_binary> refers to the editor binary you compiled with the .NET module enabled. Its exact name will differ based on your system and configuration, but should be of the form bin/godot.<platform>.editor.<arch>.mono, e.g. bin/godot.linuxbsd.editor.x86_64.mono or bin/godot.windows.editor.x86_32.mono.exe. Be especially aware of the .mono suffix! If you've previously compiled Godot without .NET support, you might have similarly named binaries without this suffix. These binaries can't be used to generate the .NET glue.

The glue sources must be regenerated every time the ClassDB-registered API changes. That is, for example, when a new method is registered to the scripting API or one of the parameters of such a method changes. Godot will print an error at startup if there is an API mismatch between ClassDB and the glue sources.

Once you have generated the .NET glue, you can build the managed libraries with the build_assemblies.py script:

If everything went well, the GodotSharp directory, containing the managed libraries, should have been created in the bin directory.

By default, all development builds share a version number, which can cause some issues with caching of the NuGet packages. To solve this issue either use GODOT_VERSION_STATUS to give every build a unique version or delete GodotNuGetFallbackFolder after every build to clear the package cache.

Unlike "classical" Godot builds, when building with the .NET module enabled (and depending on the target platform), a data directory may be created both for the editor and for exported projects. This directory is important for proper functioning and must be distributed together with Godot. More details about this directory in Data directory.

Provide the --godot-platform=<platform> argument to control for which platform specific the libraries are built. Omit this argument to build for the current system.

This currently only controls the inclusion of the support for Visual Studio as an external editor, the libraries are otherwise identical.

The API assemblies, source generators, and custom MSBuild project SDK are distributed as NuGet packages. This is all transparent to the user, but it can make things complicated during development.

In order to use Godot with a development version of those packages, a local NuGet source must be created where MSBuild can find them.

First, pick a location for the local NuGet source. If you don't have a preference, create an empty directory at one of these recommended locations:

On Windows, C:\Users\<username>\MyLocalNugetSource

On Linux, *BSD, etc., ~/MyLocalNugetSource

This path is referred to later as <my_local_source>.

After picking a directory, run this .NET CLI command to configure NuGet to use your local source:

When you run the build_assemblies.py script, pass <my_local_source> to the --push-nupkgs-local option:

This option ensures the packages will be added to the specified local NuGet source and that conflicting versions of the package are removed from the NuGet cache. It's recommended to always use this option when building the C# solutions during development to avoid mistakes.

When building Godot without deprecated classes and functions, i.e. the deprecated=no argument for scons, the managed libraries must also be built without dependencies to deprecated code. This is done by passing the --no-deprecated argument:

When building Godot with double precision support, i.e. the precision=double argument for scons, the managed libraries must be adjusted to match by passing the --precision=double argument:

The data directory is a dependency for Godot binaries built with the .NET module enabled. It contains important files for the correct functioning of Godot. It must be distributed together with the Godot executable.

The name of the data directory for the Godot editor will always be GodotSharp. This directory contains an Api subdirectory with the Godot API assemblies and a Tools subdirectory with the tools required by the editor, like the GodotTools assemblies and its dependencies.

On macOS, if the Godot editor is distributed as a bundle, the GodotSharp directory may be placed in the <bundle_name>.app/Contents/Resources/ directory inside the bundle.

The data directory for exported projects is generated by the editor during the export. It is named data_<APPNAME>_<ARCH>, where <APPNAME> is the application name as specified in the project setting application/config/name and <ARCH> is the current architecture of the export.

In the case of multi-architecture exports multiple such data directories will be generated.

The following is the list of command-line options available when building with the .NET module:

module_mono_enabled=yes | no

Build Godot with the .NET module enabled.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
<godot_binary> --headless --generate-mono-glue modules/mono/glue
```

Example 2 (unknown):
```unknown
./modules/mono/build_scripts/build_assemblies.py --godot-output-dir=./bin
```

Example 3 (unknown):
```unknown
dotnet nuget add source <my_local_source> --name MyLocalNugetSource
```

Example 4 (unknown):
```unknown
./modules/mono/build_scripts/build_assemblies.py --godot-output-dir ./bin --push-nupkgs-local <my_local_source>
```

---

## Compiling with PCK encryption key — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/compiling/compiling_with_script_encryption_key.html

**Contents:**
- Compiling with PCK encryption key
- Step by step
- Troubleshooting
- User-contributed notes

The export dialog gives you the option to encrypt your PCK file with a 256-bit AES key when releasing your project. This will make sure your scenes, scripts and other resources are not stored in plain text and can not easily be ripped by some script kiddie.

Of course, the key needs to be stored in the binary, but if it's compiled, optimized and without symbols, it would take some effort to find it.

For this to work, you need to build the export templates from source, with that same key.

This will not work if you use official, precompiled export templates. It is absolutely required to compile your own export templates to use PCK encryption.

Generate a 256-bit AES key in hexadecimal format. You can use the aes-256-cbc variant from this service.

Alternatively, you can generate it yourself using OpenSSL command-line tools:

The output in godot.gdkey should be similar to:

You can generate the key without redirecting the output to a file, but that way you can minimize the risk of exposing the key.

Set this key as environment variable in the console that you will use to compile Godot, like this:

Compile Godot export templates and set them as custom export templates in the export preset options.

Set the encryption key in the Encryption tab of the export preset:

Add filters for the files/folders to encrypt. By default, include filters are empty and nothing will be encrypted.

Export the project. The project should run with the files encrypted now.

If you get an error like below, it means the key wasn't properly included in your Godot build. Godot is encrypting PCK file during export, but can't read it at runtime.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
openssl rand -hex 32 > godot.gdkey
```

Example 2 (unknown):
```unknown
# NOTE: Do not use the key below! Generate your own key instead.
aeb1bc56aaf580cc31784e9c41551e9ed976ecba10d315db591e749f3f64890f
```

Example 3 (unknown):
```unknown
export SCRIPT_AES256_ENCRYPTION_KEY="your_generated_key"
```

Example 4 (unknown):
```unknown
set SCRIPT_AES256_ENCRYPTION_KEY=your_generated_key
```

---

## Complying with licenses — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/about/complying_with_licenses.html

**Contents:**
- Complying with licenses
- What are licenses?
- Requirements
- Inclusion
  - Credits screen
  - Licenses screen
  - Output log
  - Accompanying file
  - Printed manual
  - Link to the license

The recommendations in this page are not legal advice. They are provided in good faith to help users navigate license attribution requirements.

Godot is created and distributed under the MIT License. It doesn't have a sole owner, as every contributor that submits code to the project does it under this same license and keeps ownership of their contribution.

The license is the legal requirement for you (or your company) to use and distribute the software (and derivative projects, including games made with it). Your game or project can have a different license, but it still needs to comply with the original one.

This section covers compliance with licenses from a user perspective. If you are interested in licence compliance as a contributor, you can find guidelines here.

Alongside the Godot license text, remember to also list third-party notices for assets you're using, such as textures, models, sounds, music and fonts. This includes free assets, which often come with licenses that require attribution.

In the case of the MIT license, the only requirement is to include the license text somewhere in your game or derivative project.

This text reads as follows:

Beside its own MIT license, Godot includes code from a number of third-party libraries. See Third-party licenses for details.

Your games do not need to be under the same license. You are free to release your Godot projects under any license and to create commercial games with the engine.

The license text must be made available to the user. The license doesn't specify how the text has to be included, but here are the most common approaches (you only need to implement one of them, not all).

Include the above license text somewhere in the credits screen. It can be at the bottom after showing the rest of the credits. Most large studios use this approach with open source licenses.

Some games have a special menu (often in the settings) to display licenses. This menu is typically accessed with a button called Third-party Licenses or Open Source Licenses.

Printing the license text using the print() function may be enough on platforms where a global output log is readable. This is the case on desktop platforms, Android and HTML5 (but not iOS).

If the game is distributed on desktop platforms, a file containing the license text can be added to the software that is installed to the user PC.

If the game includes a printed manual, the license text can be included there.

The Godot Engine developers consider that a link to godotengine.org/license in your game documentation or credits would be an acceptable way to satisfy the license terms.

Godot provides several methods to get license information in the Engine singleton. This allows you to source the license information directly from the engine binary, which prevents the information from becoming outdated if you update engine versions.

For the engine itself:

Engine.get_license_text

For third-party components used by the engine:

Engine.get_license_info

Engine.get_copyright_info

Godot itself contains software written by third parties, which is compatible with, but not covered by Godot's MIT license.

Many of these dependencies are distributed under permissive open source licenses which require attribution by explicitly citing their copyright statement and license text in the final product's documentation.

Given the scope of the Godot project, this is fairly difficult to do thoroughly. For the Godot editor, the full documentation of third-party copyrights and licenses is provided in the COPYRIGHT.txt file.

A good option for end users to document third-party licenses is to include this file in your project's distribution, which you can e.g. rename to GODOT_COPYRIGHT.txt to prevent any confusion with your own code and assets.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
This game uses Godot Engine, available under the following license:

Copyright (c) 2014-present Godot Engine contributors.
Copyright (c) 2007-2014 Juan Linietsky, Ariel Manzur.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

---

## Configuring an IDE — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/configuring_an_ide/index.html

**Contents:**
- Configuring an IDE

We assume that you have already cloned and compiled Godot.

You can easily develop Godot with any text editor and by invoking scons on the command line, but if you want to work with an IDE (Integrated Development Environment), here are setup instructions for some popular ones:

It is possible to use other IDEs, but their setup is not documented yet.

If your editor supports the language server protocol, you can use clangd for completion, diagnostics, and more. You can generate a compilation database for use with clangd one of two ways:

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
# Generate compile_commands.json while compiling
scons compiledb=yes

# Generate compile_commands.json without compiling
scons compiledb=yes compile_commands.json
```

---

## Controllers, gamepads, and joysticks — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/inputs/controllers_gamepads_joysticks.html

**Contents:**
- Controllers, gamepads, and joysticks
- Supporting universal input
  - Which Input singleton method should I use?
- Vibration
- Differences between keyboard/mouse and controller input
  - Dead zone
  - "Echo" events
  - Window focus
  - Power saving prevention
- Troubleshooting

Godot supports hundreds of controller models out of the box. Controllers are supported on Windows, macOS, Linux, Android, iOS, and Web.

Since Godot 4.5, the engine relies on SDL 3 for controller support on Windows, macOS, and Linux. This means the list of supported controllers and their behavior should closely match what is available in other games and engines using SDL 3. Note that SDL is only used for input, not for windowing or sound.

Prior to Godot 4.5, the engine used its own controller support code. This can cause certain controllers to behave incorrectly. This custom code is still used to support controllers on Android, iOS, and Web, so it may result in issues appearing only on those platforms.

Note that more specialized devices such as steering wheels, rudder pedals and HOTAS are less tested and may not always work as expected. Overriding force feedback for those devices is also not implemented yet. If you have access to one of those devices, don't hesitate to report bugs on GitHub.

In this guide, you will learn:

How to write your input logic to support both keyboard and controller inputs.

How controllers can behave differently from keyboard/mouse input.

Troubleshooting issues with controllers in Godot.

Thanks to Godot's input action system, Godot makes it possible to support both keyboard and controller input without having to write separate code paths. Instead of hardcoding keys or controller buttons in your scripts, you should create input actions in the Project Settings which will then refer to specified key and controller inputs.

Input actions are explained in detail on the Using InputEvent page.

Unlike keyboard input, supporting both mouse and controller input for an action (such as looking around in a first-person game) will require different code paths since these have to be handled separately.

There are 3 ways to get input in an analog-aware way:

When you have two axes (such as joystick or WASD movement) and want both axes to behave as a single input, use Input.get_vector():

When you have one axis that can go both ways (such as a throttle on a flight stick), or when you want to handle separate axes individually, use Input.get_axis():

For other types of analog input, such as handling a trigger or handling one direction at a time, use Input.get_action_strength():

For non-analog digital/boolean input (only "pressed" or "not pressed" values), such as controller buttons, mouse buttons or keyboard keys, use Input.is_action_pressed():

If you need to know whether an input was just pressed in the previous frame, use Input.is_action_just_pressed() instead of Input.is_action_pressed(). Unlike Input.is_action_pressed() which returns true as long as the input is held, Input.is_action_just_pressed() will only return true for one frame after the button has been pressed.

Vibration (also called haptic feedback) can be used to enhance the feel of a game. For instance, in a racing game, you can convey the surface the car is currently driving on through vibration, or create a sudden vibration on a crash.

Use the Input singleton's start_joy_vibration method to start vibrating a gamepad. Use stop_joy_vibration to stop vibration early (useful if no duration was specified when starting).

On mobile devices, you can also use vibrate_handheld to vibrate the device itself (independently from the gamepad). On Android, this requires the VIBRATE permission to be enabled in the Android export preset before exporting the project.

Vibration can be uncomfortable for certain players. Make sure to provide an in-game slider to disable vibration or reduce its intensity.

If you're used to handling keyboard and mouse input, you may be surprised by how controllers handle specific situations.

Unlike keyboards and mice, controllers offer axes with analog inputs. The upside of analog inputs is that they offer additional flexibility for actions. Unlike digital inputs which can only provide strengths of 0.0 and 1.0, an analog input can provide any strength between 0.0 and 1.0. The downside is that without a deadzone system, an analog axis' strength will never be equal to 0.0 due to how the controller is physically built. Instead, it will linger at a low value such as 0.062. This phenomenon is known as drifting and can be more noticeable on old or faulty controllers.

Let's take a racing game as a real-world example. Thanks to analog inputs, we can steer the car slowly in one direction or another. However, without a deadzone system, the car would slowly steer by itself even if the player isn't touching the joystick. This is because the directional axis strength won't be equal to 0.0 when we expect it to. Since we don't want our car to steer by itself in this case, we define a "dead zone" value of 0.2 which will ignore all input whose strength is lower than 0.2. An ideal dead zone value is high enough to ignore the input caused by joystick drifting, but is low enough to not ignore actual input from the player.

Godot features a built-in deadzone system to tackle this problem. The default value is 0.5, but you can adjust it on a per-action basis in the Project Settings' Input Map tab. For Input.get_vector(), the deadzone can be specified as an optional 5th parameter. If not specified, it will calculate the average deadzone value from all of the actions in the vector.

Unlike keyboard input, holding down a controller button such as a D-pad direction will not generate repeated input events at fixed intervals (also known as "echo" events). This is because the operating system never sends "echo" events for controller input in the first place.

If you want controller buttons to send echo events, you will have to generate InputEvent objects by code and parse them using Input.parse_input_event() at regular intervals. This can be accomplished with the help of a Timer node.

Unlike keyboard input, controller inputs can be seen by all windows on the operating system, including unfocused windows.

While this is useful for third-party split screen functionality, it can also have adverse effects. Players may accidentally send controller inputs to the running project while interacting with another window.

If you wish to ignore events when the project window isn't focused, you will need to create an autoload called Focus with the following script and use it to check all your inputs:

Then, instead of using Input.is_action_pressed(action), use Focus.input_is_action_pressed(action) where action is the name of the input action. Also, instead of using event.is_action_pressed(action), use Focus.event_is_action_pressed(event, action) where event is an InputEvent reference and action is the name of the input action.

Unlike keyboard and mouse input, controller inputs do not inhibit sleep and power saving measures (such as turning off the screen after a certain amount of time has passed).

To combat this, Godot enables power saving prevention by default when a project is running. If you notice the system is turning off its display when playing with a gamepad, check the value of Display > Window > Energy Saving > Keep Screen On in the Project Settings.

On Linux, power saving prevention requires the engine to be able to use D-Bus. Check whether D-Bus is installed and reachable if running the project within a Flatpak, as sandboxing restrictions may make this impossible by default.

You can view a list of known issues with controller support on GitHub.

First, check that your controller is recognized by other applications. You can use the Gamepad Tester website to confirm that your controller is recognized.

On Windows Godot only supports up to 4 controllers at a time. This is because Godot uses the XInput API, which is limited to supporting 4 controllers at once. Additional controllers above this limit are ignored by Godot.

First, if your controller provides some kind of firmware update utility, make sure to run it to get the latest fixes from the manufacturer. For instance, Xbox One and Xbox Series controllers can have their firmware updated using the Xbox Accessories app. (This application only runs on Windows, so you have to use a Windows machine or a Windows virtual machine with USB support to update the controller's firmware.) After updating the controller's firmware, unpair the controller and pair it again with your PC if you are using the controller in wireless mode.

If buttons are incorrectly mapped, this may be due to an erroneous mapping from the SDL game controller database used by Godot or the Godot game controller database. In this case, you will need to create a custom mapping for your controller.

There are many ways to create mappings. One option is to use the mapping wizard in the official Joypads demo. Once you have a working mapping for your controller, you can test it by defining the SDL_GAMECONTROLLERCONFIG environment variable before running Godot:

To test mappings on non-desktop platforms or to distribute your project with additional controller mappings, you can add them by calling Input.add_joy_mapping() as early as possible in a script's _ready() function.

Once you are satisfied with the custom mapping, you can contribute it for the next Godot version by opening a pull request on the Godot game controller database.

If you're using a self-compiled engine binary, make sure it was compiled with udev support. This is enabled by default, but it is possible to disable udev support by specifying udev=no on the SCons command line. If you're using an engine binary supplied by a Linux distribution, double-check whether it was compiled with udev support.

Controllers can still work without udev support, but it is less reliable as regular polling must be used to check for controllers being connected or disconnected during gameplay (hotplugging).

As described at the top of the page, controller support on mobile platforms relies on a custom implementation instead of using SDL for input. This means controller support may be less reliable than on desktop platforms.

Support for SDL-based controller input on mobile platforms is planned in a future release.

Web controller support is often less reliable compared to "native" platforms. The quality of controller support tends to vary wildly across browsers. As a result, you may have to instruct your players to use a different browser if they can't get their controller to work.

Like for mobile platforms, support for SDL-based controller input on the web platform is planned in a future release.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
# `velocity` will be a Vector2 between `Vector2(-1.0, -1.0)` and `Vector2(1.0, 1.0)`.
# This handles deadzone in a correct way for most use cases.
# The resulting deadzone will have a circular shape as it generally should.
var velocity = Input.get_vector("move_left", "move_right", "move_forward", "move_back")

# The line below is similar to `get_vector()`, except that it handles
# the deadzone in a less optimal way. The resulting deadzone will have
# a square-ish shape when it should ideally have a circular shape.
var velocity = Vector2(
        Input.get_action_strength("move_right") - Input.get_action_strength("move_left"),
        Input.get_action_strength("move_back") - Input.get_action_strength("move_forward")
).limit_length(1.0)
```

Example 2 (unknown):
```unknown
// `velocity` will be a Vector2 between `Vector2(-1.0, -1.0)` and `Vector2(1.0, 1.0)`.
// This handles deadzone in a correct way for most use cases.
// The resulting deadzone will have a circular shape as it generally should.
Vector2 velocity = Input.GetVector("move_left", "move_right", "move_forward", "move_back");

// The line below is similar to `get_vector()`, except that it handles
// the deadzone in a less optimal way. The resulting deadzone will have
// a square-ish shape when it should ideally have a circular shape.
Vector2 velocity = new Vector2(
        Input.GetActionStrength("move_right") - Input.GetActionStrength("move_left"),
        Input.GetActionStrength("move_back") - Input.GetActionStrength("move_forward")
).LimitLength(1.0);
```

Example 3 (unknown):
```unknown
# `walk` will be a floating-point number between `-1.0` and `1.0`.
var walk = Input.get_axis("move_left", "move_right")

# The line above is a shorter form of:
var walk = Input.get_action_strength("move_right") - Input.get_action_strength("move_left")
```

Example 4 (unknown):
```unknown
// `walk` will be a floating-point number between `-1.0` and `1.0`.
float walk = Input.GetAxis("move_left", "move_right");

// The line above is a shorter form of:
float walk = Input.GetActionStrength("move_right") - Input.GetActionStrength("move_left");
```

---

## Control node gallery — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/ui/control_node_gallery.html

**Contents:**
- Control node gallery
- User-contributed notes

Here is a list of common Control nodes with their name next to them:

The Control Gallery demo pictured above can be found on GitHub.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## CPU optimization — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/performance/cpu_optimization.html

**Contents:**
- CPU optimization
- Measuring performance
- CPU profilers
- External profilers
- Manually timing functions
- Caches
- Languages
  - GDScript
  - C#
  - Other languages

We have to know where the "bottlenecks" are to know how to speed up our program. Bottlenecks are the slowest parts of the program that limit the rate that everything can progress. Focusing on bottlenecks allows us to concentrate our efforts on optimizing the areas which will give us the greatest speed improvement, instead of spending a lot of time optimizing functions that will lead to small performance improvements.

For the CPU, the easiest way to identify bottlenecks is to use a profiler.

Profilers run alongside your program and take timing measurements to work out what proportion of time is spent in each function.

The Godot IDE conveniently has a built-in profiler. It does not run every time you start your project: it must be manually started and stopped. This is because, like most profilers, recording these timing measurements can slow down your project significantly.

After profiling, you can look back at the results for a frame.

Results of a profile of one of the demo projects.

We can see the cost of built-in processes such as physics and audio, as well as seeing the cost of our own scripting functions at the bottom.

Time spent waiting for various built-in servers may not be counted in the profilers. This is a known bug.

When a project is running slowly, you will often see an obvious function or process taking a lot more time than others. This is your primary bottleneck, and you can usually increase speed by optimizing this area.

For more info about using Godot's built-in profiler, see Debugger panel.

Although the Godot IDE profiler is very convenient and useful, sometimes you need more power, and the ability to profile the Godot engine source code itself.

You can use a number of third-party C++ profilers to do this.

Example results from Callgrind, which is part of Valgrind.

From the left, Callgrind is listing the percentage of time within a function and its children (Inclusive), the percentage of time spent within the function itself, excluding child functions (Self), the number of times the function is called, the function name, and the file or module.

In this example, we can see nearly all time is spent under the Main::iteration() function. This is the master function in the Godot source code that is called repeatedly. It causes frames to be drawn, physics ticks to be simulated, and nodes and scripts to be updated. A large proportion of the time is spent in the functions to render a canvas (66%), because this example uses a 2D benchmark. Below this, we see that almost 50% of the time is spent outside Godot code in libglapi and i965_dri (the graphics driver). This tells us the a large proportion of CPU time is being spent in the graphics driver.

This is actually an excellent example because, in an ideal world, only a very small proportion of time would be spent in the graphics driver. This is an indication that there is a problem with too much communication and work being done in the graphics API. This specific profiling led to the development of 2D batching, which greatly speeds up 2D rendering by reducing bottlenecks in this area.

Another handy technique, especially once you have identified the bottleneck using a profiler, is to manually time the function or area under test. The specifics vary depending on the language, but in GDScript, you would do the following:

When manually timing functions, it is usually a good idea to run the function many times (1,000 or more times), instead of just once (unless it is a very slow function). The reason for doing this is that timers often have limited accuracy. Moreover, CPUs will schedule processes in a haphazard manner. Therefore, an average over a series of runs is more accurate than a single measurement.

As you attempt to optimize functions, be sure to either repeatedly profile or time them as you go. This will give you crucial feedback as to whether the optimization is working (or not).

CPU caches are something else to be particularly aware of, especially when comparing timing results of two different versions of a function. The results can be highly dependent on whether the data is in the CPU cache or not. CPUs don't load data directly from the system RAM, even though it's huge in comparison to the CPU cache (several gigabytes instead of a few megabytes). This is because system RAM is very slow to access. Instead, CPUs load data from a smaller, faster bank of memory called cache. Loading data from cache is very fast, but every time you try and load a memory address that is not stored in cache, the cache must make a trip to main memory and slowly load in some data. This delay can result in the CPU sitting around idle for a long time, and is referred to as a "cache miss".

This means that the first time you run a function, it may run slowly because the data is not in the CPU cache. The second and later times, it may run much faster because the data is in the cache. Due to this, always use averages when timing, and be aware of the effects of cache.

Understanding caching is also crucial to CPU optimization. If you have an algorithm (routine) that loads small bits of data from randomly spread out areas of main memory, this can result in a lot of cache misses, a lot of the time, the CPU will be waiting around for data instead of doing any work. Instead, if you can make your data accesses localised, or even better, access memory in a linear fashion (like a continuous list), then the cache will work optimally and the CPU will be able to work as fast as possible.

Godot usually takes care of such low-level details for you. For example, the Server APIs make sure data is optimized for caching already for things like rendering and physics. Still, you should be especially aware of caching when writing GDExtensions.

Godot supports a number of different languages, and it is worth bearing in mind that there are trade-offs involved. Some languages are designed for ease of use at the cost of speed, and others are faster but more difficult to work with.

Built-in engine functions run at the same speed regardless of the scripting language you choose. If your project is making a lot of calculations in its own code, consider moving those calculations to a faster language.

GDScript is designed to be easy to use and iterate, and is ideal for making many types of games. However, in this language, ease of use is considered more important than performance. If you need to make heavy calculations, consider moving some of your project to one of the other languages.

C# is popular and has first-class support in Godot. It offers a good compromise between speed and ease of use. Beware of possible garbage collection pauses and leaks that can occur during gameplay, though. A common approach to workaround issues with garbage collection is to use object pooling, which is outside the scope of this guide.

Third parties provide support for several other languages, including Rust.

Godot is written in C++. Using C++ will usually result in the fastest code. However, on a practical level, it is the most difficult to deploy to end users' machines on different platforms. Options for using C++ include GDExtensions and custom modules.

Consider using threads when making a lot of calculations that can run in parallel to each other. Modern CPUs have multiple cores, each one capable of doing a limited amount of work. By spreading work over multiple threads, you can move further towards peak CPU efficiency.

The disadvantage of threads is that you have to be incredibly careful. As each CPU core operates independently, they can end up trying to access the same memory at the same time. One thread can be reading to a variable while another is writing: this is called a race condition. Before you use threads, make sure you understand the dangers and how to try and prevent these race conditions. Threads can make debugging considerably more difficult.

For more information on threads, see Using multiple threads.

Although Nodes are an incredibly powerful and versatile concept, be aware that every node has a cost. Built-in functions such as _process() and _physics_process() propagate through the tree. This housekeeping can reduce performance when you have a very large numbers of nodes (how many exactly depends on the target platform and can range from thousands to tens of thousands so ensure that you profile performance on all target platforms during development).

Each node is handled individually in the Godot renderer. Therefore, a smaller number of nodes with more in each can lead to better performance.

One quirk of the SceneTree is that you can sometimes get much better performance by removing nodes from the SceneTree, rather than by pausing or hiding them. You don't have to delete a detached node. You can for example, keep a reference to a node, detach it from the scene tree using Node.remove_child(node), then reattach it later using Node.add_child(node). This can be very useful for adding and removing areas from a game, for example.

You can avoid the SceneTree altogether by using Server APIs. For more information, see Optimization using Servers.

In some situations, physics can end up becoming a bottleneck. This is particularly the case with complex worlds and large numbers of physics objects.

Here are some techniques to speed up physics:

Try using simplified versions of your rendered geometry for collision shapes. Often, this won't be noticeable for end users, but can greatly increase performance.

Try removing objects from physics when they are out of view / outside the current area, or reusing physics objects (maybe you allow 8 monsters per area, for example, and reuse these).

Another crucial aspect to physics is the physics tick rate. In some games, you can greatly reduce the tick rate, and instead of for example, updating physics 60 times per second, you may update them only 30 or even 20 times per second. This can greatly reduce the CPU load.

The downside of changing physics tick rate is you can get jerky movement or jitter when the physics update rate does not match the frames per second rendered. Also, decreasing the physics tick rate will increase input lag. It's recommended to stick to the default physics tick rate (60 Hz) in most games that feature real-time player movement.

The solution to jitter is to use fixed timestep interpolation, which involves smoothing the rendered positions and rotations over multiple frames to match the physics. Godot has built-in physics interpolation which you can read about here. Performance-wise, interpolation is a very cheap operation compared to running a physics tick. It's orders of magnitude faster, so this can be a significant performance win while also reducing jitter.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
var time_start = Time.get_ticks_usec()

# Your function you want to time
update_enemies()

var time_end = Time.get_ticks_usec()
print("update_enemies() took %d microseconds" % time_end - time_start)
```

Example 2 (unknown):
```unknown
var timeStart = Time.GetTicksUsec();

// Your function you want to time.
UpdateEnemies();

var timeEnd = Time.GetTicksUsec();
GD.Print($"UpdateEnemies() took {timeEnd - timeStart} microseconds");
```

---

## Creating iOS plugins — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/platform/ios/ios_plugin.html

**Contents:**
- Creating iOS plugins
- Loading and using an existing plugin
- Creating an iOS plugin
- User-contributed notes

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

This page explains what iOS plugins can do for you, how to use an existing plugin, and the steps to code a new one.

iOS plugins allow you to use third-party libraries and support iOS-specific features like In-App Purchases, GameCenter integration, ARKit support, and more.

An iOS plugin requires a .gdip configuration file, a binary file which can be either .a static library or .xcframework containing .a static libraries, and possibly other dependencies. To use it, you need to:

Copy the plugin's files to your Godot project's res://ios/plugins directory. You can also group files in a sub-directory, like res://ios/plugins/my_plugin.

The Godot editor automatically detects and imports .gdip files inside res://ios/plugins and its subdirectories.

You can find and activate detected plugins by going to Project -> Export... -> iOS and in the Options tab, scrolling to the Plugins section.

When a plugin is active, you can access it in your code using Engine.get_singleton():

The plugin's files have to be in the res://ios/plugins/ directory or a subdirectory, otherwise the Godot editor will not automatically detect them.

At its core, a Godot iOS plugin is an iOS library (.a archive file or .xcframework containing static libraries) with the following requirements:

The library must have a dependency on the Godot engine headers.

The library must come with a .gdip configuration file.

An iOS plugin can have the same functionality as a Godot module but provides more flexibility and doesn't require to rebuild the engine.

Here are the steps to get a plugin's development started. We recommend using Xcode as your development environment.

The Godot iOS Plugins.

The Godot iOS plugin template gives you all the boilerplate you need to get your iOS plugin started.

To build an iOS plugin:

Create an Objective-C static library for your plugin inside Xcode.

Add the Godot engine header files as a dependency for your plugin library in HEADER_SEARCH_PATHS. You can find the setting inside the Build Settings tab:

Download the Godot engine source from the Godot GitHub page.

Run SCons to generate headers. You can learn the process by reading Compiling for iOS. You don't have to wait for compilation to complete to move forward as headers are generated before the engine starts to compile.

You should use the same header files for iOS plugins and for the iOS export template.

In the Build Settings tab, specify the compilation flags for your static library in OTHER_CFLAGS. The most important ones are -fcxx-modules, -fmodules, and -DDEBUG if you need debug support. Other flags should be the same you use to compile Godot. For instance:

Add the required logic for your plugin and build your library to generate a .a file. You will probably need to build both debug and release target .a files. Depending on your needs, pick either or both. If you need both debug and release .a files, their name should match following pattern: [PluginName].[TargetType].a. You can also build the static library with your SCons configuration.

The iOS plugin system also supports .xcframework files. To generate one, you can use a command such as:

Create a Godot iOS Plugin configuration file to help the system detect and load your plugin:

The configuration file extension must be gdip (e.g.: MyPlugin.gdip).

The configuration file format is as follow:

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
if Engine.has_singleton("MyPlugin"):
    var singleton = Engine.get_singleton("MyPlugin")
    print(singleton.foo())
```

Example 2 (unknown):
```unknown
-DPTRCALL_ENABLED -DDEBUG_ENABLED -DDEBUG_MEMORY_ALLOC -DDISABLE_FORCED_INLINE -DTYPED_METHOD_BIND
```

Example 3 (unknown):
```unknown
xcodebuild -create-xcframework -library [DeviceLibrary].a -library [SimulatorLibrary].a -output [PluginName].xcframework
```

Example 4 (unknown):
```unknown
[config]
    name="MyPlugin"
    binary="MyPlugin.a"

    initialization="init_my_plugin"
    deinitialization="deinit_my_plugin"

    [dependencies]
    linked=[]
    embedded=[]
    system=["Foundation.framework"]

    capabilities=["arkit", "metal"]

    files=["data.json"]

    linker_flags=["-ObjC"]

    [plist]
    PlistKeyWithDefaultType="Some Info.plist key you might need"
    StringPlistKey:string="String value"
    IntegerPlistKey:integer=42
    BooleanPlistKey:boolean=true
    RawPlistKey:raw="
    <array>
        <string>UIInterfaceOrientationPortrait</string>
    </array>
    "
    StringPlistKeyToInput:string_input="Type something"

The ``config`` section and fields are required and defined as follow:

    -   **name**: name of the plugin

    -   **binary**: this should be the filepath of the plugin library (``a`` or ``xcframework``) file.

        -   The filepath can be relative (e.g.: ``MyPlugin.a``, ``MyPlugin.xcframework``) in which case it's relative to the directory where the ``gdip`` file is located.
        -   The filepath can be absolute: ``res://some_path/MyPlugin.a`` or ``res://some_path/MyPlugin.xcframework``.
        -   In case you need multitarget library usage, the filename should be ``MyPlugin.a`` and ``.a`` files should be named as ``MyPlugin.release.a`` and ``MyPlugin.debug.a``.
        -   In case you use multitarget ``xcframework`` libraries, their filename in the configuration should be ``MyPlugin.xcframework``. The ``.xcframework`` files should be named as ``MyPlugin.release.xcframework`` and ``MyPlugin.debug.xcframework``.

The ``dependencies`` and ``plist`` sections are optional and defined as follow:

    -   **dependencies**:

        -   **linked**: contains a list of iOS frameworks that the iOS application should be linked with.

        -   **embedded**: contains a list of iOS frameworks or libraries that should be both linked and embedded into the resulting iOS application.

        -   **system**: contains a list of iOS system frameworks that are required for plugin.

        -   **capabilities**: contains a list of iOS capabilities that is required for plugin. A list of available capabilities can be found at `Apple UIRequiredDeviceCapabilities documentation page <https://developer.apple.com/documentation/bundleresources/information_property_list/uirequireddevicecapabilities>`_.

        -   **files**: contains a list of files that should be copied on export. This is useful for data files or images.

        -   **linker_flags**: contains a list of linker flags to add to the Xcode project when exporting the plugin.

    -   **plist**: should have keys and values that should be present in ``Info.plist`` file.

        -   Each line should follow pattern: ``KeyName:KeyType=KeyValue``
        -   Supported values for ``KeyType`` are ``string``, ``integer``, ``boolean``, ``raw``, ``string_input``
        -   If no type is used (e.g.: ``KeyName="KeyValue"``) ``string`` type will be used.
        -   If ``raw`` type is used value for corresponding key will be stored in ``Info.plist`` as is.
        -   If ``string_input`` type is used you will be able to modify value in Export window.
```

---

## Cross-compiling for iOS on Linux — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/compiling/cross-compiling_for_ios_on_linux.html

**Contents:**
- Cross-compiling for iOS on Linux
- Disclaimer
- Requirements
- Configuring the environment
  - Preparing the SDK
  - Toolchain
- Compiling Godot for iPhone
- User-contributed notes

The procedure for this is somewhat complex and requires a lot of steps, but once you have the environment properly configured you can compile Godot for iOS anytime you want.

While it is possible to compile for iOS on a Linux environment, Apple is very restrictive about the tools to be used (especially hardware-wise), allowing pretty much only their products to be used for development. So this is not official. However, in 2010 Apple said they relaxed some of the App Store review guidelines to allow any tool to be used, as long as the resulting binary does not download any code, which means it should be OK to use the procedure described here and cross-compiling the binary.

XCode with the iOS SDK (you must be logged into an Apple ID to download Xcode).

Clang >= 3.5 for your development machine installed and in the PATH. It has to be version >= 3.5 to target arm64 architecture.

xar and pbzx (required to extract the .xip archive Xcode comes in).

For building xar and pbzx, you may want to follow this guide.

cctools-port for the needed build tools. The procedure for building is quite peculiar and is described below.

This also has some extra dependencies: automake, autogen, libtool.

Extract the Xcode .xip file you downloaded from Apple's developer website:

Note that for the commands below, you will need to replace the version (x.x) with whatever iOS SDK version you're using. If you don't know your iPhone SDK version, you can see the JSON file inside of Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs.

Pack the SDK so that cctools can use it:

Copy the tools to a nicer place. Note that the SCons scripts for building will look under usr/bin inside the directory you provide for the toolchain binaries, so you must copy to such subdirectory, akin to the following commands:

Now you should have the iOS toolchain binaries in $HOME/iostoolchain/usr/bin.

Once you've done the above steps, you should keep two things in your environment: the built toolchain and the iPhoneOS SDK directory. Those can stay anywhere you want since you have to provide their paths to the SCons build command.

For the iPhone platform to be detected, you need the OSXCROSS_IOS environment variable defined to anything.

Now you can compile for iPhone using SCons like the standard Godot way, with some additional arguments to provide the correct paths:

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
mkdir xcode
xar -xf /path/to/Xcode_X.x.xip -C xcode
pbzx -n Content | cpio -i

[...]
######### Blocks
```

Example 2 (unknown):
```unknown
export IOS_SDK_VERSION="x.x"
mkdir -p iPhoneSDK/iPhoneOS${IOS_SDK_VERSION}.sdk
cp -r xcode/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/* iPhoneSDK/iPhoneOS${IOS_SDK_VERSION}.sdk
cp -r xcode/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/* iPhoneSDK/iPhoneOS${IOS_SDK_VERSION}.sdk/usr/include/c++
fusermount -u xcode
```

Example 3 (unknown):
```unknown
cd iPhoneSDK
tar -cf - * | xz -9 -c - > iPhoneOS${IOS_SDK_VERSION}.sdk.tar.xz
```

Example 4 (unknown):
```unknown
git clone https://github.com/tpoechtrager/cctools-port.git
cd cctools-port/usage_examples/ios_toolchain
./build.sh /path/iPhoneOS${IOS_SDK_VERSION}.sdk.tar.xz arm64
```

---

## Customizing the interface — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/editor/customizing_editor.html

**Contents:**
- Customizing the interface
- Moving and resizing docks
- Splitting the script or shader editor to its own window
- Customizing editor layouts
- Customizing editor settings
- User-contributed notes

Godot's interface lives in a single window by default. Since Godot 4.0, you can split several elements to separate windows to better make use of multi-monitor setups.

Click and drag on the edge of any dock or panel to resize it horizontally or vertically:

Resizing a dock in the editor

Click the "3 vertical dots" icon at the top of any dock to change its location, or split it to a separate window by choosing Make Floating in the submenu that appears:

Moving a dock in the editor

To move a floating dock back to the editor window, close the dock window using the × button in the top-right corner of the window (or in the top-left corner on macOS). Alternatively, you can press Alt + F4 while the split window is focused.

This feature is only available on platforms that support spawning multiple windows: Windows, macOS and Linux.

This feature is also not available if Single Window Mode is enabled in the Editor Settings.

Since Godot 4.1, you can split the script or shader editor to its own window.

To split the script editor to its own window, click the corresponding button in the top-right corner of the script editor:

Splitting the script editor to its own window

To split the shader editor to its own window, click the corresponding button in the top-right corner of the script editor:

Splitting the shader editor to its own window

To go back to the previous state (with the script/shader editor embedded in the editor window), close the split window using the × button in the top-right corner of the window (or in the top-left corner on macOS). Alternatively, you can press Alt + F4 while the split window is focused.

You may want to save and load a dock configuration depending on the kind of task you're working on. For instance, when working on animating a character, it may be more convenient to have docks laid out in a different fashion compared to when you're designing a level.

For this purpose, Godot provides a way to save and restore editor layouts. Before saving a layout, make changes to the docks you'd like to save. The following changes are persisted to the saved layout:

Making a dock floating.

Changing a floating dock's position or size.

FileSystem dock properties: split mode, display mode, sorting order, file list display mode, selected paths and unfolded paths.

Splitting the script or shader editor to its own window is not persisted as part of a layout.

After making changes, open the Editor menu at the top of the editor then choose Editor Layouts > Save. Enter a name for the layout, then click Save. If you've already saved an editor layout, you can choose to override an existing layout using the list.

After making changes, open the Editor menu at the top of the editor then choose Editor Layouts. In the dropdown list, you will see a list of saved editor layouts, plus Default which is a hardcoded editor layout that can't be removed. The default layout matches a fresh Godot installation with no changes made to the docks' positions and sizes, and no floating docks.

You can remove a layout using the Delete option in the Editor Layouts dropdown.

If you name the saved layout Default (case-sensitive), the default editor layout will be overwritten. Note that the Default does not appear in the list of layouts to overwrite until you overwrite it once, but you can still write its name manually.

You can go back to the standard default layout by removing the Default layout after overriding it. (This option does not appear if you haven't overridden the default layout yet.)

Editor layouts are saved to a file named editor_layouts.cfg in the configuration path of the Editor data paths.

In the Editor menu at the top of the editor, you can find an Editor Settings option. This opens a window similar to the Project Settings, but with settings used by the editor. These settings are shared across all projects and are not saved in the project files.

The Editor Settings window

Some commonly changed settings are:

Interface > Editor > Editor Language: Controls the language the editor displays in. To make English tutorials easier to follow, you may want to change this to English so that menu names are identical to names referred to by tutorials. The language can also be changed in the top-right corner of the project manager.

Interface > Editor > Display Scale: Controls how large UI elements display on screen. The default Auto setting finds a suitable value based on your display's DPI and resolution. Due to engine limitations, it only takes the display-provided scaling factor on macOS, not on Windows or Linux.

Interface > Editor > Single Window Mode: If enabled, this forces the editor to use a single window. This disables certain features such as splitting the script/shaders editor to their own window. Single-window mode can be more stable, especially on Linux when using Wayland.

Interface > Theme > Preset: The editor theme preset to use. The Light theme preset may be easier to read if you're outdoors or in a room with sunlight. The Black (OLED) preset can reduce power consumption on OLED displays, which are increasingly common in laptops and phones/tablets.

FileSystem > Directories > Autoscan Project Path: This can be set to a folder path that will be automatically scanned for projects in the project manager every time it starts.

FileSystem > Directories > Default Project Path: Controls the default location where new projects are created in the project manager.

Editors > 3D > Emulate Numpad: This allows using the top row 0-9 keys in the 3D editor as their equivalent numpad keys. It's recommended to enable this option if you don't have a number pad on your keyboard.

Editors > 3D > Emulate 3 Button Mouse: This allows using the pan, zoom and orbit modifiers in the 3D editor even when not holding down any mouse button. It's recommended to enable this option if you're using a trackpad.

See the EditorSettings class reference for a complete description of most editor settings. You can also hover an editor setting's name with the mouse in the Editor Settings to show its description.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Custom Godot servers — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/architecture/custom_godot_servers.html

**Contents:**
- Custom Godot servers
- Introduction
  - References
- What for?
- Creating a Godot server
- Custom managed resource data
  - References
- Registering the class in GDScript
  - Bind methods
- MessageQueue

Godot implements multi-threading as servers. Servers are daemons which manage data, process it, and push the result. Servers implement the mediator pattern which interprets resource ID and process data for the engine and other modules. In addition, the server claims ownership for its RID allocations.

This guide assumes the reader knows how to create C++ modules and Godot data types. If not, refer to Custom modules in C++.

Why does Godot use servers and RIDs?

Adding artificial intelligence.

Adding custom asynchronous threads.

Adding support for a new input device.

Adding writing threads.

Adding a custom VoIP protocol.

At minimum, a server must have a static instance, a sleep timer, a thread loop, an initialization state and a cleanup procedure.

Godot servers implement a mediator pattern. All data types inherit RID_Data. RID_Owner<MyRID_Data> owns the object when make_rid is called. During debug mode only, RID_Owner maintains a list of RIDs. In practice, RIDs are similar to writing object-oriented C code.

Servers are allocated in register_types.cpp. The constructor sets the static instance and init() creates the managed thread; unregister_types.cpp cleans up the server.

Since a Godot server class creates an instance and binds it to a static singleton, binding the class might not reference the correct instance. Therefore, a dummy class must be created to reference the proper Godot server.

In register_server_types(), Engine::get_singleton()->add_singleton is used to register the dummy class in GDScript.

servers/register_server_types.cpp

The dummy class binds singleton methods to GDScript. In most cases, the dummy class methods wraps around.

It is possible to emit signals to GDScript by calling the GDScript dummy object.

In order to send commands into SceneTree, MessageQueue is a thread-safe buffer to queue set and call methods for other threads. To queue a command, obtain the target object RID and use either push_call, push_set, or push_notification to execute the desired behavior. The queue will be flushed whenever either SceneTree::idle or SceneTree::iteration is executed.

core/object/message_queue.cpp

Here is the GDScript sample code:

The actual Hilbert Hotel is impossible.

Connecting signal example code is pretty hacky.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (cpp):
```cpp
#pragma once

#include "core/object/object.h"
#include "core/os/thread.h"
#include "core/os/mutex.h"
#include "core/templates/list.h"
#include "core/templates/rid.h"
#include "core/templates/set.h"
#include "core/variant/variant.h"

class HilbertHotel : public Object {
    GDCLASS(HilbertHotel, Object);

    static HilbertHotel *singleton;
    static void thread_func(void *p_udata);

private:
    bool thread_exited;
    mutable bool exit_thread;
    Thread *thread;
    Mutex *mutex;

public:
    static HilbertHotel *get_singleton();
    Error init();
    void lock();
    void unlock();
    void finish();

protected:
    static void _bind_methods();

private:
    uint64_t counter;
    RID_Owner<InfiniteBus> bus_owner;
    // https://github.com/godotengine/godot/blob/master/core/templates/rid.h
    Set<RID> buses;
    void _emit_occupy_room(uint64_t room, RID rid);

public:
    RID create_bus();
    Variant get_bus_info(RID id);
    bool empty();
    bool delete_bus(RID id);
    void clear();
    void register_rooms();
    HilbertHotel();
};
```

Example 2 (cpp):
```cpp
#include "hilbert_hotel.h"

#include "core/variant/dictionary.h"
#include "core/os/os.h"

#include "prime_225.h"

void HilbertHotel::thread_func(void *p_udata) {

    HilbertHotel *ac = (HilbertHotel *) p_udata;
    uint64_t msdelay = 1000;

    while (!ac->exit_thread) {
        if (!ac->empty()) {
            ac->lock();
            ac->register_rooms();
            ac->unlock();
        }
        OS::get_singleton()->delay_usec(msdelay * 1000);
    }
}

Error HilbertHotel::init() {
    thread_exited = false;
    counter = 0;
    mutex = Mutex::create();
    thread = Thread::create(HilbertHotel::thread_func, this);
    return OK;
}

HilbertHotel *HilbertHotel::singleton = NULL;

HilbertHotel *HilbertHotel::get_singleton() {
    return singleton;
}

void HilbertHotel::register_rooms() {
    for (Set<RID>::Element *e = buses.front(); e; e = e->next()) {
        auto bus = bus_owner.getornull(e->get());

        if (bus) {
            uint64_t room = bus->next_room();
            _emit_occupy_room(room, bus->get_self());
        }
    }
}

void HilbertHotel::unlock() {
    if (!thread || !mutex) {
        return;
    }

    mutex->unlock();
}

void HilbertHotel::lock() {
    if (!thread || !mutex) {
        return;
    }

    mutex->lock();
}

void HilbertHotel::_emit_occupy_room(uint64_t room, RID rid) {
    _HilbertHotel::get_singleton()->_occupy_room(room, rid);
}

Variant HilbertHotel::get_bus_info(RID id) {
    InfiniteBus *bus = bus_owner.getornull(id);

    if (bus) {
        Dictionary d;
        d["prime"] = bus->get_bus_num();
        d["current_room"] = bus->get_current_room();
        return d;
    }

    return Variant();
}

void HilbertHotel::finish() {
    if (!thread) {
        return;
    }

    exit_thread = true;
    Thread::wait_to_finish(thread);

    memdelete(thread);

    if (mutex) {
        memdelete(mutex);
    }

    thread = NULL;
}

RID HilbertHotel::create_bus() {
    lock();
    InfiniteBus *ptr = memnew(InfiniteBus(PRIME[counter++]));
    RID ret = bus_owner.make_rid(ptr);
    ptr->set_self(ret);
    buses.insert(ret);
    unlock();

    return ret;
}

// https://github.com/godotengine/godot/blob/master/core/templates/rid.h
bool HilbertHotel::delete_bus(RID id) {
    if (bus_owner.owns(id)) {
        lock();
        InfiniteBus *b = bus_owner.get(id);
        bus_owner.free(id);
        buses.erase(id);
        memdelete(b);
        unlock();
        return true;
    }

    return false;
}

void HilbertHotel::clear() {
    for (Set<RID>::Element *e = buses.front(); e; e = e->next()) {
        delete_bus(e->get());
    }
}

bool HilbertHotel::empty() {
    return buses.size() <= 0;
}

void HilbertHotel::_bind_methods() {
}

HilbertHotel::HilbertHotel() {
    singleton = this;
}
```

Example 3 (javascript):
```javascript
const uint64_t PRIME[225] = {
        2,3,5,7,11,13,17,19,23,
        29,31,37,41,43,47,53,59,61,
        67,71,73,79,83,89,97,101,103,
        107,109,113,127,131,137,139,149,151,
        157,163,167,173,179,181,191,193,197,
        199,211,223,227,229,233,239,241,251,
        257,263,269,271,277,281,283,293,307,
        311,313,317,331,337,347,349,353,359,
        367,373,379,383,389,397,401,409,419,
        421,431,433,439,443,449,457,461,463,
        467,479,487,491,499,503,509,521,523,
        541,547,557,563,569,571,577,587,593,
        599,601,607,613,617,619,631,641,643,
        647,653,659,661,673,677,683,691,701,
        709,719,727,733,739,743,751,757,761,
        769,773,787,797,809,811,821,823,827,
        829,839,853,857,859,863,877,881,883,
        887,907,911,919,929,937,941,947,953,
        967,971,977,983,991,997,1009,1013,1019,
        1021,1031,1033,1039,1049,1051,1061,1063,1069,
        1087,1091,1093,1097,1103,1109,1117,1123,1129,
        1151,1153,1163,1171,1181,1187,1193,1201,1213,
        1217,1223,1229,1231,1237,1249,1259,1277,1279,
        1283,1289,1291,1297,1301,1303,1307,1319,1321,
        1327,1361,1367,1373,1381,1399,1409,1423,1427
};
```

Example 4 (javascript):
```javascript
class InfiniteBus : public RID_Data {
    RID self;

private:
    uint64_t prime_num;
    uint64_t num;

public:
    uint64_t next_room() {
        return prime_num * num++;
    }

    uint64_t get_bus_num() const {
        return prime_num;
    }

    uint64_t get_current_room() const {
        return prime_num * num;
    }

    _FORCE_INLINE_ void set_self(const RID &p_self) {
        self = p_self;
    }

    _FORCE_INLINE_ RID get_self() const {
        return self;
    }

    InfiniteBus(uint64_t prime) : prime_num(prime), num(1) {};
    ~InfiniteBus() {};
}
```

---

## Custom GUI controls — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/ui/custom_gui_controls.html

**Contents:**
- Custom GUI controls
- So many controls...
- Drawing
  - Checking control size
  - Checking focus
- Sizing
- Input
  - Input events
  - Notifications
- User-contributed notes

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

Yet there are never enough. Creating your own custom controls that act just the way you want them to is an obsession of almost every GUI programmer. Godot provides plenty of them, but they may not work exactly the way you want. Before contacting the developers with a pull-request to support diagonal scrollbars, at least it will be good to know how to create these controls easily from script.

For drawing, it is recommended to check the Custom drawing in 2D tutorial. The same applies. Some functions are worth mentioning due to their usefulness when drawing, so they will be detailed next:

Unlike 2D nodes, "size" is important with controls, as it helps to organize them in proper layouts. For this, the Control.size property is provided. Checking it during _draw() is vital to ensure everything is kept in-bounds.

Some controls (such as buttons or text editors) might provide input focus for keyboard or joypad input. Examples of this are entering text or pressing a button. This is controlled with the Control.focus_mode property. When drawing, and if the control supports input focus, it is always desired to show some sort of indicator (highlight, box, etc.) to indicate that this is the currently focused control. To check for this status, the Control.has_focus() method exists. Example

As mentioned before, size is important to controls. This allows them to lay out properly, when set into grids, containers, or anchored. Controls, most of the time, provide a minimum size to help properly lay them out. For example, if controls are placed vertically on top of each other using a VBoxContainer, the minimum size will make sure your custom control is not squished by the other controls in the container.

To provide this callback, just override Control._get_minimum_size(), for example:

Alternatively, set it using a function:

Controls provide a few helpers to make managing input events much easier than regular nodes.

There are a few tutorials about input before this one, but it's worth mentioning that controls have a special input method that only works when:

The mouse pointer is over the control.

The button was pressed over this control (control always captures input until button is released)

Control provides keyboard/joypad focus via Control.focus_mode.

This function is Control._gui_input(). To use it, override it in your control. No processing needs to be set.

For more information about events themselves, check the Using InputEvent tutorial.

Controls also have many useful notifications for which no dedicated callback exists, but which can be checked with the _notification callback:

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
func _draw():
    if has_focus():
         draw_selected()
    else:
         draw_normal()
```

Example 2 (unknown):
```unknown
public override void _Draw()
{
    if (HasFocus())
    {
        DrawSelected()
    }
    else
    {
        DrawNormal();
    }
}
```

Example 3 (unknown):
```unknown
func _get_minimum_size():
    return Vector2(30, 30)
```

Example 4 (unknown):
```unknown
public override Vector2 _GetMinimumSize()
{
    return new Vector2(20, 20);
}
```

---

## Custom HTML page for Web export — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/platform/web/customizing_html5_shell.html

**Contents:**
- Custom HTML page for Web export
- Setup
- Starting the project
- Customizing the behavior
- Customizing the presentation
- Debugging
- User-contributed notes

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

While Web export templates provide a default HTML page fully capable of launching the project without any further customization, it may be beneficial to create a custom HTML page. While the game itself cannot easily be directly controlled from the outside yet, such page allows to customize the initialization process for the engine.

Some use-cases where customizing the default page is useful include:

Loading files from a different directory than the page;

Loading a .zip file instead of a .pck file as the main pack;

Loading the engine from a different directory than the main pack file;

Adding a click-to-play button so that games can be started in the fullscreen mode;

Loading some extra files before the engine starts, making them available in the project file system as soon as possible;

Passing custom command line arguments, e.g. -s to start a MainLoop script.

The default HTML page is available in the Godot Engine repository at /misc/dist/html/full-size.html but the following template can be used as a much simpler example:

As shown by the example above, it is mostly a regular HTML document, with few placeholders which needs to be replaced during export, an html <canvas> element, and some simple JavaScript code that calls the Engine() class.

The only required placeholders are:

$GODOT_URL: The name of the main JavaScript file, which provides the Engine() class required to start the engine and that must be included in the HTML as a <script>. The name is generated from the Export Path during the export process.

$GODOT_CONFIG: A JavaScript object, containing the export options and can be later overridden. See EngineConfig for the full list of overrides.

The following optional placeholders will enable some extra features in your custom HTML template.

$GODOT_PROJECT_NAME: The project name as defined in the Name setting in Project Settings > Application > Config. It is a good idea to use it as a <title> in your template.

$GODOT_HEAD_INCLUDE: A custom string to include in the HTML document just before the end of the <head> tag. It is customized in the export options under the Html / Head Include section. While you fully control the HTML page you create, this variable can be useful for configuring parts of the HTML head element from the Godot Editor, e.g. for different Web export presets.

$GODOT_SPLASH: The path to the image used as the boot splash as defined in the Image setting in Project Settings > Application > Boot Splash.

$GODOT_SPLASH_COLOR The splash screen background color as defined in the BG Color setting in Project Settings > Application > Boot Splash, converted to a hex color code.

$GODOT_SPLASH_CLASSES: This placeholder provides a string of setting names and their values, which affect the splash screen. This string is meant to be used as a set of CSS class names, which allows styling the splash image based on the splash project settings. The following settings from Project Settings > Application > Boot Splash are provided, represented by the class names shown below depending on the setting's boolean value:

Show Image: show-image--true, show-image--false

Fullsize: fullsize--true, fullsize--false

Use Filter: use-filter--true, use-filter--false

When the custom page is ready, it can be selected in the export options under the Html / Custom Html Shell section.

To be able to start the game, you need to write a script that initializes the engine — the control code. This process consists of three steps, but as shown here, most of them can be skipped depending on how much customization is needed.

See the HTML5 shell class reference, for the full list of methods and options available.

First, the engine must be loaded, then it needs to be initialized, and after this the project can finally be started. You can perform every of these steps manually and with great control. However, in the simplest case all you need to do is to create an instance of the Engine() class with the exported configuration, and then call the engine.startGame method optionally overriding any EngineConfig parameters.

This snippet of code automatically loads and initializes the engine before starting the game. It uses the given configuration to load the engine. The engine.startGame method is asynchronous and returns a Promise. This allows your control code to track if the game was loaded correctly without blocking execution or relying on polling.

In case your project needs to have special control over the start arguments and dependency files, the engine.start method can be used instead. Note, that this method do not automatically preload the pck file, so you will probably want to manually preload it (and any other extra file) via the engine.preloadFile method.

Optionally, you can also manually engine.init to perform specific actions after the module initialization, but before the engine starts.

This process is a bit more complex, but gives you full control over the engine startup process.

To load the engine manually the Engine.load() static method must be called. As this method is static, multiple engine instances can be spawned if the share the same wasm.

Multiple instances cannot be spawned by default, as the engine is immediately unloaded after it is initialized. To prevent this from happening see the unloadAfterInit override option. It is still possible to unload the engine manually afterwards by calling the Engine.unload() static method. Unloading the engine frees browser memory by unloading files that are no longer needed once the instance is initialized.

In the Web environment several methods can be used to guarantee that the game will work as intended.

If you target a specific version of WebGL, or just want to check if WebGL is available at all, you can call the Engine.isWebGLAvailable() method. It optionally takes an argument that allows to test for a specific major version of WebGL.

As the real executable file does not exist in the Web environment, the engine only stores a virtual filename formed from the base name of loaded engine files. This value affects the output of the OS.get_executable_path() method and defines the name of the automatically started main pack. The executable override option can be used to override this value.

Several configuration options can be used to further customize the look and behavior of the game on your page.

By default, the first canvas element on the page is used for rendering. To use a different canvas element the canvas override option can be used. It requires a reference to the DOM element itself.

The way the engine resize the canvas can be configured via the canvasResizePolicy override option.

If your game takes some time to load, it may be useful to display a custom loading UI which tracks the progress. This can be achieved with the onProgress callback option, which allows to set up a callback function that will be called regularly as the engine loads new bytes.

Be aware that in some cases total can be 0. This means that it cannot be calculated.

If your game supports multiple languages, the locale override option can be used to force a specific locale, provided you have a valid language code string. It may be good to use server-side logic to determine which languages a user may prefer. This way the language code can be taken from the Accept-Language HTTP header, or determined by a GeoIP service.

To debug exported projects, it may be useful to read the standard output and error streams generated by the engine. This is similar to the output shown in the editor console window. By default, standard console.log and console.warn are used for the output and error streams respectively. This behavior can be customized by setting your own functions to handle messages.

Use the onPrint override option to set a callback function for the output stream, and the onPrintError override option to set a callback function for the error stream.

When handling the engine output, keep in mind that it may not be desirable to print it out in the finished product.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
<!DOCTYPE html>
<html>
    <head>
        <title>My Template</title>
        <meta charset="UTF-8">
    </head>
    <body>
        <canvas id="canvas"></canvas>
        <script src="$GODOT_URL"></script>
        <script>
            var engine = new Engine($GODOT_CONFIG);
            engine.startGame();
        </script>
    </body>
</html>
```

Example 2 (javascript):
```javascript
const engine = new Engine($GODOT_CONFIG);
engine.startGame({
    /* optional override configuration, eg. */
    // unloadAfterInit: false,
    // canvasResizePolicy: 0,
    // ...
});
```

Example 3 (javascript):
```javascript
const myWasm = 'mygame.wasm';
const myPck = 'mygame.pck';
const engine = new Engine();
Promise.all([
    // Load and init the engine
    engine.init(myWasm),
    // And the pck concurrently
    engine.preloadFile(myPck),
]).then(() => {
    // Now start the engine.
    return engine.start({ args: ['--main-pack', myPck] });
}).then(() => {
    console.log('Engine has started!');
});
```

Example 4 (javascript):
```javascript
const canvasElement = document.querySelector("#my-canvas-element");
engine.startGame({ canvas: canvasElement });
```

---

## Custom modules in C++ — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/architecture/custom_modules_in_cpp.html

**Contents:**
- Custom modules in C++
- Modules
- What for?
- Creating a new module
- Using the module
- Compiling a module externally
- Customizing module types initialization
- Writing custom documentation
- Writing custom unit tests
- Adding custom editor icons

Godot allows extending the engine in a modular way. New modules can be created and then enabled/disabled. This allows for adding new engine functionality at every level without modifying the core, which can be split for use and reuse in different modules.

Modules are located in the modules/ subdirectory of the build system. By default, dozens of modules are enabled, such as GDScript (which, yes, is not part of the base engine), GridMap support, a regular expressions module, and others. As many new modules as desired can be created and combined. The SCons build system will take care of it transparently.

While it's recommended that most of a game be written in scripting (as it is an enormous time saver), it's perfectly possible to use C++ instead. Adding C++ modules can be useful in the following scenarios:

Binding an external library to Godot (like PhysX, FMOD, etc).

Optimize critical parts of a game.

Adding new functionality to the engine and/or editor.

Porting an existing game to Godot.

Write a whole, new game in C++ because you can't live without C++.

While it is possible to use modules for custom game logic, GDExtension is generally more suited as it doesn't require recompiling the engine after every code change.

C++ modules are mainly needed when GDExtension doesn't suffice and deeper engine integration is required.

Before creating a module, make sure to download the source code of Godot and compile it.

To create a new module, the first step is creating a directory inside modules/. If you want to maintain the module separately, you can checkout a different VCS into modules and use it.

The example module will be called "summator" (godot/modules/summator). Inside we will create a summator class:

And then the cpp file.

Then, the new class needs to be registered somehow, so two more files need to be created:

These files must be in the top-level folder of your module (next to your SCsub and config.py files) for the module to be registered properly.

These files should contain the following:

Next, we need to create an SCsub file so the build system compiles this module:

With multiple sources, you can also add each file individually to a Python string list:

This allows for powerful possibilities using Python to construct the file list using loops and logic statements. Look at some modules that ship with Godot by default for examples.

To add include directories for the compiler to look at you can append it to the environment's paths:

If you want to add custom compiler flags when building your module, you need to clone env first, so it won't add those flags to whole Godot build (which can cause errors). Example SCsub with custom flags:

And finally, the configuration file for the module, this is a Python script that must be named config.py:

The module is asked if it's OK to build for the specific platform (in this case, True means it will build for every platform).

And that's it. Hope it was not too complex! Your module should look like this:

You can then zip it and share the module with everyone else. When building for every platform (instructions in the previous sections), your module will be included.

You can now use your newly created module from any script:

The output will be 60.

The previous Summator example is great for small, custom modules, but what if you want to use a larger, external library? Refer to Binding to external libraries for details about binding to external libraries.

If your module is meant to be accessed from the running project (not just from the editor), you must also recompile every export template you plan to use, then specify the path to the custom template in each export preset. Otherwise, you'll get errors when running the project as the module isn't compiled in the export template. See the Compiling pages for more information.

Compiling a module involves moving the module's sources directly under the engine's modules/ directory. While this is the most straightforward way to compile a module, there are a couple of reasons as to why this might not be a practical thing to do:

Having to manually copy modules sources every time you want to compile the engine with or without the module, or taking additional steps needed to manually disable a module during compilation with a build option similar to module_summator_enabled=no. Creating symbolic links may also be a solution, but you may additionally need to overcome OS restrictions like needing the symbolic link privilege if doing this via script.

Depending on whether you have to work with the engine's source code, the module files added directly to modules/ changes the working tree to the point where using a VCS (like git) proves to be cumbersome as you need to make sure that only the engine-related code is committed by filtering changes.

So if you feel like the independent structure of custom modules is needed, lets take our "summator" module and move it to the engine's parent directory:

Compile the engine with our module by providing custom_modules build option which accepts a comma-separated list of directory paths containing custom C++ modules, similar to the following:

The build system shall detect all modules under the ../modules directory and compile them accordingly, including our "summator" module.

Any path passed to custom_modules will be converted to an absolute path internally as a way to distinguish between custom and built-in modules. It means that things like generating module documentation may rely on a specific path structure on your machine.

Introduction to the buildsystem - Custom modules build option.

Modules can interact with other built-in engine classes during runtime and even affect the way core types are initialized. So far, we've been using register_summator_types as a way to bring in module classes to be available within the engine.

A crude order of the engine setup can be summarized as a list of the following type registration methods:

Our Summator class is initialized during the register_module_types() call. Imagine that we need to satisfy some common module runtime dependency (like singletons), or allow us to override existing engine method callbacks before they can be assigned by the engine itself. In that case, we want to ensure that our module classes are registered before any other built-in type.

This is where we can define an optional preregister_summator_types() method which will be called before anything else during the preregister_module_types() engine setup stage.

We now need to add this method to register_types header and source files:

Unlike other register methods, we have to explicitly define MODULE_SUMMATOR_HAS_PREREGISTER to let the build system know what relevant method calls to include at compile time. The module's name has to be converted to uppercase as well.

Writing documentation may seem like a boring task, but it is highly recommended to document your newly created module to make it easier for users to benefit from it. Not to mention that the code you've written one year ago may become indistinguishable from the code that was written by someone else, so be kind to your future self!

There are several steps in order to setup custom docs for the module:

Make a new directory in the root of the module. The directory name can be anything, but we'll be using the doc_classes name throughout this section.

Now, we need to edit config.py, add the following snippet:

The get_doc_path() function is used by the build system to determine the location of the docs. In this case, they will be located in the modules/summator/doc_classes directory. If you don't define this, the doc path for your module will fall back to the main doc/classes directory.

The get_doc_classes() method is necessary for the build system to know which registered classes belong to the module. You need to list all of your classes here. The classes that you don't list will end up in the main doc/classes directory.

You can use Git to check if you have missed some of your classes by checking the untracked files with git status. For example:

Now we can generate the documentation:

We can do this via running Godot's doctool i.e. godot --doctool <path>, which will dump the engine API reference to the given <path> in XML format.

In our case we'll point it to the root of the cloned repository. You can point it to an another folder, and just copy over the files that you need.

Now if you go to the godot/modules/summator/doc_classes folder, you will see that it contains a Summator.xml file, or any other classes, that you referenced in your get_doc_classes function.

Edit the file(s) following the class reference primer and recompile the engine.

Once the compilation process is finished, the docs will become accessible within the engine's built-in documentation system.

In order to keep documentation up-to-date, all you'll have to do is simply modify one of the XML files and recompile the engine from now on.

If you change your module's API, you can also re-extract the docs, they will contain the things that you previously added. Of course if you point it to your godot folder, make sure you don't lose work by extracting older docs from an older engine build on top of the newer ones.

Note that if you don't have write access rights to your supplied <path>, you might encounter an error similar to the following:

It's possible to write self-contained unit tests as part of a C++ module. If you are not familiar with the unit testing process in Godot yet, please refer to Unit testing.

The procedure is the following:

Create a new directory named tests/ under your module's root:

Create a new test suite: test_summator.h. The header must be prefixed with test_ so that the build system can collect it and include it as part of the tests/test_main.cpp where the tests are run.

Write some test cases. Here's an example:

Compile the engine with scons tests=yes, and run the tests with the following command:

You should see the passing assertions now.

Similarly to how you can write self-contained documentation within a module, you can also create your own custom icons for classes to appear in the editor.

For the actual process of creating editor icons to be integrated within the engine, please refer to Editor icons first.

Once you've created your icon(s), proceed with the following steps:

Make a new directory in the root of the module named icons. This is the default path for the engine to look for module's editor icons.

Move your newly created svg icons (optimized or not) into that folder.

Recompile the engine and run the editor. Now the icon(s) will appear in editor's interface where appropriate.

If you'd like to store your icons somewhere else within your module, add the following code snippet to config.py to override the default path:

Use GDCLASS macro for inheritance, so Godot can wrap it.

Use _bind_methods to bind your functions to scripting, and to allow them to work as callbacks for signals.

Avoid multiple inheritance for classes exposed to Godot, as GDCLASS doesn't support this. You can still use multiple inheritance in your own classes as long as they're not exposed to Godot's scripting API.

But this is not all, depending what you do, you will be greeted with some (hopefully positive) surprises.

If you inherit from Node (or any derived node type, such as Sprite2D), your new class will appear in the editor, in the inheritance tree in the "Add Node" dialog.

If you inherit from Resource, it will appear in the resource list, and all the exposed properties can be serialized when saved/loaded.

By this same logic, you can extend the Editor and almost any area of the engine.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (cpp):
```cpp
#pragma once

#include "core/object/ref_counted.h"

class Summator : public RefCounted {
    GDCLASS(Summator, RefCounted);

    int count;

protected:
    static void _bind_methods();

public:
    void add(int p_value);
    void reset();
    int get_total() const;

    Summator();
};
```

Example 2 (javascript):
```javascript
#include "summator.h"

void Summator::add(int p_value) {
    count += p_value;
}

void Summator::reset() {
    count = 0;
}

int Summator::get_total() const {
    return count;
}

void Summator::_bind_methods() {
    ClassDB::bind_method(D_METHOD("add", "value"), &Summator::add);
    ClassDB::bind_method(D_METHOD("reset"), &Summator::reset);
    ClassDB::bind_method(D_METHOD("get_total"), &Summator::get_total);
}

Summator::Summator() {
    count = 0;
}
```

Example 3 (unknown):
```unknown
register_types.h
register_types.cpp
```

Example 4 (cpp):
```cpp
#include "modules/register_module_types.h"

void initialize_summator_module(ModuleInitializationLevel p_level);
void uninitialize_summator_module(ModuleInitializationLevel p_level);
/* yes, the word in the middle must be the same as the module folder name */
```

---

## Custom platform ports — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/architecture/custom_platform_ports.html

**Contents:**
- Custom platform ports
- Official platform ports
- Creating a custom platform port
  - Required features of a platform port
  - Optional features of a platform port
- Distributing a custom platform port
- User-contributed notes

Similar to Custom modules in C++, Godot's multi-platform architecture is designed in a way that allows creating platform ports without modifying any existing source code.

An example of a custom platform port distributed independently from the engine is FRT, which targets single-board computers. Note that this platform port currently targets Godot 3.x; therefore, it does not use the DisplayServer abstraction that is new in Godot 4.

Some reasons to create custom platform ports might be:

You want to port your game to consoles, but wish to write the platform layer yourself. This is a long and arduous process, as it requires signing NDAs with console manufacturers, but it allows you to have full control over the console porting process.

You want to port Godot to an exotic platform that isn't currently supported.

If you have questions about creating a custom platform port, feel free to ask in the #platforms channel of the Godot Contributors Chat.

Godot is a modern engine with modern requirements. Even if you only intend to run simple 2D projects on the target platform, it still requires an amount of memory that makes it unviable to run on most retro consoles. For reference, in Godot 4, an empty project with nothing visible requires about 100 MB of RAM to run on Linux (50 MB in headless mode).

If you want to run Godot on heavily memory-constrained platforms, older Godot versions have lower memory requirements. The porting process is similar, with the exception of DisplayServer not being split from the OS singleton.

The official platform ports can be used as a reference when creating a custom platform port:

While platform code is usually self-contained, there are exceptions to this rule. For instance, audio drivers that are shared across several platforms and rendering drivers are located in the drivers/ folder of the Godot source code.

Creating a custom platform port is a large undertaking which requires prior knowledge of the platform's SDKs. Depending on what features you need, the amount of work needed varies:

At the very least, a platform port must have methods from the OS singleton implemented to be buildable and usable for headless operation. A logo.svg (32×32) vector image must also be present within the platform folder. This logo is displayed in the Export dialog for each export preset targeting the platform in question.

See this implementation for the Linux/*BSD platform as an example. See also the OS singleton header for reference.

If your target platform is UNIX-like, consider inheriting from the OS_Unix class to get much of the work done automatically.

If the platform is not UNIX-like, you might use the Windows port as a reference.

A detect.py file must be created within the platform's folder with all methods implemented. This file is required for SCons to detect the platform as a valid option for compiling. See the detect.py file for the Linux/*BSD platform as an example.

All methods should be implemented within detect.py as follows:

is_active(): Can be used to temporarily disable building for a platform. This should generally always return True.

get_name(): Returns the platform's user-visible name as a string.

can_build(): Return True if the host system is able to build for the target platform, False otherwise. Do not put slow checks here, as this is queried when the list of platforms is requested by the user. Use configure() for extensive dependency checks instead.

get_opts(): Returns the list of SCons build options that can be defined by the user for this platform.

get_flags(): Returns the list of overridden SCons flags for this platform.

configure(): Perform build configuration, such as selecting compiler options depending on SCons options chosen.

In practice, headless operation doesn't suffice if you want to see anything on screen and handle input devices. You may also want audio output for most games.

Some links on this list point to the Linux/*BSD platform implementation as a reference.

One or more DisplayServers, with the windowing methods implemented. DisplayServer also covers features such as mouse support, touchscreen support and tablet driver (for pen input). See the DisplayServer singleton header for reference.

For platforms not featuring full windowing support (or if it's not relevant for the port you are making), most windowing functions can be left mostly unimplemented. These functions can be made to only check if the window ID is MAIN_WINDOW_ID and specific operations like resizing may be tied to the platform's screen resolution feature (if relevant). Any attempt to create or manipulate other window IDs can be rejected.

If the target platform supports the graphics APIs in question: Rendering context for Vulkan, Direct3D 12 OpenGL 3.3 or OpenGL ES 3.0.

Input handlers for keyboard and controller.

One or more audio drivers. The audio driver can be located in the platform/ folder (this is done for the Android and Web platforms), or in the drivers/ folder if multiple platforms may be using this audio driver. See the AudioServer singleton header for reference.

Crash handler, for printing crash backtraces when the game crashes. This allows for easier troubleshooting on platforms where logs aren't readily accessible.

Text-to-speech driver (for accessibility).

Export handler (for exporting from the editor, including One-click deploy). Not required if you intend to export only a PCK from the editor, then run the export template binary directly by renaming it to match the PCK file. See the EditorExportPlatform header for reference. run_icon.svg (16×16) should be present within the platform folder if One-click deploy is implemented for the target platform. This icon is displayed at the top of the editor when one-click deploy is set up for the target platform.

If the target platform doesn't support running Vulkan, Direct3D 12, OpenGL 3.3, or OpenGL ES 3.0, you have two options:

Use a library at runtime to translate Vulkan or OpenGL calls to another graphics API. For example, MoltenVK is used on macOS to translate Vulkan to Metal at runtime.

Create a new renderer from scratch. This is a large undertaking, especially if you want to support both 2D and 3D rendering with advanced features.

Before distributing a custom platform port, make sure you're allowed to distribute all the code that is being linked against. Console SDKs are typically under NDAs which prevent redistribution to the public.

Platform ports are designed to be as self-contained as possible. Most of the code can be kept within a single folder located in platform/. Like Custom modules in C++, this allows for streamlining the build process by making it possible to git clone a platform folder within a Godot repository clone's platform/ folder, then run scons platform=<name>. No other steps are necessary for building, unless third-party platform-specific dependencies need to be installed first.

However, when a custom rendering driver is needed, another folder must be added in drivers/. In this case, the platform port can be distributed as a fork of the Godot repository, or as a collection of several folders that can be added over a Godot Git repository clone.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Custom resource format loaders — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/architecture/custom_resource_format_loaders.html

**Contents:**
- Custom resource format loaders
- Introduction
  - References
- What for?
- What not?
  - References
- Creating a ResourceFormatLoader
- Creating a ResourceFormatSaver
- Creating custom data types
  - Considerations

ResourceFormatLoader is a factory interface for loading file assets. Resources are primary containers. When load is called on the same file path again, the previous loaded Resource will be referenced. Naturally, loaded resources must be stateless.

This guide assumes the reader knows how to create C++ modules and Godot data types. If not, refer to this guide: Custom modules in C++

core/io/resource_loader.cpp

Adding new support for many file formats

Machine learning models

ImageFormatLoader should be used to load images.

core/io/image_loader.h

Each file format consist of a data container and a ResourceFormatLoader.

ResourceFormatLoaders are classes which return all the necessary metadata for supporting new extensions in Godot. The class must return the format name and the extension string.

In addition, ResourceFormatLoaders must convert file paths into resources with the load function. To load a resource, load must read and handle data serialization.

If you'd like to be able to edit and save a resource, you can implement a ResourceFormatSaver:

Godot may not have a proper substitute within its Core types or managed resources. Godot needs a new registered data type to understand additional binary formats such as machine learning models.

Here is an example of creating a custom datatype:

Some libraries may not define certain common routines such as IO handling. Therefore, Godot call translations are required.

For example, here is the code for translating FileAccess calls into std::istream.

core/io/file_access.h

Godot registers ResourcesFormatLoader with a ResourceLoader handler. The handler selects the proper loader automatically when load is called.

core/io/resource_loader.cpp

Save a file called demo.json with the following contents and place it in the project's root folder:

Then attach the following script to any node:

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (javascript):
```javascript
#pragma once

#include "core/io/resource_loader.h"

class ResourceFormatLoaderJson : public ResourceFormatLoader {
    GDCLASS(ResourceFormatLoaderJson, ResourceFormatLoader);
public:
    virtual RES load(const String &p_path, const String &p_original_path, Error *r_error = NULL);
    virtual void get_recognized_extensions(List<String> *r_extensions) const;
    virtual bool handles_type(const String &p_type) const;
    virtual String get_resource_type(const String &p_path) const;
};
```

Example 2 (javascript):
```javascript
#include "resource_loader_json.h"

#include "resource_json.h"

RES ResourceFormatLoaderJson::load(const String &p_path, const String &p_original_path, Error *r_error) {
Ref<JsonResource> json = memnew(JsonResource);
    if (r_error) {
        *r_error = OK;
    }
    Error err = json->load_file(p_path);
    return json;
}

void ResourceFormatLoaderJson::get_recognized_extensions(List<String> *r_extensions) const {
    if (!r_extensions->find("json")) {
        r_extensions->push_back("json");
    }
}

String ResourceFormatLoaderJson::get_resource_type(const String &p_path) const {
    return "Resource";
}

bool ResourceFormatLoaderJson::handles_type(const String &p_type) const {
    return ClassDB::is_parent_class(p_type, "Resource");
}
```

Example 3 (javascript):
```javascript
#pragma once

#include "core/io/resource_saver.h"

class ResourceFormatSaverJson : public ResourceFormatSaver {
    GDCLASS(ResourceFormatSaverJson, ResourceFormatSaver);
public:
    virtual Error save(const String &p_path, const RES &p_resource, uint32_t p_flags = 0);
    virtual bool recognize(const RES &p_resource) const;
    virtual void get_recognized_extensions(const RES &p_resource, List<String> *r_extensions) const;
};
```

Example 4 (javascript):
```javascript
#include "resource_saver_json.h"

#include "resource_json.h"
#include "scene/resources/resource_format_text.h"

Error ResourceFormatSaverJson::save(const String &p_path, const RES &p_resource, uint32_t p_flags) {
    Ref<JsonResource> json = memnew(JsonResource);
    Error error = json->save_file(p_path, p_resource);
    return error;
}

bool ResourceFormatSaverJson::recognize(const RES &p_resource) const {
    return Object::cast_to<JsonResource>(*p_resource) != NULL;
}

void ResourceFormatSaverJson::get_recognized_extensions(const RES &p_resource, List<String> *r_extensions) const {
    if (Object::cast_to<JsonResource>(*p_resource)) {
        r_extensions->push_back("json");
    }
}
```

---

## Debugging and profiling — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/debugging/index.html

**Contents:**
- Debugging and profiling
- Debugging the editor

This section contains pages that provide guidance if you're looking at the engine code trying to find an underlying issue or an optimization possibility.

When working on the Godot editor keep in mind that by default the executable will start in the Project Manager mode. Opening a project from the Project Manager spawns a new process, which stops the debugging session. To avoid that you should launch directly into the project using -e and --path launch options.

For example, using gdb directly, you may do this:

You can also run the editor directly from your project's folder. In that case, only the -e option is required.

You can learn more about these launch options and other command line arguments in the command line tutorial.

If you're using a code editor or an IDE to debug Godot, check out our configuration guides, which cover the setup process for building and debugging with your particular editor.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
gdb godot
> run -e --path ~/myproject
```

Example 2 (unknown):
```unknown
cd ~/myproject
gdb godot
> run -e
```

---

## Debugging on macOS — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/debugging/macos_debug.html

**Contents:**
- Debugging on macOS
- Debugging Godot editor
- Debugging exported project
- User-contributed notes

Attaching a debugger to the signed macOS process requires the "com.apple.security.get-task-allow" entitlement, which is not enabled by default, since apps can't be notarized as long as it is enabled. If you want to debug an official build of the editor it should be re-signed with the proper entitlements.

Create an editor.entitlements text file with the following contents:

Then use the following command to re-sign the editor:

To allow debugging, select the codesign\debugging (com.apple.security.get-task-allow) entitlement during the export. When it is selected, notarization is not supported and should be disabled.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
    <dict>
        <key>com.apple.security.cs.allow-dyld-environment-variables</key>
        <true/>
        <key>com.apple.security.cs.allow-jit</key>
        <true/>
        <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
        <true/>
        <key>com.apple.security.cs.disable-executable-page-protection</key>
        <true/>
        <key>com.apple.security.cs.disable-library-validation</key>
        <true/>
        <key>com.apple.security.device.audio-input</key>
        <true/>
        <key>com.apple.security.device.camera</key>
        <true/>
        <key>com.apple.security.get-task-allow</key>
        <true/>
    </dict>
</plist>
```

Example 2 (unknown):
```unknown
codesign -s - --deep --force --options=runtime --entitlements ./editor.entitlements ./path/to/Godot.app
```

---

## Default editor shortcuts — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/editor/default_key_mapping.html

**Contents:**
- Default editor shortcuts
- General editor actions
- Bottom panels
- 2D / CanvasItem editor
- 3D / Spatial editor
- Text editor
- Script editor
- Editor output
- Debugger
- File dialog

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

Many Godot editor functions can be executed with keyboard shortcuts. This page lists functions which have associated shortcuts by default, but many others are available for customization in editor settings as well. To change keys associated with these and other actions navigate to Editor > Editor Settings > Shortcuts.

While some actions are universal, a lot of shortcuts are specific to individual tools. For this reason it is possible for some key combinations to be assigned to more than one function. The correct action will be performed depending on the context.

While Windows and Linux builds of the editor share most of the default settings, some shortcuts may differ for macOS version. This is done for better integration of the editor into macOS ecosystem. Users fluent with standard shortcuts on that OS should find Godot Editor's default key mapping intuitive.

Distraction Free Mode

editor/distraction_free_mode

editor/reopen_closed_scene

Ctrl + Shift + Alt + S

Cmd + Shift + Opt + S

editor/save_all_scenes

editor/quick_open_scene

editor/quick_open_script

editor/quit_to_project_list

editor/take_screenshot

editor/fullscreen_mode

editor/play_custom_scene

editor/bottom_panel_expand

editor/command_palette

Only bottom panels that are always available have a default shortcut assigned. Others must be manually bound in the Editor Settings if desired.

Toggle Last Opened Panel

editor/toggle_last_opened_bottom_panel

Toggle Animation Bottom Panel

bottom_panels/toggle_animation_bottom_panel

Toggle Audio Bottom Panel

bottom_panels/toggle_audio_bottom_panel

Toggle Debugger Bottom Panel

bottom_panels/toggle_debugger_bottom_panel

Toggle FileSystem Bottom Panel

bottom_panels/toggle_filesystem_bottom_panel

Toggle Output Bottom Panel

bottom_panels/toggle_output_bottom_panel

Toggle Shader Editor Bottom Panel

bottom_panels/toggle_shader_editor_bottom_panel

canvas_item_editor/zoom_plus

canvas_item_editor/zoom_minus

canvas_item_editor/zoom_reset

canvas_item_editor/pan_view

canvas_item_editor/select_mode

canvas_item_editor/move_mode

canvas_item_editor/rotate_mode

canvas_item_editor/scale_mode

canvas_item_editor/ruler_mode

canvas_item_editor/use_smart_snap

canvas_item_editor/use_grid_snap

Multiply grid step by 2

canvas_item_editor/multiply_grid_step

Divide grid step by 2

canvas_item_editor/divide_grid_step

canvas_item_editor/show_grid

canvas_item_editor/show_helpers

canvas_item_editor/show_guides

canvas_item_editor/center_selection

canvas_item_editor/frame_selection

canvas_item_editor/preview_canvas_scale

canvas_item_editor/anim_insert_key

Insert Key (Existing Tracks)

canvas_item_editor/anim_insert_key_existing_tracks

Make Custom Bones from Nodes

canvas_item_editor/skeleton_make_bones

canvas_item_editor/anim_clear_pose

spatial_editor/freelook_toggle

spatial_editor/freelook_left

spatial_editor/freelook_right

spatial_editor/freelook_forward

spatial_editor/freelook_backwards

spatial_editor/freelook_up

spatial_editor/freelook_down

Freelook Speed Modifier

spatial_editor/freelook_speed_modifier

Freelook Slow Modifier

spatial_editor/freelook_slow_modifier

spatial_editor/tool_select

spatial_editor/tool_move

spatial_editor/tool_rotate

spatial_editor/tool_scale

spatial_editor/local_coords

spatial_editor/snap_to_floor

spatial_editor/top_view

spatial_editor/bottom_view

spatial_editor/front_view

spatial_editor/rear_view

spatial_editor/right_view

spatial_editor/left_view

Switch Perspective/Orthogonal View

spatial_editor/switch_perspective_orthogonal

spatial_editor/insert_anim_key

spatial_editor/focus_origin

spatial_editor/focus_selection

Align Transform with View

spatial_editor/align_transform_with_view

Align Rotation with View

spatial_editor/align_rotation_with_view

spatial_editor/1_viewport

spatial_editor/2_viewports

spatial_editor/2_viewports_alt

spatial_editor/3_viewports

spatial_editor/3_viewports_alt

spatial_editor/4_viewports

script_text_editor/cut

script_text_editor/copy

script_text_editor/paste

script_text_editor/select_all

script_text_editor/find

script_text_editor/find_next

script_text_editor/find_previous

script_text_editor/find_in_files

script_text_editor/replace

script_text_editor/replace_in_files

script_text_editor/undo

script_text_editor/redo

script_text_editor/move_up

script_text_editor/move_down

script_text_editor/delete_line

script_text_editor/toggle_comment

script_text_editor/toggle_fold_line

Ctrl + Alt + Down Arrow

Cmd + Shift + Down Arrow

script_text_editor/duplicate_lines

script_text_editor/duplicate_selection

Ctrl + Shift + Down Arrow

Shift + Opt + Down Arrow

common/ui_text_caret_add_below

Ctrl + Shift + Up Arrow

Shift + Opt + Up Arrow

common/ui_text_caret_add_above

Select Next Occurrence

common/ui_text_add_selection_for_next_occurrence

script_text_editor/complete_symbol

script_text_editor/evaluate_selection

Trim Trailing Whitespace

script_text_editor/trim_trailing_whitespace

script_text_editor/convert_to_uppercase

script_text_editor/convert_to_lowercase

script_text_editor/capitalize

Convert Indent to Spaces

script_text_editor/convert_indent_to_spaces

Convert Indent to Tabs

script_text_editor/convert_indent_to_tabs

script_text_editor/auto_indent

script_text_editor/toggle_bookmark

script_text_editor/goto_next_bookmark

Go to Previous Bookmark

script_text_editor/goto_previous_bookmark

script_text_editor/goto_function

script_text_editor/goto_line

script_text_editor/toggle_breakpoint

Remove All Breakpoints

script_text_editor/remove_all_breakpoints

Go to Next Breakpoint

script_text_editor/goto_next_breakpoint

Go to Previous Breakpoint

script_text_editor/goto_previous_breakpoint

script_text_editor/contextual_help

script_editor/find_next

script_editor/find_previous

script_editor/find_in_files

Shift + Alt + Up Arrow

Shift + Opt + Up Arrow

script_editor/window_move_up

Shift + Alt + Down Arrow

Shift + Opt + Down Arrow

script_editor/window_move_down

script_editor/next_script

script_editor/prev_script

script_editor/reopen_closed_script

Ctrl + Shift + Alt + S

Cmd + Shift + Opt + S

script_editor/save_all

script_editor/reload_script_soft

script_editor/history_previous

script_editor/history_next

script_editor/close_file

script_editor/run_file

script_editor/toggle_scripts_panel

script_editor/zoom_in

script_editor/zoom_out

script_editor/reset_zoom

file_dialog/go_forward

file_dialog/toggle_hidden_files

file_dialog/toggle_favorite

file_dialog/toggle_mode

file_dialog/create_folder

file_dialog/focus_path

file_dialog/move_favorite_up

file_dialog/move_favorite_down

filesystem_dock/copy_path

filesystem_dock/duplicate

filesystem_dock/delete

scene_tree/add_child_node

scene_tree/batch_rename

scene_tree/copy_node_path

scene_tree/delete_no_confirm

animation_editor/duplicate_selection

animation_editor/duplicate_selection_transposed

animation_editor/delete_selection

animation_editor/goto_next_step

animation_editor/goto_prev_step

tiles_editor/selection_tool

tiles_editor/paint_tool

tiles_editor/line_tool

tiles_editor/rect_tool

tiles_editor/bucket_tool

tiles_editor/flip_tile_horizontal

tiles_editor/flip_tile_vertical

tiles_editor/rotate_tile_left

tiles_editor/rotate_tile_right

tileset_editor/next_shape

tileset_editor/previous_shape

tileset_editor/editmode_region

tileset_editor/editmode_collision

tileset_editor/editmode_occlusion

tileset_editor/editmode_navigation

tileset_editor/editmode_bitmask

tileset_editor/editmode_priority

tileset_editor/editmode_icon

tileset_editor/editmode_z_index

project_manager/new_project

project_manager/import_project

project_manager/scan_projects

project_manager/edit_project

project_manager/run_project

project_manager/rename_project

project_manager/remove_project

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Deploying to Android — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/xr/deploying_to_android.html

**Contents:**
- Deploying to Android
- Setup
- Gradle Android build
- Installing the vendors plugin
- Creating the export presets
- Running on your device from the Godot editor
- User-contributed notes

Most standalone headsets run on Android and OpenXR support is making its way to these platforms.

Before following the OpenXR-specific instructions here, you'll need to first setup your system to export to Android in general, including:

Installing OpenJDK 17

Installing Android Studio

Configuring the location of the Android SDK in Godot

See Exporting for Android for the full details, and return here when you've finished these steps.

While the Mobile Vulkan renderer has many optimizations targeted at mobile devices, we're still working out the kinks. It is highly advisable to use the compatibility renderer (OpenGL) for the time being when targeting Android based XR devices.

Official support for the Android platform wasn't added to the OpenXR specification initially resulting in various vendors creating custom loaders to make OpenXR available on their headsets. While the long term expectation is that all vendors will adopt the official OpenXR loader, for now these loaders need to be added to your project.

In order to include the vendor-specific OpenXR loader into your project, you will need to setup a gradle Android build.

Select Install Android Build Template... from the Project menu:

This will create a folder called android inside of your project that contains all the runtime files needed on Android. You can now customize this installation. Godot won't show this in the editor but you can find it with a file browser.

You can read more about gradle builds here: Gradle builds for Android.

The vendors plugin can be downloaded from the asset library, search for "OpenXR vendors" and install the one named "Godot OpenXR Vendors plugin v4".

You will find the installed files inside the addons folder. Alternatively you can manually install the vendors plugin by downloading it from the release page here. You will need to copy the assets/addons/godotopenxrvendors folder from the zip file into your projects addons folder.

You can find the main repository of the vendors plugin here.

You will need to setup a separate export preset for each device, as each device will need its own loader included.

Open Project and select Export... Click on Add.. and select Android. Next change the name of the export preset for the device you're setting this up for, say Meta Quest. And enable Use Gradle Build. If you want to use one-click deploy (described below), ensure that Runnable is enabled.

If the vendors plugins were installed correctly you should find entries for the different headsets under XR Features. Change the XR Mode to OpenXR, then select the entry for your headset if you see one. If you don't see one enable the Khronos plugin.

Scroll to the bottom of the list and you'll find additional XR feature sections, currently only Meta XR Features, Pico XR Features, Magicleap XR Features and Khronos XR Features for HTC are available. You will need to select the appropriate settings if you wish to use these features.

If you've setup your export settings as described above, and your headset is connected to your computer and correctly recognized, you can launch it directly from the Godot editor using One-click deploy:

For some devices on some platforms, you may need to perform some extra steps in order for your device to be recognized correctly, so be sure to check the developer documentation from your headset vendor.

For example, with the Meta Quest 2, you need to enable developer mode on the headset, and if you're on Windows, you'll need to install special ADB drivers. See the official Meta Quest developer documentation for more details.

If you're having any issues with one-click deploy, check the Troubleshooting section.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Editor development — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/editor/index.html

**Contents:**
- Editor development

This section documents how to work with the source code of the Godot editor. When contributing to the Godot engine, you should also read the editor style guide.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Editor icons — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/editor/creating_icons.html

**Contents:**
- Editor icons
- Creating icons
- Color conversion for light editor themes
- Icon optimization
- Integrating and sharing the icons
- Troubleshooting
- References
- User-contributed notes

When a new class is created and exposed to scripting, the editor's interface will display it with a default icon representing the base class it inherits from. In most cases, it's still recommended to create icons for new classes to improve the user experience.

To create new icons, you first need a vector graphics editor installed. For instance, you can use the open source Inkscape editor.

Clone the godot repository containing all the editor icons:

The icons must be created in a vector graphics editor in SVG format. There are two main requirements to follow:

Icons must be 16×16. In Inkscape, you can configure the document size in File > Document Properties.

Lines should be snapped to pixels whenever possible to remain crisp at lower DPI. You can create a 16×16 grid in Inkscape to make this easier.

Once you're satisfied with the icon's design, save the icon in the cloned repository's editor/icons folder. The icon name should match the intended name in a case-sensitive manner. For example, to create an icon for CPUParticles2D, name the file CPUParticles2D.svg.

If the user has configured their editor to use a light theme, Godot will convert the icon's colors based on a set of predefined color mappings. This is to ensure the icon always displays with a sufficient contrast rate. Try to restrict your icon's color palette to colors found in the list above. Otherwise, your icon may become difficult to read on a light background.

Import > Import As > Texture2D

Set editor/convert_colors_with_editor_theme to true

Because the editor renders SVGs once at load time, they need to be small in size so they can be efficiently parsed. When the pre-commit hook runs, it automatically optimizes the SVG using svgo.

While this optimization step won't impact the icon's quality noticeably, it will still remove editor-only information such as guides. Therefore, it's recommended to keep the source SVG around if you need to make further changes.

If you're contributing to the engine itself, you should make a pull request to add optimized icons to editor/icons in the main repository. Recompile the engine to make it pick up new icons for classes.

It's also possible to create custom icons within a module. If you're creating your own module and don't plan to integrate it with Godot, you don't need to make a separate pull request for your icons to be available within the editor as they can be self-contained.

For specific instructions on how to create module icons, refer to Creating custom module icons.

If icons don't appear in the editor, make sure that:

Each icon's filename matches the naming requirement as described previously.

modules/svg is enabled (it should be enabled by default). Without it, icons won't appear in the editor at all.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
git clone https://github.com/godotengine/godot.git
```

---

## Editor plugins — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/plugins/editor/index.html

**Contents:**
- Editor plugins

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Engine architecture — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/architecture/index.html

**Contents:**
- Engine architecture
- Getting started with Godot's source code
- Extending Godot by modifying its source code

The following pages are meant to introduce the global organization of Godot Engine's source code, and give useful tips for extending and fixing the engine on the C++ side.

This section covers the basics that you will encounter in (almost) every source file.

This section covers what you can do by modifying Godot's C++ source code.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Engine development — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/index.html

**Contents:**
- Engine development

The guides below explain how to work on the engine's codebase. If you plan to contribute to the engine, please make sure to also read the contribution guidelines.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Exporting for Android — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/export/exporting_for_android.html

**Contents:**
- Exporting for Android
- Install OpenJDK 17
- Download the Android SDK
- Setting it up in Godot
- Providing launcher icons
- Exporting for Google Play Store
- Optimizing the file size
- Environment variables
- Export options
- User-contributed notes

This page describes how to export a Godot project to Android. If you're looking to compile export template binaries from source instead, read Compiling for Android.

Exporting for Android has fewer requirements than compiling Godot for Android. The following steps detail what is needed to set up the Android SDK and the engine.

Projects written in C# can be exported to Android as of Godot 4.2, but support is experimental and some limitations apply.

Download and install OpenJDK 17.

Higher versions of the JDK are also supported, but we recommend using JDK 17 for optimal compatibility and stability.

Download and install the Android SDK.

You can install the Android SDK using Android Studio Iguana (version 2023.2.1) or later.

Run it once to complete the SDK setup using these instructions.

Ensure that the required packages are installed as well.

Android SDK Platform-Tools version 35.0.0 or later

Android SDK Build-Tools version 35.0.0

Android SDK Platform 35

Android SDK Command-line Tools (latest)

Ensure that the NDK and CMake are installed and configured.

CMake version 3.10.2.4988404

NDK version r28b (28.1.13356709)

Alternatively, you can install the Android SDK with the sdkmanager command line tool.

Install the command line tools package using these instructions.

Once the command line tools are installed, run the following sdkmanager command to complete the setup process:

If you are using Linux, do not use an Android SDK provided by your distribution's repositories as it will often be outdated.

Enter the Editor Settings screen (under the Godot tab for macOS, or the Editor tab for other platforms). This screen contains the editor settings for the user account in the computer (it's independent of the project).

Scroll down to the section where the Android settings are located:

In that screen, 2 paths need to be set:

Java SDK Path should be the location where OpenJDK 17 was installed.

Android Sdk Path should be the location where the Android SDK was installed. - For example %LOCALAPPDATA%\Android\Sdk\ on Windows or /Users/$USER/Library/Android/sdk/ on macOS.

Once that is configured, everything is ready to export to Android!

If you get an error saying "Could not install to device.", make sure you do not have an application with the same Android package name already installed on the device (but signed with a different key).

If you have an application with the same Android package name but a different signing key already installed on the device, you must remove the application in question from the Android device before exporting to Android again.

Launcher icons are used by Android launcher apps to represent your application to users. Godot only requires high-resolution icons (for xxxhdpi density screens) and will automatically generate lower-resolution variants.

There are three types of icons:

Main Icon: The "classic" icon. This will be used on all Android versions up to Android 8 (Oreo), exclusive. Must be at least 192×192 px.

Adaptive Icons: Starting from Android 8 (inclusive), Adaptive Icons were introduced. Applications will need to include separate background and foreground icons to have a native look. The user's launcher application will control the icon's animation and masking. Must be at least 432×432 px.

Themed Icons (optional): Starting from Android 13 (inclusive), Themed Icons were introduced. Applications will need to include a monochrome icon to enable this feature. The user's launcher application will control the icon's theme. Must be at least 432×432 px.

It's important to adhere to some rules when designing adaptive icons. Google Design has provided a nice article that helps to understand those rules and some of the capabilities of adaptive icons.

The most important adaptive icon design rule is to have your icon critical elements inside the safe zone: a centered circle with a diameter of 66dp (264 pixels on xxxhdpi) to avoid being clipped by the launcher.

If you don't provide the requested icons (except for Monochrome), Godot will replace them using a fallback chain, trying the next in line when the current one fails:

Main Icon: Provided main icon -> Project icon -> Default Godot main icon.

Adaptive Icon Foreground: Provided foreground icon -> Provided main icon -> Project icon -> Default Godot foreground icon.

Adaptive Icon Background: Provided background icon -> Default Godot background icon.

It's highly recommended to provide all the requested icons with their specified resolutions. This way, your application will look great on all Android devices and versions.

All new apps uploaded to Google Play after August 2021 must be an AAB (Android App Bundle) file.

Uploading an AAB or APK to Google's Play Store requires you to sign using a non-debug keystore file; such a file can be generated like this:

This keystore and key are used to verify your developer identity, remember the password and keep it in a safe place! It is suggested to use only upper and lowercase letters and numbers. Special characters may cause errors. Use Google's Android Developer guides to learn more about app signing.

Now fill in the following forms in your Android Export Presets:

Release: Enter the path to the keystore file you just generated.

Release User: Replace with the key alias.

Release Password: Key password. Note that the keystore password and the key password currently have to be the same.

Don't forget to uncheck the Export With Debug checkbox while exporting.

If you're working with APKs and not AABs, by default, the APK will contain native libraries for both ARMv7 and ARMv8 architectures. This increases its size significantly. To create a smaller file, uncheck either Armeabi-v 7a or Arm 64 -v 8a in your project's Android export preset. This will create an APK that only contains a library for a single architecture. Note that applications targeting ARMv7 can also run on ARMv8 devices, but the opposite is not true. The reason you don't do this to save space with AABs is that Google automatically splits up the AAB on their backend, so the user only downloads what they need.

You can optimize the size further by compiling an Android export template with only the features you need. See Optimizing a build for size for more information.

You can use the following environment variables to set export options outside of the editor. During the export process, these override the values that you set in the export menu.

Encryption / Encryption Key

GODOT_SCRIPT_ENCRYPTION_KEY

Options / Keystore / Debug

GODOT_ANDROID_KEYSTORE_DEBUG_PATH

Options / Keystore / Debug User

GODOT_ANDROID_KEYSTORE_DEBUG_USER

Options / Keystore / Debug Password

GODOT_ANDROID_KEYSTORE_DEBUG_PASSWORD

Options / Keystore / Release

GODOT_ANDROID_KEYSTORE_RELEASE_PATH

Options / Keystore / Release User

GODOT_ANDROID_KEYSTORE_RELEASE_USER

Options / Keystore / Release Password

GODOT_ANDROID_KEYSTORE_RELEASE_PASSWORD

You can find a full list of export options available in the EditorExportPlatformAndroid class reference.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
sdkmanager --sdk_root=<android_sdk_path> "platform-tools" "build-tools;35.0.0" "platforms;android-35" "cmdline-tools;latest" "cmake;3.10.2.4988404" "ndk;28.1.13356709"
```

Example 2 (unknown):
```unknown
keytool -v -genkey -keystore mygame.keystore -alias mygame -keyalg RSA -validity 10000
```

---

## Exporting for dedicated servers — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/export/exporting_for_dedicated_servers.html

**Contents:**
- Exporting for dedicated servers
- Editor versus export template
- Export approaches
- Exporting a project for a dedicated server
- Starting the dedicated server
- Next steps
- User-contributed notes

If you want to run a dedicated server for your project on a machine that doesn't have a GPU or display server available, you'll need to run Godot with the headless display server and Dummy audio driver.

Since Godot 4.0, this can be done by running a Godot binary on any platform with the --headless command line argument, or running a project exported as dedicated server. You do not need to use a specialized server binary anymore, unlike Godot 3.x.

It is possible to use either an editor or export template (debug or release) binary in headless mode. Which one you should use depends on your use case:

Export template: Use this one for running dedicated servers. It does not contain editor functionality, and is therefore smaller and more optimized.

Editor: This binary contains editor functionality and is intended to be used for exporting projects. This binary can be used to run dedicated servers, but it's not recommended as it's larger and less optimized.

There are two ways to export a project for a server:

Create a separate export preset for the platform that will host the server, then export your project as usual.

Export a PCK file only, preferably for the platform that matches the platform that will host the server. Place this PCK file in the same folder as an export template binary, rename the binary to have the same name as the PCK (minus the file extension), then run the binary.

Both methods should result in identical output. The rest of the page will focus on the first approach.

See Exporting projects for more information.

If you export a project as usual when targeting a server, you will notice that the PCK file is just as large as for the client. This is because it includes all resources, including those the server doesn't need (such as texture data). Additionally, headless mode won't be automatically used; the user will have to specify --headless to make sure no window spawns.

Many resources such as textures can be stripped from the PCK file to greatly reduce its size. Godot offers a way to do this for textures and materials in a way that preserves references in scene or resource files (built-in or external).

To begin doing so, make sure you have a dedicated export preset for your server, then select it, go to its Resources tab and change its export mode:

Choosing the Export as dedicated server export mode in the export preset

When this export mode is chosen, the dedicated_server feature tag is automatically added to the exported project.

If you do not wish to use this export mode but still want the feature tag, you can write the name dedicated_server in the Features tab of the export preset. This will also force --headless when running the exported project.

After selecting this export mode, you will be presented with a list of resources in the project:

Choosing resources to keep, keep with stripped visuals or remove

Ticking a box allows you to override options for the specified file or folder. Checking boxes does not affect which files are exported; this is done by the options selected for each checkbox instead.

Files within a checked folder will automatically use the parent's option by default, which is indicated by the (Inherited) suffix for the option name (and the option name being grayed out). To change the option for a file whose option is currently inherited, you must tick the box next to it first.

Strip Visuals: Export this resource, with visual files (textures and materials) replaced by placeholder classes. Placeholder classes store the image size (as it's sometimes used to position elements in a 2D scene), but nothing else.

Keep: Export this resource as usual, with visual files intact.

Remove: The file is not included in the PCK. This is useful to ignore scenes and resources that only the client needs. If you do so, make sure the server doesn't reference these client-only scenes and resources in any way.

The general recommendation is to use Strip Visuals whenever possible, unless the server needs to access image data such as pixels' colors. For example, if your server generates collision data based on an image's contents, you need to use Keep for that particular image.

To check the file structure of your exported PCK, use the Export PCK/ZIP... button with a .zip file extension, then open the resulting ZIP file in a file manager.

Be careful when using the Remove mode, as scenes/resources that reference a removed file will no longer be able to load successfully.

If you wish to remove specific resources but make the scenes still be able to load without them, you'll have to remove the reference in the scene file and load the files to the nodes' properties using load() in a script. This approach can be used to strip resources that Godot doesn't support replacing with placeholders yet, such as audio.

Removing textures is often what makes the greatest impact on the PCK size, so it is recommended to stick with Strip Visuals at first.

With the above options used, a PCK for the client (which exports all resources normally) will look as follows:

The PCK's file structure for the server will look as follows:

If both your client and server are part of the same Godot project, you will have to add a way to start the server directly using a command-line argument.

If you exported the project using the Export as dedicated server export mode (or have added dedicated_server as a custom feature tag), you can use the dedicated_server feature tag to detect whether a dedicated server PCK is being used:

If you also wish to host a server when using the built-in --headless command line argument, this can be done by adding the following code snippet in your main scene (or an autoload)'s _ready() method:

If you wish to use a custom command line argument, this can be done by adding the following code snippet in your main scene (or an autoload)'s _ready() method:

It's a good idea to add at least one of the above command-line arguments to start a server, as it can be used to test server functionality from the command line without having to export the project.

If your client and server are separate Godot projects, your server should most likely be configured in a way where running the main scene starts a server automatically.

On Linux, to make your dedicated server restart after a crash or system reboot, you can create a systemd service. This also lets you view server logs in a more convenient fashion, with automatic log rotation provided by systemd. When making your project hostable as a systemd service, you should also enable the application/run/flush_stdout_on_print project setting. This way, journald (the systemd logging service) can collect logs while the process is running.

If you have experience with containers, you could also look into wrapping your dedicated server in a Docker container. This way, it can be used more easily in an automatic scaling setup (which is outside the scope of this tutorial).

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
.
├── .godot
│   ├── exported
│   │   └── 133200997
│   │       └── export-78c237d4bfdb4e1d02e0b5f38ddfd8bd-scene.scn
│   ├── global_script_class_cache.cfg
│   ├── imported
│   │   ├── map_data.png-ce840618f399a990343bfc7298195a13.ctex
│   │   ├── music.ogg-fa883da45ae49695a3d022f64e60aee2.oggvorbisstr
│   │   └── sprite.png-7958af25f91bb9dbae43f35388f8e840.ctex
│   └── uid_cache.bin
├── client
│   ├── music.ogg.import
│   └── sprite.png.import
├── server
│   └── map_data.png.import
├── test
│   └── scene.gd
└── unused
│   └── development_test.gd
├── project.binary
├── scene.gd
├── scene.tscn.remap
```

Example 2 (unknown):
```unknown
.
├── .godot
│   ├── exported
│   │   └── 3400186661
│   │       ├── export-78c237d4bfdb4e1d02e0b5f38ddfd8bd-scene.scn
│   │       ├── export-7958af25f91bb9dbae43f35388f8e840-sprite.res  # Placeholder texture
│   │       └── export-fa883da45ae49695a3d022f64e60aee2-music.res
│   ├── global_script_class_cache.cfg
│   ├── imported
│   │   └── map_data.png-ce840618f399a990343bfc7298195a13.ctex
│   └── uid_cache.bin
├── client
│   ├── music.ogg.import
│   └── sprite.png.import  # Points to placeholder texture
└── server
│   └── map_data.png.import
├── project.binary
├── scene.gd
├── scene.tscn.remap
```

Example 3 (unknown):
```unknown
# Note: Feature tags are case-sensitive.
if OS.has_feature("dedicated_server"):
    # Run your server startup code here...
    pass
```

Example 4 (unknown):
```unknown
// Note: Feature tags are case-sensitive.
if (OS.HasFeature("dedicated_server"))
{
    // Run your server startup code here...
}
```

---

## Exporting for iOS — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/export/exporting_for_ios.html

**Contents:**
- Exporting for iOS
- Requirements
- Export a Godot project to Xcode
- Active development considerations
  - Steps to link a Godot project folder to Xcode
- Plugins for iOS
- Environment variables
- Troubleshooting
  - xcode-select points at wrong SDK location
- Export options

This page describes how to export a Godot project to iOS. If you're looking to compile export template binaries from source instead, read Compiling for iOS.

These are the steps to load a Godot project in Xcode. This allows you to build and deploy to an iOS device, build a release for the App Store, and do everything else you can normally do with Xcode.

Projects written in C# can be exported to iOS as of Godot 4.2, but support is experimental and some limitations apply.

You must export for iOS from a computer running macOS with Xcode installed.

Download the Godot export templates. Use the Godot menu: Editor > Manage Export Templates

In the Godot editor, open the Export window from the Project menu. When the Export window opens, click Add.. and select iOS.

The App Store Team ID and (Bundle) Identifier options in the Application category are required. Leaving them blank will cause the exporter to throw an error.

After you click Export Project, there are still two important options left:

Path is an empty folder that will contain the exported Xcode project files.

File will be the name of the Xcode project and several project specific files and directories.

This tutorial uses exported_xcode_project_name, but you will use your project's name. When you see exported_xcode_project_name in the following steps, replace it with the name you used instead.

Avoid using spaces when you choose your exported_xcode_project_name as this can lead to corruption in your XCode project file.

When the export completes, the output folder should look like this:

Exporting for the iOS simulator is currently not supported as per GH-102149.

Apple Silicon Macs can run iOS apps natively, so you can run exported iOS projects directly on an Apple Silicon Mac without needing the iOS simulator.

Opening exported_xcode_project_name.xcodeproj lets you build and deploy like any other iOS app.

The above method creates an exported project that you can build for release, but you have to re-export every time you make a change in Godot.

While developing, you can speed this process up by linking your Godot project files directly into your app.

In the following example:

exported_xcode_project_name is the name of the exported iOS application (as above).

godot_project_to_export is the name of the Godot project.

godot_project_to_export must not be the same as exported_xcode_project_name to prevent signing issues in Xcode.

Start from an exported iOS project (follow the steps above).

In Finder, drag the Godot project folder into the Xcode file browser.

In the dialog, make sure to select Action: Reference files in place and Groups: Create folders. Uncheck Targets: exported_xcode_project_name.

See the godot_project_to_export folder in the Xcode file browser.

Select the godot project in the Project navigator. Then on the other side of the XCode window, in the File Inspector, make these selections:

Location: Relative to Project

Build Rules: Apply Once to Folder

add your project to Target Membership

Delete exported_xcode_project_name.pck from the Xcode project in the project navigator.

8. Open exported_xcode_project_name-Info.plist and add a string property named godot_path (this is the real key name) with a value godot_project_to_export (this is the name of your project)

That's it! You can now edit your project in the Godot editor and build it in Xcode when you want to run it on a device.

Special iOS plugins can be used in Godot. Check out the Plugins for iOS page.

You can use the following environment variables to set export options outside of the editor. During the export process, these override the values that you set in the export menu.

Encryption / Encryption Key

GODOT_SCRIPT_ENCRYPTION_KEY

Options / Application / Provisioning Profile UUID Debug

GODOT_IOS_PROVISIONING_PROFILE_UUID_DEBUG

Options / Application / Provisioning Profile UUID Release

GODOT_IOS_PROVISIONING_PROFILE_UUID_RELEASE

xcode-select is a tool that comes with Xcode and among other things points at iOS SDKs on your Mac. If you have Xcode installed, opened it, agreed to the license agreement, and installed the command line tools, xcode-select should point at the right location for the iPhone SDK. If it somehow doesn't, Godot will fail exporting to iOS with an error that may look like this:

In this case, Godot is trying to find the Platforms folder containing the iPhone SDK inside the /Library/Developer/CommandLineTools/ folder, but the Platforms folder with the iPhone SDK is actually located under /Applications/Xcode.app/Contents/Developer. To verify this, you can open up Terminal and run the following command to see what xcode-select points at:

To fix xcode-select pointing at a wrong location, enter this command in Terminal:

After running this command, Godot should be able to successfully export to iOS.

You can find a full list of export options available in the EditorExportPlatformIOS class reference.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
MSB3073: The command ""clang" <LOTS OF PATHS AND COMMAND LINE ARGUMENTS HERE>
"/Library/Developer/CommandLineTools/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk"" exited with code 1.
```

Example 2 (unknown):
```unknown
xcode-select -p
```

Example 3 (unknown):
```unknown
sudo xcode-select -switch /Applications/Xcode.app
```

---

## Exporting for Linux — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/export/exporting_for_linux.html

**Contents:**
- Exporting for Linux
- Environment variables
- Export options
- User-contributed notes

This page describes how to export a Godot project to Linux. If you're looking to compile editor or export template binaries from source instead, read Compiling for Linux, *BSD.

The simplest way to distribute a game for PC is to copy the executable (godot), compress the folder and send it to someone else. However, this is often not desired.

Godot offers a more elegant approach for PC distribution when using the export system. When exporting for Linux, the exporter takes all the project files and creates a data.pck file. This file is bundled with a specially optimized binary that is smaller, faster and does not contain the editor and debugger.

You can use the following environment variables to set export options outside of the editor. During the export process, these override the values that you set in the export menu.

Encryption / Encryption Key

GODOT_SCRIPT_ENCRYPTION_KEY

You can find a full list of export options available in the EditorExportPlatformLinuxBSD class reference.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Exporting for macOS — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/export/exporting_for_macos.html

**Contents:**
- Exporting for macOS
- Requirements
- Code signing and notarization
  - If you have an Apple Developer ID Certificate and exporting from macOS
    - To sign exported app
    - To notarize exported app
  - If you have an Apple Developer ID Certificate and exporting from Linux or Windows
    - To sign exported app
    - To notarize exported app
  - If you do not have an Apple Developer ID Certificate

This page describes how to export a Godot project to macOS. If you're looking to compile editor or export template binaries from source instead, read Compiling for macOS.

macOS apps exported with the official export templates are exported as a single "Universal 2" binary .app bundle, a folder with a specific structure which stores the executable, libraries and all the project files. This bundle can be exported as is, packed in a ZIP archive, or packed in a DMG disk image (only supported when exporting from macOS). Universal binaries for macOS support both Intel x86_64 and ARM64 (Apple Silicon) architectures.

Due to file system limitations, .app bundles exported from Windows lack the executable flag and won't run on macOS. Projects exported as .zip are not affected by this issue. To run .app bundles exported from Windows on macOS, transfer the .app to a device running macOS or Linux and use the chmod +x {executable_name} terminal command to add the executable permission. The main executable located in the Contents/MacOS/ subfolder, as well as optional helper executables in the Contents/Helpers/ subfolder, should have the executable permission for the .app bundle to be valid.

Download the Godot export templates. Use the Godot menu: Editor > Manage Export Templates.

A valid and unique Bundle identifier should be set in the Application section of the export options.

Projects exported without code signing and notarization will be blocked by Gatekeeper if they are downloaded from unknown sources, see the Running Godot apps on macOS page for more information.

By default, macOS will run only applications that are signed and notarized. If you use any other signing configuration, see Running Godot apps on macOS for workarounds.

To notarize an app, you must have a valid Apple Developer ID Certificate.

Install Xcode command line tools and open Xcode at least once or run the sudo xcodebuild -license accept command to accept license agreement.

Select Xcode codesign in the Code Signing > Codesign option.

Set valid Apple ID certificate identity (certificate "Common Name") in the Code Signing > Identity section.

Select Xcode altool in the Notarization > Notarization option.

Disable the Debugging entitlement.

Set valid Apple ID login / app. specific password or App Store Connect API UUID / Key in the Notarization section.

You can use the xcrun notarytool history command to check notarization status and use the xcrun notarytool log {ID} command to download the notarization log.

If you encounter notarization issues, see Resolving common notarization issues for more info.

After notarization is completed, staple the ticket to the exported project.

Install PyOxidizer rcodesign, and configure the path to rcodesign in the Editor Settings > Export > macOS > rcodesign.

Select PyOxidizer rcodesign in the Code Signing > Codesign option.

Set valid Apple ID PKCS #12 certificate file and password in the Code Signing section.

Select PyOxidizer rcodesign in the Notarization > Notarization option.

Disable the Debugging entitlement.

Set valid App Store Connect API UUID / Key in the Notarization section.

You can use the rcodesign notary-log command to check notarization status.

After notarization is completed, use the rcodesign staple command to staple the ticket to the exported project.

Select Built-in (ad-hoc only) in the Code Signing > Codesign option.

Select Disabled in the Notarization > Notarization option.

In this case Godot will use an ad-hoc signature, which will make running an exported app easier for the end users, see the Running Godot apps on macOS page for more information.

Tool to use for code signing.

The "Full Name" or "Common Name" of the signing identity, store in the macOS keychain. [1]

The PKCS #12 certificate file. [2]

Password for the certificate file. [2]

Array of command line arguments passed to the code signing tool.

This option is visible only when signing with Xcode codesign.

These options are visible only when signing with PyOxidizer rcodesign.

Tool to use for notarization.

Apple ID account name (email address). [3]

Apple ID app-specific password. See Using app-specific passwords to enable two-factor authentication and create app password. [3]

Team ID ("Organization Unit"), if your Apple ID belongs to multiple teams (optional). [3]

Apple App Store Connect API issuer UUID.

Apple App Store Connect API key.

You should set either Apple ID Name/Password or App Store Connect API UUID/Key.

These options are visible only when notarizing with Xcode altool.

See Notarizing macOS Software Before Distribution for more info.

Hardened Runtime entitlements manage security options and resource access policy. See Hardened Runtime for more info.

Allow JIT Code Execution [4]

Allows creating writable and executable memory for JIT code. If you are using add-ons with dynamic or self-modifying native code, enable them according to the add-on documentation.

Allow Unsigned Executable Memory [4]

Allows creating writable and executable memory without JIT restrictions. If you are using add-ons with dynamic or self-modifying native code, enable them according to the add-on documentation.

Allow DYLD Environment Variables [4]

Allows app to uss dynamic linker environment variables to inject code. If you are using add-ons with dynamic or self-modifying native code, enable them according to the add-on documentation.

Disable Library Validation

Allows app to load arbitrary libraries and frameworks. Enable it if you are using GDExtension add-ons or ad-hoc signing, or want to support user-provided external add-ons.

Enable if you need to use the microphone or other audio input sources, if it's enabled you should also provide usage message in the privacy/microphone_usage_description option.

Enable if you need to use the camera, if it's enabled you should also provide usage message in the privacy/camera_usage_description option.

Enable if you need to use location information from Location Services, if it's enabled you should also provide usage message in the privacy/location_usage_description option.

[5] Enable to allow access contacts in the user's address book, if it's enabled you should also provide usage message in the privacy/address_book_usage_description option.

[5] Enable to allow access to the user's calendar, if it's enabled you should also provide usage message in the privacy/calendar_usage_description option.

[5] Enable to allow access to the user's Photos library, if it's enabled you should also provide usage message in the privacy/photos_library_usage_description option.

[5] Enable to allow app to send Apple events to other apps.

[6] You can temporarily enable this entitlement to use native debugger (GDB, LLDB) with the exported app. This entitlement should be disabled for production export.

The Allow JIT Code Execution, Allow Unsigned Executable Memory and Allow DYLD Environment Variables entitlements are always enabled for the Godot Mono exports, and are not visible in the export options.

These features aren't supported by Godot out of the box, enable them only if you are using add-ons which require them.

To notarize an app, you must disable the Debugging entitlement.

The App Sandbox restricts access to user data, networking and devices. Sandboxed apps can't access most of the file system, can't use custom file dialogs and execute binaries (using OS.execute and OS.create_process) outside the .app bundle. See App Sandbox for more info.

To distribute an app through the App Store, you must enable the App Sandbox.

Enable to allow app to listen for incoming network connections.

Enable to allow app to establish outgoing network connections.

Enable to allow app to interact with USB devices. This entitlement is required to use wired controllers.

Enable to allow app to interact with Bluetooth devices. This entitlement is required to use wireless controllers.

Allows read or write access to the user's "Downloads" folder.

Allows read or write access to the user's "Pictures" folder.

Allows read or write access to the user's "Music" folder.

Allows read or write access to the user's "Movies" folder.

Files User Selected [7]

Allows read or write access to arbitrary folder. To gain access, a folder must be selected from the native file dialog by the user.

List of helper executables to embedded to the app bundle. Sandboxed app are limited to execute only these executable.

You can optionally provide usage messages for various folders in the privacy/*_folder_usage_description options.

You can override default entitlements by selecting custom entitlements file, in this case all other entitlement are ignored.

You can use the following environment variables to set export options outside of the editor. During the export process, these override the values that you set in the export menu.

Encryption / Encryption Key

GODOT_SCRIPT_ENCRYPTION_KEY

Options / Codesign / Certificate File

GODOT_MACOS_CODESIGN_CERTIFICATE_FILE

Options / Codesign / Certificate Password

GODOT_MACOS_CODESIGN_CERTIFICATE_PASSWORD

Options / Codesign / Provisioning Profile

GODOT_MACOS_CODESIGN_PROVISIONING_PROFILE

Options / Notarization / API UUID

GODOT_MACOS_NOTARIZATION_API_UUID

Options / Notarization / API Key

GODOT_MACOS_NOTARIZATION_API_KEY

Options / Notarization / API Key ID

GODOT_MACOS_NOTARIZATION_API_KEY_ID

Options / Notarization / Apple ID Name

GODOT_MACOS_NOTARIZATION_APPLE_ID_NAME

Options / Notarization / Apple ID Password

GODOT_MACOS_NOTARIZATION_APPLE_ID_PASSWORD

You can find a full list of export options available in the EditorExportPlatformMacOS class reference.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Exporting for the Web — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/export/exporting_for_web.html

**Contents:**
- Exporting for the Web
- Export file name
- WebGL version
- Mobile considerations
- Audio playback
- Export options
  - Thread and extension support
  - Exporting as a Progressive Web App (PWA)
- Limitations
  - Using cookies for data persistence

This page describes how to export a Godot project to HTML5. If you're looking to compile editor or export template binaries from source instead, read Compiling for the Web.

HTML5 export allows publishing games made in Godot Engine to the browser. This requires support for WebAssembly and WebGL 2.0 in the user's browser.

Projects written in C# using Godot 4 currently cannot be exported to the web. See this blog post for more information.

To use C# on web platforms, use Godot 3 instead.

Use the browser-integrated developer console, usually opened with F12 or Ctrl + Shift + I (Cmd + Option + I on macOS), to view debug information like JavaScript, engine, and WebGL errors.

If the shortcut doesn't work, it's because Godot actually captures the input. You can still open the developer console by accessing the browser's menu.

Due to security concerns with SharedArrayBuffer due to various exploits, the use of multiple threads for the Web platform has multiple drawbacks, including requiring specific server-side headers and complete cross-origin isolation (meaning no ads, nor third-party integrations on the website hosting your game).

Since Godot 4.3, Godot supports exporting your game on a single thread, which solves this issue. While it has some drawbacks on its own (it cannot use threads, and is not as performant as the multi-threaded export), it doesn't require as much overhead to install. It is also more compatible overall with stores like itch.io or Web publishers like Poki or CrazyGames. The single-threaded export works very well on macOS and iOS too, where it always had compatibility issues with multiple threads exports.

For these reasons, it is the preferred and now default way to export your games on the Web.

For more information, see this blog post about single-threaded Web export.

See the list of open issues on GitHub related to the web export for a list of known bugs.

We suggest users to export their Web projects with index.html as the file name. index.html is usually the default file loaded by web servers when accessing the parent directory, usually hiding the name of that file.

The Godot 4 Web export expects some files to be named the same name as the one set in the initial export. Some issues could occur if some exported files are renamed, including the main HTML file.

Godot 4.0 and later can only target WebGL 2.0 (using the Compatibility rendering method). Forward+/Mobile are not supported on the web platform, as these rendering methods are designed around modern low-level graphics APIs. Godot currently does not support WebGPU, which is a prerequisite for allowing Forward+/Mobile to run on the web platform.

See Can I use WebGL 2.0 for a list of browser versions supporting WebGL 2.0. Note that Safari has several issues with WebGL 2.0 support that other browsers don't have, so we recommend using a Chromium-based browser or Firefox if possible.

The Web export can run on mobile platforms with some caveats. While native Android and iOS exports will always perform better by a significant margin, the Web export allows people to run your project without going through app stores.

Remember that CPU and GPU performance is at a premium when running on mobile devices. This is even more the case when running a project exported to Web (as it's WebAssembly instead of native code). See Performance section of the documentation for advice on optimizing your project. If your project runs on platforms other than Web, you can use Feature tags to apply low-end-oriented settings when running the project exported to Web.

To speed up loading times on mobile devices, you should also compile an optimized export template with unused features disabled. Depending on the features used by your project, this can reduce the size of the WebAssembly payload significantly, making it faster to download and initialize (even when cached).

Since Godot 4.3, audio playback is done using the Web Audio API on the web platform. This Sample playback mode allows for low latency even when the project is exported without thread support, but it has several limitations:

AudioEffects are not supported.

Reverberation and doppler effects are not supported.

Procedural audio generation is not supported.

Positional audio may not always work correctly depending on the node's properties.

To use Godot's own audio playback system on the web platform, you can change the default playback mode using the Audio > General > Default Playback Type.web project setting, or change the Playback Type property to Stream on an AudioStreamPlayer, AudioStreamPlayer2D or AudioStreamPlayer3D node. This leads to increased latency (especially when thread support is disabled), but it allows the full suite of Godot's audio features to work.

If a runnable web export template is available, a button appears between the Stop scene and Play edited Scene buttons in the editor to quickly open the game in the default browser for testing.

If your project uses GDExtension, Extension Support needs to be enabled.

If you plan to use VRAM compression make sure that VRAM Texture Compression is enabled for the targeted platforms (enabling both For Desktop and For Mobile will result in a bigger, but more compatible export).

If a path to a Custom HTML shell file is given, it will be used instead of the default HTML page. See Custom HTML page for Web export.

Head Include is appended into the <head> element of the generated HTML page. This allows to, for example, load webfonts and third-party JavaScript APIs, include CSS, or run JavaScript code.

The window size will automatically match the browser window size by default. If you want to use a fixed size instead regardless of the browser window size, change Canvas Resize Policy to None. This allows controlling the window size with custom JavaScript code in the HTML shell. You can also set it to Project to make it behave closer to a native export, according to the project settings.

Each project must generate their own HTML file. On export, several text placeholders are replaced in the generated HTML file specifically for the given export options. Any direct modifications to that HTML file will be lost in future exports. To customize the generated file, use the Custom HTML shell option.

If Thread Support is enabled, the exported project will be able to make use of multithreading to improve performance. This also allows for low-latency audio playback when the playback type is set to Stream (instead of the default Sample that is used in web exports). Enabling this feature requires the use of cross-origin isolation headers, which are described in the Serving the files section below.

If Extensions Support is enabled, GDExtensions will be able to be loaded. Note that GDExtensions still need to be specifically compiled for the web platform to work. Like thread support, enabling this feature requires the use of cross-origin isolation headers.

If Progressive Web App > Enable is enabled, it will have several effects:

Configure high-resolution icons, a display mode and screen orientation. These are configured at the end of the Progressive Web App section in the export options. These options are used if the user adds the project to their device's homescreen, which is common on mobile platforms. This is also supported on desktop platforms, albeit in a more limited capacity.

Allow the project to be loaded without an Internet connection if it has been loaded at least once beforehand. This works thanks to the service worker that is installed when the project is first loaded in the user's browser. This service worker provides a local fallback when no Internet connection is available.

Note that web browsers can choose to evict the cached data if the user runs low on disk space, or if the user hasn't opened the project for a while. To ensure data is cached for a longer duration, the user can bookmark the page, or ideally add it to their device's home screen.

If the offline data is not available because it was evicted from the cache, you can configure an Offline Page that will be displayed in this case. The page must be in HTML format and will be saved on the client's machine the first time the project is loaded.

Ensure cross-origin isolation headers are always present, even if the web server hasn't been configured to send them. This allows exports with threads enabled to work when hosted on any website, even if there is no way for you to control the headers it sends.

This behavior can be disabled by unchecking Enable Cross Origin Isolation Headers in the Progressive Web App section.

For security and privacy reasons, many features that work effortlessly on native platforms are more complicated on the web platform. Following is a list of limitations you should be aware of when porting a Godot game to the web.

Browser vendors are making more and more functionalities only available in secure contexts, this means that such features are only be available if the web page is served via a secure HTTPS connection (localhost is usually exempt from such requirement).

Users must allow cookies (specifically IndexedDB) if persistence of the user:// file system is desired. When playing a game presented in an iframe, third-party cookies must also be enabled. Incognito/private browsing mode also prevents persistence.

The method OS.is_userfs_persistent() can be used to check if the user:// file system is persistent, but can give false positives in some cases.

The project will be paused by the browser when the tab is no longer the active tab in the user's browser. This means functions such as _process() and _physics_process() will no longer run until the tab is made active again by the user (by switching back to the tab). This can cause networked games to disconnect if the user switches tabs for a long duration.

This limitation does not apply to unfocused browser windows. Therefore, on the user's side, this can be worked around by running the project in a separate window instead of a separate tab.

Browsers do not allow arbitrarily entering full screen. The same goes for capturing the cursor. Instead, these actions have to occur as a response to a JavaScript input event. In Godot, this means entering full screen from within a pressed input event callback such as _input or _unhandled_input. Querying the Input singleton is not sufficient, the relevant input event must currently be active.

For the same reason, the full screen project setting doesn't work unless the engine is started from within a valid input event handler. This requires customization of the HTML page.

Some browsers restrict autoplay for audio on websites. The easiest way around this limitation is to request the player to click, tap or press a key/button to enable audio, for instance when displaying a splash screen at the start of your game.

Google offers additional information about their Web Audio autoplay policies.

Apple's Safari team also posted additional information about their Auto-Play Policy Changes for macOS.

Access to microphone requires a secure context.

Since Godot 4.3, by default Web exports will use samples instead of streams to play audio.

This is due to the way browsers prefer to play audio and the lack of processing power available when exporting Web games with the Use Threads export option off.

Please note that audio effects aren't yet implemented for samples.

Low-level networking is not implemented due to lacking support in browsers.

Currently, only HTTP client, HTTP requests, WebSocket (client) and WebRTC are supported.

The HTTP classes also have several restrictions on the HTML5 platform:

Accessing or changing the StreamPeer is not possible

Threaded/Blocking mode is not available

Cannot progress more than once per frame, so polling in a loop will freeze

Host verification cannot be disabled

Subject to same-origin policy

Clipboard synchronization between engine and the operating system requires a browser supporting the Clipboard API, additionally, due to the API asynchronous nature might not be reliable when accessed from GDScript.

Requires a secure context.

Gamepads will not be detected until one of their button is pressed. Gamepads might have the wrong mapping depending on the browser/OS/gamepad combination, sadly the Gamepad API does not provide a reliable way to detect the gamepad information necessary to remap them based on model/vendor/OS due to privacy considerations.

Requires a secure context.

Exporting for the web generates several files to be served from a web server, including a default HTML page for presentation. A custom HTML file can be used, see Custom HTML page for Web export.

Only when exporting with Use Threads, to ensure low audio latency and the ability to use Thread in web exports, Godot 4 web exports use SharedArrayBuffer. This requires a secure context, while also requiring the following CORS headers to be set when serving the files:

If you don't control the web server or are unable to add response headers, check Progressive Web App > Enable in the export options. This applies a service worker-based workaround that allows the project to run by simulating the presence of these response headers. A secure context is still required in this case.

If the client doesn't receive the required response headers or the service worker-based workaround is not applied, the project will not run.

The generated .html file can be used as DirectoryIndex in Apache servers and can be renamed to e.g. index.html at any time. Its name is never depended on by default.

The HTML page draws the game at maximum size within the browser window. This way, it can be inserted into an <iframe> with the game's size, as is common on most web game hosting sites.

The other exported files are served as they are, next to the .html file, names unchanged. The .wasm file is a binary WebAssembly module implementing the engine. The .pck file is the Godot main pack containing your game. The .js file contains start-up code and is used by the .html file to access the engine. The .png file contains the boot splash image.

The .pck file is binary, usually delivered with the MIME-type application/octet-stream. The .wasm file is delivered as application/wasm.

Delivering the WebAssembly module (.wasm) with a MIME-type other than application/wasm can prevent some start-up optimizations.

Delivering the files with server-side compression is recommended especially for the .pck and .wasm files, which are usually large in size. The WebAssembly module compresses particularly well, down to around a quarter of its original size with gzip compression. Consider using Brotli precompression if supported on your web server for further file size savings.

Hosts that provide on-the-fly compression: GitHub Pages (gzip)

Hosts that don't provide on-the-fly compression: itch.io, GitLab Pages (supports manual gzip precompression)

The Godot repository includes a Python script to host a local web server. This script is intended for testing the web editor, but it can also be used to test exported projects.

Save the linked script to a file called serve.py, move this file to the folder containing the exported project's index.html, then run the following command in a command prompt within the same folder:

On Windows, you can open a command prompt in the current folder by holding Shift and right-clicking on empty space in Windows Explorer, then choosing Open PowerShell window here.

This will serve the contents of the current folder and open the default web browser automatically.

Note that for production use cases, this Python-based web server should not be used. Instead, you should use an established web server such as Apache or nginx.

See the dedicated page on how to interact with JavaScript and access some unique Web browser features.

You can use the following environment variables to set export options outside of the editor. During the export process, these override the values that you set in the export menu.

Encryption / Encryption Key

GODOT_SCRIPT_ENCRYPTION_KEY

If you use one-click deploy in multiple projects, you may notice that one of the projects you've previously deployed is shown instead of the project you're currently working on. This is due to service worker caching which currently lacks an automated cache busting mechanism.

As a workaround, you can manually unregister the current service worker so that the cache is reset. This also allows a new service worker to be registered. In Chromium-based browsers, open the Developer Tools by pressing F12 or Ctrl + Shift + I (Cmd + Option + I on macOS), then click on the Application tab in DevTools (it may be hidden behind a chevron icon if the devtools pane is narrow). You can either check Update on reload and reload the page, or click Unregister next to the service worker that is currently registered, then reload the page.

Unregistering the service worker in Chromium-based browsers' DevTools

The procedure is similar in Firefox. Open developer tools by pressing F12 or Ctrl + Shift + I (Cmd + Option + I on macOS), click on the Application tab in DevTools (it may be hidden behind a chevron icon if the devtools pane is narrow). Click Unregister next to the service worker that is currently registered, then reload the page.

Unregistering the service worker in Firefox's DevTools

You can find a full list of export options available in the EditorExportPlatformWeb class reference.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
Cross-Origin-Opener-Policy: same-origin
Cross-Origin-Embedder-Policy: require-corp
```

Example 2 (unknown):
```unknown
# You may need to replace `python` with `python3` on some platforms.
python serve.py --root .
```

---

## Exporting for visionOS — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/export/exporting_for_visionos.html

**Contents:**
- Exporting for visionOS
- User-contributed notes

This page describes how to export a Godot project to visionOS. If you're looking to compile export template binaries from source instead, see Compiling for visionOS.

Exporting instructions for visionOS are currently identical to Compiling for iOS, except you should add a visionOS export preset instead of iOS. See the linked page for details.

Note that currently, only exporting an application for use on a flat plane within the headset is supported. Immersive experiences are not supported.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Exporting for Windows — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/export/exporting_for_windows.html

**Contents:**
- Exporting for Windows
- Changing the executable icon
- Code signing
  - Setup
- Environment variables
- Export options
- User-contributed notes

This page describes how to export a Godot project to Windows. If you're looking to compile editor or export template binaries from source instead, read Compiling for Windows.

The simplest way to distribute a game for PC is to copy the executable (godot.exe), compress the folder and send it to someone else. However, this is often not desired.

Godot offers a more elegant approach for PC distribution when using the export system. When exporting for Windows, the exporter takes all the project files and creates a data.pck file. This file is bundled with a specially optimized binary that is smaller, faster and does not contain the editor and debugger.

Godot will automatically use whatever image is set as your project's icon in the project settings, and convert it to an ICO file for the exported project. If you want to manually create an ICO file for greater control over how the icon looks at different resolutions then see the Manually changing application icon for Windows page.

Godot is capable of automatic code signing on export. To do this you must have the Windows SDK (on Windows) or osslsigncode (on any other OS) installed. You will also need a package signing certificate, information on creating one can be found here.

If you export for Windows with embedded PCK files, you will not be able to sign the program as it will break.

On Windows, PCK embedding is also known to cause false positives in antivirus programs. Therefore, it's recommended to avoid using it unless you're distributing your project via Steam as it bypasses code signing and antivirus checks.

Settings need to be changed in two places. First, in the editor settings, under Export > Windows. Click on the folder next to the Sign Tool setting, if you're using Windows navigate to and select SignTool.exe, if you're on a different OS select osslsigncode.

The second location is the Windows export preset, which can be found in Project > Export.... Add a windows desktop preset if you haven't already. Under options there is a code signing category.

Enabled must be set to true, and Identity must be set to the signing certificate. The other settings can be adjusted as needed. Once this is Done Godot will sign your project on export.

You can use the following environment variables to set export options outside of the editor. During the export process, these override the values that you set in the export menu.

Encryption / Encryption Key

GODOT_SCRIPT_ENCRYPTION_KEY

Options / Codesign / Identity Type

GODOT_WINDOWS_CODESIGN_IDENTITY_TYPE

Options / Codesign / Identity

GODOT_WINDOWS_CODESIGN_IDENTITY

Options / Codesign / Password

GODOT_WINDOWS_CODESIGN_PASSWORD

You can find a full list of export options available in the EditorExportPlatformWindows class reference.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Exporting packs, patches, and mods — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/export/exporting_pcks.html

**Contents:**
- Exporting packs, patches, and mods
- Use cases
- Overview of PCK/ZIP files
- Generating PCK files
- Opening PCK or ZIP files at runtime
  - Troubleshooting
- Summary
- User-contributed notes

Oftentimes, one would like to add functionality to one's game after it has been deployed.

Examples of this include...

Downloadable Content: the ability to add features and content to one's game.

Patches: the ability to fix a bug that is present in a shipped product.

Mods: grant other people the ability to create content for one's game.

These tools help developers to extend their development beyond the initial release.

Godot enables this via a feature called resource packs (PCK files, with the .pck extension, or ZIP files).

incremental updates/patches

no source code disclosure needed for mods

more modular project structure

users don't have to replace the entire game

The first part of using them involves exporting and delivering the project to players. Then, when one wants to add functionality or content later on, they just deliver the updates via PCK/ZIP files to the users.

PCK/ZIP files usually contain, but are not limited to:

any other asset suitable for import into the game

The PCK/ZIP files can even be an entirely different Godot project, which the original game loads in at runtime.

It is possible to load both PCK and ZIP files as additional packs at the same time. See PCK versus ZIP pack file formats for a comparison of the two formats.

If you want to load loose files at runtime (not packed in a PCK or ZIP by Godot), consider using Runtime file loading and saving instead. This is useful for loading user-generated content that is not made with Godot, without requiring users to pack their mods into a specific file format.

The downside of this approach is that it's less transparent to the game logic, as it will not benefit from the same resource management as PCK/ZIP files.

In order to pack all resources of a project into a PCK file, open the project and go to Project > Export and click on Export PCK/ZIP. Also, make sure to have an export preset selected while doing so.

Another method would be to export from the command line with --export-pack. The output file must with a .pck or .zip file extension. The export process will build that type of file for the chosen platform.

If one wishes to support mods for their game, they will need their users to create similarly exported files. Assuming the original game expects a certain structure for the PCK's resources and/or a certain interface for its scripts, then either...

The developer must publicize documentation of these expected structures/ interfaces, expect modders to install Godot Engine, and then also expect those modders to conform to the documentation's defined API when building mod content for the game (so that it will work). Users would then use Godot's built in exporting tools to create a PCK file, as detailed above.

The developer uses Godot to build a GUI tool for adding their exact API content to a project. This Godot tool must either run on a tools-enabled build of the engine or have access to one (distributed alongside or perhaps in the original game's files). The tool can then use the Godot executable to export a PCK file from the command line with OS.execute(). The game itself shouldn't use a tool-build of the engine (for security), so it's best to keep the modding tool and game separate.

To load a PCK or ZIP file, one uses the ProjectSettings singleton. The following example expects a mod.pck file in the directory of the game's executable. The PCK or ZIP file contains a mod_scene.tscn test scene in its root.

By default, if you import a file with the same file path/name as one you already have in your project, the imported one will replace it. This is something to watch out for when creating DLC or mods. You can solve this problem by using a tool that isolates mods to a specific mods subfolder.

However, it is also a way of creating patches for one's own game. A PCK/ZIP file of this kind can fix the content of a previously loaded PCK/ZIP (therefore, the order in which packs are loaded matters).

To opt out of this behavior, pass false as the second argument to ProjectSettings.load_resource_pack().

For a C# project, you need to build the DLL and place it in the project directory first. Then, before loading the resource pack, you need to load its DLL as follows: Assembly.LoadFile("mod.dll")

If you are loading a resource pack and are not noticing any changes, it may be due to the pack being loaded too late. This is particularly the case with menu scenes that may preload other scenes using preload(). This means that loading a pack in the menu will not affect the other scene that was already preloaded.

To avoid this, you need to load the pack as early as possible. To do so, create a new autoload script and call ProjectSettings.load_resource_pack() in the autoload script's _init() function, rather than _enter_tree() or _ready().

This tutorial explains how to add mods, patches, or DLC to a game. The most important thing is to identify how one plans to distribute future content for their game and develop a workflow that is customized for that purpose. Godot should make that process smooth regardless of which route a developer pursues.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
func _your_function():
    # This could fail if, for example, mod.pck cannot be found.
    var success = ProjectSettings.load_resource_pack(OS.get_executable_path().get_base_dir().path_join("mod.pck"))

    if success:
        # Now one can use the assets as if they had them in the project from the start.
        var imported_scene = load("res://mod_scene.tscn")
```

Example 2 (unknown):
```unknown
private void YourFunction()
{
    // This could fail if, for example, mod.pck cannot be found.
    var success = ProjectSettings.LoadResourcePack(OS.get_executable_path().get_base_dir().path_join("mod.pck));

    if (success)
    {
        // Now one can use the assets as if they had them in the project from the start.
        var importedScene = (PackedScene)ResourceLoader.Load("res://mod_scene.tscn");
    }
}
```

---

## Exporting projects — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/export/exporting_projects.html

**Contents:**
- Exporting projects
- Why export?
  - On PC
  - On mobile
- Export menu
  - Export templates
  - Resource options
- Configuration files
- Exporting from the command line
- PCK versus ZIP pack file formats

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

Originally, Godot did not have any means to export projects. The developers would compile the proper binaries and build the packages for each platform manually.

When more developers (and even non-programmers) started using it, and when our company started taking more projects at the same time, it became evident that this was a bottleneck.

Distributing a game project on PC with Godot is rather easy. Drop the Godot binary in the same directory as the project.godot file, then compress the project directory and you are done.

It sounds simple, but there are probably a few reasons why the developer may not want to do this. The first one is that it may not be desirable to distribute loads of files. Some developers may not like curious users peeking at how the game was made, others may find it inelegant, and so on. Another reason is that the developer might prefer a specially-compiled binary, which is smaller in size, more optimized and does not include tools like the editor and debugger.

Finally, Godot has a simple but efficient system for creating DLCs as extra package files.

The same scenario on mobile platforms is a little worse. To distribute a project on those devices, a binary for each of those platforms is built, then added to a native project together with the game data.

This can be troublesome because it means that the developer must be familiarized with the SDK of each platform before even being able to export. While learning each SDK is always encouraged, it can be frustrating to be forced to do it at an undesired time.

There is also another problem with this approach: different devices prefer some data in different formats to run. The main example of this is texture compression. All PC hardware uses S3TC (BC) compression and that has been standardized for more than a decade, but mobile devices use different formats for texture compression, such as ETC1 and ETC2.

After many attempts at different export workflows, the current one has proven to work the best. At the time of this writing, not all platforms are supported yet, but the supported platforms continue to grow.

To open the export menu, click the Export button:

The export menu will open. However, it will be completely empty. This is because we need to add an export preset.

To create an export preset, click the Add… button at the top of the export menu. This will open a drop-down list of platforms to choose from for an export preset.

The default options are often enough to export, so tweaking them is usually not necessary. However, many platforms require additional tools (SDKs) to be installed to be able to export. Additionally, Godot needs export templates installed to create packages. The export menu will complain when something is missing and will not allow the user to export for that platform until they resolve it:

At that time, the user is expected to come back to the documentation and follow instructions on how to properly set up that platform.

The buttons at the bottom of the menu allow you to export the project in a few different ways:

Export All: Export the project as a playable build (Godot executable and project data) for all the presets defined. All presets must have an Export Path defined for this to work.

Export Project: Export the project as a playable build (Godot executable and project data) for the selected preset.

Export PCK/ZIP: Export the project resources as a PCK or ZIP package. This is not a playable build, it only exports the project data without a Godot executable.

Apart from setting up the platform, the export templates must be installed to be able to export projects. They can be obtained as a TPZ file (which is a renamed ZIP archive) from the download page of the website.

Once downloaded, they can be installed using the Install Export Templates option in the editor:

When exporting, Godot makes a list of all the files to export and then creates the package. There are 3 different modes for exporting:

Export all resources in the project

Export selected scenes (and dependencies)

Export selected resources (and dependencies)

Export all resources in the project will export every resource in the project. Export selected scenes and Export selected resources gives you a list of the scenes or resources in the project, and you have to select every scene or resource you want to export.

Export all resources in the project except resources checked below does exactly what it says, everything will be exported except for what you select in the list.

Export as dedicated server will remove all visuals from a project and replace them with a placeholder. This includes Cubemap, CubemapArray, Material, Mesh, Texture2D, Texture2DArray, Texture3D. You can also go into the list of files and specify specific visual resources that you do wish to keep.

Files and folders whose name begin with a period will never be included in the exported project. This is done to prevent version control folders like .git from being included in the exported PCK file.

Below the list of resources are two filters that can be setup. The first allows non-resource files such as .txt, .json and .csv to be exported with the project. The second filter can be used to exclude every file of a certain type without manually deselecting every one. For example, .png files.

The export configuration is stored in two files that can both be found in the project directory:

export_presets.cfg: This file contains the vast majority of the export configuration and can be safely committed to version control. There is nothing in here that you would normally have to keep secret.

.godot/export_credentials.cfg: This file contains export options that are considered confidential, like passwords and encryption keys. It should generally not be committed to version control or shared with others unless you know exactly what you are doing.

Since the credentials file is usually kept out of version control systems, some export options will be missing if you clone the project to a new machine. The easiest way to deal with this is to copy the file manually from the old location to the new one.

In production, it is useful to automate builds, and Godot supports this with the --export-release and --export-debug command line parameters. Exporting from the command line still requires an export preset to define the export parameters. A basic invocation of the command would be:

This will export to some_name.exe, assuming there is a preset called "Windows Desktop" and the template can be found. (The export preset name must be written within quotes if it contains spaces or special characters.) The output path is relative to the project path or absolute; it does not respect the directory the command was invoked from.

The output file extension should match the one used by the Godot export process:

macOS: .app or .zip (or .dmg when exporting from macOS)

Linux: Any extension (including none). .x86_64 is typically used for 64-bit x86 binaries.

You can also configure it to export only the PCK or ZIP file, allowing a single exported main pack file to be used with multiple Godot executables. When doing so, the export preset name must still be specified on the command line:

It is often useful to combine the --export-release flag with the --path flag, so that you do not need to cd to the project folder before running the command:

See Command line tutorial for more information about using Godot from the command line.

Each format has its upsides and downsides. PCK is the default and recommended format for most use cases, but you may want to use a ZIP archive instead depending on your needs.

Uncompressed format. Larger file size, but faster to read/write.

Not readable and writable using tools normally present on the user's operating system, even though there are third-party tools to extract and create PCK files.

Compressed format. Smaller file size, but slower to read/write.

Readable and writable using tools normally present on the user's operating system. This can be useful to make modding easier (see also Exporting packs, patches, and mods).

Due to a known bug, when using a ZIP file as a pack file, the exported binary will not try to use it automatically. Therefore, you have to create a launcher script that the player can double-click or run from a terminal to launch the project:

Save the launcher script and place it in the same folder as the exported binary. On Linux, make sure to give executable permissions to the launcher script using the command chmod +x launch.sh.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
godot --export-release "Windows Desktop" some_name.exe
```

Example 2 (unknown):
```unknown
godot --export-pack "Windows Desktop" some_name.pck
```

Example 3 (unknown):
```unknown
godot --path /path/to/project --export-release "Windows Desktop" some_name.exe
```

Example 4 (unknown):
```unknown
:: launch.bat (Windows)
@echo off
my_project.exe --main-pack my_project.zip

# launch.sh (Linux)
./my_project.x86_64 --main-pack my_project.zip
```

---

## Export — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/export/index.html

**Contents:**
- Export

This section is about exporting a build of your project. If you're trying to export properties from a script, see GDScript exported properties or C# exported properties.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Feature tags — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/export/feature_tags.html

**Contents:**
- Feature tags
- Introduction
- Default features
- Custom features
- Overriding project settings
- Default overrides
- Taking feature tags into account when reading project settings
- Customizing the build
- User-contributed notes

Godot has a special system to tag availability of features. Each feature is represented as a string, which can refer to many of the following:

Platform architecture (64-bit or 32-bit, x86 or ARM).

Platform type (desktop, mobile, Web).

Supported texture compression algorithms on the platform.

Whether a build is debug or release (debug includes the editor).

Whether the project is running from the editor or a "standalone" binary.

Features can be queried at runtime from the singleton API by calling:

OS feature tags are used by GDExtension to determine which libraries to load. For example, a library for linux.debug.editor.x86_64 will be loaded only on a debug editor build for Linux x86_64.

Here is a list of most feature tags in Godot. Keep in mind they are case-sensitive:

Running on Android (but not within a Web browser)

Running on *BSD (but not within a Web browser)

Running on Linux (but not within a Web browser)

Running on macOS (but not within a Web browser)

Running on iOS (but not within a Web browser)

Running on visionOS (but not within a Web browser)

Running on Linux or *BSD

Running on a debug build (including the editor)

Running on a release build

Running on an editor build

Running on an editor build, and inside the editor

Running on an editor build, and running the project

Running on a non-editor (export template) build

Running on a double-precision build

Running on a single-precision build

Running on a 64-bit build (any architecture)

Running on a 32-bit build (any architecture)

Running on a 64-bit x86 build

Running on a 32-bit x86 build

Running on an x86 build (any bitness)

Running on a 64-bit ARM build

Running on a 32-bit ARM build

Running on an ARM build (any bitness)

Running on a 64-bit RISC-V build

Running on a RISC-V build (any bitness)

Running on a 64-bit PowerPC build

Running on a 32-bit PowerPC build

Running on a PowerPC build (any bitness)

Running on a 64-bit WebAssembly build (not yet possible)

Running on a 32-bit WebAssembly build

Running on a WebAssembly build (any bitness)

Host OS is a mobile platform

Host OS is a PC platform (desktop/laptop)

Host OS is a Web browser

Running without threading support

Running with threading support

Host OS is a Web browser running on Android

Host OS is a Web browser running on iOS

Host OS is a Web browser running on Linux or *BSD

Host OS is a Web browser running on macOS

Host OS is a Web browser running on Windows

Textures using ETC1 compression are supported

Textures using ETC2 compression are supported

Textures using S3TC (DXT/BC) compression are supported

Movie Maker mode is active

Project was exported with shader baking enabled (only applies to the exported project, not when running in the editor)

Project was exported as a dedicated server (only applies to the exported project, not when running in the editor)

With the exception of texture compression, web_<platform> and movie feature tags, default feature tags are immutable. This means that they will not change depending on runtime conditions. For example, OS.has_feature("mobile") will return false when running a project exported to Web on a mobile device.

To check whether a project exported to Web is running on a mobile device, use OS.has_feature("web_android") or OS.has_feature("web_ios").

It is possible to add custom features to a build; use the relevant field in the export preset used to generate it:

Custom feature tags are only used when running the exported project (including with One-click deploy). They are not used when running the project from the editor, even if the export preset marked as Runnable for your current platform has custom feature tags defined.

Custom feature tags are also not used in EditorExportPlugin scripts. Instead, feature tags in EditorExportPlugin will reflect the device the editor is currently running on.

Features can be used to override specific configuration values in the Project Settings. This allows you to better customize any configuration when doing a build.

In the following example, a different icon is added for the demo build of the game (which was customized in a special export preset, which, in turn, includes only demo levels).

The desired configuration is selected, which effectively copies its properties to the panel above (1). The "demo_build" feature tag is selected (2). The configuration is added to the project settings (3).

After overriding, a new field is added for this specific configuration.

When using the project settings "override.cfg" functionality (which is unrelated to feature tags), remember that feature tags still apply. Therefore, make sure to also override the setting with the desired feature tag(s) if you want them to override base project settings on all platforms and configurations.

There are already a lot of settings that come with overrides by default; they can be found in many sections of the project settings.

By default, feature tags are not taken into account when reading project settings using the typical approaches (ProjectSettings.get_setting or ProjectSettings.get). Instead, you must use ProjectSettings.get_setting_with_override.

For example, with the following project settings:

Using ProjectSettings.get_setting("section/subsection/example") will return "Release" regardless of whether a debug build is currently running. On the other hand, ProjectSettings.get_setting_with_override("section/subsection/example") will obey feature tags and will return "Debug" if using a debug build.

Feature tags can be used to customize a build process too, by writing a custom ExportPlugin. They are also used to specify which shared library is loaded and exported in GDExtension.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
OS.has_feature(name)
```

Example 2 (unknown):
```unknown
OS.HasFeature(name);
```

Example 3 (unknown):
```unknown
[section]

subsection/example = "Release"
subsection/example.debug = "Debug"
```

---

## File and data I/O — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/io/index.html

**Contents:**
- File and data I/O

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## File paths in Godot projects — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/io/data_paths.html

**Contents:**
- File paths in Godot projects
- Path separators
- Accessing files in the project folder (res://)
- Accessing persistent user data (user://)
- File logging
- Converting paths to absolute paths or "local" paths
- Editor data paths
  - Self-contained mode
- User-contributed notes

This page explains how file paths work inside Godot projects. You will learn how to access paths in your projects using the res:// and user:// notations, and where Godot stores project and editor files on your and your users' systems.

To make supporting multiple platforms easier, Godot uses UNIX-style path separators (forward slash /). These work on all platforms, including Windows.

Instead of writing paths like C:\Projects\Game, in Godot, you should write C:/Projects/Game.

Windows-style path separators (backward slash \) are also supported in some path-related methods, but they need to be doubled (\\), as \ is normally used as an escape for characters with a special meaning.

This makes it possible to work with paths returned by other Windows applications. We still recommend using only forward slashes in your own code to guarantee that everything will work as intended.

The String class offers over a dozen methods to work with strings that represent file paths:

String.filecasecmp_to()

String.filenocasecmp_to()

String.get_base_dir()

String.get_basename()

String.get_extension()

String.is_absolute_path()

String.is_relative_path()

String.is_valid_filename()

String.simplify_path()

String.validate_filename()

Godot considers that a project exists in any folder that contains a project.godot text file, even if the file is empty. The folder that contains this file is your project's root folder.

You can access any file relative to it by writing paths starting with res://, which stands for resources. For example, you can access an image file character.png located in the project's root folder in code with the following path: res://character.png.

To store persistent data files, like the player's save or settings, you want to use user:// instead of res:// as your path's prefix. This is because when the game is running, the project's file system will likely be read-only.

The user:// prefix points to a different directory on the user's device. Unlike res://, the directory pointed at by user:// is created automatically and guaranteed to be writable to, even in an exported project.

The location of the user:// folder depends on what is configured in the Project Settings:

By default, the user:// folder is created within Godot's editor data path in the app_userdata/[project_name] folder. This is the default so that prototypes and test projects stay self-contained within Godot's data folder.

If application/config/use_custom_user_dir is enabled in the Project Settings, the user:// folder is created next to Godot's editor data path, i.e. in the standard location for applications data.

By default, the folder name will be inferred from the project name, but it can be further customized with application/config/custom_user_dir_name. This path can contain path separators, so you can use it e.g. to group projects of a given studio with a Studio Name/Game Name structure.

On desktop platforms, the actual directory paths for user:// are:

[project_name] is based on the application name defined in the Project Settings, but you can override it on a per-platform basis using feature tags.

On mobile platforms, this path is unique to the project and is not accessible by other applications for security reasons.

On HTML5 exports, user:// will refer to a virtual filesystem stored on the device via IndexedDB. (Interaction with the main filesystem can still be performed through the JavaScriptBridge singleton.)

Documentation on file logging has been moved to Logging.

You can use ProjectSettings.globalize_path() to convert a "local" path like res://path/to/file.txt to an absolute OS path. For example, ProjectSettings.globalize_path() can be used to open "local" paths in the OS file manager using OS.shell_open() since it only accepts native OS paths.

To convert an absolute OS path to a "local" path starting with res:// or user://, use ProjectSettings.localize_path(). This only works for absolute paths that point to files or folders in your project's root or user:// folders.

The editor uses different paths for editor data, editor settings, and cache, depending on the platform. By default, these paths are:

Editor data contains export templates and project-specific data.

Editor settings contains the main editor settings configuration file as well as various other user-specific customizations (editor layouts, feature profiles, script templates, etc.).

Cache contains data generated by the editor, or stored temporarily. It can safely be removed when Godot is closed.

Godot complies with the XDG Base Directory Specification on Linux/*BSD. You can override the XDG_DATA_HOME, XDG_CONFIG_HOME and XDG_CACHE_HOME environment variables to change the editor and project data paths.

If you use Godot packaged as a Flatpak, the editor data paths will be located in subfolders in ~/.var/app/org.godotengine.Godot/.

If you create a file called ._sc_ or _sc_ in the same directory as the editor binary (or in MacOS/Contents/ for a macOS editor .app bundle), Godot will enable self-contained mode. This mode makes Godot write all editor data, settings, and cache to a directory named editor_data/ in the same directory as the editor binary. You can use it to create a portable installation of the editor.

The Steam release of Godot uses self-contained mode by default.

Self-contained mode is not supported in exported projects yet. To read and write files relative to the executable path, use OS.get_executable_path(). Note that writing files in the executable path only works if the executable is placed in a writable location (i.e. not Program Files or another directory that is read-only for regular users).

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Fixing jitter, stutter and input lag — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/rendering/jitter_stutter.html

**Contents:**
- Fixing jitter, stutter and input lag
- What is jitter, stutter and input lag?
- Distinguishing between jitter and stutter
- Jitter
- Stutter
  - Windows
  - Linux
  - macOS
  - Android
  - iOS

Jitter and stutter are two different alterations to visible motion of objects on screen that may affect a game, even when running at full speed. These effects are mostly visible in games where the world moves at a constant speed in a fixed direction, like runners or platformers.

Input lag is unrelated to jitter and stutter, but is sometimes discussed alongside. Input lag refers to visible on-screen delay when performing actions with the mouse, keyboard, controller or touchscreen. It can be related to game code, engine code or external factors (such as hardware). Input lag is most noticeable in games that use the mouse to aim, such as first-person games. Input lag can't be completely eliminated, but it can be reduced in several ways.

A game running at a normal framerate without exhibiting any effect will appear smooth:

A game exhibiting jitter will shake constantly in a very subtle way:

Finally, a game exhibiting stutter will appear smooth, but appear to stop or roll back a frame every few seconds:

There can be many causes of jitter. The most typical one happens when the game physics frequency (usually 60 Hz) runs at a different resolution than the monitor refresh rate. Check whether your monitor refresh rate is different from 60 Hz.

Sometimes, only some objects appear to jitter (character or background). This happens when they are processed in different time sources (one is processed in the physics step while another is processed in the idle step).

This cause of jitter can be alleviated by enabling physics interpolation in the Project Settings. Physics interpolation will smooth out physics updates by interpolating the transforms of physics objects between physics frames. This way, the visual representation of physics objects will always look smooth no matter the framerate and physics tick rate.

Enabling physics interpolation has some caveats you should be aware of. For example, care should be taken when teleporting objects so that they don't visibly interpolate between the old position and new position when it's not intended. See the Physics Interpolation documentation for details.

Enabling physics interpolation will increase input lag for behavior that depends on the physics tick, such as player movement. In most games, this is generally preferable to jitter, but consider this carefully for games that operate on a fixed framerate (like fighting or rhythm games). This increase in input lag can be compensated by increasing the physics tick rate as described in the Input lag section.

Stutter may happen due to several different reasons. One reason is the game not being able to keep full framerate performance due to a CPU or GPU bottleneck. Solving this is game-specific and will require optimization.

Another common reason for stuttering is shader compilation stutter. This occurs when a shader needs to be compiled when a new material or particle effect is spawned for the first time in a game. This kind of stuttering generally only happens on the first playthrough, or after a graphics driver update when the shader cache is invalidated.

Since Godot 4.4, when using the Forward+ or Mobile renderers, the engine tries to avoid shader compilation stutter using an ubershader approach. For this approach to be most effective, care must be taken when designing scenes and resources so that Godot can gather as much information as possible when the scene/resource is loaded, as opposed as to when it's being drawn for the first time. See Reducing stutter from shader (pipeline) compilations for more information.

However, when using the Compatibility renderer, it is not possible to use this ubershader approach due to technical limitations in OpenGL. Therefore, to avoid shader compilation stutter in the Compatibility renderer, you need to spawn every mesh and visual effect in front of the camera for a single frame when the level is loading. This will ensure the shader is compiled when the level is loaded, as opposed to occurring during gameplay. This can be done behind solid 2D UI (such as a fullscreen ColorRect node) so that it's not visible to the player.

On platforms that support disabling V-Sync, stuttering can be made less noticeable by disabling V-Sync in the project settings. This will however cause tearing to appear, especially on monitors with low refresh rates. If your monitor supports it, consider enabling variable refresh rate (G-Sync/FreeSync) while leaving V-Sync enabled. This allows mitigating some forms of stuttering without introducing tearing. However, it will not help with large stutters, such as the ones caused by shader compilation stutter.

Forcing your graphics card to use the maximum performance profile can also help reduce stuttering, at the cost of increased GPU power draw.

Additionally, stutter may be induced by the underlying operating system. Here is some information regarding stutter on different OSes:

Windows is known to cause stutter in windowed games. This mostly depends on the hardware installed, drivers version and processes running in parallel (e.g. having many browser tabs open may cause stutter in a running game). To avoid this, Godot raises the game priority to "Above Normal". This helps considerably, but may not completely eliminate stutter.

Eliminating this completely requires giving your game full privileges to become "Time Critical", which is not advised. Some games may do it, but it is advised to learn to live with this problem, as it is common for Windows games and most users won't play games windowed (games that are played in a window, e.g. puzzle games, will usually not exhibit this problem anyway).

For fullscreen, Windows gives special priority to the game so stutter is no longer visible and very rare. This is how most games are played.

When using a mouse with a polling rate of 1,000 Hz or more, consider using a fully up-to-date Windows 11 installation which comes with fixes related to high CPU utilization with high polling rate mice. These fixes are not available in Windows 10 and older versions.

Games should use the Exclusive Fullscreen window mode, as opposed to Fullscreen which is designed to prevent Windows from automatically treating the window as if it was exclusive fullscreen.

Fullscreen is meant to be used by GUI applications that want to use per-pixel transparency without a risk of having it disabled by the OS. It achieves this by leaving a 1-pixel line at the bottom of the screen. By contrast, Exclusive Fullscreen uses the actual screen size and allows Windows to reduce jitter and input lag for fullscreen games.

Stutter may be visible on desktop Linux, but this is usually associated with different video drivers and compositors. Some compositors may also trigger this problem (e.g. KWin), so it is advised to try using a different one to rule it out as the cause. Some window managers such as KWin and Xfwm allow you to manually disable compositing, which can improve performance (at the cost of tearing).

There is no workaround for driver or compositor stuttering, other than reporting it as an issue to the driver or compositor developers. Stutter may be more present when playing in windowed mode as opposed to fullscreen, even with compositing disabled.

Feral GameMode can be used to automatically apply optimizations (such as forcing the GPU performance profile) when running specific processes.

Generally, macOS is stutter-free, although recently some bugs were reported when running on fullscreen (this is a macOS bug). If you have a machine exhibiting this behavior, please let us know.

Generally, Android is stutter and jitter-free because the running activity gets all the priority. That said, there may be problematic devices (older Kindle Fire is known to be one). If you see this problem on Android, please let us know.

iOS devices are generally stutter-free, but older devices running newer versions of the operating system may exhibit problems. This is generally unavoidable.

On platforms that support disabling V-Sync, input lag can be made less noticeable by disabling V-Sync in the project settings. This will however cause tearing to appear, especially on monitors with low refresh rates. It's suggested to make V-Sync available as an option for players to toggle.

When using the Forward+ or Mobile rendering methods, another way to reduce visual latency when V-Sync is enabled is to use double-buffered V-Sync instead of the default triple-buffered V-Sync. Since Godot 4.3, this can be achieved by reducing the Display > Window > V-Sync > Swapchain Image Count project setting to 2. The downside of using double buffering is that framerate will be less stable if the display refresh rate can't be reached due to a CPU or GPU bottleneck. For instance, on a 60 Hz display, if the framerate would normally drop to 55 FPS during gameplay with triple buffering, it will have to drop down to 30 FPS momentarily with double buffering (and then go back to 60 FPS when possible). As a result, double-buffered V-Sync is only recommended if you can consistently reach the display refresh rate on the target hardware.

Increasing the number of physics iterations per second can also reduce physics-induced input latency. This is especially noticeable when using physics interpolation (which improves smoothness but increases latency). To do so, set Physics > Common > Physics Ticks Per Second to a value higher than the default 60, or set Engine.physics_ticks_per_second at runtime in a script. Values that are a multiple of the monitor refresh rate (typically 60) work best when physics interpolation is disabled, as they will avoid jitter. This means values such as 120, 180 and 240 are good starting points. As a bonus, higher physics FPSes make tunneling and physics instability issues less likely to occur.

The downside of increasing physics FPS is that CPU usage will increase, which can lead to performance bottlenecks in games that have heavy physics simulation code. This can be alleviated by increasing physics FPS only in situations where low latency is critical, or by letting players adjust physics FPS to match their hardware. However, different physics FPS will lead to different outcomes in physics simulation, even when delta is consistently used in your game logic. This can give certain players an advantage over others. Therefore, allowing the player to change the physics FPS themselves should be avoided for competitive multiplayer games.

Lastly, you can disable input buffering on a per-rendered frame basis by calling Input.set_use_accumulated_input(false) in a script. This will make it so the _input() and _unhandled_input() functions in your scripts are called on every input, rather than accumulating inputs and waiting for a frame to be rendered. Disabling input accumulation will increase CPU usage, so it should be done with caution.

On any Godot project, you can use the --disable-vsync command line argument to forcibly disable V-Sync. Since Godot 4.2, --max-fps <fps> can also be used to set an FPS limit (0 is unlimited). These arguments can be used at the same time.

If your monitor supports it, consider enabling variable refresh rate (G-Sync/FreeSync) while leaving V-Sync enabled, then cap the framerate in the project settings to a slightly lower value than your monitor's maximum refresh rate as per this page. For example, on a 144 Hz monitor, you can set the project's framerate cap to 141. This may be counterintuitive at first, but capping the FPS below the maximum refresh rate range ensures that the OS never has to wait for vertical blanking to finish. This leads to similar input lag as V-Sync disabled with the same framerate cap (usually less than 1 ms greater), but without any tearing.

This can be done by changing the Application > Run > Max FPS project setting or assigning Engine.max_fps at runtime in a script.

On some platforms, you can also opt into a low-latency mode in the graphics driver options (such as the NVIDIA Control Panel on Windows). The Ultra setting will give you the lowest possible latency, at the cost of slightly lower average framerates. Forcing the GPU to use the maximum performance profile can also further reduce input lag, at the cost of higher power consumption (and resulting heat/fan noise).

Finally, make sure your monitor is running at its highest possible refresh rate in the OS' display settings.

Also, ensure that your mouse is configured to use its highest polling rate (typically 1,000 Hz for gaming mice, sometimes more). High USB polling rates can however result in high CPU usage, so 500 Hz may be a safer bet on low-end CPUs. If your mouse offers multiple DPI settings, consider also using the highest possible setting and reducing in-game sensitivity to reduce mouse latency.

On Linux when using X11, disabling compositing in window managers that allow it (such as KWin or Xfwm) can reduce input lag significantly.

If you are reporting a stutter or jitter problem (opening an issue) not caused by any of the above reasons, please specify very clearly all the information possible about device, operating system, driver versions, etc. This may help to better troubleshoot it.

If you are reporting input lag problems, please include a capture made with a high speed camera (such as your phone's slow motion video mode). The capture must have both the screen and the input device visible so that the number of frames between an input and the on-screen result can be counted. Also, make sure to mention your monitor's refresh rate and your input device's polling rate (especially for mice).

Also, make sure to use the correct term (jitter, stutter, input lag) based on the exhibited behavior. This will help understand your issue much faster. Provide a project that can be used to reproduce the issue, and if possible, include a screen capture demonstrating the bug.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Frequently asked questions — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/about/faq.html

**Contents:**
- Frequently asked questions
- What can I do with Godot? How much does it cost? What are the license terms?
- Which platforms are supported by Godot?
- Which programming languages are supported in Godot?
- What is GDScript and why should I use it?
- What were the motivations behind creating GDScript?
- Which programming language is fastest?
- What 3D model formats does Godot support?
- Will [insert closed SDK such as FMOD, GameWorks, etc.] be supported in Godot?
- How can I extend Godot?

Godot is Free and open source Software available under the OSI-approved MIT license. This means it is free as in "free speech" as well as in "free beer."

You are free to download and use Godot for any purpose: personal, non-profit, commercial, or otherwise.

You are free to modify, distribute, redistribute, and remix Godot to your heart's content, for any reason, both non-commercially and commercially.

All the contents of this accompanying documentation are published under the permissive Creative Commons Attribution 3.0 (CC BY 3.0) license, with attribution to "Juan Linietsky, Ariel Manzur and the Godot Engine community."

Logos and icons are generally under the same Creative Commons license. Note that some third-party libraries included with Godot's source code may have different licenses.

For full details, look at the COPYRIGHT.txt as well as the LICENSE.txt and LOGO_LICENSE.txt files in the Godot repository.

Also, see the license page on the Godot website.

Android (experimental)

For exporting your games:

Both 32- and 64-bit binaries are supported where it makes sense, with 64 being the default. Official macOS builds support Apple Silicon natively as well as x86_64.

Some users also report building and using Godot successfully on ARM-based systems with Linux, like the Raspberry Pi.

The Godot team can't provide an open source console export due to the licensing terms imposed by console manufacturers. Regardless of the engine you use, though, releasing games on consoles is always a lot of work. You can read more about Console support in Godot.

For more on this, see the sections on exporting and compiling Godot yourself.

Godot 3 also had support for Universal Windows Platform (UWP). This platform port was removed in Godot 4 due to lack of maintenance, and it being deprecated by Microsoft. It is still available in the current stable release of Godot 3 for interested users.

The officially supported languages for Godot are GDScript, C#, and C++. See the subcategories for each language in the scripting section.

If you are just starting out with either Godot or game development in general, GDScript is the recommended language to learn and use since it is native to Godot. While scripting languages tend to be less performant than lower-level languages in the long run, for prototyping, developing Minimum Viable Products (MVPs), and focusing on Time-To-Market (TTM), GDScript will provide a fast, friendly, and capable way of developing your games.

Note that C# support is still relatively new, and as such, you may encounter some issues along the way. C# support is also currently missing on the web platform. Our friendly and hard-working development community is always ready to tackle new problems as they arise, but since this is an open source project, we recommend that you first do some due diligence yourself. Searching through discussions on open issues is a great way to start your troubleshooting.

As for new languages, support is possible via third parties with GDExtensions. (See the question about plugins below). Work is currently underway, for example, on unofficial bindings for Godot to Python and Nim.

GDScript is Godot's integrated scripting language. It was built from the ground up to maximize Godot's potential in the least amount of code, affording both novice and expert developers alike to capitalize on Godot's strengths as fast as possible. If you've ever written anything in a language like Python before, then you'll feel right at home. For examples and a complete overview of the power GDScript offers you, check out the GDScript scripting guide.

There are several reasons to use GDScript, but the most salient reason is the overall reduction of complexity.

The original intent of creating a tightly integrated, custom scripting language for Godot was two-fold: first, it reduces the amount of time necessary to get up and running with Godot, giving developers a rapid way of exposing themselves to the engine with a focus on productivity; second, it reduces the overall burden of maintenance, attenuates the dimensionality of issues, and allows the developers of the engine to focus on squashing bugs and improving features related to the engine core, rather than spending a lot of time trying to get a small set of incremental features working across a large set of languages.

Since Godot is an open source project, it was imperative from the start to prioritize a more integrated and seamless experience over attracting additional users by supporting more familiar programming languages, especially when supporting those more familiar languages would result in a worse experience. We understand if you would rather use another language in Godot (see the list of supported options above). That being said, if you haven't given GDScript a try, try it for three days. Just like Godot, once you see how powerful it is and how rapid your development becomes, we think GDScript will grow on you.

More information about getting comfortable with GDScript or dynamically typed languages can be found in the GDScript: An introduction to dynamic languages tutorial.

In the early days, the engine used the Lua scripting language. Lua can be fast thanks to LuaJIT, but creating bindings to an object-oriented system (by using fallbacks) was complex and slow and took an enormous amount of code. After some experiments with Python, that also proved difficult to embed.

The main reasons for creating a custom scripting language for Godot were:

Poor threading support in most script VMs, and Godot uses threads (Lua, Python, Squirrel, JavaScript, ActionScript, etc.).

Poor class-extending support in most script VMs, and adapting to the way Godot works is highly inefficient (Lua, Python, JavaScript).

Many existing languages have horrible interfaces for binding to C++, resulting in a large amount of code, bugs, bottlenecks, and general inefficiency (Lua, Python, Squirrel, JavaScript, etc.). We wanted to focus on a great engine, not a great number of integrations.

No native vector types (Vector3, Transform3D, etc.), resulting in highly reduced performance when using custom types (Lua, Python, Squirrel, JavaScript, ActionScript, etc.).

Garbage collector results in stalls or unnecessarily large memory usage (Lua, Python, JavaScript, ActionScript, etc.).

Difficulty integrating with the code editor for providing code completion, live editing, etc. (all of them).

GDScript was designed to curtail the issues above, and more.

In most games, the scripting language itself is not the cause of performance problems. Instead, performance is slowed by inefficient algorithms (which are slow in all languages), by GPU performance, or by the common C++ engine code like physics or navigation. All languages supported by Godot are fast enough for general-purpose scripting. You should choose a language based on other factors, like ease-of-use, familiarity, platform support, or language features.

In general, the performance of C# and GDScript is within the same order of magnitude, and C++ is faster than both.

Comparing GDScript performance to C# is tricky, since C# can be faster in some specific cases. The C# language itself tends to be faster than GDScript, which means that C# can be faster in situations with few calls to Godot engine code. However, C# can be slower than GDScript when making many Godot API calls, due to the cost of marshalling. C#'s performance can also be brought down by garbage collection which occurs at random and unpredictable moments. This can result in stuttering issues in complex projects, and is not exclusive to Godot.

C++, using GDExtension, will almost always be faster than either C# or GDScript. However, C++ is less easy to use than C# or GDScript, and is slower to develop with.

You can also use multiple languages within a single project, with cross-language scripting, or by using GDExtension and scripting languages together. Be aware that doing so comes with its own complications.

You can find detailed information on supported formats, how to export them from your 3D modeling software, and how to import them for Godot in the Importing 3D scenes documentation.

The aim of Godot is to create a free and open source MIT-licensed engine that is modular and extendable. There are no plans for the core engine development community to support any third-party, closed-source/proprietary SDKs, as integrating with these would go against Godot's ethos.

That said, because Godot is open source and modular, nothing prevents you or anyone else interested in adding those libraries as a module and shipping your game with them, as either open- or closed-source.

To see how support for your SDK of choice could still be provided, look at the Plugins question below.

If you know of a third-party SDK that is not supported by Godot but that offers free and open source integration, consider starting the integration work yourself. Godot is not owned by one person; it belongs to the community, and it grows along with ambitious community contributors like you.

For extending Godot, like creating Godot Editor plugins or adding support for additional languages, take a look at EditorPlugins and tool scripts.

Also, see the official blog post on GDExtension, a way to develop native extensions for Godot:

Introducing GDNative's successor, GDExtension

You can also take a look at the GDScript implementation, the Godot modules, as well as the Jolt physics engine integration for Godot. This would be a good starting point to see how another third-party library integrates with Godot.

Since you don't need to actually install Godot on your system to run it, this means desktop integration is not performed automatically. There are two ways to overcome this. You can install Godot from Steam (all platforms), Scoop (Windows), Homebrew (macOS) or Flathub (Linux). This will automatically perform the required steps for desktop integration.

Alternatively, you can manually perform the steps that an installer would do for you:

Move the Godot executable to a stable location (i.e. outside of your Downloads folder), so you don't accidentally move it and break the shortcut in the future.

Right-click the Godot executable and choose Create Shortcut.

Move the created shortcut to %APPDATA%\Microsoft\Windows\Start Menu\Programs. This is the user-wide location for shortcuts that will appear in the Start menu. You can also pin Godot in the task bar by right-clicking the executable and choosing Pin to Task Bar.

Drag the extracted Godot application to /Applications/Godot.app, then drag it to the Dock if desired. Spotlight will be able to find Godot as long as it's in /Applications or ~/Applications.

Move the Godot binary to a stable location (i.e. outside of your Downloads folder), so you don't accidentally move it and break the shortcut in the future.

Rename and move the Godot binary to a location present in your PATH environment variable. This is typically /usr/local/bin/godot or /usr/bin/godot. Doing this requires administrator privileges, but this also allows you to run the Godot editor from a terminal by entering godot.

If you cannot move the Godot editor binary to a protected location, you can keep the binary somewhere in your home directory, and modify the Path= line in the .desktop file linked below to contain the full absolute path to the Godot binary.

Save this .desktop file to $HOME/.local/share/applications/. If you have administrator privileges, you can also save the .desktop file to /usr/local/share/applications to make the shortcut available for all users.

In its default configuration, Godot is semi-portable. Its executable can run from any location (including non-writable locations) and never requires administrator privileges.

However, configuration files will be written to the user-wide configuration or data directory. This is usually a good approach, but this means configuration files will not carry across machines if you copy the folder containing the Godot executable. See File paths in Godot projects for more information.

If true portable operation is desired (e.g. for use on a USB stick), follow the steps in Self-contained mode.

Godot aims for cross-platform compatibility and open standards first and foremost. OpenGL and Vulkan are the technologies that are both open and available on (nearly) all platforms. Thanks to this design decision, a project developed with Godot on Windows will run out of the box on Linux, macOS, and more.

While Vulkan and OpenGL remain our primary focus for their open standard and cross-platform benefits, Godot 4.3 introduced experimental support for Direct3D 12. This addition aims to enhance performance and compatibility on platforms where Direct3D 12 is prevalent, such as Windows and Xbox. However, Vulkan and OpenGL will continue as the default rendering drivers on all platforms, including Windows.

Godot intentionally does not include features that can be implemented by add-ons unless they are used very often. One example of something not used often is advanced artificial intelligence functionality.

There are several reasons for this:

Code maintenance and surface for bugs. Every time we accept new code in the Godot repository, existing contributors often take the responsibility of maintaining it. Some contributors don't always stick around after getting their code merged, which can make it difficult for us to maintain the code in question. This can lead to poorly maintained features with bugs that are never fixed. On top of that, the "API surface" that needs to be tested and checked for regressions keeps increasing over time.

Ease of contribution. By keeping the codebase small and tidy, it can remain fast and easy to compile from source. This makes it easier for new contributors to get started with Godot, without requiring them to purchase high-end hardware.

Keeping the binary size small for the editor. Not everyone has a fast Internet connection. Ensuring that everyone can download the Godot editor, extract it and run it in less than 5 minutes makes Godot more accessible to developers in all countries.

Keeping the binary size small for export templates. This directly impacts the size of projects exported with Godot. On mobile and web platforms, keeping file sizes low is important to ensure fast installation and loading on underpowered devices. Again, there are many countries where high-speed Internet is not readily available. To add to this, strict data usage caps are often in effect in those countries.

For all the reasons above, we have to be selective of what we can accept as core functionality in Godot. This is why we are aiming to move some core functionality to officially supported add-ons in future versions of Godot. In terms of binary size, this also has the advantage of making you pay only for what you actually use in your project. (In the meantime, you can compile custom export templates with unused features disabled to optimize the distribution size of your project.)

This question pops up often and it's probably thanks to the misunderstanding created by Apple when they originally doubled the resolution of their devices. It made people think that having the same assets in different resolutions was a good idea, so many continued towards that path. That originally worked to a point and only for Apple devices, but then several Android and Apple devices with different resolutions and aspect ratios were created, with a very wide range of sizes and DPIs.

The most common and proper way to achieve this is to, instead, use a single base resolution for the game and only handle different screen aspect ratios. This is mostly needed for 2D, as in 3D, it's just a matter of camera vertical or horizontal FOV.

Choose a single base resolution for your game. Even if there are devices that go up to 1440p and devices that go down to 400p, regular hardware scaling in your device will take care of this at little or no performance cost. The most common choices are either near 1080p (1920x1080) or 720p (1280x720). Keep in mind the higher the resolution, the larger your assets, the more memory they will take and the longer the time it will take for loading.

Use the stretch options in Godot; canvas items stretching while keeping aspect ratios works best. Check the Multiple resolutions tutorial on how to achieve this.

Determine a minimum resolution and then decide if you want your game to stretch vertically or horizontally for different aspect ratios, or if there is one aspect ratio and you want black bars to appear instead. This is also explained in Multiple resolutions.

For user interfaces, use the anchoring to determine where controls should stay and move. If UIs are more complex, consider learning about Containers.

And that's it! Your game should work in multiple resolutions.

When it's ready! See When is the next release out? for more information.

We recommend using Godot 4.x for new projects, but depending on the feature set you need, it may be better to use 3.x instead. See Which version should I use for a new project? for more information.

Some new versions are safer to upgrade to than others. In general, whether you should upgrade depends on your project's circumstances. See Should I upgrade my project to use new engine versions? for more information.

You can find a detailed comparison of the renderers in Overview of renderers.

Awesome! As an open source project, Godot thrives off of the innovation and the ambition of developers like you.

The best way to start contributing to Godot is by using it and reporting any issues that you might experience. A good bug report with clear reproduction steps helps your fellow contributors fix bugs quickly and efficiently. You can also report issues you find in the online documentation.

If you feel ready to submit your first PR, pick any issue that resonates with you from one of the links above and try your hand at fixing it. You will need to learn how to compile the engine from sources, or how to build the documentation. You also need to get familiar with Git, a version control system that Godot developers use.

We explain how to work with the engine source, how to edit the documentation, and what other ways to contribute are there in our documentation for contributors.

We are always looking for suggestions about how to improve the engine. User feedback is the main driving force behind our decision-making process, and limitations that you might face while working on your project are a great data point for us when considering engine enhancements.

If you experience a usability problem or are missing a feature in the current version of Godot, start by discussing it with our community. There may be other, perhaps better, ways to achieve the desired result that community members could suggest. And you can learn if other users experience the same issue, and figure out a good solution together.

If you come up with a well-defined idea for the engine, feel free to open a proposal issue. Try to be specific and concrete while describing your problem and your proposed solution — only actionable proposals can be considered. It is not required, but if you want to implement it yourself, that's always appreciated!

If you only have a general idea without specific details, you can open a proposal discussion. These can be anything you want, and allow for a free-form discussion in search of a solution. Once you find one, a proposal issue can be opened.

Please, read the readme document before creating a proposal to learn more about the process.

Yes! Godot features an extensive built-in UI system, and its small distribution size can make it a suitable alternative to frameworks like Electron or Qt.

When creating a non-game application, make sure to enable low-processor mode in the Project Settings to decrease CPU and GPU usage.

Check out Material Maker and Pixelorama for examples of open source applications made with Godot.

Godot is meant to be used with its editor. We recommend you give it a try, as it will most likely save you time in the long term. There are no plans to make Godot usable as a library, as it would make the rest of the engine more convoluted and difficult to use for casual users.

If you want to use a rendering library, look into using an established rendering engine instead. Keep in mind rendering engines usually have smaller communities compared to Godot. This will make it more difficult to find answers to your questions.

Godot does not use a standard GUI toolkit like GTK, Qt or wxWidgets. Instead, Godot uses its own user interface toolkit, rendered using OpenGL ES or Vulkan. This toolkit is exposed in the form of Control nodes, which are used to render the editor (which is written in C++). These Control nodes can also be used in projects from any scripting language supported by Godot.

This custom toolkit makes it possible to benefit from hardware acceleration and have a consistent appearance across all platforms. On top of that, it doesn't have to deal with the LGPL licensing caveats that come with GTK or Qt. Lastly, this means Godot is "eating its own dog food" since the editor itself is one of the most complex users of Godot's UI system.

This custom UI toolkit can't be used as a library, but you can still use Godot to create non-game applications by using the editor.

Godot uses the SCons build system. There are no plans to switch to a different build system in the near future. There are many reasons why we have chosen SCons over other alternatives. For example:

Godot can be compiled for a dozen different platforms: all PC platforms, all mobile platforms, many consoles, and WebAssembly.

Developers often need to compile for several of the platforms at the same time, or even different targets of the same platform. They can't afford reconfiguring and rebuilding the project each time. SCons can do this with no sweat, without breaking the builds.

SCons will never break a build no matter how many changes, configurations, additions, removals etc.

Godot's build process is not simple. Several files are generated by code (binders), others are parsed (shaders), and others need to offer customization (modules). This requires complex logic which is easier to write in an actual programming language (like Python) rather than using a mostly macro-based language only meant for building.

Godot's build process makes heavy use of cross-compiling tools. Each platform has a specific detection process, and all these must be handled as specific cases with special code written for each.

Please try to keep an open mind and get at least a little familiar with SCons if you are planning to build Godot yourself.

Like many other libraries (Qt as an example), Godot does not make use of STL (with a few exceptions such as threading primitives). We believe STL is a great general-purpose library, but we had special requirements for Godot.

STL templates create very large symbols, which results in huge debug binaries. We use few templates with very short names instead.

Most of our containers cater to special needs, like Vector, which uses copy on write and we use to pass data around, or the RID system, which requires O(1) access time for performance. Likewise, our hash map implementations are designed to integrate seamlessly with internal engine types.

Our containers have memory tracking built-in, which helps better track memory usage.

For large arrays, we use pooled memory, which can be mapped to either a preallocated buffer or virtual memory.

We use our custom String type, as the one provided by STL is too basic and lacks proper internationalization support.

Check out Godot's container types for alternatives.

We believe games should not crash, no matter what. If an unexpected situation happens, Godot will print an error (which can be traced even to script), but then it will try to recover as gracefully as possible and keep going.

Additionally, exceptions significantly increase the binary size for the executable and result in increased compile times.

Godot does not use an ECS and relies on inheritance instead. While there is no universally better approach, we found that using an inheritance-based approach resulted in better usability while still being fast enough for most use cases.

That said, nothing prevents you from making use of composition in your project by creating child Nodes with individual scripts. These nodes can then be added and removed at runtime to dynamically add and remove behaviors.

More information about Godot's design choices can be found in this article.

While Godot internally attempts to use cache coherency as much as possible, we believe users don't need to be forced to use DOD practices.

DOD is mostly a cache coherency optimization that can only provide significant performance improvements when dealing with dozens of thousands of objects which are processed every frame with little modification. That is, if you are moving a few hundred sprites or enemies per frame, DOD won't result in a meaningful improvement in performance. In such a case, you should consider a different approach to optimization.

The vast majority of games do not need this and Godot provides handy helpers to do the job for most cases when you do.

If a game needs to process such a large amount of objects, our recommendation is to use C++ and GDExtensions for performance-heavy tasks and GDScript (or C#) for the rest of the game.

See How to contribute.

See the corresponding page on the Godot website.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## General optimization tips — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/performance/general_optimization.html

**Contents:**
- General optimization tips
- Introduction
  - Smoke and mirrors
  - The nature of slowness
- Measuring performance
  - Limitations
- Detective work
  - Hypothesis testing
  - Binary search
- Profilers

In an ideal world, computers would run at infinite speed. The only limit to what we could achieve would be our imagination. However, in the real world, it's all too easy to produce software that will bring even the fastest computer to its knees.

Thus, designing games and other software is a compromise between what we would like to be possible, and what we can realistically achieve while maintaining good performance.

To achieve the best results, we have two approaches:

And preferably, we will use a blend of the two.

Part of working smarter is recognizing that, in games, we can often get the player to believe they're in a world that is far more complex, interactive, and graphically exciting than it really is. A good programmer is a magician, and should strive to learn the tricks of the trade while trying to invent new ones.

To the outside observer, performance problems are often lumped together. But in reality, there are several different kinds of performance problems:

A slow process that occurs every frame, leading to a continuously low frame rate.

An intermittent process that causes "spikes" of slowness, leading to stalls.

A slow process that occurs outside of normal gameplay, for instance, when loading a level.

Each of these are annoying to the user, but in different ways.

Probably the most important tool for optimization is the ability to measure performance - to identify where bottlenecks are, and to measure the success of our attempts to speed them up.

There are several methods of measuring performance, including:

Putting a start/stop timer around code of interest.

Using the Godot profiler.

Using external CPU profilers.

Using external GPU profilers/debuggers such as NVIDIA Nsight Graphics, Radeon GPU Profiler, PIX (Direct3D 12 only), Xcode (Metal only), or Arm Performance Studio.

Checking the frame rate (with V-Sync disabled). Third-party utilities such as RivaTuner Statistics Server (Windows), Special K (Windows), or MangoHud (Linux) can also be useful here.

Using an unofficial debug menu add-on.

Be very aware that the relative performance of different areas can vary on different hardware. It's often a good idea to measure timings on more than one device. This is especially the case if you're targeting mobile devices.

CPU profilers are often the go-to method for measuring performance. However, they don't always tell the whole story.

Bottlenecks are often on the GPU, "as a result" of instructions given by the CPU.

Spikes can occur in the operating system processes (outside of Godot) "as a result" of instructions used in Godot (for example, dynamic memory allocation).

You may not always be able to profile specific devices like a mobile phone due to the initial setup required.

You may have to solve performance problems that occur on hardware you don't have access to.

As a result of these limitations, you often need to use detective work to find out where bottlenecks are.

Detective work is a crucial skill for developers (both in terms of performance, and also in terms of bug fixing). This can include hypothesis testing, and binary search.

Say, for example, that you believe sprites are slowing down your game. You can test this hypothesis by:

Measuring the performance when you add more sprites, or take some away.

This may lead to a further hypothesis: does the size of the sprite determine the performance drop?

You can test this by keeping everything the same, but changing the sprite size, and measuring performance.

If you know that frames are taking much longer than they should, but you're not sure where the bottleneck lies. You could begin by commenting out approximately half the routines that occur on a normal frame. Has the performance improved more or less than expected?

Once you know which of the two halves contains the bottleneck, you can repeat this process until you've pinned down the problematic area.

Profilers allow you to time your program while running it. Profilers then provide results telling you what percentage of time was spent in different functions and areas, and how often functions were called.

This can be very useful both to identify bottlenecks and to measure the results of your improvements. Sometimes, attempts to improve performance can backfire and lead to slower performance. Always use profiling and timing to guide your efforts.

For more info about using Godot's built-in profiler, see The Profiler.

Programmers waste enormous amounts of time thinking about, or worrying about, the speed of noncritical parts of their programs, and these attempts at efficiency actually have a strong negative impact when debugging and maintenance are considered. We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%.

The messages are very important:

Developer time is limited. Instead of blindly trying to speed up all aspects of a program, we should concentrate our efforts on the aspects that really matter.

Efforts at optimization often end up with code that is harder to read and debug than non-optimized code. It is in our interests to limit this to areas that will really benefit.

Just because we can optimize a particular bit of code, it doesn't necessarily mean that we should. Knowing when and when not to optimize is a great skill to develop.

One misleading aspect of the quote is that people tend to focus on the subquote "premature optimization is the root of all evil". While premature optimization is (by definition) undesirable, performant software is the result of performant design.

The danger with encouraging people to ignore optimization until necessary, is that it conveniently ignores that the most important time to consider performance is at the design stage, before a key has even hit a keyboard. If the design or algorithms of a program are inefficient, then no amount of polishing the details later will make it run fast. It may run faster, but it will never run as fast as a program designed for performance.

This tends to be far more important in game or graphics programming than in general programming. A performant design, even without low-level optimization, will often run many times faster than a mediocre design with low-level optimization.

Of course, in practice, unless you have prior knowledge, you are unlikely to come up with the best design the first time. Instead, you'll often make a series of versions of a particular area of code, each taking a different approach to the problem, until you come to a satisfactory solution. It's important not to spend too much time on the details at this stage until you have finalized the overall design. Otherwise, much of your work will be thrown out.

It's difficult to give general guidelines for performant design because this is so dependent on the problem. One point worth mentioning though, on the CPU side, is that modern CPUs are nearly always limited by memory bandwidth. This has led to a resurgence in data-oriented design, which involves designing data structures and algorithms for cache locality of data and linear access, rather than jumping around in memory.

Assuming we have a reasonable design, and taking our lessons from Knuth, our first step in optimization should be to identify the biggest bottlenecks - the slowest functions, the low-hanging fruit.

Once we've successfully improved the speed of the slowest area, it may no longer be the bottleneck. So we should test/profile again and find the next bottleneck on which to focus.

Profile / Identify bottleneck.

Some profilers will even tell you which part of a function (which data accesses, calculations) are slowing things down.

As with design, you should concentrate your efforts first on making sure the algorithms and data structures are the best they can be. Data access should be local (to make best use of CPU cache), and it can often be better to use compact storage of data (again, always profile to test results). Often, you precalculate heavy computations ahead of time. This can be done by performing the computation when loading a level, by loading a file containing precalculated data, or by storing the results of complex calculations into a script constant and reading its value.

Once algorithms and data are good, you can often make small changes in routines which improve performance. For instance, you can move some calculations outside of loops or transform nested for loops into non-nested loops. (This should be feasible if you know a 2D array's width or height in advance.)

Always retest your timing/bottlenecks after making each change. Some changes will increase speed, others may have a negative effect. Sometimes, a small positive effect will be outweighed by the negatives of more complex code, and you may choose to leave out that optimization.

The proverb "a chain is only as strong as its weakest link" applies directly to performance optimization. If your project is spending 90% of the time in function A, then optimizing A can have a massive effect on performance.

In this example, improving this bottleneck A by a factor of 9× decreases overall frame time by 5× while increasing frames per second by 5×.

However, if something else is running slowly and also bottlenecking your project, then the same improvement can lead to less dramatic gains:

In this example, even though we have hugely optimized function A, the actual gain in terms of frame rate is quite small.

In games, things become even more complicated because the CPU and GPU run independently of one another. Your total frame time is determined by the slower of the two.

In this example, we optimized the CPU hugely again, but the frame time didn't improve because we are GPU-bottlenecked.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
A: 9 ms
Everything else: 1 ms
Total frame time: 10 ms
```

Example 2 (unknown):
```unknown
A: 1 ms
Everything else: 1ms
Total frame time: 2 ms
```

Example 3 (unknown):
```unknown
A: 9 ms
Everything else: 50 ms
Total frame time: 59 ms
```

Example 4 (unknown):
```unknown
A: 1 ms
Everything else: 50 ms
Total frame time: 51 ms
```

---

## Getting the source — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/compiling/getting_source.html

**Contents:**
- Getting the source
- Downloading the Godot source code
- User-contributed notes

Before getting into the SCons build system and compiling Godot, you need to actually download the Godot source code.

The source code is available on GitHub and while you can manually download it via the website, in general you want to do it via the git version control system.

If you are compiling in order to make contributions or pull requests, you should follow the instructions from the Pull Request workflow.

If you don't know much about git yet, there are a great number of tutorials available on various websites.

In general, you need to install git and/or one of the various GUI clients.

Afterwards, to get the latest development version of the Godot source code (the unstable master branch), you can use git clone.

If you are using the git command line client, this is done by entering the following in a terminal:

For any stable release, visit the release page and click on the link for the release you want. You can then download and extract the source from the download link on the page.

With git, you can also clone a stable release by specifying its branch or tag after the --branch (or just -b) argument:

The maintenance branches are used to release further patches on each minor version.

You can get the source code for each release and pre-release in .tar.xz format from godotengine/godot-builds on GitHub. This lacks version control information but has a slightly smaller download size.

After downloading the Godot source code, you can continue to compiling Godot.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
git clone https://github.com/godotengine/godot.git
# You can add the --depth 1 argument to omit the commit history (shallow clone).
# A shallow clone is faster, but not all Git operations (like blame) will work.
```

Example 2 (unknown):
```unknown
# Clone the continuously maintained stable branch (`4.5` as of writing).
git clone https://github.com/godotengine/godot.git -b 4.5

# Clone the `4.5-stable` tag. This is a fixed revision that will never change.
git clone https://github.com/godotengine/godot.git -b 4.5-stable

# After cloning, optionally go to a specific commit.
# This can be used to access the source code at a specific point in time,
# e.g. for development snapshots, betas and release candidates.
cd godot
git checkout f4af8201bac157b9d47e336203d3e8a8ef729de2
```

---

## Godot's architecture diagram — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/architecture/godot_architecture_diagram.html

**Contents:**
- Godot's architecture diagram
- User-contributed notes

The following diagram describes the architecture used by Godot, from the core components down to the abstracted drivers, via the scene structure and the servers.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Godot Android library — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/platform/android/android_library.html

**Contents:**
- Godot Android library
- Using the Godot Android library
- Godot Android plugins
- Embedding Godot in existing Android projects
  - 1. Create the Android app
  - 2. Create the Godot project
  - 3. Build and run the app
- User-contributed notes

The Godot Engine for Android platforms is designed to be used as an Android library. This architecture enables several key features on Android platforms:

Ability to integrate the Gradle build system within the Godot Editor, which provides the ability to leverage more components from the Android ecosystem such as libraries and tools

Ability to make the engine portable and embeddable:

Key in enabling the port of the Godot Editor to Android and mobile XR devices

Key in allowing the integration and reuse of Godot's capabilities within existing codebase

Below we describe some of the use-cases and scenarios this architecture enables.

The Godot Android library is packaged as an AAR archive file and hosted on MavenCentral along with its documentation.

It provides access to Godot APIs and capabilities on Android platforms for the following non-exhaustive use-cases.

Android plugins are powerful tools to extend the capabilities of the Godot Engine by tapping into the functionality provided by Android platforms and ecosystem.

An Android plugin is an Android library with a dependency on the Godot Android library which the plugin uses to integrate into the engine's lifecycle and to access Godot APIs, granting it powerful capabilities such as GDExtension support which allows to update / mod the engine behavior as needed.

For more information, see Godot Android plugins.

The Godot Engine can be embedded within existing Android applications or libraries, allowing developers to leverage mature and battle-tested code and libraries better suited to a specific task.

The hosting component is responsible for driving the engine lifecycle via Godot's Android APIs. These APIs can also be used to provide bidirectional communication between the host and the embedded Godot instance allowing for greater control over the desired experience.

We showcase how this is done using a sample Android app that embeds the Godot Engine as an Android view, and uses it to render 3D glTF models.

The GLTF Viewer sample app uses an Android RecyclerView component to create a list of glTF items, populated from Kenney's Food Kit pack. When an item on the list is selected, the app's logic interacts with the embedded Godot Engine to render the selected glTF item as a 3D model.

The sample app source code can be found on GitHub. Follow the instructions on its README to build and install it.

Below we break-down the steps used to create the GLTF Viewer app.

Currently only a single instance of the Godot Engine is supported per process. You can configure the process the Android Activity runs under using the android:process attribute.

Automatic resizing / orientation configuration events are not supported and may cause a crash. You can disable those events:

By locking to a specific orientation using the android:screenOrientation attribute.

By declaring that the Activity will handle these configuration events using the android:configChanges attribute.

The Android sample app was created using Android Studio and using Gradle as the build system.

The Android ecosystem provides multiple tools, IDEs, build systems for creating Android apps so feel free to use what you're familiar with, and update the steps below accordingly (contributions to this documentation are welcomed as well!).

Set up an Android application project. It may be a brand new empty project, or an existing project

Add the maven dependency for the Godot Android library

If using gradle, add the following to the dependency section of the app's gradle build file. Make sure to update <version> to the latest version of the Godot Android library:

If using gradle, include the following aaptOptions configuration under the android > defaultConfig section of the app's gradle build file. Doing so allows gradle to include Godot's hidden directories when building the app binary.

If your build system does not support including hidden directories, you can configure the Godot project to not use hidden directories by deselecting Application > Config > Use Hidden Project Data Directory in the Project Settings.

Create / update the application's Activity that will be hosting the Godot Engine instance. For the sample app, this is MainActivity

The host Activity should implement the GodotHost interface

The sample app uses Fragments to organize its UI, so it uses GodotFragment, a fragment component provided by the Godot Android library to automatically host and manage the Godot Engine instance.

The Godot Android library also provide GodotActivity, an Activity component that can be extended to automatically host and manage the Godot Engine instance.

Alternatively, applications can directly create a Godot instance, host and manage it themselves.

Using GodotHost#getHostPlugins(...), the sample app creates a runtime GodotPlugin instance that's used to send signals to the gdscript logic

The runtime GodotPlugin can also be used by gdscript logic to access JVM methods. For more information, see Godot Android plugins.

Add any additional logic that will be used by your application

For the sample app, this includes adding the ItemsSelectionFragment fragment (and related classes), a fragment used to build and show the list of glTF items

Open the AndroidManifest.xml file, and configure the orientation if needed using the android:screenOrientation attribute

If needed, disable automatic resizing / orientation configuration changes using the android:configChanges attribute

On Android, Godot's project files are exported to the assets directory of the generated apk binary.

We leverage that architecture to bind our Android app and Godot project together by creating the Godot project in the Android app's assets directory.

Note that it's also possible to create the Godot project in a separate directory and export it as a PCK or ZIP file to the Android app's assets directory. Using this approach requires passing the --main-pack <pck_or_zip_filepath_relative_to_assets_dir> argument to the hosted Godot Engine instance using GodotHost#getCommandLine().

The instructions below and the sample app follow the first approach of creating the Godot project in the Android app's assets directory.

As mentioned in the note above, open the Godot Editor and create a Godot project directly (no subfolder) in the assets directory of the Android application project

See the sample app's Godot project for reference

Configure the Godot project as desired

Make sure the orientation set for the Godot project matches the one set in the Android app's manifest

For Android, make sure textures/vram_compression/import_etc2_astc is set to true

Update the Godot project script logic as needed

For the sample app, the script logic queries for the runtime GodotPlugin instance and uses it to register for signals fired by the app logic

The app logic fires a signal every time an item is selected in the list. The signal contains the filepath of the glTF model, which is used by the gdscript logic to render the model.

Once you complete configuration of your Godot project, build and run the Android app. If set up correctly, the host Activity will initialize the embedded Godot Engine on startup. The Godot Engine will check the assets directory for project files to load (unless configured to look for a main pack), and will proceed to run the project.

While the app is running on device, you can check Android logcat to investigate any errors or crashes.

For reference, check the build and install instructions for the GLTF Viewer sample app.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
implementation("org.godotengine:godot:<version>")
```

Example 2 (unknown):
```unknown
android {

  defaultConfig {
      // The default ignore pattern for the 'assets' directory includes hidden files and
      // directories which are used by Godot projects, so we override it with the following.
      aaptOptions {
          ignoreAssetsPattern "!.svn:!.git:!.gitignore:!.ds_store:!*.scc:<dir>_*:!CVS:!thumbs.db:!picasa.ini:!*~"
      }
    ...
```

Example 3 (unknown):
```unknown
private var godotFragment: GodotFragment? = null

override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    setContentView(R.layout.activity_main)

    val currentGodotFragment = supportFragmentManager.findFragmentById(R.id.godot_fragment_container)
    if (currentGodotFragment is GodotFragment) {
        godotFragment = currentGodotFragment
    } else {
        godotFragment = GodotFragment()
        supportFragmentManager.beginTransaction()
            .replace(R.id.godot_fragment_container, godotFragment!!)
            .commitNowAllowingStateLoss()
    }

    ...
```

Example 4 (unknown):
```unknown
<activity android:name=".MainActivity"
    android:screenOrientation="fullUser"
    android:configChanges="orientation|screenSize|smallestScreenSize|screenLayout"
    android:exported="true">

    ...
</activity>
```

---

## Godot Android plugins — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/platform/android/android_plugin.html

**Contents:**
- Godot Android plugins
- Introduction
- Android plugin
  - v2 Architecture
  - v2 Packaging format
- Building a v2 Android plugin
  - Building a v2 Android plugin with GDExtension capabilities
  - Migrating a v1 Android plugin to v2
- Packaging a v2 Android plugin
  - Packaging a v2 Android plugin with GDExtension capabilities

Android plugins are powerful tools to extend the capabilities of the Godot engine by tapping into the functionality provided by Android platforms and ecosystem.

For example in Godot 4, Android plugins are used to support multiple Android-based XR platforms without encumbering the core codebase with vendor specific code or binaries.

Version 1 (v1) of the Android plugin system was introduced in Godot 3 and compatible with Godot 4.0 and 4.1. That version allowed developers to augment the Godot engine with Java, Kotlin and native functionality.

Starting in Godot 4.2, Android plugins built on the v1 architecture are now deprecated. Instead, Godot 4.2 introduces a new Version 2 (v2) architecture for Android plugins.

Godot Android plugin leverages the Gradle build system.

Building on the previous v1 architecture, Android plugins continue to be derived from the Android archive library.

At its core, a Godot Android plugin v2 is an Android library with a dependency on the Godot Android library, and a custom Android library manifest.

This architecture allows Android plugins to extend the functionality of the engine with:

Android platform APIs

Kotlin and Java libraries

Native libraries (via JNI)

GDExtension libraries

Each plugin has an init class extending from the GodotPlugin class which is provided by the Godot Android library.

The GodotPlugin class provides APIs to access the running Godot instance and hook into its lifecycle. It is loaded at runtime by the Godot engine.

v1 Android plugins required a custom gdap configuration file that was used by the Godot Editor to detect and load them. However this approach had several drawbacks, primary ones being that it lacked flexibility and departed from the existing Godot EditorExportPlugin format, delivery and installation flow.

This has been resolved for v2 Android plugins by deprecating the gdap packaging and configuration mechanism in favor of the existing Godot EditorExportPlugin packaging format. The EditorExportPlugin API in turn has been extended to properly support Android plugins.

A github project template is provided at https://github.com/m4gr3d/Godot-Android-Plugin-Template as a quickstart for building Godot Android plugins for Godot 4.2+. You can follow the template README to set up your own Godot Android plugin project.

To provide further understanding, here is a break-down of the steps used to create the project template:

Create an Android library module using these instructions

Add the Godot Android library as a dependency by updating the module's gradle build file:

The Godot Android library is hosted on MavenCentral, and updated for each release.

Create GodotAndroidPlugin, an init class for the plugin extending GodotPlugin.

If the plugin exposes Kotlin or Java methods to be called from GDScript, they must be annotated with @UsedByGodot. The name called from GDScript must match the method name exactly. There is no coercing snake_case to camelCase. For example, from GDScript:

If the plugin uses signals, the init class must return the set of signals used by overriding GodotPlugin::getPluginSignals(). To emit signals, the plugin can use the GodotPlugin::emitSignal(...) method.

Update the plugin AndroidManifest.xml file with the following meta-data:

PluginName is the name of the plugin

plugin.init.ClassFullName is the full component name (package + class name) of the plugin init class (e.g: org.godotengine.plugin.android.template.GodotAndroidPlugin).

Create the EditorExportPlugin configuration to package the plugin. The steps used to create the configuration can be seen in the Packaging a v2 Android plugin section.

Similar to GDNative support in v1 Android plugins, v2 Android plugins support the ability to integrate GDExtension capabilities.

A github project template is provided at https://github.com/m4gr3d/GDExtension-Android-Plugin-Template as a quickstart for building GDExtension Android plugins for Godot 4.2+. You can follow the template's README to set up your own Godot Android plugin project.

Use the following steps if you have a v1 Android plugin you want to migrate to v2:

Update the plugin's manifest file:

Change the org.godotengine.plugin.v1 prefix to org.godotengine.plugin.v2

Update the Godot Android library build dependency:

You can continue using the godot-lib.<version>.<status>.aar binary from Godot's download page if that's your preference. Make sure it's updated to the latest stable version.

Or you can switch to the MavenCentral provided dependency:

After updating the Godot Android library dependency, sync or build the plugin and resolve any compile errors:

The Godot instance provided by GodotPlugin::getGodot() no longer has access to an android.content.Context reference. Use GodotPlugin::getActivity() instead.

Delete the gdap configuration file(s) and follow the instructions in the Packaging a v2 Android plugin section to set up the plugin configuration.

As mentioned, a v2 Android plugin is now provided to the Godot Editor as an EditorExportPlugin plugin, so it shares a lot of the same packaging steps.

Add the plugin output binaries within the plugin directory (e.g: in addons/<plugin_name>/)

Add the tool script for the export functionality within the plugin directory (e.g: in addons/<plugin_name>/)

The created script must be a @tool script, or else it will not work properly

The export tool script is used to configure the Android plugin and hook it within the Godot Editor's export process. It should look something like this:

Create a plugin.cfg. This is an INI file with metadata about your plugin:

For reference, here is the folder structure for the Godot Android plugin project template. At build time, the contents of the export_scripts_template directory as well as the generated plugin binaries are copied to the addons/<plugin_name> directory:

For GDExtension, we follow the same steps as for Packaging a v2 Android plugin and add the GDExtension config file in the same location as plugin.cfg.

For reference, here is the folder structure for the GDExtension Android plugin project template. At build time, the contents of the export_scripts_template directory as well as the generated plugin binaries are copied to the addons/<plugin_name> directory:

Here is what the plugin.gdextension config file should look like:

Of note is the android_aar_plugin field that specifies this GDExtension module is provided as part of a v2 Android plugin. During the export process, this will indicate to the Godot Editor that the GDExtension native shared libraries are exported by the Android plugin AAR binaries.

For GDExtension Android plugins, the plugin init class must override GodotPlugin::getPluginGDExtensionLibrariesPaths(), and return the paths to the bundled GDExtension libraries config files (*.gdextension).

The paths must be relative to the Android library's assets directory. At runtime, the plugin will provide these paths to the Godot engine which will use them to load and initialize the bundled GDExtension libraries.

Godot 4.2 or higher is required

v2 Android plugin requires the use of the Gradle build process.

The provided github project templates include demo Godot projects for quick testing.

Copy the plugin's output directory (addons/<plugin_name>) to the target Godot project's directory

Open the project in the Godot Editor; the Editor should detect the plugin

Navigate to Project -> Project Settings... -> Plugins, and ensure the plugin is enabled

Install the Godot Android build template by clicking on Project -> Install Android Build Template...

Navigate to Project -> Export...

In the Export window, create an Android export preset

In the Android export preset, scroll to Gradle Build and set Use Gradle Build to true

Update the project's scripts as needed to access the plugin's functionality. For example:

Connect an Android device to your machine and run the project on it

Since they are also Android libraries, Godot v2 Android plugins can be stripped from their EditorExportPlugin packaging and provided as raw AAR binaries for use as libraries alongside the Godot Android library by Android apps.

If targeting this use-case, make sure to include additional instructions for how the AAR binaries should be included (e.g: custom additions to the Android app's manifest).

Godot Android Plugins Samples

Godot Android Plugin Template

GDExtension Android Plugin Template

To make it easier to access the exposed Java / Kotlin APIs in the Godot Editor, it's recommended to provide one (or multiple) gdscript wrapper class(es) for your plugin users to interface with.

If planning to use the GDExtension functionality in the Godot Editor, it is recommended that the GDExtension's native binaries are compiled not just for Android, but also for the OS onto which developers / users intend to run the Godot Editor. Not doing so may prevent developers / users from writing code that accesses the plugin from within the Godot Editor.

This may involve creating dummy plugins for the host OS just so the API is published to the editor. You can use the godot-cpp-template github template for reference on how to do so.

Check adb logcat for possible problems, then:

Check that the methods exposed by the plugin used the following Java types: void, boolean, int, float, java.lang.String, org.godotengine.godot.Dictionary, int[], byte[], float[], java.lang.String[].

More complex datatypes are not supported for now.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
dependencies {
    implementation("org.godotengine:godot:4.2.0.stable")
}
```

Example 2 (unknown):
```unknown
if Engine.has_singleton("MyPlugin"):
    var singleton = Engine.get_singleton("MyPlugin")
    print(singleton.myPluginFunction("World"))
```

Example 3 (unknown):
```unknown
<meta-data
    android:name="org.godotengine.plugin.v2.[PluginName]"
    android:value="[plugin.init.ClassFullName]" />
```

Example 4 (unknown):
```unknown
dependencies {
    implementation("org.godotengine:godot:4.2.0.stable")
}
```

---

## Godot Docs – 4.5 branch — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/

**Contents:**
- Godot Docs – 4.5 branch
- Get involved
- Offline documentation

Godot's documentation is available in various languages and versions. Expand the "Read the Docs" panel at the bottom of the sidebar to see the list.

Welcome to the official documentation of Godot Engine, the free and open source community-driven 2D and 3D game engine! If you are new to this documentation, we recommend that you read the introduction page to get an overview of what this documentation has to offer.

The table of contents in the sidebar should let you easily access the documentation for your topic of interest. You can also use the search function in the top-left corner.

Godot Engine is an open source project developed by a community of volunteers. The documentation team can always use your feedback and help to improve the tutorials and class reference. If you don't understand something, or cannot find what you are looking for in the docs, help us make the documentation better by letting us know!

Submit an issue or pull request on the GitHub repository, help us translate the documentation into your language, or talk to us on the #documentation channel on the Godot Contributors Chat!

To browse the documentation offline, you can download an HTML copy (updated every Monday): stable, latest, 3.6. Extract the ZIP archive then open the top-level index.html in a web browser.

For mobile devices or e-readers, you can also download an ePub copy (updated every Monday): stable, latest, 3.6. Extract the ZIP archive then open the GodotEngine.epub file in an e-book reader application.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Godot file formats — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/file_formats/index.html

**Contents:**
- Godot file formats

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Godot interfaces — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/best_practices/godot_interfaces.html

**Contents:**
- Godot interfaces
- Acquiring object references
- Accessing data or logic from an object
- User-contributed notes

Often one needs scripts that rely on other objects for features. There are 2 parts to this process:

Acquiring a reference to the object that presumably has the features.

Accessing the data or logic from the object.

The rest of this tutorial outlines the various ways of doing all this.

For all Objects, the most basic way of referencing them is to get a reference to an existing object from another acquired instance.

The same principle applies for RefCounted objects. While users often access Node and Resource this way, alternative measures are available.

Instead of property or method access, one can get Resources by load access.

There are many ways in which a language can load such resources.

When designing how objects will access data, don't forget that one can pass resources around as references as well.

Keep in mind that loading a resource fetches the cached resource instance maintained by the engine. To get a new object, one must duplicate an existing reference or instantiate one from scratch with new().

Nodes likewise have an alternative access point: the SceneTree.

Godot's scripting API is duck-typed. This means that if a script executes an operation, Godot doesn't validate that it supports the operation by type. It instead checks that the object implements the individual method.

For example, the CanvasItem class has a visible property. All properties exposed to the scripting API are in fact a setter and getter pair bound to a name. If one tried to access CanvasItem.visible, then Godot would do the following checks, in order:

If the object has a script attached, it will attempt to set the property through the script. This leaves open the opportunity for scripts to override a property defined on a base object by overriding the setter method for the property.

If the script does not have the property, it performs a HashMap lookup in the ClassDB for the "visible" property against the CanvasItem class and all of its inherited types. If found, it will call the bound setter or getter. For more information about HashMaps, see the data preferences docs.

If not found, it does an explicit check to see if the user wants to access the "script" or "meta" properties.

If not, it checks for a _set/_get implementation (depending on type of access) in the CanvasItem and its inherited types. These methods can execute logic that gives the impression that the Object has a property. This is also the case with the _get_property_list method.

Note that this happens even for non-legal symbol names, such as names starting with a digit or containing a slash.

As a result, this duck-typed system can locate a property either in the script, the object's class, or any class that object inherits, but only for things which extend Object.

Godot provides a variety of options for performing runtime checks on these accesses:

A duck-typed property access. These will be property checks (as described above). If the operation isn't supported by the object, execution will halt.

A method check. In the case of CanvasItem.visible, one can access the methods, set_visible and is_visible like any other method.

Outsource the access to a Callable. These may be useful in cases where one needs the max level of freedom from dependencies. In this case, one relies on an external context to setup the method.

These strategies contribute to Godot's flexible design. Between them, users have a breadth of tools to meet their specific needs.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
var obj = node.object # Property access.
var obj = node.get_object() # Method access.
```

Example 2 (unknown):
```unknown
GodotObject obj = node.Object; // Property access.
GodotObject obj = node.GetObject(); // Method access.
```

Example 3 (javascript):
```javascript
# If you need an "export const var" (which doesn't exist), use a conditional
# setter for a tool script that checks if it's executing in the editor.
# The `@tool` annotation must be placed at the top of the script.
@tool

# Load resource during scene load.
var preres = preload(path)
# Load resource when program reaches statement.
var res = load(path)

# Note that users load scenes and scripts, by convention, with PascalCase
# names (like typenames), often into constants.
const MyScene = preload("my_scene.tscn") # Static load
const MyScript = preload("my_script.gd")

# This type's value varies, i.e. it is a variable, so it uses snake_case.
@export var script_type: Script

# Must configure from the editor, defaults to null.
@export var const_script: Script:
    set(value):
        if Engine.is_editor_hint():
            const_script = value

# Warn users if the value hasn't been set.
func _get_configuration_warnings():
    if not const_script:
        return ["Must initialize property 'const_script'."]

    return []
```

Example 4 (javascript):
```javascript
// Tool script added for the sake of the "const [Export]" example.
[Tool]
public MyType
{
    // Property initializations load during Script instancing, i.e. .new().
    // No "preload" loads during scene load exists in C#.

    // Initialize with a value. Editable at runtime.
    public Script MyScript = GD.Load<Script>("res://Path/To/MyScript.cs");

    // Initialize with same value. Value cannot be changed.
    public readonly Script MyConstScript = GD.Load<Script>("res://Path/To/MyScript.cs");

    // Like 'readonly' due to inaccessible setter.
    // But, value can be set during constructor, i.e. MyType().
    public Script MyNoSetScript { get; } = GD.Load<Script>("res://Path/To/MyScript.cs");

    // If need a "const [Export]" (which doesn't exist), use a
    // conditional setter for a tool script that checks if it's executing
    // in the editor.
    private PackedScene _enemyScn;

    [Export]
    public PackedScene EnemyScn
    {
        get { return _enemyScn; }
        set
        {
            if (Engine.IsEditorHint())
            {
                _enemyScn = value;
            }
        }
    };

    // Warn users if the value hasn't been set.
    public string[] _GetConfigurationWarnings()
    {
        if (EnemyScn == null)
        {
            return ["Must initialize property 'EnemyScn'."];
        }
        return [];
    }
}
```

---

## Godot notifications — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/best_practices/godot_notifications.html

**Contents:**
- Godot notifications
- _process vs. _physics_process vs. *_input
- _init vs. initialization vs. export
- _ready vs. _enter_tree vs. NOTIFICATION_PARENTED
- User-contributed notes

Every Object in Godot implements a _notification method. Its purpose is to allow the Object to respond to a variety of engine-level callbacks that may relate to it. For example, if the engine tells a CanvasItem to "draw", it will call _notification(NOTIFICATION_DRAW).

Some of these notifications, like draw, are useful to override in scripts. So much so that Godot exposes many of them with dedicated functions:

_ready(): NOTIFICATION_READY

_enter_tree(): NOTIFICATION_ENTER_TREE

_exit_tree(): NOTIFICATION_EXIT_TREE

_process(delta): NOTIFICATION_PROCESS

_physics_process(delta): NOTIFICATION_PHYSICS_PROCESS

_draw(): NOTIFICATION_DRAW

What users might not realize is that notifications exist for types other than Node alone, for example:

Object::NOTIFICATION_POSTINITIALIZE: a callback that triggers during object initialization. Not accessible to scripts.

Object::NOTIFICATION_PREDELETE: a callback that triggers before the engine deletes an Object, i.e. a "destructor".

And many of the callbacks that do exist in Nodes don't have any dedicated methods, but are still quite useful.

Node::NOTIFICATION_PARENTED: a callback that triggers anytime one adds a child node to another node.

Node::NOTIFICATION_UNPARENTED: a callback that triggers anytime one removes a child node from another node.

One can access all these custom notifications from the universal _notification() method.

Methods in the documentation labeled as "virtual" are also intended to be overridden by scripts.

A classic example is the _init method in Object. While it has no NOTIFICATION_* equivalent, the engine still calls the method. Most languages (except C#) rely on it as a constructor.

So, in which situation should one use each of these notifications or virtual functions?

Use _process() when one needs a framerate-dependent delta time between frames. If code that updates object data needs to update as often as possible, this is the right place. Recurring logic checks and data caching often execute here, but it comes down to the frequency at which one needs the evaluations to update. If they don't need to execute every frame, then implementing a Timer-timeout loop is another option.

Use _physics_process() when one needs a framerate-independent delta time between frames. If code needs consistent updates over time, regardless of how fast or slow time advances, this is the right place. Recurring kinematic and object transform operations should execute here.

While it is possible, to achieve the best performance, one should avoid making input checks during these callbacks. _process() and _physics_process() will trigger at every opportunity (they do not "rest" by default). In contrast, *_input() callbacks will trigger only on frames in which the engine has actually detected the input.

One can check for input actions within the input callbacks just the same. If one wants to use delta time, one can fetch it from the related delta time methods as needed.

If the script initializes its own node subtree, without a scene, that code should execute in _init(). Other property or SceneTree-independent initializations should also run here.

The C# equivalent to GDScript's _init() method is the constructor.

_init() triggers before _enter_tree() or _ready(), but after a script creates and initializes its properties. When instantiating a scene, property values will set up according to the following sequence:

Initial value assignment: the property is assigned its initialization value, or its default value if one is not specified. If a setter exists, it is not used.

_init() assignment: the property's value is replaced by any assignments made in _init(), triggering the setter.

Exported value assignment: an exported property's value is again replaced by any value set in the Inspector, triggering the setter.

As a result, instantiating a script versus a scene may affect both the initialization and the number of times the engine calls the setter.

When instantiating a scene connected to the first executed scene, Godot will instantiate nodes down the tree (making _init() calls) and build the tree going downwards from the root. This causes _enter_tree() calls to cascade down the tree. Once the tree is complete, leaf nodes call _ready. A node will call this method once all child nodes have finished calling theirs. This then causes a reverse cascade going up back to the tree's root.

When instantiating a script or a standalone scene, nodes are not added to the SceneTree upon creation, so no _enter_tree() callbacks trigger. Instead, only the _init() call occurs. When the scene is added to the SceneTree, the _enter_tree() and _ready() calls occur.

If one needs to trigger behavior that occurs as nodes parent to another, regardless of whether it occurs as part of the main/active scene or not, one can use the PARENTED notification. For example, here is a snippet that connects a node's method to a custom signal on the parent node without failing. Useful on data-centric nodes that one might create at runtime.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
# Allows for recurring operations that don't trigger script logic
# every frame (or even every fixed frame).
func _ready():
    var timer = Timer.new()
    timer.autostart = true
    timer.wait_time = 0.5
    add_child(timer)
    timer.timeout.connect(func():
        print("This block runs every 0.5 seconds")
    )
```

Example 2 (javascript):
```javascript
using Godot;

public partial class MyNode : Node
{
    // Allows for recurring operations that don't trigger script logic
    // every frame (or even every fixed frame).
    public override void _Ready()
    {
        var timer = new Timer();
        timer.Autostart = true;
        timer.WaitTime = 0.5;
        AddChild(timer);
        timer.Timeout += () => GD.Print("This block runs every 0.5 seconds");
    }
}
```

Example 3 (csharp):
```csharp
using namespace godot;

class MyNode : public Node {
    GDCLASS(MyNode, Node)

public:
    // Allows for recurring operations that don't trigger script logic
    // every frame (or even every fixed frame).
    virtual void _ready() override {
        Timer *timer = memnew(Timer);
        timer->set_autostart(true);
        timer->set_wait_time(0.5);
        add_child(timer);
        timer->connect("timeout", callable_mp(this, &MyNode::run));
    }

    void run() {
        UtilityFunctions::print("This block runs every 0.5 seconds.");
    }
};
```

Example 4 (unknown):
```unknown
# Called every frame, even when the engine detects no input.
func _process(delta):
    if Input.is_action_just_pressed("ui_select"):
        print(delta)

# Called during every input event.
func _unhandled_input(event):
    match event.get_class():
        "InputEventKey":
            if Input.is_action_just_pressed("ui_accept"):
                print(get_process_delta_time())
```

---

## Godot release policy — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/about/release_policy.html

**Contents:**
- Godot release policy
- Godot versioning
- Release support timeline
- Which version should I use for a new project?
- Should I upgrade my project to use new engine versions?
- When is the next release out?
- What are the criteria for compatibility across engine versions?

Godot's release policy is in constant evolution. The description below provides a general idea of what to expect, but what will actually happen depends on the choices of core contributors and the needs of the community at a given time.

Godot loosely follows Semantic Versioning with a major.minor.patch versioning system, albeit with an interpretation of each term adapted to the complexity of a game engine:

The major version is incremented when major compatibility breakages happen which imply significant porting work to move projects from one major version to another.

For example, porting Godot projects from Godot 3.x to Godot 4.x requires running the project through a conversion tool, and then performing a number of further adjustments manually for what the tool could not do automatically.

The minor version is incremented for feature releases that do not break compatibility in a major way. Minor compatibility breakage in very specific areas may happen in minor versions, but the vast majority of projects should not be affected or require significant porting work.

This is because Godot, as a game engine, covers many areas like rendering, physics, and scripting. Fixing bugs or implementing new features in one area might sometimes require changing a feature's behavior or modifying a class's interface, even if the rest of the engine API remains backwards compatible.

Upgrading to a new minor version is recommended for all users, but some testing is necessary to ensure that your project still behaves as expected.

The patch version is incremented for maintenance releases which focus on fixing bugs and security issues, implementing new requirements for platform support, and backporting safe usability enhancements. Patch releases are backwards compatible.

Patch versions may include minor new features which do not impact the existing API, and thus have no risk of impacting existing projects.

Updating to new patch versions is therefore considered safe and strongly recommended to all users of a given stable branch.

We call major.minor combinations stable branches. Each stable branch starts with a major.minor release (without the 0 for patch) and is further developed for maintenance releases in a Git branch of the same name (for example patch updates for the 4.0 stable branch are developed in the 4.0 Git branch).

Stable branches are supported at least until the next stable branch is released and has received its first patch update. In practice, we support stable branches on a best effort basis for as long as they have active users who need maintenance updates.

Whenever a new major version is released, we make the previous stable branch a long-term supported release, and do our best to provide fixes for issues encountered by users of that branch who cannot port complex projects to the new major version. This was the case for the 2.1 branch, and is the case for the 3.x branch.

In a given minor release series, only the latest patch release receives support. If you experience an issue using an older patch release, please upgrade to the latest patch release of that series and test again before reporting an issue on GitHub.

Development. Receives new features, usability and performance improvements, as well as bug fixes, while under development.

Receives fixes for bugs and security issues, as well as patches that enable platform support.

Receives fixes for bugs and security issues, as well as patches that enable platform support.

Receives fixes for security and platform support issues only.

No longer supported (last update: 4.1.4).

No longer supported (last update: 4.0.4).

Beta. Receives new features, usability and performance improvements, as well as bug fixes, while under development.

Receives fixes for bugs and security issues, as well as patches that enable platform support.

Receives fixes for security and platform support issues only.

No longer supported (last update: 3.4.5).

No longer supported (last update: 3.3.4).

No longer supported (last update: 3.2.3).

No longer supported (last update: 3.1.2).

No longer supported (last update: 3.0.6).

No longer supported (last update: 2.1.6).

No longer supported (last update: 2.0.4.1).

Legend: Full support – Partial support – No support (end of life) – Development version

Pre-release Godot versions aren't intended to be used in production and are provided for testing purposes only.

See Upgrading from Godot 3 to Godot 4 for instructions on migrating a project from Godot 3.x to 4.x.

We recommend using Godot 4.x for new projects, as the Godot 4.x series will be supported long after 3.x stops receiving updates in the future. One caveat is that a lot of third-party documentation hasn't been updated for Godot 4.x yet. If you have to follow a tutorial designed for Godot 3.x, we recommend keeping Upgrading from Godot 3 to Godot 4 open in a separate tab to check which methods have been renamed (if you get a script error while trying to use a specific node or method that was renamed in Godot 4.x).

If your project requires a feature that is missing in 4.x (such as GLES2/WebGL 1.0), you should use Godot 3.x for a new project instead.

Upgrading software while working on a project is inherently risky, so consider whether it's a good idea for your project before attempting an upgrade. Also, make backups of your project or use version control to prevent losing data in case the upgrade goes wrong.

That said, we do our best to keep minor and especially patch releases compatible with existing projects.

The general recommendation is to upgrade your project to follow new patch releases, such as upgrading from 4.0.2 to 4.0.3. This ensures you get bug fixes, security updates and platform support updates (which is especially important for mobile platforms). You also get continued support, as only the last patch release receives support on official community platforms.

For minor releases, you should determine whether it's a good idea to upgrade on a case-by-case basis. We've made a lot of effort in making the upgrade process as seamless as possible, but some breaking changes may be present in minor releases, along with a greater risk of regressions. Some fixes included in minor releases may also change a class' expected behavior as required to fix some bugs. This is especially the case in classes marked as experimental in the documentation.

Major releases bring a lot of new functionality, but they also remove previously existing functionality and may raise hardware requirements. They also require much more work to upgrade to compared to minor releases. As a result, we recommend sticking with the major release you've started your project with if you are happy with how your project currently works. For example, if your project was started with 3.5, we recommend upgrading to 3.5.2 and possibly 3.6 in the future, but not to 4.0+, unless your project really needs the new features that come with 4.0+.

While Godot contributors aren't working under any deadlines, we strive to publish minor releases relatively frequently.

In particular, after the very long release cycle for 4.0, we are pivoting to a faster-paced development workflow, 4.1 released 4 months after 4.0, and 4.2 released 4 months after 4.1.

Frequent minor releases will enable us to ship new features faster (possibly as experimental), get user feedback quickly, and iterate to improve those features and their usability. Likewise, the general user experience will be improved more steadily with a faster path to the end users.

Maintenance (patch) releases are released as needed with potentially very short development cycles, to provide users of the current stable branch with the latest bug fixes for their production needs.

There is currently no planned release date for the next 3.x minor version, 3.7. The current stable release, 3.6, may be the last stable branch of Godot 3.x. Godot 3.x is supported on a best-effort basis, as long as contributors continue to maintain it.

This section is intended to be used by contributors to determine which changes are safe for a given release. The list is not exhaustive; it only outlines the most common situations encountered during Godot's development.

The following changes are acceptable in patch releases:

Fixing a bug in a way that has no major negative impact on most projects, such as a visual or physics bug. Godot's physics engine is not deterministic, so physics bug fixes are not considered to break compatibility. If fixing a bug has a negative impact that could impact a lot of projects, it should be made optional (e.g. using a project setting or separate method).

Adding a new optional parameter to a method.

Small-scale editor usability tweaks.

Note that we tend to be more conservative with the fixes we allow in each subsequent patch release. For instance, 4.0.1 may receive more impactful fixes than 4.0.4 would.

The following changes are acceptable in minor releases, but not patch releases:

Significant new features.

Renaming a method parameter. In C#, method parameters can be passed by name (but not in GDScript). As a result, this can break some projects that use C#.

Deprecating a method, member variable, or class. This is done by adding a deprecated flag to its class reference, which will show up in the editor. When a method is marked as deprecated, it's slated to be removed in the next major release.

Changes that affect the default project theme's visuals.

Bug fixes which significantly change the behavior or the output, with the aim to meet user expectations better. In comparison, in patch releases, we may favor keeping a buggy behavior so we don't break existing projects which likely already rely on the bug or use a workaround.

Performance optimizations that result in visual changes.

The following changes are considered compatibility-breaking and can only be performed in a new major release:

Renaming or removing a method, member variable, or class.

Modifying a node's inheritance tree by making it inherit from a different class.

Changing the default value of a project setting value in a way that affects existing projects. To only affect new projects, the project manager should write a modified project.godot instead.

Since Godot 5.0 hasn't been branched off yet, we currently discourage making compatibility-breaking changes of this kind.

When modifying a method's signature in any fashion (including adding an optional parameter), a GDExtension compatibility method must be created. This ensures that existing GDExtensions continue to work across patch and minor releases, so that users don't have to recompile them. See Handling compatibility breakages for more information.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## GPU optimization — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/performance/gpu_optimization.html

**Contents:**
- GPU optimization
- Introduction
- Draw calls, state changes, and APIs
  - 2D batching
  - 3D batching
  - Reuse shaders and materials
- Pixel cost versus vertex cost
- Pixel/fragment shaders and fill rate
  - Reading textures
  - Texture compression

The demand for new graphics features and progress almost guarantees that you will encounter graphics bottlenecks. Some of these can be on the CPU side, for instance in calculations inside the Godot engine to prepare objects for rendering. Bottlenecks can also occur on the CPU in the graphics driver, which sorts instructions to pass to the GPU, and in the transfer of these instructions. And finally, bottlenecks also occur on the GPU itself.

Where bottlenecks occur in rendering is highly hardware-specific. Mobile GPUs in particular may struggle with scenes that run easily on desktop.

Understanding and investigating GPU bottlenecks is slightly different to the situation on the CPU. This is because, often, you can only change performance indirectly by changing the instructions you give to the GPU. Also, it may be more difficult to take measurements. In many cases, the only way of measuring performance is by examining changes in the time spent rendering each frame.

The following section is not relevant to end-users, but is useful to provide background information that is relevant in later sections.

Godot sends instructions to the GPU via a graphics API (Vulkan, OpenGL, OpenGL ES or WebGL). The communication and driver activity involved can be quite costly, especially in OpenGL, OpenGL ES and WebGL. If we can provide these instructions in a way that is preferred by the driver and GPU, we can greatly increase performance.

Nearly every API command in OpenGL requires a certain amount of validation to make sure the GPU is in the correct state. Even seemingly simple commands can lead to a flurry of behind-the-scenes housekeeping. Therefore, the goal is to reduce these instructions to a bare minimum and group together similar objects as much as possible so they can be rendered together, or with the minimum number of these expensive state changes.

In 2D, the costs of treating each item individually can be prohibitively high - there can easily be thousands of them on the screen. This is why 2D batching is used. Multiple similar items are grouped together and rendered in a batch, via a single draw call, rather than making a separate draw call for each item. In addition, this means state changes, material and texture changes can be kept to a minimum.

In 3D, we still aim to minimize draw calls and state changes. However, it can be more difficult to batch together several objects into a single draw call. 3D meshes tend to comprise hundreds or thousands of triangles, and combining large meshes in real-time is prohibitively expensive. The costs of joining them quickly exceeds any benefits as the number of triangles grows per mesh. A much better alternative is to join meshes ahead of time (static meshes in relation to each other). This can be done by artists, or programmatically within Godot using an add-on.

There is also a cost to batching together objects in 3D. Several objects rendered as one cannot be individually culled. An entire city that is off-screen will still be rendered if it is joined to a single blade of grass that is on screen. Thus, you should always take objects' locations and culling into account when attempting to batch 3D objects together. Despite this, the benefits of joining static objects often outweigh other considerations, especially for large numbers of distant or low-poly objects.

For more information on 3D specific optimizations, see Optimizing 3D performance.

The Godot renderer is a little different to what is out there. It's designed to minimize GPU state changes as much as possible. StandardMaterial3D does a good job at reusing materials that need similar shaders. If custom shaders are used, make sure to reuse them as much as possible. Godot's priorities are:

Reusing Materials: The fewer different materials in the scene, the faster the rendering will be. If a scene has a huge amount of objects (in the hundreds or thousands), try reusing the materials. In the worst case, use atlases to decrease the amount of texture changes.

Reusing Shaders: If materials can't be reused, at least try to reuse shaders. Note: shaders are automatically reused between StandardMaterial3Ds that share the same configuration (features that are enabled or disabled with a check box) even if they have different parameters.

If a scene has, for example, 20,000 objects with 20,000 different materials each, rendering will be slow. If the same scene has 20,000 objects, but only uses 100 materials, rendering will be much faster.

You may have heard that the lower the number of polygons in a model, the faster it will be rendered. This is really relative and depends on many factors.

On a modern PC and console, vertex cost is low. GPUs originally only rendered triangles. This meant that every frame:

All vertices had to be transformed by the CPU (including clipping).

All vertices had to be sent to the GPU memory from the main RAM.

Nowadays, all this is handled inside the GPU, greatly increasing performance. 3D artists usually have the wrong feeling about polycount performance because 3D modeling software (such as Blender, 3ds Max, etc.) need to keep geometry in CPU memory for it to be edited, reducing actual performance. Game engines rely on the GPU more, so they can render many triangles much more efficiently.

On mobile devices, the story is different. PC and console GPUs are brute-force monsters that can pull as much electricity as they need from the power grid. Mobile GPUs are limited to a tiny battery, so they need to be a lot more power efficient.

To be more efficient, mobile GPUs attempt to avoid overdraw. Overdraw occurs when the same pixel on the screen is being rendered more than once. Imagine a town with several buildings. GPUs don't know what is visible and what is hidden until they draw it. For example, a house might be drawn and then another house in front of it (which means rendering happened twice for the same pixel). PC GPUs normally don't care much about this and just throw more pixel processors to the hardware to increase performance (which also increases power consumption).

Using more power is not an option on mobile so mobile devices use a technique called tile-based rendering which divides the screen into a grid. Each cell keeps the list of triangles drawn to it and sorts them by depth to minimize overdraw. This technique improves performance and reduces power consumption, but takes a toll on vertex performance. As a result, fewer vertices and triangles can be processed for drawing.

Additionally, tile-based rendering struggles when there are small objects with a lot of geometry within a small portion of the screen. This forces mobile GPUs to put a lot of strain on a single screen tile, which considerably decreases performance as all the other cells must wait for it to complete before displaying the frame.

To summarize, don't worry about vertex count on mobile, but avoid concentration of vertices in small parts of the screen. If a character, NPC, vehicle, etc. is far away (which means it looks tiny), use a smaller level of detail (LOD) model. Even on desktop GPUs, it's preferable to avoid having triangles smaller than the size of a pixel on screen.

Pay attention to the additional vertex processing required when using:

Skinning (skeletal animation)

Vertex-lit objects (common on mobile)

In contrast to vertex processing, the costs of fragment (per-pixel) shading have increased dramatically over the years. Screen resolutions have increased: the area of a 4K screen is 8,294,400 pixels, versus 307,200 for an old 640×480 VGA screen. That is 27 times the area! Also, the complexity of fragment shaders has exploded. Physically-based rendering requires complex calculations for each fragment.

You can test whether a project is fill rate-limited quite easily. Turn off V-Sync to prevent capping the frames per second, then compare the frames per second when running with a large window, to running with a very small window. You may also benefit from similarly reducing your shadow map size if using shadows. Usually, you will find the FPS increases quite a bit using a small window, which indicates you are to some extent fill rate-limited. On the other hand, if there is little to no increase in FPS, then your bottleneck lies elsewhere.

You can increase performance in a fill rate-limited project by reducing the amount of work the GPU has to do. You can do this by simplifying the shader (perhaps turn off expensive options if you are using a StandardMaterial3D), or reducing the number and size of textures used. Also, when using non-unshaded particles, consider forcing vertex shading in their material to decrease the shading cost.

On supported hardware, Variable rate shading can be used to reduce shading processing costs without impacting the sharpness of edges on the final image.

When targeting mobile devices, consider using the simplest possible shaders you can reasonably afford to use.

The other factor in fragment shaders is the cost of reading textures. Reading textures is an expensive operation, especially when reading from several textures in a single fragment shader. Also, consider that filtering may slow it down further (trilinear filtering between mipmaps, and averaging). Reading textures is also expensive in terms of power usage, which is a big issue on mobiles.

If you use third-party shaders or write your own shaders, try to use algorithms that require as few texture reads as possible.

By default, Godot compresses textures of 3D models when imported using video RAM (VRAM) compression. Video RAM compression isn't as efficient in size as PNG or JPG when stored, but increases performance enormously when drawing large enough textures.

This is because the main goal of texture compression is bandwidth reduction between memory and the GPU.

In 3D, the shapes of objects depend more on the geometry than the texture, so compression is generally not noticeable. In 2D, compression depends more on shapes inside the textures, so the artifacts resulting from 2D compression are more noticeable.

As a warning, most Android devices do not support texture compression of textures with transparency (only opaque), so keep this in mind.

Even in 3D, "pixel art" textures should have VRAM compression disabled as it will negatively affect their appearance, without improving performance significantly due to their low resolution.

Post-processing effects and shadows can also be expensive in terms of fragment shading activity. Always test the impact of these on different hardware.

Reducing the size of shadowmaps can increase performance, both in terms of writing and reading the shadowmaps. On top of that, the best way to improve performance of shadows is to turn shadows off for as many lights and objects as possible. Smaller or distant OmniLights/SpotLights can often have their shadows disabled with only a small visual impact.

Transparent objects present particular problems for rendering efficiency. Opaque objects (especially in 3D) can be essentially rendered in any order and the Z-buffer will ensure that only the front most objects get shaded. Transparent or blended objects are different. In most cases, they cannot rely on the Z-buffer and must be rendered in "painter's order" (i.e. from back to front) to look correct.

Transparent objects are also particularly bad for fill rate, because every item has to be drawn even if other transparent objects will be drawn on top later on.

Opaque objects don't have to do this. They can usually take advantage of the Z-buffer by writing to the Z-buffer only first, then only performing the fragment shader on the "winning" fragment, the object that is at the front at a particular pixel.

Transparency is particularly expensive where multiple transparent objects overlap. It is usually better to use transparent areas as small as possible to minimize these fill rate requirements, especially on mobile, where fill rate is very expensive. Indeed, in many situations, rendering more complex opaque geometry can end up being faster than using transparency to "cheat".

If you are aiming to release on multiple platforms, test early and test often on all your platforms, especially mobile. Developing a game on desktop but attempting to port it to mobile at the last minute is a recipe for disaster.

In general, you should design your game for the lowest common denominator, then add optional enhancements for more powerful platforms. For example, you may want to use the Compatibility rendering method for both desktop and mobile platforms where you target both.

As described above, GPUs on mobile devices work in dramatically different ways from GPUs on desktop. Most mobile devices use tile renderers. Tile renderers split up the screen into regular-sized tiles that fit into super fast cache memory, which reduces the number of read/write operations to the main memory.

There are some downsides though. Tiled rendering can make certain techniques much more complicated and expensive to perform. Tiles that rely on the results of rendering in different tiles or on the results of earlier operations being preserved can be very slow. Be very careful to test the performance of shaders, viewport textures and post processing.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Gradle builds for Android — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/export/android_gradle_build.html

**Contents:**
- Gradle builds for Android
- Set up the gradle build environment
- Enabling the gradle build and exporting
- User-contributed notes

Godot provides the option to build using the gradle buildsystem. Instead of using the already pre-built template that ships with Godot, an Android Java project gets installed into your project folder. Godot will then build it and use it as an export template every time you export the project.

There are some reasons why you may want to do this:

Modify the project before it's built.

Add external SDKs that build with your project.

Configuring the gradle build is a fairly straightforward process. But first you need to follow the steps in exporting for android up to Setting it up in Godot. After doing that, follow the steps below.

Go to the Project menu, and install the Gradle Build template:

Make sure export templates are downloaded. If not, this menu will help you download them.

A Gradle-based Android project will be created under res://android/build. Editing these files is not needed unless you really need to modify the project.

When setting up the Android project in the Project > Export dialog, Gradle Build needs to be enabled:

From now on, attempting to export the project or one-click deploy will call the Gradle build system to generate fresh templates (this window will appear every time):

The templates built will be used automatically afterwards, so no further configuration is needed.

When using the gradle Android build system, assets that are placed within a folder whose name begins with an underscore will not be included in the generated APK. This does not apply to assets whose file name begins with an underscore.

For example, _example/image.png will not be included as an asset, but _image.png will.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Handling quit requests — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/inputs/handling_quit_requests.html

**Contents:**
- Handling quit requests
- Quitting
- Handling the notification
- On mobile devices
- Sending your own quit notification
- User-contributed notes

Most platforms have the option to request the application to quit. On desktops, this is usually done with the "x" icon on the window title bar. On mobile devices, the app can quit at any time while it is suspended to the background.

On desktop and web platforms, Node receives a special NOTIFICATION_WM_CLOSE_REQUEST notification when quitting is requested from the window manager.

Handling the notification is done as follows (on any node):

It is important to note that by default, Godot apps have the built-in behavior to quit when quit is requested from the window manager. This can be changed, so that the user can take care of the complete quitting procedure:

There is no direct equivalent to NOTIFICATION_WM_CLOSE_REQUEST on mobile platforms. Due to the nature of mobile operating systems, the only place that you can run code prior to quitting is when the app is being suspended to the background. On both Android and iOS, the app can be killed while suspended at any time by either the user or the OS. A way to plan ahead for this possibility is to utilize NOTIFICATION_APPLICATION_PAUSED in order to perform any needed actions as the app is being suspended.

On iOS, you only have approximately 5 seconds to finish a task started by this signal. If you go over this allotment, iOS will kill the app instead of pausing it.

On Android, pressing the Back button will exit the application if Application > Config > Quit On Go Back is checked in the Project Settings (which is the default). This will fire NOTIFICATION_WM_GO_BACK_REQUEST.

While forcing the application to close can be done by calling SceneTree.quit, doing so will not send the NOTIFICATION_WM_CLOSE_REQUEST to the nodes in the scene tree. Quitting by calling SceneTree.quit will not allow custom actions to complete (such as saving, confirming the quit, or debugging), even if you try to delay the line that forces the quit.

Instead, if you want to notify the nodes in the scene tree about the upcoming program termination, you should send the notification yourself:

Sending this notification will inform all nodes about the program termination, but will not terminate the program itself unlike in 3.X. In order to achieve the previous behavior, SceneTree.quit should be called after the notification.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
func _notification(what):
    if what == NOTIFICATION_WM_CLOSE_REQUEST:
        get_tree().quit() # default behavior
```

Example 2 (unknown):
```unknown
public override void _Notification(int what)
{
    if (what == NotificationWMCloseRequest)
    {
        GetTree().Quit(); // default behavior
    }
}
```

Example 3 (unknown):
```unknown
get_tree().set_auto_accept_quit(false)
```

Example 4 (unknown):
```unknown
GetTree().AutoAcceptQuit = false;
```

---

## High-level multiplayer — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/networking/high_level_multiplayer.html

**Contents:**
- High-level multiplayer
- High-level vs low-level API
- Mid-level abstraction
- Hosting considerations
- Initializing the network
- Managing connections
- Remote procedure calls
- Channels
- Example lobby implementation
- Exporting for dedicated servers

The following explains the differences of high- and low-level networking in Godot as well as some fundamentals. If you want to jump in head-first and add networking to your first nodes, skip to Initializing the network below. But make sure to read the rest later on!

Godot always supported standard low-level networking via UDP, TCP and some higher-level protocols such as HTTP and SSL. These protocols are flexible and can be used for almost anything. However, using them to synchronize game state manually can be a large amount of work. Sometimes that work can't be avoided or is worth it, for example when working with a custom server implementation on the backend. But in most cases, it's worthwhile to consider Godot's high-level networking API, which sacrifices some of the fine-grained control of low-level networking for greater ease of use.

This is due to the inherent limitations of the low-level protocols:

TCP ensures packets will always arrive reliably and in order, but latency is generally higher due to error correction. It's also quite a complex protocol because it understands what a "connection" is, and optimizes for goals that often don't suit applications like multiplayer games. Packets are buffered to be sent in larger batches, trading less per-packet overhead for higher latency. This can be useful for things like HTTP, but generally not for games. Some of this can be configured and disabled (e.g. by disabling "Nagle's algorithm" for the TCP connection).

UDP is a simpler protocol, which only sends packets (and has no concept of a "connection"). No error correction makes it pretty quick (low latency), but packets may be lost along the way or received in the wrong order. Added to that, the MTU (maximum packet size) for UDP is generally low (only a few hundred bytes), so transmitting larger packets means splitting them, reorganizing them and retrying if a part fails.

In general, TCP can be thought of as reliable, ordered, and slow; UDP as unreliable, unordered and fast. Because of the large difference in performance, it often makes sense to re-build the parts of TCP wanted for games (optional reliability and packet order), while avoiding the unwanted parts (congestion/traffic control features, Nagle's algorithm, etc). Due to this, most game engines come with such an implementation, and Godot is no exception.

In summary, you can use the low-level networking API for maximum control and implement everything on top of bare network protocols or use the high-level API based on SceneTree that does most of the heavy lifting behind the scenes in a generally optimized way.

Most of Godot's supported platforms offer all or most of the mentioned high- and low-level networking features. As networking is always largely hardware and operating system dependent, however, some features may change or not be available on some target platforms. Most notably, the HTML5 platform currently offers WebSockets and WebRTC support but lacks some of the higher-level features, as well as raw access to low-level protocols like TCP and UDP.

More about TCP/IP, UDP, and networking: https://gafferongames.com/post/udp_vs_tcp/

Gaffer On Games has a lot of useful articles about networking in Games (here), including the comprehensive introduction to networking models in games.

Adding networking to your game comes with some responsibility. It can make your application vulnerable if done wrong and may lead to cheats or exploits. It may even allow an attacker to compromise the machines your application runs on and use your servers to send spam, attack others or steal your users' data if they play your game.

This is always the case when networking is involved and has nothing to do with Godot. You can of course experiment, but when you release a networked application, always take care of any possible security concerns.

Before going into how we would like to synchronize a game across the network, it can be helpful to understand how the base network API for synchronization works.

Godot uses a mid-level object MultiplayerPeer. This object is not meant to be created directly, but is designed so that several C++ implementations can provide it.

This object extends from PacketPeer, so it inherits all the useful methods for serializing, sending and receiving data. On top of that, it adds methods to set a peer, transfer mode, etc. It also includes signals that will let you know when peers connect or disconnect.

This class interface can abstract most types of network layers, topologies and libraries. By default, Godot provides an implementation based on ENet (ENetMultiplayerPeer), one based on WebRTC (WebRTCMultiplayerPeer), and one based on WebSocket (WebSocketPeer), but this could be used to implement mobile APIs (for ad hoc WiFi, Bluetooth) or custom device/console-specific networking APIs.

For most common cases, using this object directly is discouraged, as Godot provides even higher level networking facilities. This object is still made available in case a game has specific needs for a lower-level API.

When hosting a server, clients on your LAN can connect using the internal IP address which is usually of the form 192.168.*.*. This internal IP address is not reachable by non-LAN/Internet clients.

On Windows, you can find your internal IP address by opening a command prompt and entering ipconfig. On macOS, open a Terminal and enter ifconfig. On Linux, open a terminal and enter ip addr.

If you're hosting a server on your own machine and want non-LAN clients to connect to it, you'll probably have to forward the server port on your router. This is required to make your server reachable from the Internet since most residential connections use a NAT. Godot's high-level multiplayer API only uses UDP, so you must forward the port in UDP, not just TCP.

After forwarding a UDP port and making sure your server uses that port, you can use this website to find your public IP address. Then give this public IP address to any Internet clients that wish to connect to your server.

Godot's high-level multiplayer API uses a modified version of ENet which allows for full IPv6 support.

High-level networking in Godot is managed by the SceneTree.

Each node has a multiplayer property, which is a reference to the MultiplayerAPI instance configured for it by the scene tree. Initially, every node is configured with the same default MultiplayerAPI object.

It is possible to create a new MultiplayerAPI object and assign it to a NodePath in the scene tree, which will override multiplayer for the node at that path and all of its descendants. This allows sibling nodes to be configured with different peers, which makes it possible to run a server and a client simultaneously in one instance of Godot.

To initialize networking, a MultiplayerPeer object must be created, initialized as a server or client, and passed to the MultiplayerAPI.

To terminate networking:

When exporting to Android, make sure to enable the INTERNET permission in the Android export preset before exporting the project or using one-click deploy. Otherwise, network communication of any kind will be blocked by Android.

Every peer is assigned a unique ID. The server's ID is always 1, and clients are assigned a random positive integer.

Responding to connections or disconnections is possible by connecting to MultiplayerAPI's signals:

peer_connected(id: int) This signal is emitted with the newly connected peer's ID on each other peer, and on the new peer multiple times, once with each other peer's ID.

peer_disconnected(id: int) This signal is emitted on every remaining peer when one disconnects.

The rest are only emitted on clients:

connected_to_server()

server_disconnected()

To get the unique ID of the associated peer:

To check whether the peer is server or client:

Remote procedure calls, or RPCs, are functions that can be called on other peers. To create one, use the @rpc annotation before a function definition. To call an RPC, use Callable's method rpc() to call in every peer, or rpc_id() to call in a specific peer.

RPCs will not serialize objects or callables.

For a remote call to be successful, the sending and receiving node need to have the same NodePath, which means they must have the same name. When using add_child() for nodes which are expected to use RPCs, set the argument force_readable_name to true.

If a function is annotated with @rpc on the client script (resp. server script), then this function must also be declared on the server script (resp. client script). Both RPCs must have the same signature which is evaluated with a checksum of all RPCs. All RPCs in a script are checked at once, and all RPCs must be declared on both the client scripts and the server scripts, even functions that are currently not in use.

The signature of the RPC includes the @rpc() declaration, the function, return type, and the NodePath. If an RPC resides in a script attached to /root/Main/Node1, then it must reside in precisely the same path and node on both the client script and the server script. Function arguments are not checked for matching between the server and client code (example: func sendstuff(): and func sendstuff(arg1, arg2): will pass signature matching).

If these conditions are not met (if all RPCs do not pass signature matching), the script may print an error or cause unwanted behavior. The error message may be unrelated to the RPC function you are currently building and testing.

See further explanation and troubleshooting on this post.

The annotation can take a number of arguments, which have default values. @rpc is equivalent to:

The parameters and their functions are as follows:

"authority": Only the multiplayer authority can call remotely. The authority is the server by default, but can be changed per-node using Node.set_multiplayer_authority.

"any_peer": Clients are allowed to call remotely. Useful for transferring user input.

"call_remote": The function will not be called on the local peer.

"call_local": The function can be called on the local peer. Useful when the server is also a player.

"unreliable" Packets are not acknowledged, can be lost, and can arrive at any order.

"unreliable_ordered" Packets are received in the order they were sent in. This is achieved by ignoring packets that arrive later if another that was sent after them has already been received. Can cause packet loss if used incorrectly.

"reliable" Resend attempts are sent until packets are acknowledged, and their order is preserved. Has a significant performance penalty.

transfer_channel is the channel index.

The first 3 can be passed in any order, but transfer_channel must always be last.

The function multiplayer.get_remote_sender_id() can be used to get the unique id of an rpc sender, when used within the function called by rpc.

Modern networking protocols support channels, which are separate connections within the connection. This allows for multiple streams of packets that do not interfere with each other.

For example, game chat related messages and some of the core gameplay messages should all be sent reliably, but a gameplay message should not wait for a chat message to be acknowledged. This can be achieved by using different channels.

Channels are also useful when used with the unreliable ordered transfer mode. Sending packets of variable size with this transfer mode can cause packet loss, since packets which are slower to arrive are ignored. Separating them into multiple streams of homogeneous packets by using channels allows ordered transfer with little packet loss, and without the latency penalty caused by reliable mode.

The default channel with index 0 is actually three different channels - one for each transfer mode.

This is an example lobby that can handle peers joining and leaving, notify UI scenes through signals, and start the game after all clients have loaded the game scene.

The game scene's root node should be named Game. In the script attached to it:

Once you've made a multiplayer game, you may want to export it to run it on a dedicated server with no GPU available. See Exporting for dedicated servers for more information.

The code samples on this page aren't designed to run on a dedicated server. You'll have to modify them so the server isn't considered to be a player. You'll also have to modify the game starting mechanism so that the first player who joins can start the game.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
# By default, these expressions are interchangeable.
multiplayer # Get the MultiplayerAPI object configured for this node.
get_tree().get_multiplayer() # Get the default MultiplayerAPI object.
```

Example 2 (unknown):
```unknown
// By default, these expressions are interchangeable.
Multiplayer; // Get the MultiplayerAPI object configured for this node.
GetTree().GetMultiplayer(); // Get the default MultiplayerAPI object.
```

Example 3 (unknown):
```unknown
# Create client.
var peer = ENetMultiplayerPeer.new()
peer.create_client(IP_ADDRESS, PORT)
multiplayer.multiplayer_peer = peer

# Create server.
var peer = ENetMultiplayerPeer.new()
peer.create_server(PORT, MAX_CLIENTS)
multiplayer.multiplayer_peer = peer
```

Example 4 (unknown):
```unknown
// Create client.
var peer = new ENetMultiplayerPeer();
peer.CreateClient(IPAddress, Port);
Multiplayer.MultiplayerPeer = peer;

// Create server.
var peer = new ENetMultiplayerPeer();
peer.CreateServer(Port, MaxClients);
Multiplayer.MultiplayerPeer = peer;
```

---

## Importing audio samples — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/assets_pipeline/importing_audio_samples.html

**Contents:**
- Importing audio samples
- Supported audio formats
- Importing audio samples
- Import options (WAV)
- Force > 8 Bit
- Force > Mono
- Force > Max Rate
- Edit > Trim
- Edit > Normalize
- Edit > Loop Mode

Godot provides 3 options to import your audio data: WAV, Ogg Vorbis and MP3.

Each format has different advantages:

WAV files use raw data or light compression (IMA ADPCM or Quite OK Audio). Currently they can only be imported in raw format, but Godot allows compression after import. They are lightweight to play back on the CPU (hundreds of simultaneous voices in this format are fine). The downside is that they take up a lot of disk space.

Ogg Vorbis files use a stronger compression that results in much smaller file size, but require significantly more processing power to play back.

MP3 files use better compression than WAV with IMA ADPCM or Quite OK Audio, but worse than Ogg Vorbis. This means that an MP3 file with roughly equal quality to Ogg Vorbis will be significantly larger. On the bright side, MP3 requires less CPU usage to play back compared to Ogg Vorbis.

If you've compiled the Godot editor from source with specific modules disabled, some formats may not be available.

Here is a comparative chart representing the file size of 1 second of audio with each format:

WAV 24-bit, 96 kHz, stereo

WAV 16-bit, 44 kHz, mono

WAV IMA ADPCM, 44 kHz, mono

Quite OK Audio, 44 kHz, mono

Ogg Vorbis 128 Kb/s, stereo

Ogg Vorbis 96 Kb/s, stereo

Note that the MP3 and Ogg Vorbis figures can vary depending on the encoding type. The above figures use CBR encoding for simplicity, but most Ogg Vorbis and MP3 files you can find online are encoded with VBR encoding which is more efficient. VBR encoding makes the effective audio file size depend on how "complex" the source audio is.

Consider using WAV for short and repetitive sound effects, and Ogg Vorbis for music, speech, and long sound effects. MP3 is useful for mobile and web projects where CPU resources are limited, especially when playing multiple compressed sounds at the same time (such as long ambient sounds).

Several options are available in the Import dock after selecting a WAV file in the FileSystem dock:

Import options in the Import dock after selecting a WAV file in the FileSystem dock

The set of options available after selecting an Ogg Vorbis or MP3 file is different:

Import options in the Import dock after selecting an MP3 file in the FileSystem dock. Options are identical for Ogg Vorbis files.

After importing a sound, you can play it back using the AudioStreamPlayer, AudioStreamPlayer2D or AudioStreamPlayer3D nodes. See Audio streams for more information.

If enabled, forces the imported audio to use 8-bit quantization if the source file is 16-bit or higher.

Enabling this is generally not recommended, as 8-bit quantization decreases audio quality significantly. If you need smaller file sizes, consider using Ogg Vorbis or MP3 audio instead.

If enabled, forces the imported audio to be mono if the source file is stereo. This decreases the file size by 50% by merging the two channels into one.

If set to a value greater than 0, forces the audio's sample rate to be reduced to a value lower than or equal to the value specified here.

This can decrease file size noticeably on certain sounds, without impacting quality depending on the actual sound's contents. See Best practices for more information.

The source audio file may contain long silences at the beginning and/or the end. These silences are inserted by DAWs when saving to a waveform, which increases their size unnecessarily and add latency to the moment they are played back.

Enabling Trim will automatically trim the beginning and end of the audio if it's lower than -50 dB after normalization (see Edit > Normalize below). A fade-in/fade-out period of 500 samples is also used during trimming to avoid audible pops.

If enabled, audio volume will be normalized so that its peak volume is equal to 0 dB. When enabled, normalization will make audio sound louder depending on its original peak volume.

Unlike Ogg Vorbis and MP3, WAV files can contain metadata to indicate whether they're looping (in addition to loop points). By default, Godot will follow this metadata, but you can choose to apply a specific loop mode:

Detect from WAV: Uses loop information from the WAV metadata.

Disabled: Don't loop audio, even if metadata indicates the file should be played back looping.

Forward: Standard audio looping. Plays the audio forward from the beginning to the loop end, then returns to the loop beginning and repeats.

Ping-Pong: Plays the audio forward until the loop end, then backwards to the loop beginning, repeating this cycle.

Backward: Plays the audio backwards from the loop end to the loop beginning, then repeats.

When choosing one of the Forward, Ping-Pong or Backward loop modes, loop points can also be defined to make only a specific part of the sound loop. Loop Begin is set in samples after the beginning of the audio file. Loop End is also set in samples after the beginning of the audio file, but will use the end of the audio file if set to -1.

In AudioStreamPlayer, the finished signal won't be emitted for looping audio when it reaches the end of the audio file, as the audio will keep playing indefinitely.

Three compression modes can be chosen from for WAV files: PCM (Uncompressed), IMA ADPCM, or Quite OK Audio (default). IMA ADPCM reduces file size and memory usage a little, at the cost of decreasing quality in an audible manner. Quite OK Audio reduces file size a bit more than IMA ADPCM and the quality decrease is much less noticeable, at the cost of slightly higher CPU usage (still much lower than MP3).

Ogg Vorbis and MP3 don't decrease quality as much and can provide greater file size reductions, at the cost of higher CPU usage during playback. This higher CPU usage is usually not a problem (especially with MP3), unless playing dozens of compressed sounds at the same time on mobile/web platforms.

If enabled, the audio will begin playing at the beginning after playback ends by reaching the end of the audio.

In AudioStreamPlayer, the finished signal won't be emitted for looping audio when it reaches the end of the audio file, as the audio will keep playing indefinitely.

The loop offset determines where audio will start to loop after playback reaches the end of the audio. This can be used to only loop a part of the audio file, which is useful for some ambient sounds or music. The value is determined in seconds relative to the beginning of the audio, so 0 will loop the entire audio file.

Only has an effect if Loop is enabled.

A more convenient editor for Loop Offset is provided in the Advanced import settings dialog, as it lets you preview your changes without having to reimport the audio.

The Beats Per Minute of the audio track. This should match the BPM measure that was used to compose the track. This is only relevant for music that wishes to make use of interactive music functionality, not sound effects.

A more convenient editor for BPM is provided in the Advanced import settings dialog, as it lets you preview your changes without having to reimport the audio.

The beat count of the audio track. This is only relevant for music that wishes to make use of interactive music functionality, not sound effects.

A more convenient editor for Beat Count is provided in the Advanced import settings dialog, as it lets you preview your changes without having to reimport the audio.

The number of bars within a single beat in the audio track. This is only relevant for music that wishes to make use of interactive music functionality , not sound effects.

A more convenient editor for Bar Beats is provided in the Advanced import settings dialog, as it lets you preview your changes without having to reimport the audio.

If you double-click an Ogg Vorbis or MP3 file in the FileSystem dock (or choose Advanced… in the Import dock), you will see a dialog appear:

Advanced dialog when double-clicking an Ogg Vorbis or MP3 file in the FileSystem dock

This dialog allows you to edit the audio's loop point with a real-time preview, in addition to the BPM, beat count and bar beats. These 3 settings are currently unused, but they will be used in the future for interactive music support (which allows smoothly transitioning between different music tracks).

Unlike WAV files, Ogg Vorbis and MP3 only support a "loop begin" loop point, not a "loop end" point. Looping can also be only be standard forward looping, not ping-pong or backward.

While keeping pristine-quality audio sources is important if you're performing editing, using the same quality in the exported project is not necessary. For WAV files, Godot offers several import options to reduce the final file size without modifying the source file on disk.

To reduce memory usage and file size, choose an appropriate quantization, sample rate and number of channels for your audio:

There's no audible benefit to using 24-bit audio, especially in a game where several sounds are often playing at the same time (which makes it harder to appreciate individual sounds).

Unless you are slowing down the audio at runtime, there's no audible benefit to using a sample rate greater than 48 kHz. If you wish to keep a source with a higher sample rate for editing, use the Force > Max Rate import option to limit the sample rate of the imported sound (only available for WAV files).

Many sound effects can generally be converted to mono as opposed to stereo. If you wish to keep a source with stereo for editing, use the Force > Mono import option to convert the imported sound to mono (only available for WAV files).

Voices can generally be converted to mono, but can also have their sample rate reduced to 22 kHz without a noticeable loss in quality (unless the voice is very high-pitched). This is because most human voices never go past 11 kHz.

Godot has an extensive bus system with built-in effects. This saves SFX artists the need to add reverb to the sound effects, reducing their size greatly and ensuring correct trimming.

As you can see above, sound effects become much larger in file size with reverb added.

Audio samples can be loaded and saved at runtime using runtime file loading and saving, including from an exported project.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Importing images — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/assets_pipeline/importing_images.html

**Contents:**
- Importing images
- Supported image formats
- Importing textures
  - Changing import type
  - Detect 3D
- Import options
  - Compress > Mode
  - Compress > High Quality
  - Compress > HDR Compression
  - Compress > Normal Map

Godot can import the following image formats:

BMP (.bmp) - No support for 16-bit per pixel images. Only 1-bit, 4-bit, 8-bit, 24-bit, and 32-bit per pixel images are supported.

DirectDraw Surface (.dds) - If mipmaps are present in the texture, they will be loaded directly. This can be used to achieve effects using custom mipmaps.

Khronos Texture (.ktx) - Decoding is done using libktx. Only supports 2D images. Cubemaps, texture arrays and de-padding are not supported.

OpenEXR (.exr) - Supports HDR (highly recommended for panorama skies).

Radiance HDR (.hdr) - Supports HDR (highly recommended for panorama skies).

JPEG (.jpg, .jpeg) - Doesn't support transparency per the format's limitations.

PNG (.png) - Precision is limited to 8 bits per channel upon importing (no HDR images).

Truevision Targa (.tga)

SVG (.svg) - SVGs are rasterized using ThorVG when importing them. Support is limited; complex vectors may not render correctly. Text must be converted to paths; otherwise, it won't appear in the rasterized image. You can check whether ThorVG can render a certain vector correctly using its web-based viewer. For complex vectors, rendering them to PNGs using Inkscape is often a better solution. This can be automated thanks to its command-line interface.

WebP (.webp) - WebP files support transparency and can be compressed lossily or losslessly. The precision is limited to 8 bits per channel.

If you've compiled the Godot editor from source with specific modules disabled, some formats may not be available.

The default action in Godot is to import images as textures. Textures are stored in video memory. Their pixel data can't be accessed directly from the CPU without converting them back to an Image in a script. This is what makes drawing them efficient.

There are over a dozen import options that can be adjusted after selecting an image in the FileSystem dock:

Import options in the Import dock after selecting an image in the FileSystem dock. Some of these options are only visible with certain compression modes.

It is possible to choose other types of imported resources in the Import dock:

BitMap: 1-bit monochrome texture (intended to be used as a click mask in TextureButton and TouchScreenButton). This resource type cannot be displayed directly onto 2D or 3D nodes, but the pixel values can be queried from a script using get_bit.

Cubemap: Import the texture as a 6-sided cubemap, with interpolation between the cubemap's sides (seamless cubemaps), which can be sampled in custom shaders.

CubemapArray: Import the texture as a collection of 6-sided cubemaps, which can be sampled in custom shaders. This resource type can only be displayed when using the Forward+ or Mobile renderers, not the Compatibility renderer.

Font Data (Monospace Image Font): Import the image as a bitmap font where all characters have the same width. See Using Fonts.

Image: Import the image as-is. This resource type cannot be displayed directly onto 2D or 3D nodes, but the pixel values can be queried from a script using get_pixel.

Texture2D: Import the image as a 2-dimensional texture, suited for display on 2D and 3D surfaces. This is the default import mode.

Texture2DArray: Import the image as a collection of 2-dimensional textures. Texture2DArray is similar to a 3-dimensional texture, but without interpolation between layers. Built-in 2D and 3D shaders cannot display texture arrays, so you must create a custom shader in 2D or 3D to display a texture from a texture array.

Texture3D: Import the image as a 3-dimensional texture. This is not a 2D texture applied onto a 3D surface. Texture3D is similar to a texture array, but with interpolation between layers. Texture3D is typically used for FogMaterial density maps in volumetric fog, particle attractor vector fields, Environment 3D LUT color correction, and custom shaders.

TextureAtlas: Import the image as an atlas of different textures. Can be used to reduce memory usage for animated 2D sprites. Only supported in 2D due to missing support in built-in 3D shaders.

For Cubemap, the expected image order is X+, X-, Y+, Y-, Z+, Z- (in Godot's coordinate system, so Y+ is "up" and Z- is "forward"). Here are templates you can use for cubemap images (right-click > Save Link As…):

2×3 cubemap template (default layout option)

The default import options (no mipmaps and Lossless compression) are suited for 2D, but are not ideal for most 3D projects. Detect 3D makes Godot aware of when a texture is used in a 3D scene (such as a texture in a BaseMaterial3D). If this happens, several import options are changed so the texture flags are friendlier to 3D. Mipmaps are enabled and the compression mode is changed to VRAM Compressed unless Detect 3D > Compress To is changed. The texture is also reimported automatically.

A message is printed to the Output panel when a texture is detected to be used in 3D.

If you run into quality issues when a texture is detected to be used in 3D (e.g. for pixel art textures), change the Detect 3D > Compress To option before using the texture in 3D, or change Compress > Mode to Lossless after using the texture in 3D. This is preferable to disabling Detect 3D, as mipmap generation remains enabled to prevent textures from looking grainy at a distance.

In Godot 4.0, changing the texture filter and repeat mode is no longer done in the import options.

Instead, texture filter and repeat modes are changed in the CanvasItem properties in 2D (with a project setting acting as a default), and in a per-material configuration in 3D. In custom shaders, filter and repeat mode is changed on the sampler2D uniform using hints described in the Shading language documentation.

Images are one of the largest assets in a game. To handle them efficiently, they need to be compressed. Godot offers several compression methods, depending on the use case.

Lossless: This is the default and most common compression mode for 2D assets. It shows assets without any kind of artifacting, and disk compression is decent. It will use considerably more amount of video memory than VRAM Compression, though. This is also the recommended setting for pixel art.

Lossy: This is a good choice for large 2D assets. It has some artifacts, but less than VRAM compression and the file size is several times lower compared to Lossless or VRAM Uncompressed. Video memory usage isn't decreased by this mode; it's the same as with Lossless or VRAM Uncompressed.

VRAM Compressed: This is the default and most common compression mode for 3D assets. Size on disk is reduced and video memory usage is also decreased considerably (usually by a factor between 4 and 6). This mode should be avoided for 2D as it exhibits noticeable artifacts, especially for lower-resolution textures.

VRAM Uncompressed: Only useful for formats that can't be compressed, such as raw floating-point images.

Basis Universal: This alternative VRAM compression mode encodes the texture to a format that can be transcoded to most GPU-compressed formats at load-time. This provides very small files that make use of VRAM compression, at the cost of lower quality compared to VRAM Compressed and slow compression times. VRAM usage is usually the same as VRAM Compressed. Basis Universal does not support floating-point image formats (the engine will internally fall back to VRAM Compressed instead).

Even in 3D, "pixel art" textures should have VRAM compression disabled as it will negatively affect their appearance, without improving performance significantly due to their low resolution.

In this table, each of the 5 options are described together with their advantages and disadvantages ( = best, = worst):

Stored as Lossless WebP / PNG

Stored as S3TC, BPTC or ETC2 depending on platform

Transcoded to VRAM Compressed format

Estimated memory usage for a single RGBA8 texture with mipmaps enabled:

In the above table, memory usage will be reduced by 25% for images that do not have an alpha channel (RGB8). Memory usage will be further decreased by 25% for images that have mipmaps disabled.

Notice how at larger resolutions, the impact of VRAM compression is much greater. With a 4:1 compression ratio (6:1 for opaque textures with S3TC), VRAM compression effectively allows a texture to be twice as large on each axis, while using the same amount of memory on the GPU.

VRAM compression also reduces the memory bandwidth required to sample the texture, which can speed up rendering in memory bandwidth-constrained scenarios (which are frequent on integrated graphics and mobile). These factors combined make VRAM compression a must-have for 3D games with high-resolution textures.

You can preview how much memory a texture takes by double-clicking it in the FileSystem dock, then looking at the Inspector:

Previewing a texture in the Inspector. Credit: Red Brick 03 - Poly Haven

High-quality VRAM texture compression is only supported in the Forward+ and Mobile renderers.

When using the Compatibility renderer, this option is always considered disabled.

If enabled, uses BPTC compression on desktop platforms and ASTC compression on mobile platforms. When using BPTC, BC7 is used for SDR textures and BC6H is used for HDR textures.

If disabled (default), uses the faster but lower-quality S3TC compression on desktop platforms and ETC2 on mobile/web platforms. When using S3TC, DXT1 (BC1) is used for opaque textures and DXT5 (BC3) is used for transparent or normal map (RGTC) textures.

BPTC and ASTC support VRAM compression for HDR textures, but S3TC and ETC2 do not (see HDR Compression below).

This option only has an effect on textures that are imported as HDR formats in Godot (.hdr and .exr files).

If set to Disabled, never uses VRAM compression for HDR textures, regardless of whether they're opaque or transparent. Instead, the texture is converted to RGBE9995 (9-bits per channel + 5-bit exponent = 32 bits per pixel) to reduce memory usage compared to a half-float or single-precision float image format.

If set to Opaque Only (default), only uses VRAM compression for opaque HDR textures. This is due to a limitation of HDR formats, as there is no VRAM-compressed HDR format that supports transparency at the same time.

If set to Always, will force VRAM compression even for HDR textures with an alpha channel. To perform this, the alpha channel is discarded on import.

When using a texture as normal map, only the red and green channels are required. Given regular texture compression algorithms produce artifacts that don't look that nice in normal maps, the RGTC compression format is the best fit for this data. Forcing this option to Enable will make Godot import the image as RGTC compressed. By default, it's set to Detect. This means that if the texture is ever detected to be used as a normal map, it will be changed to Enable and reimported automatically.

Note that RGTC compression affects the resulting normal map image. You will have to adjust custom shaders that use the normal map's blue channel to take this into account. Built-in material shaders already ignore the blue channel in a normal map (regardless of the actual normal map's contents).

In the example below, the normal map with RGTC compression is able to preserve its detail much better, while using the same amount of memory as a standard RGBA VRAM-compressed texture:

Normal map with standard VRAM compression (left) and with RGTC VRAM compression (right)

Godot requires the normal map to use the X+, Y+ and Z+ coordinates, which is known as an OpenGL-style normal map. If you've imported a material made to be used with another engine, it may be DirectX-style. In this case, the normal map needs to be converted by enabling the Normal Map Invert Y import option.

More information about normal maps (including a coordinate order table for popular engines) can be found here.

If set to sRGB Friendly (default), prevents the RG color format from being used as it does not support sRGB color.

If set to Optimized, allows the RG color format to be used if the texture does not use the blue channel.

A third option Normal Map (RG Channels) is only available in layered textures (Cubemap, CubemapArray, Texture2DArray and Texture3D). This forces all layers from the texture to be imported with the RG color format, with only the red and green channels preserved. RGTC compression is able to preserve its detail much better, while using the same amount of memory as a standard RGBA VRAM-compressed texture. This only has an effect on textures with the VRAM Compressed or Basis Universal compression modes.

If enabled, smaller versions of the texture are generated on import. For example, a 64×64 texture will generate 6 mipmaps (32×32, 16×16, 8×8, 4×4, 2×2, 1×1). This has several benefits:

Textures will not become grainy in the distance (in 3D), or if scaled down due to camera zoom or CanvasItem scale (in 2D).

Performance will improve if the texture is displayed in the distance, since sampling smaller versions of the original texture is faster and requires less memory bandwidth.

The downside of mipmaps is that they increase memory usage by roughly 33%.

It's recommended to enable mipmaps in 3D. However, in 2D, this should only be enabled if your project visibly benefits from having mipmaps enabled. If the camera never zooms out significantly, there won't be a benefit to enabling mipmaps but memory usage will increase.

Mipmaps > Limit is currently not implemented and has no effect when changed.

If set to a value greater than -1, limits the maximum number of mipmaps that can be generated. This can be decreased if you don't want textures to become too low-resolution at extreme distances, at the cost of some graininess.

The color channel to consider as a roughness map in this texture. Only effective if Roughness > Src Normal is not empty.

The path to the texture to consider as a normal map for roughness filtering on import. Specifying this can help decrease specular aliasing slightly in 3D.

Roughness filtering on import is only used in 3D rendering, not 2D.

This puts pixels of the same surrounding color in transition from transparent to opaque areas. For textures displayed with bilinear filtering, this helps mitigate the outline effect when exporting images from an image editor.

It's recommended to leave this enabled (as it is by default), unless this causes issues for a particular image.

An alternative to fixing darkened borders with Fix Alpha Border is to use premultiplied alpha. By enabling this option, the texture will be converted to this format. A premultiplied alpha texture requires specific materials to be displayed correctly:

In 2D, a CanvasItemMaterial will need to be created and configured to use the Premul Alpha blend mode on CanvasItems that use this texture. In custom canvas item shaders, render_mode blend_premul_alpha; should be used.

In 3D, a BaseMaterial3D will need to be created and configured to use the Premul Alpha blend mode on materials that use this texture. In custom spatial shaders, render_mode blend_premul_alpha; should be used.

Godot requires the normal map to use the X+, Y+ and Z+ coordinates, which is known as an OpenGL-style normal map. If you've imported a material made to be used with another engine, it may be DirectX-style. In this case, the normal map needs to be converted by enabling the Normal Map Invert Y import option.

More information about normal maps (including a coordinate order table for popular engines) can be found here.

Some HDR images you can find online may be broken and contain sRGB color data (instead of linear color data). It is advised not to use those files. If you absolutely have to, enabling this option on will make them look correct.

Enabling HDR as sRGB on well-formatted HDR images will cause the resulting image to look too dark, so leave this disabled if unsure.

Some HDR panorama images you can find online may contain extremely bright pixels, due to being taken from real life sources without any clipping.

While these HDR panorama images are accurate to real life, this can cause the radiance map generated by Godot to contain sparkles when used as a background sky. This can be seen in material reflections (even on rough materials in extreme cases). Enabling HDR Clamp Exposure can resolve this using a smart clamping formula that does not introduce visible clipping – glow will keep working when looking at the background sky.

If set to a value greater than 0, the size of the texture is limited on import to a value smaller than or equal to the value specified here. For non-square textures, the size limit affects the longer dimension, with the shorter dimension scaled to preserve aspect ratio. Resizing is performed using cubic interpolation.

This can be used to reduce memory usage without affecting the source images, or avoid issues with textures not displaying on mobile/web platforms (as these usually can't display textures larger than 4096×4096).

This changes the Compress > Mode option that is used when a texture is detected as being used in 3D.

Changing this import option only has an effect if a texture is detected as being used in 3D. Changing this to Disabled then reimporting will not change the existing compress mode on a texture (if it's detected to be used in 3D), but choosing VRAM Compressed or Basis Universal will.

This is only available for SVG images.

The scale the SVG should be rendered at, with 1.0 being the original design size. Higher values result in a larger image. Note that unlike font oversampling, this affects the physical size the SVG is rendered at in 2D. See also Editor > Scale With Editor Scale below.

This is only available for SVG images.

If true, scales the imported image to match the editor's display scale factor. This should be enabled for editor plugin icons and custom class icons, but should be left disabled otherwise.

This is only available for SVG images.

If checked, converts the imported image's colors to match the editor's icon and font color palette. This assumes the image uses the exact same colors as Godot's own color palette for editor icons, with the source file designed for a dark editor theme. This should be enabled for editor plugin icons and custom class icons, but should be left disabled otherwise.

As the SVG library used in Godot doesn't support rasterizing text found in SVG images, text must be converted to a path first. Otherwise, text won't appear in the rasterized image.

There are two ways to achieve this in a non-destructive manner, so you can keep editing the original text afterwards:

Select your text object in Inkscape, then duplicate it in place by pressing Ctrl + D and use Path > Object to Path. Hide the original text object afterwards using the Layers and Objects dock.

Use the Inkscape command line to export an SVG from another SVG file with text converted to paths:

To support multiple resolutions with crisp visuals at high resolutions, you will need to use high-resolution source images (suited for the highest resolution you wish to support without blurriness, which is typically 4K in modern desktop games).

There are 2 ways to proceed:

Use a high base resolution in the project settings (such as 4K), then use the textures at original scale. This is an easier approach.

Use a low base resolution in the project settings (such as 1080p), then downscale textures when using them. This is often more difficult and can make various calculations in script tedious, so the approach described above is recommended instead.

After doing this, you may notice that textures become grainy at lower viewport resolutions. To resolve this, enable Mipmaps on textures used in 2D in the Import dock. This will increase memory usage.

Enabling mipmaps can also make textures appear blurrier, but you can choose to make textures sharper (at the cost of some graininess) by setting Rendering > Textures > Default Filters > Texture Mipmap Bias to a negative value.

While there's no "one size fits all" recommendation, here are some general recommendations for choosing texture sizes in 3D:

The size of a texture should be adjusted to have a consistent texel density compared to surrounding objects. While this cannot be ensured perfectly when sticking to power-of-two texture sizes, it's usually possible to keep texture detail fairly consistent throughout a 3D scene.

The smaller the object appears on screen, the smaller its texture should be. For example, a tree that only appears in the background doesn't need a texture resolution as high as other objects the player may be able to walk close to.

Using power-of-two texture sizes is recommended, but is not required. Textures don't have to be square – sizes such as 1024×512 are acceptable.

There are diminishing returns to using large texture sizes, despite the increased memory usage and loading times. Most modern 3D games not using a pixel art style stick to 2048×2048 textures on average, with 1024×1024 and 512×512 for textures spanning smaller surfaces.

When working with physically-based materials in 3D, you can reduce memory usage and file size without affecting quality too much by using a lower resolution for certain texture maps. This works especially well for textures that only feature low-frequency detail (such as a normal map for a snow texture).

If you have control over how the 3D models are created, these tips are also worth exploring:

When working with 3D models that are mostly symmetrical, you may be able to use mirrored UVs to double the effective texel density. This may look unnatural when used on human faces though.

When working with 3D models using a low-poly style and plain colors, you can rely on vertex colors instead of textures to represent colors on the model's surfaces.

Images can be loaded and saved at runtime using runtime file loading and saving, including from an exported project.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
inkscape --export-text-to-path --export-filename svg_with_text_converted_to_path.svg svg_with_text.svg
```

---

## Importing translations — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/assets_pipeline/importing_translations.html

**Contents:**
- Importing translations
- Games and internationalization
- Supported formats
- User-contributed notes

The gaming community isn't monolingual or monocultural. It's made up of many different languages and cultures - just like the Godot community! If you want to allow players to experience your game in their language, one of things you'll need to provide is text translations, which Godot supports via internationalized text.

In regular desktop or mobile applications, internationalized text is usually located in resource files (or .po files for GNU stuff). Games, however, can use several orders of magnitude more text than applications, so they must support efficient methods for dealing with loads of multilingual text.

There are two approaches to generate multilingual language games and applications. Both are based on a key:value system. The first is to use one of the languages as the key (usually English), the second is to use a specific identifier. The first approach is probably easier for development if a game is released first in English, later in other languages, but a complete nightmare if working with many languages at the same time.

In general, games use the second approach and a unique ID is used for each string. This allows you to revise the text while it is being translated to other languages. The unique ID can be a number, a string, or a string with a number (it's just a unique string anyway).

To complete the picture and allow efficient support for translations, Godot has a special importer that can read CSV files. Most spreadsheet editors can export to this format, so the only requirement is that the files have a special arrangement. See Localization using spreadsheets for detailed info on formatting and importing CSVs.

If you need a more powerful file format, Godot also supports loading translations written in the gettext .po format. See Localization using gettext (PO files) for details.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Import plugins — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/plugins/editor/import_plugins.html

**Contents:**
- Import plugins
- Introduction
- Configuration
- The EditorImportPlugin class
- Options and presets
- The import method
- Platform variants and generated files
- Trying the plugin
- User-contributed notes

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

This tutorial assumes you already know how to make generic plugins. If in doubt, refer to the Making plugins page. This also assumes you are acquainted with Godot's import system.

An import plugin is a special type of editor tool that allows custom resources to be imported by Godot and be treated as first-class resources. The editor itself comes bundled with a lot of import plugins to handle the common resources like PNG images, Collada and glTF models, Ogg Vorbis sounds, and many more.

This tutorial shows how to create an import plugin to load a custom text file as a material resource. This text file will contain three numeric values separated by comma, which represents the three channels of a color, and the resulting color will be used as the albedo (main color) of the imported material. In this example it contains the pure blue color (zero red, zero green, and full blue):

First we need a generic plugin that will handle the initialization and destruction of our import plugin. Let's add the plugin.cfg file first:

Then we need the material_import.gd file to add and remove the import plugin when needed:

When this plugin is activated, it will create a new instance of the import plugin (which we'll soon make) and add it to the editor using the add_import_plugin() method. We store a reference to it in a class member import_plugin so we can refer to it later when removing it. The remove_import_plugin() method is called when the plugin is deactivated to clean up the memory and let the editor know the import plugin isn't available anymore.

Note that the import plugin is a reference type, so it doesn't need to be explicitly released from memory with the free() function. It will be released automatically by the engine when it goes out of scope.

The main character of the show is the EditorImportPlugin class. It is responsible for implementing the methods that are called by Godot when it needs to know how to deal with files.

Let's begin to code our plugin, one method at time:

The first method is the _get_importer_name(). This is a unique name for your plugin that is used by Godot to know which import was used in a certain file. When the files needs to be reimported, the editor will know which plugin to call.

The _get_visible_name() method is responsible for returning the name of the type it imports and it will be shown to the user in the Import dock.

You should choose this name as a continuation to "Import as", e.g. "Import as Silly Material". You can name it whatever you want but we recommend a descriptive name for your plugin.

Godot's import system detects file types by their extension. In the _get_recognized_extensions() method you return an array of strings to represent each extension that this plugin can understand. If an extension is recognized by more than one plugin, the user can select which one to use when importing the files.

Common extensions like .json and .txt might be used by many plugins. Also, there could be files in the project that are just data for the game and should not be imported. You have to be careful when importing to validate the data. Never expect the file to be well-formed.

The imported files are saved in the .import folder at the project's root. Their extension should match the type of resource you are importing, but since Godot can't tell what you'll use (because there might be multiple valid extensions for the same resource), you need to declare what will be used in the import.

Since we're importing a Material, we'll use the special extension for such resource types. If you are importing a scene, you can use scn. Generic resources can use the res extension. However, this is not enforced in any way by the engine.

The imported resource has a specific type, so the editor can know which property slot it belongs to. This allows drag and drop from the FileSystem dock to a property in the Inspector.

In our case it's a StandardMaterial3D, which can be applied to 3D objects.

If you need to import different types from the same extension, you have to create multiple import plugins. You can abstract the import code on another file to avoid duplication in this regard.

Your plugin can provide different options to allow the user to control how the resource will be imported. If a set of selected options is common, you can also create different presets to make it easier for the user. The following image shows how the options will appear in the editor:

Since there might be many presets and they are identified with a number, it's a good practice to use an enum so you can refer to them using names.

Now that the enum is defined, let's keep looking at the methods of an import plugin:

The _get_preset_count() method returns the amount of presets that this plugins defines. We only have one preset now, but we can make this method future-proof by returning the size of our Presets enumeration.

Here we have the _get_preset_name() method, which gives names to the presets as they will be presented to the user, so be sure to use short and clear names.

We can use the match statement here to make the code more structured. This way it's easy to add new presets in the future. We use the catch all pattern to return something too. Although Godot won't ask for presets beyond the preset count you defined, it's always better to be on the safe side.

If you have only one preset you could simply return its name directly, but if you do this you have to be careful when you add more presets.

This is the method which defines the available options. _get_import_options() returns an array of dictionaries, and each dictionary contains a few keys that are checked to customize the option as it's shown to the user. The following table shows the possible keys:

The name of the option. When showed, underscores become spaces and first letters are capitalized.

The default value of the option for this preset.

One of the PropertyHint values to use as hint.

The hint text of the property. The same as you'd add in the export statement in GDScript.

One of the PropertyUsageFlags values to define the usage.

The name and default_value keys are mandatory, the rest are optional.

Note that the _get_import_options method receives the preset number, so you can configure the options for each different preset (especially the default value). In this example we use the match statement, but if you have lots of options and the presets only change the value you may want to create the array of options first and then change it based on the preset.

The _get_import_options method is called even if you don't define presets (by making _get_preset_count return zero). You have to return an array even it's empty, otherwise you can get errors.

For the _get_option_visibility() method, we simply return true because all of our options (i.e. the single one we defined) are visible all the time.

If you need to make certain option visible only if another is set with a certain value, you can add the logic in this method.

The heavy part of the process, responsible for converting the files into resources, is covered by the _import() method. Our sample code is a bit long, so let's split in a few parts:

The first part of our import method opens and reads the source file. We use the FileAccess class to do that, passing the source_file parameter which is provided by the editor.

If there's an error when opening the file, we return it to let the editor know that the import wasn't successful.

This code takes the line of the file it read before and splits it in pieces that are separated by a comma. If there are more or less than the three values, it considers the file invalid and reports an error.

Then it creates a new Color variable and sets its values according to the input file. If the use_red_anyway option is enabled, then it sets the color as a pure red instead.

This part makes a new StandardMaterial3D that is the imported resource. We create a new instance of it and then set its albedo color as the value we got before.

This is the last part and quite an important one, because here we save the made resource to the disk. The path of the saved file is generated and informed by the editor via the save_path parameter. Note that this comes without the extension, so we add it using string formatting. For this we call the _get_save_extension method that we defined earlier, so we can be sure that they won't get out of sync.

We also return the result from the ResourceSaver.save() method, so if there's an error in this step, the editor will know about it.

You may have noticed that our plugin ignored two arguments of the import method. Those are return arguments (hence the r at the beginning of their name), which means that the editor will read from them after calling your import method. Both of them are arrays that you can fill with information.

The r_platform_variants argument is used if you need to import the resource differently depending on the target platform. While it's called platform variants, it is based on the presence of feature tags, so even the same platform can have multiple variants depending on the setup.

To import a platform variant, you need to save it with the feature tag before the extension, and then push the tag to the r_platform_variants array so the editor can know that you did.

For example, let's say we save a different material for a mobile platform. We would need to do something like the following:

The r_gen_files argument is meant for extra files that are generated during your import process and need to be kept. The editor will look at it to understand the dependencies and make sure the extra file is not inadvertently deleted.

This is also an array and should be filled with full paths of the files you save. As an example, let's create another material for the next pass and save it in a different file:

This has been theoretical, but now that the import plugin is done, let's test it. Make sure you created the sample file (with the contents described in the introduction section) and save it as test.mtxt. Then activate the plugin in the Project Settings.

If everything goes well, the import plugin is added to the editor and the file system is scanned, making the custom resource appear on the FileSystem dock. If you select it and focus the Import dock, you can see the only option to select there.

Create a MeshInstance3D node in the scene, and for its Mesh property set up a new SphereMesh. Unfold the Material section in the Inspector and then drag the file from the FileSystem dock to the material property. The object will update in the viewport with the blue color of the imported material.

Go to Import dock, enable the "Use Red Anyway" option, and click on "Reimport". This will update the imported material and should automatically update the view showing the red color instead.

And that's it! Your first import plugin is done! Now get creative and make plugins for your own beloved formats. This can be quite useful to write your data in a custom format and then use it in Godot as if they were native resources. This shows how the import system is powerful and extendable.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
[plugin]

name="Silly Material Importer"
description="Imports a 3D Material from an external text file."
author="Yours Truly"
version="1.0"
script="material_import.gd"
```

Example 2 (gdscript):
```gdscript
# material_import.gd
@tool
extends EditorPlugin


var import_plugin


func _enter_tree():
    import_plugin = preload("import_plugin.gd").new()
    add_import_plugin(import_plugin)


func _exit_tree():
    remove_import_plugin(import_plugin)
    import_plugin = null
```

Example 3 (unknown):
```unknown
# import_plugin.gd
@tool
extends EditorImportPlugin


func _get_importer_name():
    return "demos.sillymaterial"
```

Example 4 (unknown):
```unknown
func _get_visible_name():
    return "Silly Material"
```

---

## Import process — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/assets_pipeline/import_process.html

**Contents:**
- Import process
- Importing assets in Godot
- Changing import parameters
- Reimporting multiple assets
- Automatic reimport
- Files generated
- Changing import resource type
- Changing default import parameters
- Further reading
- User-contributed notes

To import assets in Godot, place your assets (image files, scenes, audio files, fonts, etc) directly in the project folder. There are 2 ways to achieve this:

For any file type: Copy files manually with your operating system's file manager.

For file types that can be imported by Godot: Drag-and-drop files from the operating system's file manager to the editor's FileSystem dock. This only works with resource file types (i.e. file types that Godot can import).

Godot will automatically import these files internally and keep the imported resources hidden in a res://.godot/imported/ folder.

This means that when trying to access imported assets through code, you need to use the Resource Loader as it will automatically take into account where the internal files are saved. If you try and access an imported asset using the FileAccess class, it will work in the editor, but it will break in the exported project.

However, the Resource Loader cannot access non-imported files. Only the FileAccess class can.

Import parameters are only present in non-native Godot resource types. This means Godot's own scene and resource file formats (.tscn, .scn, .tres, .res) don't have import options you can select in the Import dock.

To change the import parameters of an asset in Godot, select the relevant resource in the FileSystem dock:

After adjusting the parameters, click Reimport. Be careful: if you select another file in the FileSystem dock before clicking Reimport, changes will be discarded. After clicking Reimport, the chosen parameters will only be used for this asset and on future reimports.

Changing the import parameters of several assets at the same time is also possible. Select all of them together in the FileSystem dock and the exposed parameters will apply to all of them when reimporting.

While working on a project you may find that several assets need to have the same parameters changed, such as enabling mipmaps, but you only want those specific parameters changed. To do this, select every asset you want to reimport in the file system. In the import tab there will now be a checkbox to the left of every import parameter.

Select the checkbox of the parameters you want to change on your imported assets, then change the parameters normally. Finally, click the reimport button and every selected asset will be reimported with only those parameters changed.

When the MD5 checksum of the source asset changes, Godot will perform an automatic reimport of it, applying the preset configured for that specific asset.

Importing will add an extra <asset>.import file next to the source file, containing the import configuration.

Make sure to commit these files to your version control system, as these files contain important metadata.

Additionally, extra assets will be present in the hidden res://.godot/imported/ folder:

If any of the files present in this folder is erased (or the whole folder), the asset or assets will be reimported automatically. As such, committing the .godot/ folder to the version control system is not recommended. While committing this folder can shorten reimporting time when checking out on another computer, it requires considerably more space and bandwidth.

The default version control metadata that can be generated on project creation will automatically ignore the .godot/ folder.

Some source assets can be imported as different types of resources. For this, select the relevant type of resource desired then click Reimport:

Select Keep File (exported as is) as resource type to skip file import, files with this resource type will be preserved as is during project export.

Select Skip File (not exported) as resource type to skip file import and ignore file during project export.

Different types of projects might require different defaults. Changing the import options to a predefined set of options can be achieved by using the Preset... Menu. Besides some resource types offering presets, the default settings can be saved and cleared too:

The default import parameters for a given resource type can be changed project-wide using the Import Defaults tab of the Project Settings dialog:

This workflow takes a little time to get used to, but it enforces a more correct way to deal with resources.

There are many types of assets available for import. Continue reading to understand how to work with all of them:

Importing audio samples

Importing translations

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
ls
example.png
example.png.import
project.godot
```

Example 2 (unknown):
```unknown
ls .godot/imported
example.png-218a8f2b3041327d8a5756f3a245f83b.ctex
example.png-218a8f2b3041327d8a5756f3a245f83b.md5
```

---

## Input examples — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/inputs/input_examples.html

**Contents:**
- Input examples
- Introduction
- Events versus polling
- Input events
- InputMap
  - Capturing actions
- Keyboard events
  - Keyboard modifiers
- Mouse events
  - Mouse buttons

In this tutorial, you'll learn how to use Godot's InputEvent system to capture player input. There are many different types of input your game may use - keyboard, gamepad, mouse, etc. - and many different ways to turn those inputs into actions in your game. This document will show you some of the most common scenarios, which you can use as starting points for your own projects.

For a detailed overview of how Godot's input event system works, see Using InputEvent.

Sometimes you want your game to respond to a certain input event - pressing the "jump" button, for example. For other situations, you might want something to happen as long as a key is pressed, such as movement. In the first case, you can use the _input() function, which will be called whenever an input event occurs. In the second case, Godot provides the Input singleton, which you can use to query the state of an input.

This gives you the flexibility to mix-and-match the type of input processing you do.

For the remainder of this tutorial, we'll focus on capturing individual events in _input().

Input events are objects that inherit from InputEvent. Depending on the event type, the object will contain specific properties related to that event. To see what events actually look like, add a Node and attach the following script:

As you press keys, move the mouse, and perform other inputs, you'll see each event scroll by in the output window. Here's an example of the output:

As you can see, the results are very different for the different types of input. Key events are even printed as their key symbols. For example, let's consider InputEventMouseButton. It inherits from the following classes:

InputEvent - the base class for all input events

InputEventWithModifiers - adds the ability to check if modifiers are pressed, such as Shift or Alt.

InputEventMouse - adds mouse event properties, such as position

InputEventMouseButton - contains the index of the button that was pressed, whether it was a double-click, etc.

It's a good idea to keep the class reference open while you're working with events so you can check the event type's available properties and methods.

You can encounter errors if you try to access a property on an input type that doesn't contain it - calling position on InputEventKey for example. To avoid this, make sure to test the event type first:

The InputMap is the most flexible way to handle a variety of inputs. You use this by creating named input actions, to which you can assign any number of input events, such as keypresses or mouse clicks. To see them, and to add your own, open Project -> Project Settings and select the InputMap tab:

A new Godot project includes a number of default actions already defined. To see them, turn on Show Built-in Actions in the InputMap dialog.

Once you've defined your actions, you can process them in your scripts using is_action_pressed() and is_action_released() by passing the name of the action you're looking for:

Keyboard events are captured in InputEventKey. While it's recommended to use input actions instead, there may be cases where you want to specifically look at key events. For this example, let's check for the T:

See @GlobalScope_Key for a list of keycode constants.

Due to keyboard ghosting, not all key inputs may be registered at a given time if you press too many keys at once. Due to their location on the keyboard, certain keys are more prone to ghosting than others. Some keyboards feature antighosting at a hardware level, but this feature is generally not present on low-end keyboards and laptop keyboards.

As a result, it's recommended to use a default keyboard layout that is designed to work well on a keyboard without antighosting. See this Gamedev Stack Exchange question for more information.

Modifier properties are inherited from InputEventWithModifiers. This allows you to check for modifier combinations using boolean properties. Let's imagine you want one thing to happen when the T is pressed, but something different when it's Shift + T:

See @GlobalScope_Key for a list of keycode constants.

Mouse events stem from the InputEventMouse class, and are separated into two types: InputEventMouseButton and InputEventMouseMotion. Note that this means that all mouse events will contain a position property.

Capturing mouse buttons is very similar to handling key events. @GlobalScope_MouseButton contains a list of MOUSE_BUTTON_* constants for each possible button, which will be reported in the event's button_index property. Note that the scrollwheel also counts as a button - two buttons, to be precise, with both MOUSE_BUTTON_WHEEL_UP and MOUSE_BUTTON_WHEEL_DOWN being separate events.

InputEventMouseMotion events occur whenever the mouse moves. You can find the move's distance with the relative property.

Here's an example using mouse events to drag-and-drop a Sprite2D node:

If you are using a touchscreen device, you can generate touch events. InputEventScreenTouch is equivalent to a mouse click event, and InputEventScreenDrag works much the same as mouse motion.

To test your touch events on a non-touchscreen device, open Project Settings and go to the "Input Devices/Pointing" section. Enable "Emulate Touch From Mouse" and your project will interpret mouse clicks and motion as touch events.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
func _input(event):
    if event.is_action_pressed("jump"):
        jump()


func _physics_process(delta):
    if Input.is_action_pressed("move_right"):
        # Move as long as the key/button is pressed.
        position.x += speed * delta
```

Example 2 (unknown):
```unknown
public override void _Input(InputEvent @event)
{
    if (@event.IsActionPressed("jump"))
    {
        Jump();
    }
}

public override void _PhysicsProcess(double delta)
{
    if (Input.IsActionPressed("move_right"))
    {
        // Move as long as the key/button is pressed.
        position.X += speed * (float)delta;
    }
}
```

Example 3 (unknown):
```unknown
extends Node


func _input(event):
    print(event.as_text())
```

Example 4 (unknown):
```unknown
using Godot;

public partial class Node : Godot.Node
{
    public override void _Input(InputEvent @event)
    {
        GD.Print(@event.AsText());
    }
}
```

---

## Input handling — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/inputs/index.html

**Contents:**
- Input handling

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Inspector Dock — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/editor/inspector_dock.html

**Contents:**
- Inspector Dock
- Usage
- User-contributed notes

The Inspector dock lists all properties of an object, resource, or node. It will update the list of the properties as you select a different node from the Scene Tree dock, or if you use Open command from the FileSystem's context menu.

This page explains how the Inspector dock works in-depth. You will learn how to edit properties, fold and unfold areas, use the search bar, and more.

If the inspector dock is visible, clicking on a node in the scene tree will automatically display its properties. If it is not visible, you can show it by navigating to Editor > Editor Docks > Inspector.

At the top of the dock are the file and navigation buttons.

Opens a new window to select and create a resource in the memory and edit it.

Opens a resource from the FileSystem to edit.

Saves the currently edited resource to disk.

Edit Resource from Clipboard by pasting the copied resource.

Copy Resource to clipboard.

Show in FileSystem if the resource is already saved.

Make Resource Built-In to work in a built-in resource, not the one from the disk.

The "<" and ">" arrows let you navigate through your edited object history.

The button next to them opens the history list for a quicker navigation. If you created multiple resources in the memory, you will also see them here.

Below, you can find the selected node's icon, its name, and the quick button to open its documentation on the right side. Clicking on the node's name itself will list the sub-resources of this node if there are any.

Then comes the search bar. Type anything in it to filter displayed properties. Delete the text to clear the search. This search is case insensitive and also searches letter by letter as you type. For instance, if you type vsb, one of the results you see will be Visibility property as this property contains all of these letters.

Before discussing the tool button next to the filter bar, it is worth mentioning what you actually see below it and how it is structured.

Properties are grouped inside their respective classes as sections. You can expand each section to view the related properties.

You can also open the documentation of each class by right-clicking on a class and selecting Open Documentation. Similarly, you can right click on a property and copy or paste its value, copy the property path, favorite it to be shown on the top of the inspector, or open its documentation page.

If you hover your mouse over a property, you will see the description of what it does as well as how it can be called inside the script.

You can directly change the values by clicking, typing, or selecting from the menu. If the property is a number or a slider, you can keep your left mouse button pressed and drag to change the values.

If a node's property is a sub-resource, you can click on the down arrow to pick a resource type, or load one using the Quick Load or Load options. Alternatively, a supported resource can be dragged from the FileSystem. Once you start dragging, the compatible property will be highlighted. Simply drop it on the appropriate property's value.

After loading a sub-resource, you can click on it to see its properties or adjust them.

The values with different values than their original values will have a revert icon (). Clicking on this icon reverts the value to its original state. If the values are linked with each other, they will have a chain icon and changing one will change others as well. You can unchain them by clicking on this icon.

If you are changing a property a lot, you may consider favoriting it by right-clicking and choosing Favorite Property. This will show it at the top of the inspector for all objects of this class.

Now that we have a better understanding of the terms, we can proceed with the tool menu. If you click the tool menu icon next to the filter bar, a drop-down menu will offer various view and edit options.

Expand All: Expands all sections showing all available properties.

Collapse All: Collapses all properties showing only classes and the sections.

Expand Non-Default: Only expands the sections where the original value is different than the current value (the properties with a revert icon ()).

Property Name Style: This section determines how the properties' text is displayed in the inspector. Raw uses the property's own naming, Capitalized uses title case by changing the initial letters of each word to uppercase and removing underscores, Localized displays the translation of the properties if you are using the Editor in a language other than English.

Copy Properties: Copies all properties of the current node with their current values.

Paste Properties: Pastes the copied properties from the clipboard. Useful to apply the common properties of one node to another.

Make Sub-Resources Unique: By default, a duplicated node shares the sub-resources of the original node. Changing one parameter of the sub-resource in one node, affects the other one. Clicking this option makes each sub-resource used in this node unique, separated from other nodes.

If a node has exported variables in its attached script, you will also see these in the inspector. The first image in this section has one for the Player node: Action Suffix. See GDScript exported properties for more on this topic.

Refer to Customizing the interface for dock customization options.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Installing plugins — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/plugins/editor/installing_plugins.html

**Contents:**
- Installing plugins
- Finding plugins
- Installing a plugin
- Enabling a plugin
- User-contributed notes

Godot features an editor plugin system with numerous plugins developed by the community. Plugins can extend the editor's functionality with new nodes, additional docks, convenience features, and more.

The preferred way to find Godot plugins is to use the Asset Library. While it can be browsed online, it's more convenient to use it directly from the editor. To do so, click the AssetLib tab at the top of the editor:

You can also find assets on code hosting websites such as GitHub.

Some repositories describe themselves as "plugins" but may not actually be editor plugins. This is especially the case for scripts that are intended to be used in a running project. You don't need to enable such plugins to use them. Download them and extract the files in your project folder.

One way to distinguish editor plugins from non-editor plugins is to look for a plugin.cfg file in the repository that hosts the plugin. If the repository contains a plugin.cfg file in a folder placed in the addons/ folder, then it is an editor plugin.

To install a plugin, download it as a ZIP archive. On the Asset Library, this can be done using the Download button, either from the editor or using the Web interface.

On GitHub, if a plugin has tags (versions) declared, go to the Releases tab to download a stable release. This ensures you download a version that was declared to be stable by its author.

On GitHub, if the plugin doesn't have any tags declared, use the Download ZIP button to download a ZIP of the latest revision:

Extract the ZIP archive and move the addons/ folder it contains into your project folder. If your project already contains an addons/ folder, move the plugin's addons/ folder into your project folder to merge the new folder contents with the existing one. Your file manager may ask you whether to write into the folder; answer Yes. No files will be overwritten in the process.

To enable the freshly installed plugin, open Project > Project Settings at the top of the editor then go the Plugins tab. If the plugin was packaged correctly, you should see it in the list of plugins. Click on the Enable checkbox to enable the plugin.

You can use the plugin immediately after enabling it; there's no need to restart the editor. Likewise, disabling a plugin can be done without having to restart the editor.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Internal rendering architecture — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/architecture/internal_rendering_architecture.html

**Contents:**
- Internal rendering architecture
- Rendering methods
  - Forward+
  - Mobile
  - Compatibility
  - Why not deferred rendering?
- Rendering drivers
  - Vulkan
  - Direct3D 12
  - Metal

This page is a high-level overview of Godot 4's internal renderer design. It does not apply to previous Godot versions.

The goal of this page is to document design decisions taken to best suit Godot's design philosophy, while providing a starting point for new rendering contributors.

If you have questions about rendering internals not answered here, feel free to ask in the #rendering channel of the Godot Contributors Chat.

If you have difficulty understanding concepts on this page, it is recommended to go through an OpenGL tutorial such as LearnOpenGL.

Modern low-level APIs (Vulkan/Direct3D 12/Metal) require intermediate knowledge of higher-level APIs (OpenGL/Direct3D 11) to be used effectively. Thankfully, contributors rarely need to work directly with low-level APIs. Godot's renderers are built entirely on OpenGL and RenderingDevice, which is our abstraction over Vulkan/Direct3D 12/Metal.

This is a forward renderer that uses a clustered approach to lighting.

Clustered lighting uses a compute shader to group lights into a 3D frustum aligned grid. Then, at render time, pixels can lookup what lights affect the grid cell they are in and only run light calculations for lights that might affect that pixel.

This approach can greatly speed up rendering performance on desktop hardware, but is substantially less efficient on mobile.

This is a forward renderer that uses a traditional single-pass approach to lighting. Internally, it is called Forward Mobile.

Intended for mobile platforms, but can also run on desktop platforms. This rendering method is optimized to perform well on mobile GPUs. Mobile GPUs have a very different architecture compared to desktop GPUs due to their unique constraints around battery usage, heat, and overall bandwidth limitations of reading and writing data. Compute shaders also have very limited support or aren't supported at all. As a result, the mobile renderer purely uses raster-based shaders (fragment/vertex).

Unlike desktop GPUs, mobile GPUs perform tile-based rendering. Instead of rendering the whole image as a single unit, the image is divided in smaller tiles that fit within the faster internal memory of the mobile GPU. Each tile is rendered and then written out to the destination texture. This all happens automatically on the graphics driver.

The problem is that this introduces bottlenecks in our traditional approach. For desktop rendering, we render all opaque geometry, then handle the background, then transparent geometry, then post-processing. Each pass will need to read the current result into tile memory, perform its operations and then write it out again. We then wait for all tiles to be completed before moving on to the next pass.

The first important change in the mobile renderer is that the mobile renderer does not use the RGBA16F texture formats that the desktop renderer does. Instead, it is using an R10G10B10A2 UNORM texture format. This halves the bandwidth required and has further improvements as mobile hardware often further optimizes for 32-bit formats. The tradeoff is that the mobile renderer has limited HDR capabilities due to the reduced precision and maximum values in the color data.

The second important change is the use of sub-passes whenever possible. Sub-passes allows us to perform the rendering steps end-to-end per tile saving on the overhead introduced by reading from and writing to the tiles between each rendering pass. The ability to use sub-passes is limited by the inability to read neighboring pixels, as we're constrained to working within a single tile.

This limitation of subpasses results in not being able to implement features such as glow and depth of field efficiently. Similarly, if there is a requirement to read from the screen texture or depth texture, we must fully write out the rendering result limiting our ability to use sub-passes. When such features are enabled, a mix of sub-passes and normal passes are used, and these features result in a notable performance penalty.

On desktop platforms, the use of sub-passes won't have any impact on performance. However, this rendering method can still perform better than Forward+ in simple scenes thanks to its lower complexity and lower bandwidth usage. This is especially noticeable on low-end GPUs, integrated graphics or in VR applications.

Given its low-end focus, this rendering method does not provide high-end rendering features such as SDFGI and Volumetric fog and fog volumes. Several post-processing effects are also not available.

This is the only rendering method available when using the OpenGL driver. This rendering method is not available when using Vulkan, Direct3D 12, or Metal.

This is a traditional (non-clustered) forward renderer. Internally, it is called GL Compatibility. It's intended for old GPUs that don't have Vulkan support, but still works very efficiently on newer hardware. Specifically, it is optimized for older and lower-end mobile devices. However, many optimizations carry over making it a good choice for older and lower-end desktop as well.

Like the Mobile renderer, the Compatibility renderer uses an R10G10B10A2 UNORM texture for 3D rendering. Unlike the mobile renderer, colors are tonemapped and stored in sRGB format so there is no HDR support. This avoids the need for a tonemapping pass and allows us to use the lower bit texture without substantial banding.

The Compatibility renderer uses a traditional forward single-pass approach to drawing objects with lights, but it uses a multi-pass approach to draw lights with shadows. Specifically, in the first pass, it can draw multiple lights without shadows and up to one DirectionalLight3D with shadows. In each subsequent pass, it can draw up to one OmniLight3D, one SpotLight3D and one DirectionalLight3D with shadows. Lights with shadows will affect the scene differently than lights without shadows, as the lighting is blended in sRGB space instead of linear space. This difference in lighting will impact how the scene looks and needs to be kept in mind when designing scenes for the Compatibility renderer.

Given its low-end focus, this rendering method does not provide high-end rendering features (even less so compared to Mobile). Most post-processing effects are not available.

Forward rendering generally provides a better tradeoff for performance versus flexibility, especially when a clustered approach to lighting is used. While deferred rendering can be faster in some cases, it's also less flexible and requires using hacks to be able to use MSAA. Since games with a less realistic art style can benefit a lot from MSAA, we chose to go with forward rendering for Godot 4 (like Godot 3).

That said, parts of the forward renderer are performed with a deferred approach to allow for some optimizations when possible. This applies to VoxelGI and SDFGI in particular.

A clustered deferred renderer may be developed in the future. This renderer could be used in situations where performance is favored over flexibility.

Godot 4 supports the following graphics APIs:

This is the main driver in Godot 4, with most of the development focus going towards this driver.

Vulkan 1.0 is required as a baseline, with optional Vulkan 1.1 and 1.2 features used when available. volk is used as a Vulkan loader, and Vulkan Memory Allocator is used for memory management.

Both the Forward+ and Mobile Rendering methods are supported when using the Vulkan driver.

Vulkan context creation:

drivers/vulkan/vulkan_context.cpp

Direct3D 12 context creation:

drivers/d3d12/d3d12_context.cpp

Like Vulkan, the Direct3D 12 driver targets modern platforms only. It is designed to target both Windows and Xbox (whereas Vulkan can't be used directly on Xbox).

Both the Forward+ and Mobile Rendering methods can be used with Direct3D 12.

Core shaders are shared with the Vulkan renderer. Shaders are transpiled from SPIR-V to DXIL using Mesa NIR (more information).

This driver is still experimental and only available in Godot 4.3 and later. While Direct3D 12 allows supporting Direct3D-exclusive features on Windows 11 such as windowed optimizations and Auto HDR, Vulkan is still recommended for most projects. See the pull request that introduced Direct3D 12 support for more information.

Godot provides a native Metal driver that works on all Apple Silicon hardware (macOS ARM). Compared to using the MoltenVK translation layer, this is significantly faster, particularly in CPU-bound scenarios.

Both the Forward+ and Mobile Rendering methods can be used with Metal.

Core shaders are shared with the Vulkan renderer. Shaders are transpiled from GLSL to MSL using SPIRV-Cross.

Godot also supports Metal rendering via MoltenVK, which is used as a fallback when native Metal support is not available (e.g. on x86 macOS).

This driver is still experimental and only available in Godot 4.4 and later. See the pull request that introduced Metal support for more information.

This driver uses OpenGL ES 3.0 and targets legacy and low-end devices that don't support Vulkan. OpenGL 3.3 Core Profile is used on desktop platforms to run this driver, as most graphics drivers on desktop don't support OpenGL ES. WebGL 2.0 is used for web exports.

It is possible to use OpenGL ES 3.0 directly on desktop platforms by passing the --rendering-driver opengl3_es command line argument, although this will only work on graphics drivers that feature native OpenGL ES support (such as Mesa).

Only the Compatibility rendering method can be used with the OpenGL driver.

Core shaders are entirely different from the Vulkan renderer.

Many advanced features are not supported with this driver, as it targets low-end devices first and foremost.

The following rendering API + rendering method combinations are currently possible:

Vulkan + Forward+ (optionally through MoltenVK on macOS and iOS)

Vulkan + Mobile (optionally through MoltenVK on macOS and iOS)

Direct3D 12 + Forward+

OpenGL + Compatibility (optionally through ANGLE on Windows and macOS)

Each combination has its own limitations and performance characteristics. Make sure to test your changes on all rendering methods if possible before opening a pull request.

The OpenGL driver does not use the RenderingDevice abstraction.

To make the complexity of modern low-level graphics APIs more manageable, Godot uses its own abstraction called RenderingDevice.

This means that when writing code for modern rendering methods, you don't actually use the Vulkan, Direct3D 12, or Metal APIs directly. While this is still lower-level than an API like OpenGL, this makes working on the renderer easier, as RenderingDevice will abstract many API-specific quirks for you. The RenderingDevice presents a similar level of abstraction as WebGPU.

Vulkan RenderingDevice implementation:

drivers/vulkan/rendering_device_driver_vulkan.cpp

Direct3D 12 RenderingDevice implementation:

drivers/d3d12/rendering_device_driver_d3d12.cpp

Metal RenderingDevice implementation:

drivers/metal/rendering_device_driver_metal.mm

This diagram represents the structure of rendering classes in Godot, including the RenderingDevice abstraction:

While shaders in Godot projects are written using a custom language inspired by GLSL, core shaders are written directly in GLSL.

These core shaders are embedded in the editor and export template binaries at compile-time. To see any changes you've made to those GLSL shaders, you need to recompile the editor or export template binary.

Some material features such as height mapping, refraction and proximity fade are not part of core shaders, and are performed in the default BaseMaterial3D using the Godot shader language instead (not GLSL). This is done by procedurally generating the required shader code depending on the features enabled in the material.

By convention, shader files with _inc in their name are included in other GLSL files for better code reuse. Standard GLSL preprocessing is used to achieve this.

Core material shaders will be used by every material in the scene – both with the default BaseMaterial3D and custom shaders. As a result, these shaders must be kept as simple as possible to avoid performance issues and ensure shader compilation doesn't become too slow.

If you use if branching in a shader, performance may decrease as VGPR usage will increase in the shader. This happens even if all pixels evaluate to true or false in a given frame.

If you use #if preprocessor branching, the number of required shader versions will increase in the scene. In a worst-case scenario, adding a single boolean #define can double the number of shader versions that may need to be compiled in a given scene. In some cases, Vulkan specialization constants can be used as a faster (but more limited) alternative.

This means there is a high barrier to adding new built-in material features in Godot, both in the core shaders and BaseMaterial3D. While BaseMaterial3D can make use of dynamic code generation to only include the shader code if the feature is enabled, it'll still require generating more shader versions when these features are used in a project. This can make shader compilation stutter more noticeable in complex 3D scenes.

See The Shader Permutation Problem and Branching on a GPU blog posts for more information.

Core GLSL material shaders:

Forward+: servers/rendering/renderer_rd/shaders/forward_clustered/scene_forward_clustered.glsl

Mobile: servers/rendering/renderer_rd/shaders/forward_mobile/scene_forward_mobile.glsl

Compatibility: drivers/gles3/shaders/scene.glsl

Material shader generation:

scene/resources/material.cpp

Other GLSL shaders for Forward+ and Mobile rendering methods:

servers/rendering/renderer_rd/shaders/

modules/lightmapper_rd/

Other GLSL shaders for the Compatibility rendering method:

drivers/gles3/shaders/

The following is only applicable in the Forward+ and Mobile rendering methods, not in Compatibility. Multiple Viewports can be used to emulate this when using the Compatibility renderer, or to perform 2D resolution scaling.

2D and 3D are rendered to separate buffers, as 2D rendering in Godot is performed in LDR sRGB-space while 3D rendering uses HDR linear space.

The color format used for 2D rendering is RGB8 (RGBA8 if the Transparent property on the Viewport is enabled). 3D rendering uses a 24-bit unsigned normalized integer depth buffer, or 32-bit signed floating-point if a 24-bit depth buffer is not supported by the hardware. 2D rendering does not use a depth buffer.

3D resolution scaling is performed differently depending on whether bilinear or FSR 1.0 scaling is used. When bilinear scaling is used, no special upscaling shader is run. Instead, the viewport's texture is stretched and displayed with a linear sampler (which makes the filtering happen directly on the hardware). This allows maximizing the performance of bilinear 3D scaling.

The configure() function in RenderSceneBuffersRD reallocates the 2D/3D buffers when the resolution or scaling changes.

Dynamic resolution scaling isn't supported yet, but is planned in a future Godot release.

2D and 3D rendering buffer configuration C++ code:

servers/rendering/renderer_rd/storage_rd/render_scene_buffers_rd.cpp

servers/rendering/renderer_rd/effects/fsr.cpp

2D light rendering is performed in a single pass to allow for better performance with large amounts of lights.

All rendering methods feature 2D batching to improve performance, which is especially noticeable with lots of text on screen.

MSAA can be enabled in 2D to provide "automatic" line and polygon antialiasing, but FXAA does not affect 2D rendering as it's calculated before 2D rendering begins. Godot's 2D drawing methods such as the Line2D node or some CanvasItem draw_*() methods provide their own way of antialiasing based on triangle strips and vertex colors, which don't require MSAA to work.

A 2D signed distance field representing LightOccluder2D nodes in the viewport is automatically generated if a user shader requests it. This can be used for various effects in custom shaders, such as 2D global illumination. It is also used to calculate particle collisions in 2D.

2D SDF generation GLSL shader:

servers/rendering/renderer_rd/shaders/canvas_sdf.glsl

In the Forward+ renderer, Vulkan instancing is used to group rendering of identical opaque or alpha-tested objects for performance. (Alpha-blended objects are never instanced.) This is not as fast as static mesh merging, but it still allows instances to be culled individually.

Decal rendering is currently not available in the Compatibility renderer.

The Forward+ renderer uses clustered lighting. This allows using as many lights as you want; performance largely depends on screen coverage. Shadow-less lights can be almost free if they don't occupy much space on screen.

All rendering methods also support rendering up to 8 directional lights at the same time (albeit with lower shadow quality when more than one light has shadows enabled).

The Mobile renderer uses a single-pass lighting approach, with a limitation of 8 OmniLights + 8 SpotLights affecting each Mesh resource (plus a limitation of 256 OmniLights + 256 SpotLights in the camera view). These limits are hardcoded and can't be adjusted in the project settings.

The Compatibility renderer uses a hybrid single-pass + multi-pass lighting approach. Lights without shadows are rendered in a single pass. Lights with shadows are rendered in multiple passes. This is required for performance reasons on mobile devices. As a result, performance does not scale well with many shadow-casting lights. It is recommended to only have a handful of lights with shadows in the camera frustum at a time and for those lights to be spread apart so that each object is only touched by 1 or 2 shadowed lights at a time. The maximum number of lights visible at once can be adjusted in the project settings.

In all 3 methods, lights without shadows are much cheaper than lights with shadows. To improve performance, lights are only updated when the light is modified or when objects in its radius are modified. Godot currently doesn't separate static shadow rendering from dynamic shadow rendering, but this is planned in a future release.

Clustering is also used for reflection probes and decal rendering in the Forward+ renderer.

Both Forward+ and Mobile methods use PCF to filter shadow maps and create a soft penumbra. Instead of using a fixed PCF pattern, these methods use a vogel disk pattern which allows for changing the number of samples and smoothly changing the quality.

Godot also supports percentage-closer soft shadows (PCSS) for more realistic shadow penumbra rendering. PCSS shadows are limited to the Forward+ renderer as they're too demanding to be usable in the Mobile renderer. PCSS also uses a vogel-disk shaped kernel.

Additionally, both shadow-mapping techniques rotate the kernel on a per-pixel basis to help soften under-sampling artifacts.

The Compatibility renderer supports shadow mapping for DirectionalLight3D, OmniLight3D, and SpotLight3D lights.

Only available in the Forward+ renderer, not the Mobile or Compatibility renderers.

Godot uses a custom TAA implementation based on the old TAA implementation from Spartan Engine.

Temporal antialiasing requires motion vectors to work. If motion vectors are not correctly generated, ghosting will occur when the camera or objects move.

Motion vectors are generated on the GPU in the main material shader. This is done by running the vertex shader corresponding to the previous rendered frame (with the previous camera transform) in addition to the vertex shader for the current rendered frame, then storing the difference between them in a color buffer.

Alternatively, FSR 2.2 can be used as an upscaling solution that also provides its own temporal antialiasing algorithm. FSR 2.2 is implemented on top of the RenderingDevice abstraction as opposed to using AMD's reference code directly.

servers/rendering/renderer_rd/shaders/effects/taa_resolve.glsl

servers/rendering/renderer_rd/effects/fsr2.cpp

servers/rendering/renderer_rd/shaders/effects/fsr2/

VoxelGI and SDFGI are only available in the Forward+ renderer, not the Mobile or Compatibility renderers.

LightmapGI baking is only available in the Forward+ and Mobile renderers, and can only be performed within the editor (not in an exported project). LightmapGI rendering is supported by the Compatibility renderer.

Godot supports voxel-based GI (VoxelGI), signed distance field GI (SDFGI) and lightmap baking and rendering (LightmapGI). These techniques can be used simultaneously if desired.

Lightmap baking happens on the GPU using Vulkan compute shaders. The GPU-based lightmapper is implemented in the LightmapperRD class, which inherits from the Lightmapper class. This allows for implementing additional lightmappers, paving the way for a future port of the CPU-based lightmapper present in Godot 3.x. This would allow baking lightmaps while using the Compatibility renderer.

servers/rendering/renderer_rd/environment/gi.cpp

scene/3d/voxel_gi.cpp - VoxelGI node

editor/plugins/voxel_gi_editor_plugin.cpp - Editor UI for the VoxelGI node

Core GI GLSL shaders:

servers/rendering/renderer_rd/shaders/environment/voxel_gi.glsl

servers/rendering/renderer_rd/shaders/environment/voxel_gi_debug.glsl - VoxelGI debug draw mode

servers/rendering/renderer_rd/shaders/environment/sdfgi_debug.glsl - SDFGI Cascades debug draw mode

servers/rendering/renderer_rd/shaders/environment/sdfgi_debug_probes.glsl - SDFGI Probes debug draw mode

servers/rendering/renderer_rd/shaders/environment/sdfgi_integrate.glsl

servers/rendering/renderer_rd/shaders/environment/sdfgi_preprocess.glsl

servers/rendering/renderer_rd/shaders/environment/sdfgi_direct_light.glsl

Lightmapper C++ code:

scene/3d/lightmap_gi.cpp - LightmapGI node

editor/plugins/lightmap_gi_editor_plugin.cpp - Editor UI for the LightmapGI node

scene/3d/lightmapper.cpp - Abstract class

modules/lightmapper_rd/lightmapper_rd.cpp - GPU-based lightmapper implementation

Lightmapper GLSL shaders:

modules/lightmapper_rd/lm_raster.glsl

modules/lightmapper_rd/lm_compute.glsl

modules/lightmapper_rd/lm_blendseams.glsl

Only available in the Forward+ and Mobile renderers, not the Compatibility renderer.

The Forward+ and Mobile renderers use different approaches to DOF rendering, with different visual results. This is done to best match the performance characteristics of the target hardware. In Forward+, DOF is performed using a compute shader. In Mobile, DOF is performed using a fragment shader (raster).

Box, hexagon and circle bokeh shapes are available (from fastest to slowest). Depth of field can optionally be jittered every frame to improve its appearance when temporal antialiasing is enabled.

Depth of field C++ code:

servers/rendering/renderer_rd/effects/bokeh_dof.cpp

Depth of field GLSL shader (compute - used for Forward+):

servers/rendering/renderer_rd/shaders/effects/bokeh_dof.glsl

Depth of field GLSL shader (raster - used for Mobile):

servers/rendering/renderer_rd/shaders/effects/bokeh_dof_raster.glsl

Only available in the Forward+ renderer, not the Mobile or Compatibility renderers.

The Forward+ renderer supports screen-space ambient occlusion, screen-space indirect lighting, screen-space reflections and subsurface scattering.

SSAO uses an implementation derived from Intel's ASSAO (converted to Vulkan). SSIL is derived from SSAO to provide high-performance indirect lighting.

When both SSAO and SSIL are enabled, parts of SSAO and SSIL are shared to reduce the performance impact.

SSAO and SSIL are performed at half resolution by default to improve performance. SSR is always performed at half resolution to improve performance.

Screen-space effects C++ code:

servers/rendering/renderer_rd/effects/ss_effects.cpp

Screen-space ambient occlusion GLSL shader:

servers/rendering/renderer_rd/shaders/effects/ssao.glsl

servers/rendering/renderer_rd/shaders/effects/ssao_blur.glsl

servers/rendering/renderer_rd/shaders/effects/ssao_interleave.glsl

servers/rendering/renderer_rd/shaders/effects/ssao_importance_map.glsl

Screen-space indirect lighting GLSL shader:

servers/rendering/renderer_rd/shaders/effects/ssil.glsl

servers/rendering/renderer_rd/shaders/effects/ssil_blur.glsl

servers/rendering/renderer_rd/shaders/effects/ssil_interleave.glsl

servers/rendering/renderer_rd/shaders/effects/ssil_importance_map.glsl

Screen-space reflections GLSL shader:

servers/rendering/renderer_rd/shaders/effects/screen_space_reflection.glsl

servers/rendering/renderer_rd/shaders/effects/screen_space_reflection_scale.glsl

servers/rendering/renderer_rd/shaders/effects/screen_space_reflection_filter.glsl

Subsurface scattering GLSL:

servers/rendering/renderer_rd/shaders/effects/subsurface_scattering.glsl

Godot supports using shaders to render the sky background. The radiance map (which is used to provide ambient light and reflections for PBR materials) is automatically updated based on the sky shader.

The SkyMaterial resources such as ProceduralSkyMaterial, PhysicalSkyMaterial and PanoramaSkyMaterial generate a built-in shader for sky rendering. This is similar to what BaseMaterial3D provides for 3D scene materials.

A detailed technical implementation can be found in the Custom sky shaders in Godot 4.0 article.

Sky rendering C++ code:

servers/rendering/renderer_rd/environment/sky.cpp - Sky rendering

scene/resources/sky.cpp - Sky resource (not to be confused with sky rendering)

scene/resources/sky_material.cpp SkyMaterial resources (used in the Sky resource)

Sky rendering GLSL shader:

Only available in the Forward+ renderer, not the Mobile or Compatibility renderers.

Godot supports a frustum-aligned voxel (froxel) approach to volumetric fog rendering. As opposed to a post-processing filter, this approach is more general-purpose as it can work with any light type. Fog can also use shaders for custom behavior, which allows animating the fog or using a 3D texture to represent density.

The FogMaterial resource generates a built-in shader for FogVolume nodes. This is similar to what BaseMaterial3D provides for 3D scene materials.

A detailed technical explanation can be found in the Fog Volumes arrive in Godot 4.0 article.

Volumetric fog C++ code:

servers/rendering/renderer_rd/environment/fog.cpp - General volumetric fog

scene/3d/fog_volume.cpp - FogVolume node

scene/resources/fog_material.cpp - FogMaterial resource (used by FogVolume)

Volumetric fog GLSL shaders:

servers/rendering/renderer_rd/shaders/environment/volumetric_fog.glsl

servers/rendering/renderer_rd/shaders/environment/volumetric_fog_process.glsl

While modern GPUs can handle drawing a lot of triangles, the number of draw calls in complex scenes can still be a bottleneck (even with Vulkan, Direct3D 12, and Metal).

Godot 4 supports occlusion culling to reduce overdraw (when the depth prepass is disabled) and reduce vertex throughput. This is done by rasterizing a low-resolution buffer on the CPU using Embree. The buffer's resolution depends on the number of CPU threads on the system, as this is done in parallel. This buffer includes occluder shapes that were baked in the editor or created at runtime.

As complex occluders can introduce a lot of strain on the CPU, baked occluders can be simplified automatically when generated in the editor.

Godot's occlusion culling doesn't support dynamic occluders yet, but OccluderInstance3D nodes can still have their visibility toggled or be moved. However, this will be slow when updating complex occluders this way. Therefore, updating occluders at runtime is best done only on simple occluder shapes such as quads or cuboids.

This CPU-based approach has a few advantages over other solutions, such as portals and rooms or a GPU-based culling solution:

No manual setup required (but can be tweaked manually for best performance).

No frame delay, which is problematic in cutscenes during camera cuts or when the camera moves fast behind a wall.

Works the same on all rendering drivers and methods, with no unpredictable behavior depending on the driver or GPU hardware.

Occlusion culling is performed by registering occluder meshes, which is done using OccluderInstance3D nodes (which themselves use Occluder3D resources). RenderingServer then performs occlusion culling by calling Embree in RendererSceneOcclusionCull.

Occlusion culling C++ code:

scene/3d/occluder_instance_3d.cpp

servers/rendering/renderer_scene_occlusion_cull.cpp

Godot supports manually authored hierarchical level of detail (HLOD), with distances specified by the user in the inspector.

In RenderingSceneCull, the _scene_cull() and _render_scene() functions are where most of the LOD determination happens. Each viewport can render the same mesh with different LODs (to allow for split screen rendering to look correct).

Visibility range C++ code:

servers/rendering/renderer_scene_cull.cpp

The ImporterMesh class is used for the 3D mesh import workflow in the editor. Its generate_lods() function handles generating using the meshoptimizer library.

LOD mesh generation also generates shadow meshes at the same time. These are meshes that have their vertices welded regardless of smoothing and materials. This is used to improve shadow rendering performance by lowering the vertex throughput required to render shadows.

The RenderingSceneCull class's _render_scene() function determines which mesh LOD should be used when rendering. Each viewport can render the same mesh with different LODs (to allow for split screen rendering to look correct).

The mesh LOD is automatically chosen based on a screen coverage metric. This takes resolution and camera FOV changes into account without requiring user intervention. The threshold multiplier can be adjusted in the project settings.

To improve performance, shadow rendering and reflection probe rendering also choose their own mesh LOD thresholds (which can be different from the main scene rendering).

Mesh LOD generation on import C++ code:

scene/resources/importer_mesh.cpp

Mesh LOD determination C++ code:

servers/rendering/renderer_scene_cull.cpp

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Internationalization — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/i18n/index.html

**Contents:**
- Internationalization

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Internationalizing games — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/i18n/internationalizing_games.html

**Contents:**
- Internationalizing games
- Introduction
- Configuring the imported translation
- Localizing resources
- Automatically setting a language
- Locale vs. language
- Converting keys to text
  - Placeholders
  - Translation contexts
  - Pluralization

While indie or niche games usually do not need localization, games targeting a more massive market often require localization. Godot offers many tools to make this process more straightforward, so this tutorial is more like a collection of tips and tricks.

Localization is usually done by specific studios hired for the job. Despite the huge amount of software and file formats available for this, the most common way to do localization to this day is still with spreadsheets. The process of creating the spreadsheets and importing them is already covered in the Importing translations tutorial. If you haven't read the Importing translations page before, we recommend you give it a read before reading this page.

We will be using the official demo as an example; you can download it from the Asset Library.

Translations can get updated and re-imported when they change, but they still have to be added to the project. This is done in Project → Project Settings → Localization:

The above dialog is used to add or remove translations project-wide.

It is also possible to instruct Godot to use alternate versions of assets (resources) depending on the current language. This can be used for localized images such as in-game billboards or localized voices.

The Remaps tab can be used for this:

Select the resource to be remapped then add some alternatives for each locale.

The resource remapping system isn't supported for DynamicFonts. To use different fonts depending on the language's script, use the DynamicFont fallback system instead, which lets you define as many fallback fonts as you want.

The upside of the DynamicFont fallback system is that it works regardless of the current language, making it ideal for things like multiplayer chat where the text language may not match the client's language.

It is recommended to default to the user's preferred language which can be obtained via OS.get_locale_language(). If your game is not available in that language, it will fall back to the Fallback in Project Settings > Internationalization > Locale, or to en if empty. Nevertheless letting players change the language in game is recommended for various reasons (e.g. translation quality or player preference).

A locale is commonly a combination of a language with a region or country, but can also contain information like a script or a variant.

en_GB: English in Great Britain / British English

en_US: English in the USA / American English

en_DE: English in Germany

Indie games generally only need to care about language, but read on for more information.

Why locales exist can be illustrated through the USA and Great Britain. Both speak the same language (English), yet differ in many aspects: - Spelling: E.g. gray (USA), grey (GB) - Use of words: E.g. eggplant (USA), aubergine (GB) - Units or currencies: E.g. feet/inches (USA), metres/cm (GB)

It can get more complex however. Imagine you offer different content in Europe and in China (e.g. in an MMO). You will need to translate each of those content variations into many languages and store and load them accordingly.

Some controls, such as Button and Label, will automatically fetch a translation if their text matches a translation key. For example, if a label's text is "MAIN_SCREEN_GREETING1" and that key exists in the current translation, then the text will automatically be translated.

This automatic translation behavior may be undesirable in certain cases. For instance, when using a Label to display a player's name, you most likely don't want the player's name to be translated if it matches a translation key. To disable automatic translation on a specific node, disable Localization > Auto Translate in the inspector.

In code, the Object.tr() function can be used. This will just look up the text in the translations and convert it if found:

If no text is displayed after changing the language, try to use a different font. The default project font only supports a subset of the Latin-1 character set, which cannot be used to display languages like Russian or Chinese.

A good resource for multilingual fonts is Noto Fonts. Make sure to download the correct variation if you're using a less common language.

Once you've downloaded the font, load the TTF file into a DynamicFont resource and use it as a custom font of your Control node. For better reusability, associate a new a Theme resource to your root Control node and define the DynamicFont as the Default Font in the theme.

To feature placeholders in your translated strings, use GDScript format strings or the equivalent feature in C#. This lets translators move the location of the placeholder in the string freely, which allows translations to sound more natural. Named placeholders with the String.format() function should be used whenever possible, as they also allow translators to choose the order in which placeholders appear:

If you're using plain English as source strings (rather than message codes LIKE_THIS), you may run into ambiguities when you have to translate the same English string to different strings in certain target languages. You can optionally specify a translation context to resolve this ambiguity and allow target languages to use different strings, even though the source string is identical:

Most languages require different strings depending on whether an object is in singular or plural form. However, hardcoding the "is plural" condition depending on whether there is more than 1 object is not valid in all languages.

Some languages have more than two plural forms, and the rules on the number of objects required for each plural form vary. Godot offers support for pluralization so that the target locales can handle this automatically.

Pluralization is meant to be used with positive (or zero) integer numbers only. Negative and floating-point values usually represent physical entities for which singular and plural don't clearly apply.

This can be combined with a context if needed:

Providing pluralized translations is only supported with Localization using gettext (PO files), not CSV.

The same text in different languages can vary greatly in length. For this, make sure to read the tutorial on Size and anchors, as dynamically adjusting control sizes may help. Container can be useful, as well as the text wrapping options available in Label.

To check whether your UI can accommodate translations with longer strings than the original, you can enable pseudolocalization in the advanced Project Settings. This will replace all your localizable strings with longer versions of themselves, while also replacing some characters in the original strings with accented versions (while still being readable). Placeholders are kept as-is, so that they keep working when pseudolocalization is enabled.

For example, the string Hello world, this is %s! becomes [Ĥéłłô ŵôŕłd́, ŧh̀íš íš %s!] when pseudolocalization is enabled.

While looking strange at first, pseudolocalization has several benefits:

It lets you spot non-localizable strings quickly, so you can go over them and make them localizable (if it makes sense to do so).

It lets you check UI elements that can't fit long strings. Many languages will feature much longer translations than the source text, so it's important to ensure your UI can accommodate longer-than-usual strings.

It lets you check whether your font contains all the characters required to support various languages. However, since the goal of pseudolocalization is to keep the original strings readable, it's not an effective test for checking whether a font can support CJK or right-to-left languages.

The project settings allow you to tune pseudolocalization behavior, so that you can disable parts of it if desired.

Godot has a server handling low-level translation management called the TranslationServer. Translations can be added or removed during runtime; the current language can also be changed at runtime.

Arabic and Hebrew are written from right to left (except for the numbers and Latin words mixed in), and the user interface for these languages should be mirrored as well. In some languages the shape of a glyph changes depending on the surrounding characters.

Support for bidirectional writing systems and UI mirroring is transparent, you don't usually need to change anything or have any knowledge of the specific writing system.

For RTL languages, Godot will automatically do the following changes to the UI:

Mirrors left/right anchors and margins.

Swaps left and right text alignment.

Mirrors horizontal order of the child controls in the containers, and items in Tree/ItemList controls.

Uses mirrored order of the internal control elements (e.g. OptionButton dropdown button, checkbox alignment, List column order, Tree item icons and connecting line alignment, e.t.c.), in some cases mirrored controls use separate theme styles.

Coordinate system is not mirrored, and non-UI nodes (sprites, e.t.c) are not affected.

It is possible to override text and control layout direction by using the following control properties:

text_direction, sets the base text direction. When set to "auto", direction depends on the first strong directional character in the text according to the Unicode Bidirectional Algorithm,

language, overrides current project locale.

structured_text_bidi_override property and _structured_text_parser callback, enables special handling for structured text.

layout_direction, overrides control mirroring.

You can see how right-to-left typesetting works in action using the BiDI and Font Features demo project.

Some languages are written without spaces. In those languages, word and line breaking require more than rules over character sequences. Godot includes ICU rule and dictionary-based break iterator data, but this data is not included in exported projects by default.

To include it, go to Project → Project Settings, enable Internationalization → Locale → Include Text Server Data, then export the project. Break iterator data is about 4 MB in size.

Unicode BiDi algorithm is designed to work with natural text and it's incapable of handling text with the higher level order, like file names, URIs, email addresses, regular expressions or source code.

For example, the path for this shown directory structure will be displayed incorrectly (top "LineEdit" control). "File" type structured text override splits text into segments, then BiDi algorithm is applied to each of them individually to correctly display directory names in any language and preserve correct order of the folders (bottom "LineEdit" control).

Custom callbacks provide a way to override BiDi for the other types of structured text.

Controls specifically designed for number input or output (e.g. ProgressBar, SpinBox) will use localized numbering system automatically, for the other control TextServer.format_number(string, language) can be used to convert Western Arabic numbers (0..9) to the localized numbering system and TextServer.parse_number(string, language) to convert it back.

Icons with left and right pointing arrows which may need to be reversed for Arabic and Hebrew locales, in case they indicate movement or direction (e.g. back/forward buttons). Otherwise, they can remain the same.

You may want to test a project's translation before releasing it. Godot provides three ways to do this.

First, in the Project Settings, under Internationalization > Locale (with advanced settings enabled), there is a Test property. Set this property to the locale code of the language you want to test. Godot will run the project with that locale when the project is run (either from the editor or when exported).

Keep in mind that since this is a project setting, it will show up in version control when it is set to a non-empty value. Therefore, it should be set back to an empty value before committing changes to version control.

Second, from within the editor go to the top bar and click on View on the top bar, then go down to Preview Translation and select the language you want to preview.

All text in scenes in the editor should now be displayed using the selected language.

Translations can also be tested when running Godot from the command line. For example, to test a game in French, the following argument can be supplied:

The project name becomes the app name when exporting to different operating systems and platforms. To specify the project name in more than one language go to Project > Project Settings> Application > Config. From here click on the button that says Localizable String (Size 0). Now there should be a button below that which says Add Translation. Click on that and it will take you to a page where you can choose the language (and country if needed) for your project name translation. After doing that you can now type in the localized name.

If you are unsure about the language code to use, refer to the list of locale codes.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
var language = "automatic"
# Load here language from the user settings file
if language == "automatic":
   var preferred_language = OS.get_locale_language()
   TranslationServer.set_locale(preferred_language)
else:
   TranslationServer.set_locale(language)
```

Example 2 (unknown):
```unknown
level.text = tr("LEVEL_5_NAME")
status.text = tr("GAME_STATUS_%d" % status_index)
```

Example 3 (unknown):
```unknown
level.Text = Tr("LEVEL_5_NAME");
status.Text = Tr($"GAME_STATUS_{statusIndex}");
```

Example 4 (unknown):
```unknown
# The placeholder's locations can be changed, but not their order.
# This will probably not suffice for some target languages.
message.text = tr("%s picked up the %s") % ["Ogre", "Sword"]

# The placeholder's locations and order can be changed.
# Additionally, this form gives more context for translators to work with.
message.text = tr("{character} picked up the {weapon}").format({character = "Ogre", weapon = "Sword"})
```

---

## Interpolation — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/math/interpolation.html

**Contents:**
- Interpolation
- Vector interpolation
- Transform interpolation
- Smoothing motion
- User-contributed notes

Interpolation is a common operation in graphics programming, which is used to blend or transition between two values. Interpolation can also be used to smooth movement, rotation, etc. It's good to become familiar with it in order to expand your horizons as a game developer.

The basic idea is that you want to transition from A to B. A value t, represents the states in-between.

For example, if t is 0, then the state is A. If t is 1, then the state is B. Anything in-between is an interpolation.

Between two real (floating-point) numbers, an interpolation can be described as:

And often simplified to:

The name of this type of interpolation, which transforms a value into another at constant speed is "linear". So, when you hear about Linear Interpolation, you know they are referring to this formula.

There are other types of interpolations, which will not be covered here. A recommended read afterwards is the Bezier page.

Vector types (Vector2 and Vector3) can also be interpolated, they come with handy functions to do it Vector2.lerp() and Vector3.lerp().

For cubic interpolation, there are also Vector2.cubic_interpolate() and Vector3.cubic_interpolate(), which do a Bezier style interpolation.

Here is example pseudo-code for going from point A to B using interpolation:

It will produce the following motion:

It is also possible to interpolate whole transforms (make sure they have either uniform scale or, at least, the same non-uniform scale). For this, the function Transform3D.interpolate_with() can be used.

Here is an example of transforming a monkey from Position1 to Position2:

Using the following pseudocode:

And again, it will produce the following motion:

Interpolation can be used to smoothly follow a moving target value, such as a position or a rotation. Each frame, lerp() moves the current value towards the target value by a fixed percentage of the remaining difference between the values. The current value will smoothly move towards the target, slowing down as it gets closer. Here is an example of a circle following the mouse using interpolation smoothing:

Here is how it looks:

This is useful for smoothing camera movement, for allies following the player (ensuring they stay within a certain range), and for many other common game patterns.

Despite using delta, the formula used above is framerate-dependent, because the weight parameter of lerp() represents a percentage of the remaining difference in values, not an absolute amount to change. In _physics_process(), this is usually fine because physics is expected to maintain a constant framerate, and therefore delta is expected to remain constant.

For a framerate-independent version of interpolation smoothing that can also be used in process(), use the following formula instead:

Deriving this formula is beyond the scope of this page. For an explanation, see Improved Lerp Smoothing or watch Lerp smoothing is broken.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
interpolation = A * (1 - t) + B * t
```

Example 2 (unknown):
```unknown
interpolation = A + (B - A) * t
```

Example 3 (gdscript):
```gdscript
var t = 0.0

func _physics_process(delta):
    t += delta * 0.4

    $Sprite2D.position = $A.position.lerp($B.position, t)
```

Example 4 (unknown):
```unknown
private float _t = 0.0f;

public override void _PhysicsProcess(double delta)
{
    _t += (float)delta * 0.4f;

    Marker2D a = GetNode<Marker2D>("A");
    Marker2D b = GetNode<Marker2D>("B");
    Sprite2D sprite = GetNode<Sprite2D>("Sprite2D");

    sprite.Position = a.Position.Lerp(b.Position, _t);
}
```

---

## Introducing XR tools — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/xr/introducing_xr_tools.html

**Contents:**
- Introducing XR tools
- Installing XR Tools
- Basic hands
- More information
- User-contributed notes

Out of the box Godot gives you all the basic support to setup an XR project. XR specific game mechanics however need to be implemented on top of this foundation. While Godot makes this relatively easy this can still be a daunting task.

For this reason Godot has developed a toolkit called Godot XR Tools that implements many of the basic mechanics found in XR games, from locomotion to object interaction to UI interaction.

This toolkit is designed to work with both OpenXR and WebXR runtimes. We'll be using this as a base for our documentation here. It helps developers hit the ground running but for more specific use cases building your own logic is just as valid. In that case XR tools can help in providing inspiration.

Continuing on from our project we started in Setting up XR we want to add in the Godot XR Tools library. This can be downloaded from the Godot XR Tools releases page. Find the latest release for Godot 4, and under Assets, download the godot-xr-tools.zip file. You can also find it in the asset library with the title "Godot XR Tools for Godot 4".

If you're using the zip file, once it's downloaded unzip it. You will notice the files are held within a godot-xr-tools subfolder. Inside of this folder you will find an addons folder. It is this folder that you want to copy in its entirety to your Godot project folder. Your project should now look something like this:

Now open up your project in Godot, if you haven't already, and give it a minute or so to import all the resources of the plugin. If it asks for a path to Blender to be set you can just click the option to disable blender import and restart the editor.

After the import finishes you may notice that several "failed to load script" messages popped up, that's normal, the plugin just needs to be enabled in the project settings.

Next open the Project menu and select Project Settings... Now go to the Plugins tab and enable the plugin.

After doing that you need to close and re-open your project so everything is properly enabled.

Just to get a feel of things we're going to add a few standard components that dress up our scene starting with hands for our player.

OpenXR supports full hand tracking however there currently are significant differences in capabilities between the different XR Runtimes.

As a reliable alternative Godot XR Tools comes with a number of rigged hand scenes that react on trigger and grip inputs of your controller. These hands come in low and high poly versions, come in a few configurations, a number of animation files to control finger positions and a number of different textures.

In your scene tree select your left hand XRController3D node. Now click on the instantiate Child Scene button to add a child scene. Click the addons toggle so the addons folder can be searched. Then search for left_hand_low.tscn, and select it.

As you can see from the path of this scene, low poly models are in the lowpoly subfolder while high poly models are in the highpoly subfolder. You will want to use the low poly versions if you plan to release your game on mobile devices.

The default hand we chose is just a hand. The other options are:

tac_glove - the hand is wearing a glove with fingers exposed

full_glove - the hand is wearing a glove that covers the entire hand

Finally each hand comes in a physics version. This exposes all the bones. We'll look at how that can be used in another tutorial.

We repeat the same for the right hand.

We'll continue with adding features to our tutorial project using Godot XR tools in the next couple of pages. More detailed information about the toolkit can be found on the toolkits help pages.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## iOS plugins — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/platform/ios/index.html

**Contents:**
- iOS plugins

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## JetBrains Rider — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/configuring_an_ide/rider.html

**Contents:**
- JetBrains Rider
- Importing the project
- Compiling and debugging the project
- Debug visualizers
- Unit testing
- Profiling
- Known issues
- User-contributed notes

JetBrains Rider is a commercial JetBrains IDE for C++, C# and GDScript that uses the same solution system as Visual Studio.

This documentation is for contributing to the game engine, not for using JetBrains Rider as a C# or GDScript editor. To code C# or GDScript in an external editor, see the C# guide to configure an external editor.

If you already use Visual Studio as your main IDE, you can use the same solution file in Rider. Rider and Visual Studio use the same solution format, so you can switch between the two IDEs without rebuilding the solution file. Debug configurations need to be changed when going from one IDE to another.

If you are starting from the scratch, please follow instructions, specifically:

Install all the dependencies.

Figure out the scons command for compiling to target a specific platform.

Provide scons with additional arguments to request a solution file generation:

Add vsproj=yes dev_build=yes to the scons command

The vsproj parameter signals that you want Visual Studio solution generated. The dev_build parameter ensures the debug symbols are included, allowing to e.g. step through code using breakpoints.

Open the generated godot.sln in Rider.

Ensure that the appropriate Solution configuration is selected on the Rider toolbar. It affects resolve of the SDKs, code analysis, build, run, etc.

Rider comes with a built-in debugger that can be used to debug the Godot project. You can launch the debugger by pressing the Debug icon at the top of the screen, this only works for the Project Manager, if you want to debug the editor, you need to configure the debugger first.

Click on the Godot > Edit Configurations option at the top of the screen.

Ensure the following values for the C++ Project Run Configuration:

Exe Path : $(LocalDebuggerCommand)

Program Arguments: -e --path <path to the Godot project>

Working Directory: $(LocalDebuggerWorkingDirectory)

Before Launch has a value of "Build Project"

This will tell the executable to debug the specified project without opening the Project Manager. Use the root path to the project folder, not project.godot file path.

Finally click on "Apply" and "OK" to save the changes.

When you press the Debug icon at the top of the screen, JetBrains Rider will launch the Godot editor with the debugger attached.

Alternatively you can use Run > Attach to Process to attach the debugger to a running Godot instance.

You can find the Godot instance by searching for godot.editor and then clicking Attach with LLDB

Debug visualizers customize how complex data structures are displayed during debugging. For Windows "natvis" (short for "Native Visualization") built-in with Godot are automatically used. For other operating systems, similar functionality can be setup manually.

Please follow RIDER-123535.

Leverage Rider doctest support. Please refer to the instructions.

Please refer to the profiling instructions.

Please consult the JetBrains Rider documentation for any specific information about the JetBrains IDE.

Debugging Windows MinGV build - symbols are not loaded. Reported RIDER-106816.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## KDevelop — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/configuring_an_ide/kdevelop.html

**Contents:**
- KDevelop
- Importing the project
- Debugging the project
- User-contributed notes

KDevelop is a free, open source IDE for all desktop platforms.

From the KDevelop's main screen select Open Project.

KDevelop's main screen.

Navigate to the Godot root folder and select it.

On the next screen, choose Custom Build System for the Project Manager.

After the project has been imported, open the project configuration by right-clicking on it in the Projects panel and selecting Open Configuration.. option.

Under Language Support open the Includes/Imports tab and add the following paths:

Under Custom Build System add a new build configuration with the following settings:

See Introduction to the buildsystem for a full list of arguments.

Apply the changes and close the configuration window.

Select Run > Configure Launches... from the top menu.

Click Add to create a new launch configuration.

Select Executable option and specify the path to your executable located in the <Godot root directory>/bin folder. The name depends on your build configuration, e.g. godot.linuxbsd.editor.dev.x86_64 for 64-bit LinuxBSD platform with platform=linuxbsd, target=editor, and dev_build=yes.

If you run into any issues, ask for help in one of Godot's community channels.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
.  // A dot, to indicate the root of the Godot project
core/
core/os/
core/math/
drivers/
platform/<your_platform>/  // Replace <your_platform> with a folder
                              corresponding to your current platform
```

---

## Keyboard/Controller Navigation and Focus — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/ui/gui_navigation.html

**Contents:**
- Keyboard/Controller Navigation and Focus
- Node settings
- Necessary code
- User-contributed notes

It is a common requirement for a user interface to have full keyboard and controller support for navigation and interaction. There are two main reasons why this is beneficial for projects: improved accessibility (not everyone can use mouse or touch controls for interactions), and getting your project ready for consoles (or just for people who prefer to game with a controller on PC).

Navigating between UI elements with keyboard or controller is done by changing which node is actively selected. This is also called changing UI focus. Every Control node in Godot is capable of having focus. By default, some control nodes have the ability to automatically grab focus reacting to built-in UI actions such as ui_up, ui_down, ui_focus_next, etc. These actions can be seen in the project settings in the input map and can be modified.

Because these actions are used for focus they should not be used for any gameplay code.

In addition to the built-in logic, you can define what is known as focus neighbors for each individual control node. This allows to finely tune the path the UI focus takes across the user interface of your project. The settings for individual nodes can be found in the Inspector dock, under the "Focus" category of the "Control" section.

Neighbor options are used to define nodes for 4-directional navigation, such as using arrow keys or a D-pad on a controller. For example, the bottom neighbor will be used when navigating down with the down arrow or by pushing down on the D-pad. The "Next" and "Previous" options are used with the focus shift button, such as Tab on desktop operating systems.

A node can lose focus if it becomes hidden.

The mode setting defines how a node can be focused. All means a node can be focused by clicking on it with the mouse, or selecting it with a keyboard or controller. Click means it can only be focused on by clicking on it. Finally, None means it can't be focused at all. Different control nodes have different default settings for this based on how they are typically used, for example, Label nodes are set to "None" by default, while buttons are set to "All".

Make sure to properly configure your scenes for focus and navigation. If a node has no focus neighbor configured, the engine will try to guess the next control automatically. This may result in unintended behavior, especially in a complex user interface that doesn't have well-defined vertical or horizontal navigation flow.

For keyboard and controller navigation to work correctly, any node must be focused by using code when the scene starts. Without doing this, pressing buttons or keys won't do anything.

You can use the Control.grab_focus() method to focus a control. Here is a basic example of setting initial focus with code:

Now when the scene starts, the "Start Button" node will be focused, and the keyboard or a controller can be used to navigate between it and other UI elements.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
func _ready():
    $StartButton.grab_focus.call_deferred()
```

Example 2 (unknown):
```unknown
public override void _Ready()
{
    GetNode<Button>("StartButton").GrabFocus.CallDeferred();
}
```

---

## List of features — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/about/list_of_features.html

**Contents:**
- List of features
- Platforms
- Editor
- Rendering
- 2D graphics
- 2D tools
- 2D physics
- 3D graphics
- 3D tools
- 3D physics

This page aims to list all features currently supported by Godot.

This page lists features supported by the current stable version of Godot. Some of these features are not available in the 3.x release series.

See System requirements for hardware and software version requirements.

Can run both the editor and exported projects:

Windows (x86 and ARM, 64-bit and 32-bit).

macOS (x86 and ARM, 64-bit only).

Linux (x86 and ARM, 64-bit and 32-bit).

Binaries are statically linked and can run on any distribution if compiled on an old enough base distribution.

Official binaries are compiled using the Godot Engine buildroot, allowing for binaries that work across common Linux distributions.

Android (editor support is experimental).

Web browsers. Experimental in 4.0, using Godot 3.x is recommended instead when targeting HTML5.

Linux supports rv64 (RISC-V), ppc64 & ppc32 (PowerPC), and loongarch64. However you must compile the editor for that platform (as well as export templates) yourself, no official downloads are currently provided. RISC-V compiling instructions can be found on the Compiling for Linux, *BSD page.

Runs exported projects:

Godot aims to be as platform-independent as possible and can be ported to new platforms with relative ease.

Projects written in C# using Godot 4 currently cannot be exported to the web platform. To use C# on that platform, consider Godot 3 instead. Android and iOS platform support is available as of Godot 4.2, but is experimental and some limitations apply.

Built-in script editor.

Support for external script editors such as Visual Studio Code or Vim.

Support for debugging in threads is available since 4.2.

Visual profiler with CPU and GPU time indications for each step of the rendering pipeline.

Performance monitoring tools, including custom performance monitors.

Live script reloading.

Changes will reflect in the editor and will be kept after closing the running project.

Changes won't reflect in the editor and won't be kept after closing the running project.

Live camera replication.

Move the in-editor camera and see the result in the running project.

Built-in offline class reference documentation.

Use the editor in dozens of languages contributed by the community.

Editor plugins can be downloaded from the asset library to extend editor functionality.

Create your own plugins using GDScript to add new features or speed up your workflow.

Download projects from the asset library in the Project Manager and import them directly.

Godot 4 includes three renderers:

Forward+. The most advanced renderer, suited for desktop platforms only. Used by default on desktop platforms. This renderer uses Vulkan, Direct3D 12, or Metal as the rendering driver, and it uses the RenderingDevice backend.

Mobile. Fewer features, but renders simple scenes faster. Suited for mobile and desktop platforms. Used by default on mobile platforms. This renderer uses Vulkan, Direct3D 12, or Metal as the rendering driver, and it uses the RenderingDevice backend.

Compatibility, sometimes called GL Compatibility. The least advanced renderer, suited for low-end desktop and mobile platforms. Used by default on the web platform. This renderer uses OpenGL as the rendering driver.

See Overview of renderers for a detailed comparison of the rendering methods.

Sprite, polygon and line rendering.

High-level tools to draw lines and polygons such as Polygon2D and Line2D, with support for texturing.

AnimatedSprite2D as a helper for creating animated sprites.

Pseudo-3D support including preview in the editor.

2D lighting with normal maps and specular maps.

Point (omni/spot) and directional 2D lights.

Hard or soft shadows (adjustable on a per-light basis).

Custom shaders can access a real-time SDF representation of the 2D scene based on LightOccluder2D nodes, which can be used for improved 2D lighting effects including 2D global illumination.

Font rendering using bitmaps, rasterization using FreeType or multi-channel signed distance fields (MSDF).

Bitmap fonts can be exported using tools like BMFont, or imported from images (for fixed-width fonts only).

Dynamic fonts support monochrome fonts as well as colored fonts (e.g. for emoji). Supported formats are TTF, OTF, WOFF1 and WOFF2.

Dynamic fonts support optional font outlines with adjustable width and color.

Dynamic fonts support variable fonts and OpenType features including ligatures.

Dynamic fonts support simulated bold and italic when the font file lacks those styles.

Dynamic fonts support oversampling to keep fonts sharp at higher resolutions.

Dynamic fonts support subpixel positioning to make fonts crisper at low sizes.

Dynamic fonts support LCD subpixel optimizations to make fonts even crisper at low sizes.

Signed distance field fonts can be scaled at any resolution without requiring re-rasterization. Multi-channel usage makes SDF fonts scale down to lower sizes better compared to monochrome SDF fonts.

GPU-based particles with support for custom particle shaders.

Optional 2D HDR rendering for better glow capabilities.

TileMaps for 2D tile-based level design.

2D camera with built-in smoothing and drag margins.

Path2D node to represent a path in 2D space.

Can be drawn in the editor or generated procedurally.

PathFollow2D node to make nodes follow a Path2D.

2D geometry helper class.

Animatable bodies (for objects moving only by script or animation, such as doors and platforms).

Areas to detect bodies entering or leaving it.

Built-in shapes: line, box, circle, capsule, world boundary (infinite plane).

Collision polygons (can be drawn manually or generated from a sprite in the editor).

HDR rendering with sRGB.

Perspective, orthographic and frustum-offset cameras.

When using the Forward+ renderer, a depth prepass is used to improve performance in complex scenes by reducing the cost of overdraw.

Variable rate shading on supported GPUs in Forward+ and Mobile.

Physically-based rendering (built-in material features):

Follows the Disney PBR model.

Supports Burley, Lambert, Lambert Wrap (half-Lambert) and Toon diffuse shading modes.

Supports Schlick-GGX, Toon and Disabled specular shading modes.

Uses a roughness-metallic workflow with support for ORM textures.

Uses horizon specular occlusion (Filament model) to improve material appearance.

Parallax/relief mapping with automatic level of detail based on distance.

Detail mapping for the albedo and normal maps.

Sub-surface scattering and transmittance.

Screen-space refraction with support for material roughness (resulting in blurry refraction).

Proximity fade (soft particles) and distance fade.

Distance fade can use alpha blending or dithering to avoid going through the transparent pipeline.

Dithering can be determined on a per-pixel or per-object basis.

Directional lights (sun/moon). Up to 4 per scene.

Omnidirectional lights.

Spot lights with adjustable cone angle and attenuation.

Specular, indirect light, and volumetric fog energy can be adjusted on a per-light basis.

Adjustable light "size" for fake area lights (will also make shadows blurrier).

Optional distance fade system to fade distant lights and their shadows, improving performance.

When using the Forward+ renderer (default on desktop), lights are rendered with clustered forward optimizations to decrease their individual cost. Clustered rendering also lifts any limits on the number of lights that can be used on a mesh.

When using the Mobile renderer, up to 8 omni lights and 8 spot lights can be displayed per mesh resource. Baked lighting can be used to overcome this limit if needed.

DirectionalLight: Orthogonal (fastest), PSSM 2-split and 4-split. Supports blending between splits.

OmniLight: Dual paraboloid (fast) or cubemap (slower but more accurate). Supports colored projector textures in the form of panoramas.

SpotLight: Single texture. Supports colored projector textures.

Shadow normal offset bias and shadow pancaking to decrease the amount of visible shadow acne and peter-panning.

PCSS-like shadow blur based on the light size and distance from the surface the shadow is cast on.

Adjustable shadow blur on a per-light basis.

Global illumination with indirect lighting:

Baked lightmaps (fast, but can't be updated at runtime).

Supports baking indirect light only or baking both direct and indirect lighting. The bake mode can be adjusted on a per-light basis to allow for hybrid light baking setups.

Supports lighting dynamic objects using automatic and manually placed probes.

Optionally supports directional lighting and rough reflections based on spherical harmonics.

Lightmaps are baked on the GPU using compute shaders (much faster compared to CPU lightmapping). Baking can only be performed from the editor, not in exported projects.

Supports GPU-based denoising with JNLM, or CPU/GPU-based denoising with OIDN.

Voxel-based GI probes. Supports dynamic lights and dynamic occluders, while also supporting reflections. Requires a fast baking step which can be performed in the editor or at runtime (including from an exported project).

Signed-distance field GI designed for large open worlds. Supports dynamic lights, but not dynamic occluders. Supports reflections. No baking required.

Screen-space indirect lighting (SSIL) at half or full resolution. Fully real-time and supports any kind of emissive light source (including decals).

VoxelGI and SDFGI use a deferred pass to allow for rendering GI at half resolution to improve performance (while still having functional MSAA support).

Voxel-based reflections (when using GI probes) and SDF-based reflections (when using signed distance field GI). Voxel-based reflections are visible on transparent surfaces, while rough SDF-based reflections are visible on transparent surfaces.

Fast baked reflections or slow real-time reflections using ReflectionProbe. Parallax box correction can optionally be enabled.

Screen-space reflections with support for material roughness.

Reflection techniques can be mixed together for greater accuracy or scalability.

When using the Forward+ renderer (default on desktop), reflection probes are rendered with clustered forward optimizations to decrease their individual cost. Clustered rendering also lifts any limits on the number of reflection probes that can be used on a mesh.

When using the Mobile renderer, up to 8 reflection probes can be displayed per mesh resource. When using the Compatibility renderer, up to 2 reflection probes can be displayed per mesh resource.

Supports albedo, emissive, ORM, and normal mapping.

Texture channels are smoothly overlaid on top of the underlying material, with support for normal/ORM-only decals.

Support for normal fade to fade the decal depending on its incidence angle.

Does not rely on runtime mesh generation. This means decals can be used on complex skinned meshes with no performance penalty, even if the decal moves every frame.

Support for nearest, bilinear, trilinear or anisotropic texture filtering (configured globally).

Optional distance fade system to fade distant decals, improving performance.

When using the Forward+ renderer (default on desktop), decals are rendered with clustered forward optimizations to decrease their individual cost. Clustered rendering also lifts any limits on the number of decals that can be used on a mesh.

When using the Mobile renderer, up to 8 decals can be displayed per mesh resource.

Panorama sky (using an HDRI).

Procedural sky and Physically-based sky that respond to the DirectionalLights in the scene.

Support for custom sky shaders, which can be animated.

The radiance map used for ambient and specular light can be updated in real-time depending on the quality settings chosen.

Exponential depth fog.

Exponential height fog.

Support for automatic fog color depending on the sky color (aerial perspective).

Support for sun scattering in the fog.

Support for controlling how much fog rendering should affect the sky, with separate controls for traditional and volumetric fog.

Support for making specific materials ignore fog.

Global volumetric fog that reacts to lights and shadows.

Volumetric fog can take indirect light into account when using VoxelGI or SDFGI.

Fog volume nodes that can be placed to add fog to specific areas (or remove fog from specific areas). Supported shapes include box, ellipse, cone, cylinder, and 3D texture-based density maps.

Each fog volume can have its own custom shader.

Can be used together with traditional fog.

GPU-based particles with support for subemitters (2D + 3D), trails (2D + 3D), attractors (3D only) and collision (2D + 3D).

3D particle attractor shapes supported: box, sphere and 3D vector fields.

3D particle collision shapes supported: box, sphere, baked signed distance field and real-time heightmap (suited for open world weather effects).

2D particle collision is handled using a signed distance field generated in real-time based on LightOccluder2D nodes in the scene.

Trails can use the built-in ribbon trail and tube trail meshes, or custom meshes with skeletons.

Support for custom particle shaders with manual emission.

Tonemapping (Linear, Reinhard, Filmic, ACES, AgX).

Automatic exposure adjustments based on viewport brightness (and manual exposure override).

Near and far depth of field with adjustable bokeh simulation (box, hexagon, circle).

Screen-space ambient occlusion (SSAO) at half or full resolution.

Glow/bloom with optional bicubic upscaling and several blend modes available: Screen, Soft Light, Add, Replace, Mix.

Glow can have a colored dirt map texture, acting as a lens dirt effect.

Glow can be used as a screen-space blur effect.

Color correction using a one-dimensional ramp or a 3D LUT texture.

Roughness limiter to reduce the impact of specular aliasing.

Brightness, contrast and saturation adjustments.

Nearest, bilinear, trilinear or anisotropic filtering.

Filtering options are defined on a per-use basis, not a per-texture basis.

Basis Universal (slow, but results in smaller files).

BPTC for high-quality compression (not supported on macOS).

ETC2 (not supported on macOS).

S3TC (not supported on mobile/Web platforms).

Temporal antialiasing (TAA).

AMD FidelityFX Super Resolution 2.2 antialiasing (FSR2), which can be used at native resolution as a form of high-quality temporal antialiasing.

Multi-sample antialiasing (MSAA), for both 2D antialiasing and 3D antialiasing.

Fast approximate antialiasing (FXAA).

Super-sample antialiasing (SSAA) using bilinear 3D scaling and a 3D resolution scale above 1.0.

Alpha antialiasing, MSAA alpha to coverage and alpha hashing on a per-material basis.

Support for rendering 3D at a lower resolution while keeping 2D rendering at the original scale. This can be used to improve performance on low-end systems or improve visuals on high-end systems.

Resolution scaling uses bilinear filtering, AMD FidelityFX Super Resolution 1.0 (FSR1) or AMD FidelityFX Super Resolution 2.2 (FSR2).

Texture mipmap LOD bias is adjusted automatically to improve quality at lower resolution scales. It can also be modified with a manual offset.

Most effects listed above can be adjusted for better performance or to further improve quality. This can be helpful when using Godot for offline rendering.

Built-in meshes: cube, cylinder/cone, (hemi)sphere, prism, plane, quad, torus, ribbon, tube.

GridMaps for 3D tile-based level design.

Constructive solid geometry (intended for prototyping).

Tools for procedural geometry generation.

Path3D node to represent a path in 3D space.

Can be drawn in the editor or generated procedurally.

PathFollow3D node to make nodes follow a Path3D.

3D geometry helper class.

Support for exporting the current scene as a glTF 2.0 file, both from the editor and at runtime from an exported project.

Animatable bodies (for objects moving only by script or animation, such as doors and platforms).

Vehicle bodies (intended for arcade physics, not simulation).

Areas to detect bodies entering or leaving it.

Built-in shapes: cuboid, sphere, capsule, cylinder, world boundary (infinite plane).

Generate triangle collision shapes for any mesh from the editor.

Generate one or several convex collision shapes for any mesh from the editor.

2D: Custom vertex, fragment, and light shaders.

3D: Custom vertex, fragment, light, and sky shaders.

Text-based shaders using a shader language inspired by GLSL.

Visual shader editor.

Support for visual shader plugins.

Object-oriented design pattern with scripts extending nodes.

Signals and groups for communicating between scripts.

Support for cross-language scripting.

Many 2D, 3D and 4D linear algebra data types such as vectors and transforms.

High-level interpreted language with optional static typing.

Syntax inspired by Python. However, GDScript is not based on Python.

Syntax highlighting is provided on GitHub.

Use threads to perform asynchronous actions or make use of multiple processor cores.

Packaged in a separate binary to keep file sizes and dependencies down.

Supports .NET 8 and higher.

Full support for the C# 12.0 syntax and features.

Supports Windows, Linux, and macOS. Since Godot 4.2, experimental support for Android and iOS is also available.

On the iOS platform only some architectures are supported: arm64.

The web platform is currently unsupported. To use C# on that platform, consider Godot 3 instead.

Using an external editor is recommended to benefit from IDE functionality.

GDExtension (C, C++, Rust, D, ...):

When you need it, link to native libraries for higher performance and third-party integrations.

For scripting game logic, GDScript or C# are recommended if their performance is suitable.

Official GDExtension bindings for C and C++.

Use any build system and language features you wish.

Actively developed GDExtension bindings for D, Swift, and Rust bindings provided by the community. (Some of these bindings may be experimental and not production-ready).

Mono, stereo, 5.1 and 7.1 output.

Non-positional and positional playback in 2D and 3D.

Optional Doppler effect in 2D and 3D.

Support for re-routable audio buses and effects with dozens of effects included.

Support for polyphony (playing several sounds from a single AudioStreamPlayer node).

Support for random volume and pitch.

Support for real-time pitch scaling.

Support for sequential/random sample selection, including repetition prevention when using random sample selection.

Listener2D and Listener3D nodes to listen from a position different than the camera.

Support for procedural audio generation.

Audio input to record microphones.

No support for MIDI output yet.

Linux: PulseAudio or ALSA.

Support for custom import plugins.

Images: See Importing images.

WAV with optional IMA-ADPCM compression.

3D scenes: See Importing 3D scenes.

glTF 2.0 (recommended).

.blend (by calling Blender's glTF export functionality transparently).

FBX (by calling FBX2glTF transparently).

Wavefront OBJ (static scenes only, can be loaded directly as a mesh or imported as a 3D scene).

Support for loading glTF 2.0 scenes at runtime, including from an exported project.

3D meshes use Mikktspace to generate tangents on import, which ensures consistency with other 3D applications such as Blender.

Input mapping system using hardcoded input events or remappable input actions.

Axis values can be mapped to two different actions with a configurable deadzone.

Use the same code to support both keyboards and gamepads.

Keys can be mapped in "physical" mode to be independent of the keyboard layout.

The mouse cursor can be visible, hidden, captured or confined within the window.

When captured, raw input will be used on Windows and Linux to sidestep the OS' mouse acceleration settings.

Gamepad input (up to 8 simultaneous controllers).

Pen/tablet input with pressure support.

A* algorithm in 2D and 3D.

Navigation meshes with dynamic obstacle avoidance in 2D and 3D.

Generate navigation meshes from the editor or at runtime (including from an exported project).

Low-level TCP networking using StreamPeer and TCPServer.

Low-level UDP networking using PacketPeer and UDPServer.

Low-level HTTP requests using HTTPClient.

High-level HTTP requests using HTTPRequest.

Supports HTTPS out of the box using bundled certificates.

High-level multiplayer API using UDP and ENet.

Automatic replication using remote procedure calls (RPCs).

Supports unreliable, reliable and ordered transfers.

WebSocket client and server, available on all platforms.

WebRTC client and server, available on all platforms.

Support for UPnP to sidestep the requirement to forward ports when hosting a server behind a NAT.

Full support for Unicode including emoji.

Store localization strings using CSV or gettext.

Support for generating gettext POT and PO files from the editor.

Use localized strings in your project automatically in GUI elements or by using the tr() function.

Support for pluralization and translation contexts when using gettext translations.

Support for bidirectional typesetting, text shaping and OpenType localized forms.

Automatic UI mirroring for right-to-left locales.

Support for pseudolocalization to test your project for i18n-friendliness.

Spawn multiple independent windows within a single process.

Move, resize, minimize, and maximize windows spawned by the project.

Change the window title and icon.

Request attention (will cause the title bar to blink on most platforms).

Uses borderless fullscreen by default on Windows for fast alt-tabbing, but can optionally use exclusive fullscreen to reduce input lag.

Borderless windows (fullscreen or non-fullscreen).

Ability to keep a window always on top.

Global menu integration on macOS.

Execute commands in a blocking or non-blocking manner (including running multiple instances of the same project).

Open file paths and URLs using default or custom protocol handlers (if registered on the system).

Parse custom command line arguments.

Any Godot binary (editor or exported project) can be used as a headless server by starting it with the --headless command line argument. This allows running the engine without a GPU or display server.

In-app purchases on Android and iOS.

Support for advertisements using third-party modules.

Out of the box support for OpenXR.

Including support for popular desktop headsets like the Valve Index, WMR headsets, and Quest over Link.

Support for Android-based headsets using OpenXR through a plugin.

Including support for popular stand alone headsets like the Meta Quest 1/2/3 and Pro, Pico 4, Magic Leap 2, and Lynx R1.

Out of the box limited support for visionOS Apple headsets.

Currently only exporting an application for use on a flat plane within the headset is supported. Immersive experiences are not supported.

Other devices supported through an XR plugin structure.

Various advanced toolkits are available that implement common features required by XR applications.

Godot's GUI is built using the same Control nodes used to make games in Godot. The editor UI can easily be extended in many ways using add-ons.

Checkboxes, check buttons, radio buttons.

Text entry using LineEdit (single line) and TextEdit (multiple lines). TextEdit also supports code editing features such as displaying line numbers and syntax highlighting.

Dropdown menus using PopupMenu and OptionButton.

RichTextLabel for text formatted using BBCode, with support for animated custom effects.

Trees (can also be used to represent tables).

Color picker with RGB and HSV modes.

Controls can be rotated and scaled.

Anchors to keep GUI elements in a specific corner, edge or centered.

Containers to place GUI elements automatically following certain rules.

Flow layouts (similar to autowrapping text).

Margin, centered and aspect ratio layouts.

Draggable splitter layouts.

Scale to multiple resolutions using the canvas_items or viewport stretch modes.

Support any aspect ratio using anchors and the expand stretch aspect.

Built-in theme editor.

Generate a theme based on the current editor theme settings.

Procedural vector-based theming using StyleBoxFlat.

Supports rounded/beveled corners, drop shadows, per-border widths and antialiasing.

Texture-based theming using StyleBoxTexture.

Godot's small distribution size can make it a suitable alternative to frameworks like Electron or Qt.

Direct kinematics and inverse kinematics.

Support for animating any property with customizable interpolation.

Support for calling methods in animation tracks.

Support for playing sounds in animation tracks.

Support for Bézier curves in animation.

Scenes and resources can be saved in text-based or binary formats.

Text-based formats are human-readable and more friendly to version control.

Binary formats are faster to save/load for large scenes/resources.

Read and write text or binary files using FileAccess.

Can optionally be compressed or encrypted.

Read and write JSON files.

Read and write INI-style configuration files using ConfigFile.

Can (de)serialize any Godot datatype, including Vector2/3, Color, ...

Read XML files using XMLParser.

Load and save images, audio/video, fonts and ZIP archives in an exported project without having to go through Godot's import system.

Pack game data into a PCK file (custom format optimized for fast seeking), into a ZIP archive, or directly into the executable for single-file distribution.

Export additional PCK files that can be read by the engine to support mods and DLCs.

Video playback with built-in support for Ogg Theora.

Movie Maker mode to record videos from a running project with synchronized audio and perfect frame pacing.

Low-level access to servers which allows bypassing the scene tree's overhead when needed.

Command line interface for automation.

Export and deploy projects using continuous integration platforms.

Shell completion scripts are available for Bash, zsh and fish.

Print colored text to standard output on all platforms using print_rich.

The editor can detect features used in a project and create a compilation profile, which can be used to create smaller export template binaries with unneeded features disabled.

Support for C++ modules statically linked into the engine binary.

Most built-in modules can be disabled at compile-time to reduce binary size in custom builds. See Optimizing a build for size for details.

Engine and editor written in C++17.

Can be compiled using GCC, Clang and MSVC. MinGW is also supported.

Friendly towards packagers. In most cases, system libraries can be used instead of the ones provided by Godot. The build system doesn't download anything. Builds can be fully reproducible.

Licensed under the permissive MIT license.

Open development process with contributions welcome.

The Godot proposals repository lists features that have been requested by the community and may be implemented in future Godot releases.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Locale codes — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/i18n/locales.html

**Contents:**
- Locale codes
- List of supported language codes
- List of supported script codes
- List of supported country codes
- User-contributed notes

Locale code has the following format: language_Script_COUNTRY_VARIANT, where:

language - 2 or 3-letter language code, in lower case.

Script - optional, 4-letter script code, in title case.

COUNTRY - optional, 2-letter country code, in upper case.

VARIANT - optional, language variant, region and, sort order. A variant can have any number of underscored keywords.

American Sign Language

Seselwa Creole French

Jamaican Creole English

Chimborazo Highland Quichua

Central Atlas Tamazight

Standard Moroccan Tamazight

Unified Canadian Aboriginal

Anatolian Hieroglyphs

Nyiakeng Puachue Hmong

Inscriptional Pahlavi

Inscriptional Parthian

Bosnia and Herzegovina

Caribbean Netherlands

Cocos (Keeling) Islands

Central African Republic

South Georgia and South Sandwich Islands

Heard Island and McDonald Islands

British Indian Ocean Territory

Northern Mariana Islands

St. Pierre and Miquelon

St. Helena, Ascension and Tristan da Cunha

Svalbard and Jan Mayen

Sao Tome and Principe

Turks and Caicos Islands

French Southern Territories

U.S. Outlying Islands

United States of America

St. Vincent and the Grenadines

British Virgin Islands

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Localization using gettext (PO files) — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/i18n/localization_using_gettext.html

**Contents:**
- Localization using gettext (PO files)
- Advantages
- Disadvantages
- Installing gettext tools
- Creating the PO template
  - Automatic generation using the editor
  - Manual creation
- Creating a messages file from a PO template
- Loading a messages file in Godot
- Updating message files to follow the PO template

In addition to importing translations in CSV format, Godot also supports loading translation files written in the GNU gettext format (text-based .po and compiled .mo since Godot 4.0).

For an introduction to gettext, check out A Quick Gettext Tutorial. It's written with C projects in mind, but much of the advice also applies to Godot (with the exception of xgettext).

For the complete documentation, see GNU Gettext.

gettext is a standard format, which can be edited using any text editor or GUI editors such as Poedit. This can be significant as it provides a lot of tools for translators, such as marking outdated strings, finding strings that haven't been translated etc.

gettext supports plurals and context.

gettext is supported by translation platforms such as Transifex and Weblate, which makes it easier for people to collaborate to localization.

Compared to CSV, gettext files work better with version control systems like Git, as each locale has its own messages file.

Multiline strings are more convenient to edit in gettext PO files compared to CSV files.

gettext PO files have a more complex format than CSV and can be harder to grasp for people new to software localization.

People who maintain localization files will have to install gettext tools on their system. However, as Godot supports using text-based message files (.po), translators can test their work without having to install gettext tools.

gettext PO files usually use English as the base language. Translators will use this base language to translate to other languages. You could still user other languages as the base language, but this is not common.

The command line gettext tools are required to perform maintenance operations, such as updating message files. Therefore, it's strongly recommended to install them.

Windows: Download an installer from this page. Any architecture and binary type (shared or static) works; if in doubt, choose the 64-bit static installer.

macOS: Install gettext either using Homebrew with the brew install gettext command, or using MacPorts with the sudo port install gettext command.

Linux: On most distributions, install the gettext package from your distribution's package manager.

For a GUI tool you can get Poedit from its Official website. The basic version is open source and available under the MIT license.

Since Godot 4.0, the editor can generate a PO template automatically from specified scene and GDScript files. This POT generation also supports translation contexts and pluralization if used in a script, with the optional second argument of tr() and the tr_n() method.

Open the Project Settings' Localization > POT Generation tab, then use the Add… button to specify the path to your project's scenes and scripts that contain localizable strings:

Creating a PO template in the Localization > POT Generation tab of the Project Settings

After adding at least one scene or script, click Generate POT in the top-right corner, then specify the path to the output file. This file can be placed anywhere in the project directory, but it's recommended to keep it in a subdirectory such as locale, as each locale will be defined in its own file.

See below for how to add comments for translators or exclude some strings from being added to the PO template for GDScript files.

You can then move over to creating a messages file from a PO template.

Remember to regenerate the PO template after making any changes to localizable strings, or after adding new scenes or scripts. Otherwise, newly added strings will not be localizable and translators won't be able to update translations for outdated strings.

If the automatic generation approach doesn't work out for your needs, you can create a PO template by hand in a text editor. This file can be placed anywhere in the project directory, but it's recommended to keep it in a subdirectory, as each locale will be defined in its own file.

Create a directory named locale in the project directory. In this directory, save a file named messages.pot with the following contents:

Messages in gettext are made of msgid and msgstr pairs. msgid is the source string (usually in English), msgstr will be the translated string.

The msgstr value in PO template files (.pot) should always be empty. Localization will be done in the generated .po files instead.

The msginit command is used to turn a PO template into a messages file. For instance, to create a French localization file, use the following command while in the locale directory:

The command above will create a file named fr.po in the same directory as the PO template.

Alternatively, you can do that graphically using Poedit, or by uploading the POT file to your web platform of choice.

To register a messages file as a translation in a project, open the Project Settings, then go to the Localization tab. In Translations, click Add… then choose the .po or .mo file in the file dialog. The locale will be inferred from the "Language: <code>\n" property in the messages file.

See Internationalizing games for more information on importing and testing translations in Godot.

After updating the PO template, you will have to update message files so that they contain new strings, while removing strings that are no longer present in the PO template. This can be done automatically using the msgmerge tool:

If you want to keep a backup of the original message file (which would be saved as fr.po~ in this example), remove the --backup=none argument.

After running msgmerge, strings which were modified in the source language will have a "fuzzy" comment added before them in the .po file. This comment denotes that the translation should be updated to match the new source string, as the translation will most likely be inaccurate until it's updated.

Strings with "fuzzy" comments will not be read by Godot until the translation is updated and the "fuzzy" comment is removed.

It is possible to check whether a gettext file's syntax is valid.

If you open with Poeditor, it will display the appropriate warnings if there's some syntax errors. You can also verify by running the gettext command below:

If there are syntax errors or warnings, they will be displayed in the console. Otherwise, msgfmt won't output anything.

For large projects with several thousands of strings to translate or more, it can be worth it to use binary (compiled) MO message files instead of text-based PO files. Binary MO files are smaller and faster to read than the equivalent PO files.

You can generate an MO file with the command below:

If the PO file is valid, this command will create an fr.mo file besides the PO file. This MO file can then be loaded in Godot as described above.

The original PO file should be kept in version control so you can update your translation in the future. In case you lose the original PO file and wish to decompile an MO file into a text-based PO file, you can do so with:

The decompiled file will not include comments or fuzzy strings, as these are never compiled in the MO file in the first place.

The built-in editor plugin recognizes a variety of patterns in source code to extract localizable strings from GDScript files, including but not limited to the following:

tr(), tr_n(), atr(), and atr_n() calls;

assigning properties text, placeholder_text, and tooltip_text;

add_tab(), add_item(), set_tab_title(), and other calls;

FileDialog filters like "*.png ; PNG Images".

The argument or right operand must be a constant string, otherwise the plugin will not be able to evaluate the expression and will ignore it.

If the plugin extracts unnecessary strings, you can ignore them with the NO_TRANSLATE comment. You can also provide additional information for translators using the TRANSLATORS: comment. These comments must be placed either on the same line as the recognized pattern or precede it.

The context parameter can be used to differentiate the situation where a translation is used, or to differentiate polysemic words (words with multiple meanings).

Some time or later, you'll add new content to our game, and there will be new strings that need to be translated. When this happens, you'll need to update the existing PO files to include the new strings.

First, generate a new POT file containing all the existing strings plus the newly added strings. After that, merge the existing PO files with the new POT file. There are two ways to do this:

Use a gettext editor, and it should have an option to update a PO file from a POT file.

Use the gettext msgmerge tool:

If you want to keep a backup of the original message file (which would be saved as fr.po~ in this example), remove the --backup=none argument.

If you have any extra file format to deal with, you could write a custom plugin to parse and and extract the strings from the custom file. This custom plugin will extract the strings and write into the POT file when you hit Generate POT. To learn more about how to create the translation parser plugin, see EditorTranslationParserPlugin.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
# Don't remove the two lines below, they're required for gettext to work correctly.
msgid ""
msgstr ""

# Example of a regular string.
msgid "Hello world!"
msgstr ""

# Example of a string with pluralization.
msgid "There is %d apple."
msgid_plural "There are %d apples."
msgstr[0] ""
msgstr[1] ""

# Example of a string with a translation context.
msgctxt "Actions"
msgid "Close"
msgstr ""
```

Example 2 (unknown):
```unknown
msginit --no-translator --input=messages.pot --locale=fr
```

Example 3 (unknown):
```unknown
# The order matters: specify the message file *then* the PO template!
msgmerge --update --backup=none fr.po messages.pot
```

Example 4 (unknown):
```unknown
msgfmt fr.po --check
```

---

## Localization using spreadsheets — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/i18n/localization_using_spreadsheets.html

**Contents:**
- Localization using spreadsheets
- Formatting
- CSV importer
- User-contributed notes

Spreadsheets are one of the most common formats for localizing games. In Godot, spreadsheets are supported through the CSV format. This guide explains how to work with CSVs.

The CSV files must be saved with UTF-8 encoding without a byte order mark.

By default, Microsoft Excel will always save CSV files with ANSI encoding rather than UTF-8. There is no built-in way to do this, but there are workarounds as described here.

We recommend using LibreOffice or Google Sheets instead.

CSV files must be formatted as follows:

The "lang" tags must represent a language, which must be one of the valid locales supported by the engine, or they must start with an underscore (_), which means the related column is served as comment and won't be imported. The "KEY" tags must be unique and represent a string universally (they are usually in uppercase, to differentiate from other strings). These keys will be replaced at runtime by the matching translated string. Note that the case is important, "KEY1" and "Key1" will be different keys. The top-left cell is ignored and can be left empty or having any content. Here's an example:

"Hello" said the man.

"Hola" dijo el hombre.

The same example is shown below as a comma-separated plain text file, which should be the result of editing the above in a spreadsheet. When editing the plain text version, be sure to enclose with double quotes any message that contains commas, line breaks or double quotes, so that commas are not parsed as delimiters, line breaks don't create new entries and double quotes are not parsed as enclosing characters. Be sure to escape any double quotes a message may contain by preceding them with another double quote. Alternatively, you can select another delimiter than comma in the import options.

Godot will treat CSV files as translations by default. It will import them and generate one or more compressed translation resource files next to it.

Importing will also add the translation to the list of translations to load when the game runs, specified in project.godot (or the project settings). Godot allows loading and removing translations at runtime as well.

Select the .csv file and access the Import dock to define import options. You can toggle the compression of the imported translations, and select the delimiter to use when parsing the CSV file.

Be sure to click Reimport after any change to these options.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
keys,en,es,ja
GREET,"Hello, friend!","Hola, amigo!",こんにちは
ASK,How are you?,Cómo está?,元気ですか
BYE,Goodbye,Adiós,さようなら
QUOTE,"""Hello"" said the man.","""Hola"" dijo el hombre.",「こんにちは」男は言いました
```

---

## Making main screen plugins — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/plugins/editor/making_main_screen_plugins.html

**Contents:**
- Making main screen plugins
- What this tutorial covers
- Initializing the plugin
- Main screen scene
- Update the plugin script
- Try the plugin
- User-contributed notes

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

Main screen plugins allow you to create new UIs in the central part of the editor, which appear next to the "2D", "3D", "Script", "Game", and "AssetLib" buttons. Such editor plugins are referred as "Main screen plugins".

This tutorial leads you through the creation of a basic main screen plugin. For the sake of simplicity, our main screen plugin will contain a single button that prints text to the console.

First create a new plugin from the Plugins menu. For this tutorial, we'll put it in a folder called main_screen, but you can use any name you'd like.

The plugin script will come with _enter_tree() and _exit_tree() methods, but for a main screen plugin we need to add a few extra methods. Add five extra methods such that the script looks like this:

The important part in this script is the _has_main_screen() function, which is overloaded so it returns true. This function is automatically called by the editor on plugin activation, to tell it that this plugin adds a new center view to the editor. For now, we'll leave this script as-is and we'll come back to it later.

Create a new scene with a root node derived from Control (for this example plugin, we'll make the root node a CenterContainer). Select this root node, and in the viewport, click the Layout menu and select Full Rect. You also need to enable the Expand vertical size flag in the inspector. The panel now uses all the space available in the main viewport.

Next, let's add a button to our example main screen plugin. Add a Button node, and set the text to "Print Hello" or similar. Add a script to the button like this:

Then connect the "pressed" signal to itself. If you need help with signals, see the Using signals article.

We are done with the main screen panel. Save the scene as main_panel.tscn.

We need to update the main_screen_plugin.gd script so the plugin instances our main panel scene and places it where it needs to be. Here is the full plugin script:

A couple of specific lines were added. MainPanel is a constant that holds a reference to the scene, and we instance it into main_panel_instance.

The _enter_tree() function is called before _ready(). This is where we instance the main panel scene, and add them as children of specific parts of the editor. We use EditorInterface.get_editor_main_screen() to obtain the main editor screen and add our main panel instance as a child to it. We call the _make_visible(false) function to hide the main panel so it doesn't compete for space when first activating the plugin.

The _exit_tree() function is called when the plugin is deactivated. If the main screen still exists, we call queue_free() to free the instance and remove it from memory.

The _make_visible() function is overridden to hide or show the main panel as needed. This function is automatically called by the editor when the user clicks on the main viewport buttons at the top of the editor.

The _get_plugin_name() and _get_plugin_icon() functions control the displayed name and icon for the plugin's main viewport button.

Another function you can add is the handles() function, which allows you to handle a node type, automatically focusing the main screen when the type is selected. This is similar to how clicking on a 3D node will automatically switch to the 3D viewport.

Activate the plugin in the Project Settings. You'll observe a new button next to 2D, 3D, Script above the main viewport. Clicking it will take you to your new main screen plugin, and the button in the middle will print text.

If you would like to try a finished version of this plugin, check out the plugin demos here: https://github.com/godotengine/godot-demo-projects/tree/master/plugins

If you would like to see a more complete example of what main screen plugins are capable of, check out the 2.5D demo projects here: https://github.com/godotengine/godot-demo-projects/tree/master/misc/2.5d

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
@tool
extends EditorPlugin


func _enter_tree():
    pass


func _exit_tree():
    pass


func _has_main_screen():
    return true


func _make_visible(visible):
    pass


func _get_plugin_name():
    return "Main Screen Plugin"


func _get_plugin_icon():
    return EditorInterface.get_editor_theme().get_icon("Node", "EditorIcons")
```

Example 2 (unknown):
```unknown
#if TOOLS
using Godot;

[Tool]
public partial class MainScreenPlugin : EditorPlugin
{
    public override void _EnterTree()
    {

    }

    public override void _ExitTree()
    {

    }

    public override bool _HasMainScreen()
    {
        return true;
    }

    public override void _MakeVisible(bool visible)
    {

    }

    public override string _GetPluginName()
    {
        return "Main Screen Plugin";
    }

    public override Texture2D _GetPluginIcon()
    {
        return EditorInterface.Singleton.GetEditorTheme().GetIcon("Node", "EditorIcons");
    }
}
#endif
```

Example 3 (unknown):
```unknown
@tool
extends Button


func _on_print_hello_pressed():
    print("Hello from the main screen plugin!")
```

Example 4 (unknown):
```unknown
using Godot;

[Tool]
public partial class PrintHello : Button
{
    private void OnPrintHelloPressed()
    {
        GD.Print("Hello from the main screen plugin!");
    }
}
```

---

## Making plugins — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/plugins/editor/making_plugins.html

**Contents:**
- Making plugins
- About plugins
- Creating a plugin
  - The script file
- A custom node
- A custom dock
  - Checking the results
- Registering autoloads/singletons in plugins
- Using sub-plugins
- Going beyond

A plugin is a great way to extend the editor with useful tools. It can be made entirely with GDScript and standard scenes, without even reloading the editor. Unlike modules, you don't need to create C++ code nor recompile the engine. While this makes plugins less powerful, there are still many things you can do with them. Note that a plugin is similar to any scene you can already make, except it is created using a script to add editor functionality.

This tutorial will guide you through the creation of two plugins so you can understand how they work and be able to develop your own. The first is a custom node that you can add to any scene in the project, and the other is a custom dock added to the editor.

Before starting, create a new empty project wherever you want. This will serve as a base to develop and test the plugins.

The first thing you need for the editor to identify a new plugin is to create two files: a plugin.cfg for configuration and a tool script with the functionality. Plugins have a standard path like addons/plugin_name inside the project folder. Godot provides a dialog for generating those files and placing them where they need to be.

In the main toolbar, click the Project dropdown. Then click Project Settings.... Go to the Plugins tab and then click on the Create New Plugin button in the top-right.

You will see the dialog appear, like so:

The placeholder text in each field describes how it affects the plugin's creation of the files and the config file's values.

To continue with the example, use the following values:

Unchecking the Activate now? option in C# is always required because, like every other C# script, the EditorPlugin script needs to be compiled which requires building the project. After building the project the plugin can be enabled in the Plugins tab of Project Settings.

You should end up with a directory structure like this:

plugin.cfg is an INI file with metadata about your plugin. The name and description help people understand what it does. Your name helps you get properly credited for your work. The version number helps others know if they have an outdated version; if you are unsure on how to come up with the version number, check out Semantic Versioning. The main script file will instruct Godot what your plugin does in the editor once it is active.

Upon creation of the plugin, the dialog will automatically open the EditorPlugin script for you. The script has two requirements that you cannot change: it must be a @tool script, or else it will not load properly in the editor, and it must inherit from EditorPlugin.

In addition to the EditorPlugin script, any other GDScript that your plugin uses must also be a tool. Any GDScript without @tool used by the editor will act like an empty file!

It's important to deal with initialization and clean-up of resources. A good practice is to use the virtual function _enter_tree() to initialize your plugin and _exit_tree() to clean it up. Thankfully, the dialog generates these callbacks for you. Your script should look something like this:

This is a good template to use when creating new plugins.

Sometimes you want a certain behavior in many nodes, such as a custom scene or control that can be reused. Instancing is helpful in a lot of cases, but sometimes it can be cumbersome, especially if you're using it in many projects. A good solution to this is to make a plugin that adds a node with a custom behavior.

Nodes added via an EditorPlugin are "CustomType" nodes. While they work with any scripting language, they have fewer features than the Script Class system. If you are writing GDScript or NativeScript, we recommend using Script Classes instead.

To create a new node type, you can use the function add_custom_type() from the EditorPlugin class. This function can add new types to the editor (nodes or resources). However, before you can create the type, you need a script that will act as the logic for the type. While that script doesn't have to use the @tool annotation, it can be added so the script runs in the editor.

For this tutorial, we'll create a button that prints a message when clicked. For that, we'll need a script that extends from Button. It could also extend BaseButton if you prefer:

That's it for our basic button. You can save this as my_button.gd inside the plugin folder. You'll also need a 16×16 icon to show in the scene tree. If you don't have one, you can grab the default one from the engine and save it in your addons/my_custom_node folder as icon.png, or use the default Godot logo (preload("res://icon.svg")).

SVG images that are used as custom node icons should have the Editor > Scale With Editor Scale and Editor > Convert Colors With Editor Theme import options enabled. This allows icons to follow the editor's scale and theming settings if the icons are designed with the same color palette as Godot's own icons.

Now, we need to add it as a custom type so it shows on the Create New Node dialog. For that, change the custom_node.gd script to the following:

With that done, the plugin should already be available in the plugin list in the Project Settings, so activate it as explained in Checking the results.

Then try it out by adding your new node:

When you add the node, you can see that it already has the script you created attached to it. Set a text to the button, save and run the scene. When you click the button, you can see some text in the console:

Sometimes, you need to extend the editor and add tools that are always available. An easy way to do it is to add a new dock with a plugin. Docks are just scenes based on Control, so they are created in a way similar to usual GUI scenes.

Creating a custom dock is done just like a custom node. Create a new plugin.cfg file in the addons/my_custom_dock folder, then add the following content to it:

Then create the script custom_dock.gd in the same folder. Fill it with the template we've seen before to get a good start.

Since we're trying to add a new custom dock, we need to create the contents of the dock. This is nothing more than a standard Godot scene: just create a new scene in the editor then edit it.

For an editor dock, the root node must be a Control or one of its child classes. For this tutorial, you can create a single button. The name of the root node will also be the name that appears on the dock tab, so be sure to give it a short and descriptive name. Also, don't forget to add some text to your button.

Save this scene as my_dock.tscn. Now, we need to grab the scene we created then add it as a dock in the editor. For this, you can rely on the function add_control_to_dock() from the EditorPlugin class.

You need to select a dock position and define the control to add (which is the scene you just created). Don't forget to remove the dock when the plugin is deactivated. The script could look like this:

Note that, while the dock will initially appear at its specified position, the user can freely change its position and save the resulting layout.

It's now time to check the results of your work. Open the Project Settings and click on the Plugins tab. Your plugin should be the only one on the list.

You can see the plugin is not enabled. Click the Enable checkbox to activate the plugin. The dock should become visible before you even close the settings window. You should now have a custom dock:

It is possible for editor plugins to automatically register autoloads when the plugin is enabled. This also includes unregistering the autoload when the plugin is disabled.

This makes setting up plugins faster for users, as they no longer have to manually add autoloads to their project settings if your editor plugin requires the use of an autoload.

Use the following code to register a singleton from an editor plugin:

Often a plugin adds multiple things, for example a custom node and a panel. In those cases it might be easier to have a separate plugin script for each of those features. Sub-plugins can be used for this.

First create all plugins and sub plugins as normal plugins:

Then move the sub plugins into the main plugin folder:

Godot will hide sub-plugins from the plugin list, so that a user can't enable or disable them. Instead the main plugin script should enable and disable sub-plugins like this:

Now that you've learned how to make basic plugins, you can extend the editor in several ways. Lots of functionality can be added to the editor with GDScript; it is a powerful way to create specialized editors without having to delve into C++ modules.

You can make your own plugins to help yourself and share them in the Asset Library so that people can benefit from your work.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
Plugin Name: My Custom Node
Subfolder: my_custom_node
Description: A custom node made to extend the Godot Engine.
Author: Your Name Here
Version: 1.0.0
Language: GDScript
Script Name: custom_node.gd
Activate now: No
```

Example 2 (unknown):
```unknown
Plugin Name: My Custom Node
Subfolder: MyCustomNode
Description: A custom node made to extend the Godot Engine.
Author: Your Name Here
Version: 1.0.0
Language: C#
Script Name: CustomNode.cs
Activate now: No
```

Example 3 (unknown):
```unknown
@tool
extends EditorPlugin


func _enter_tree():
    # Initialization of the plugin goes here.
    pass


func _exit_tree():
    # Clean-up of the plugin goes here.
    pass
```

Example 4 (unknown):
```unknown
#if TOOLS
using Godot;

[Tool]
public partial class CustomNode : EditorPlugin
{
    public override void _EnterTree()
    {
        // Initialization of the plugin goes here.
    }

    public override void _ExitTree()
    {
        // Clean-up of the plugin goes here.
    }
}
#endif
```

---

## Managing editor features — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/editor/managing_editor_features.html

**Contents:**
- Managing editor features
- Introduction
- Creating a profile
- Sharing a profile
- User-contributed notes

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

In certain situations, it may be desirable to limit what features can be used in the Godot editor. For example, a UI designer on a team who doesn't need to see 3D features, or an educator slowly introducing features to students. Godot has a built-in system called "feature profiles" to do this.

With feature profiles, major features and nodes can be hidden from the editor. This only hides parts of the interface and does not actually remove support for these features, so scenes and scripts relying on those features will still work fine. This also means feature profiles are not an optimization technique. For information on how to optimize Godot see Performance.

To manage editor features go to Editor > Manage Editor Features. This will open the Manage Editor Feature Profiles window. By default there will be no profile. Click on Create Profile and give it a name. You will then see a list of all the features in the Godot editor.

The first section allows major editor features to be removed, such as the 3D editor or scripting editor. Below the main features is every class and node in Godot, which can be disabled as well. Click on a node and all of its properties and options will be listed in the Extra Items box, these can all be individually disabled.

To share profiles between editors click on the Export button. Save the custom profile somewhere as a .profile file. To use this in another editor open that editor's Manage Editor Feature Profiles window and click import, then select the .profile file.

This process is potentially cumbersome however if a large amount of computers need custom profiles. As an alternative, you can enable self-contained mode for Godot, which allows putting all editor configuration in the same folder as the editor binary. See Self-contained mode for details.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Manually changing application icon for Windows — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/export/changing_application_icon_for_windows.html

**Contents:**
- Manually changing application icon for Windows
- Creating a custom ICO file
- Changing the taskbar icon
- Changing the file icon
- Testing the result
- User-contributed notes

Windows applications use a Windows only format called ICO for their file icon and taskbar icon. Since Godot 4.1, Godot can create an ICO file for you based on the icon file defined in the Windows export preset. Supported formats are PNG, WebP, and SVG. If no icon is defined in the Windows export preset, the application/config/icon project setting is used automatically instead.

This means you no longer need to follow the steps in this section to manually create an ICO file, unless you wish to have control over the icon design depending on its displayed size.

You can create your application icon in any program but you will have to convert it to an ICO file using a program such as GIMP.

This video tutorial goes over how to export an ICO file with GIMP.

It is also possible to convert a PNG image to an hiDPI-friendly ICO file using this ImageMagick command:

Depending on which version of ImageMagick you installed, you might need to leave out the magick and run this command instead:

For the ICO file to effectively replace the default Godot icon, it must contain all the sizes included in the default Godot icon: 16×16, 32×32, 48×48, 64×64, 128×128, 256×256. If the ICO file does not contain all the sizes, the default Godot icon will be kept for the sizes that weren't overridden.

The above ImageMagick command takes this into account.

The taskbar icon is the icon that shows up on the taskbar when your project is running.

To change the taskbar icon, go to Project > Project Settings > Application > Config, make sure Advanced Settings are enabled to see the setting, then go to Windows Native Icon. Click on the folder icon and select your ICO file.

This setting only changes the icon for your exported game on Windows. To set the icon for macOS, use Macos Native Icon. And for any other platform, use the Icon setting.

The file icon is the icon of the executable that you click on to start the project.

To do that, you will need to specify the icon when exporting. Go to Project > Export. Assuming you have already created a Windows Desktop preset, select your icon in ICO format in the Application > Icon field.

You can now export the project. If it worked correctly, you should see this:

If your icon isn't showing up properly try clearing the icon cache. To do so, open the Run dialog and enter ie4uinit.exe -ClearIconCache or ie4uinit.exe -show.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
magick convert icon.png -define icon:auto-resize=256,128,64,48,32,16 icon.ico
```

Example 2 (unknown):
```unknown
convert icon.png -define icon:auto-resize=256,128,64,48,32,16 icon.ico
```

---

## Math — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/math/index.html

**Contents:**
- Math

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Matrices and transforms — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/math/matrices_and_transforms.html

**Contents:**
- Matrices and transforms
- Introduction
  - Matrix components and the Identity matrix
  - Scaling the transformation matrix
  - Rotating the transformation matrix
  - Basis of the transformation matrix
  - Translating the transformation matrix
  - Putting it all together
  - Shearing the transformation matrix (advanced)
- Practical applications of transforms

Before reading this tutorial, we recommend that you thoroughly read and understand the Vector math tutorial, as this tutorial requires a knowledge of vectors.

This tutorial is about transformations and how we represent them in Godot using matrices. It is not a full in-depth guide to matrices. Transformations are most of the time applied as translation, rotation, and scale, so we will focus on how to represent those with matrices.

Most of this guide focuses on 2D, using Transform2D and Vector2, but the way things work in 3D is very similar.

As mentioned in the previous tutorial, it is important to remember that in Godot, the Y axis points down in 2D. This is the opposite of how most schools teach linear algebra, with the Y axis pointing up.

The convention is that the X axis is red, the Y axis is green, and the Z axis is blue. This tutorial is color-coded to match these conventions, but we will also represent the origin vector with a blue color.

The identity matrix represents a transform with no translation, no rotation, and no scale. Let's start by looking at the identity matrix and how its components relate to how it visually appears.

Matrices have rows and columns, and a transformation matrix has specific conventions on what each does.

In the image above, we can see that the red X vector is represented by the first column of the matrix, and the green Y vector is likewise represented by the second column. A change to the columns will change these vectors. We will see how they can be manipulated in the next few examples.

You should not worry about manipulating rows directly, as we usually work with columns. However, you can think of the rows of the matrix as showing which vectors contribute to moving in a given direction.

When we refer to a value such as t.x.y, that's the Y component of the X column vector. In other words, the bottom-left of the matrix. Similarly, t.x.x is top-left, t.y.x is top-right, and t.y.y is bottom-right, where t is the Transform2D.

Applying a scale is one of the easiest operations to understand. Let's start by placing the Godot logo underneath our vectors so that we can visually see the effects on an object:

Now, to scale the matrix, all we need to do is multiply each component by the scale we want. Let's scale it up by 2. 1 times 2 becomes 2, and 0 times 2 becomes 0, so we end up with this:

To do this in code, we multiply each of the vectors:

If we wanted to return it to its original scale, we can multiply each component by 0.5. That's pretty much all there is to scaling a transformation matrix.

To calculate the object's scale from an existing transformation matrix, you can use length() on each of the column vectors.

In actual projects, you can use the scaled() method to perform scaling.

We'll start the same way as earlier, with the Godot logo underneath the identity matrix:

As an example, let's say we want to rotate our Godot logo clockwise by 90 degrees. Right now the X axis points right and the Y axis points down. If we rotate these in our head, we would logically see that the new X axis should point down and the new Y axis should point left.

You can imagine that you grab both the Godot logo and its vectors, and then spin it around the center. Wherever you finish spinning, the orientation of the vectors determines what the matrix is.

We need to represent "down" and "left" in normal coordinates, so means we'll set X to (0, 1) and Y to (-1, 0). These are also the values of Vector2.DOWN and Vector2.LEFT. When we do this, we get the desired result of rotating the object:

If you have trouble understanding the above, try this exercise: Cut a square of paper, draw X and Y vectors on top of it, place it on graph paper, then rotate it and note the endpoints.

To perform rotation in code, we need to be able to calculate the values programmatically. This image shows the formulas needed to calculate the transformation matrix from a rotation angle. Don't worry if this part seems complicated, I promise it's the hardest thing you need to know.

Godot represents all rotations with radians, not degrees. A full turn is TAU or PI*2 radians, and a quarter turn of 90 degrees is TAU/4 or PI/2 radians. Working with TAU usually results in more readable code.

Fun fact: In addition to Y being down in Godot, rotation is represented clockwise. This means that all the math and trig functions behave the same as a Y-is-up CCW system, since these differences "cancel out". You can think of rotations in both systems being "from X to Y".

In order to perform a rotation of 0.5 radians (about 28.65 degrees), we plug in a value of 0.5 to the formula above and evaluate to find what the actual values should be:

Here's how that would be done in code (place the script on a Node2D):

To calculate the object's rotation from an existing transformation matrix, you can use atan2(t.x.y, t.x.x), where t is the Transform2D.

In actual projects, you can use the rotated() method to perform rotations.

So far we have only been working with the x and y, vectors, which are in charge of representing rotation, scale, and/or shearing (advanced, covered at the end). The X and Y vectors are together called the basis of the transformation matrix. The terms "basis" and "basis vectors" are important to know.

You might have noticed that Transform2D actually has three Vector2 values: x, y, and origin. The origin value is not part of the basis, but it is part of the transform, and we need it to represent position. From now on we'll keep track of the origin vector in all examples. You can think of origin as another column, but it's often better to think of it as completely separate.

Note that in 3D, Godot has a separate Basis structure for holding the three Vector3 values of the basis, since the code can get complex and it makes sense to separate it from Transform3D (which is composed of one Basis and one extra Vector3 for the origin).

Changing the origin vector is called translating the transformation matrix. Translating is basically a technical term for "moving" the object, but it explicitly does not involve any rotation.

Let's work through an example to help understand this. We will start with the identity transform like last time, except we will keep track of the origin vector this time.

If we want to move the object to a position of (1, 2), we need to set its origin vector to (1, 2):

There is also a translated_local() method, which performs a different operation to adding or changing origin directly. The translated_local() method will translate the object relative to its own rotation. For example, an object rotated 90 degrees clockwise will move to the right when translated_local() with Vector2.UP. To translate relative to the global/parent frame use translated() instead.

Godot's 2D uses coordinates based on pixels, so in actual projects you will want to translate by hundreds of units.

We're going to apply everything we mentioned so far onto one transform. To follow along, create a project with a Sprite2D node and use the Godot logo for the texture resource.

Let's set the translation to (350, 150), rotate by -0.5 rad, and scale by 3. I've posted a screenshot, and the code to reproduce it, but I encourage you to try and reproduce the screenshot without looking at the code!

If you are only looking for how to use transformation matrices, feel free to skip this section of the tutorial. This section explores an uncommonly used aspect of transformation matrices for the purpose of building an understanding of them.

Node2D provides a shearing property out of the box.

You may have noticed that a transform has more degrees of freedom than the combination of the above actions. The basis of a 2D transformation matrix has four total numbers in two Vector2 values, while a rotation value and a Vector2 for scale only has 3 numbers. The high-level concept for the missing degree of freedom is called shearing.

Normally, you will always have the basis vectors perpendicular to each other. However, shearing can be useful in some situations, and understanding shearing helps you understand how transforms work.

To show you visually how it will look, let's overlay a grid onto the Godot logo:

Each point on this grid is obtained by adding the basis vectors together. The bottom-right corner is X + Y, while the top-right corner is X - Y. If we change the basis vectors, the entire grid moves with it, as the grid is composed of the basis vectors. All lines on the grid that are currently parallel will remain parallel no matter what changes we make to the basis vectors.

As an example, let's set Y to (1, 1):

You can't set the raw values of a Transform2D in the editor, so you must use code if you want to shear the object.

Due to the vectors no longer being perpendicular, the object has been sheared. The bottom-center of the grid, which is (0, 1) relative to itself, is now located at a world position of (1, 1).

The intra-object coordinates are called UV coordinates in textures, so let's borrow that terminology for here. To find the world position from a relative position, the formula is U * X + V * Y, where U and V are numbers and X and Y are the basis vectors.

The bottom-right corner of the grid, which is always at the UV position of (1, 1), is at the world position of (2, 1), which is calculated from X*1 + Y*1, which is (1, 0) + (1, 1), or (1 + 1, 0 + 1), or (2, 1). This matches up with our observation of where the bottom-right corner of the image is.

Similarly, the top-right corner of the grid, which is always at the UV position of (1, -1), is at the world position of (0, -1), which is calculated from X*1 + Y*-1, which is (1, 0) - (1, 1), or (1 - 1, 0 - 1), or (0, -1). This matches up with our observation of where the top-right corner of the image is.

Hopefully you now fully understand how a transformation matrix affects the object, and the relationship between the basis vectors and how the object's "UV" or "intra-coordinates" have their world position changed.

In Godot, all transform math is done relative to the parent node. When we refer to "world position", that would be relative to the node's parent instead, if the node had a parent.

If you would like additional explanation, you should check out 3Blue1Brown's excellent video about linear transformations: https://www.youtube.com/watch?v=kYB8IZa5AuE

In actual projects, you will usually be working with transforms inside transforms by having multiple Node2D or Node3D nodes parented to each other.

However, it's useful to understand how to manually calculate the values we need. We will go over how you could use Transform2D or Transform3D to manually calculate transforms of nodes.

There are many cases where you'd want to convert a position in and out of a transform. For example, if you have a position relative to the player and would like to find the world (parent-relative) position, or if you have a world position and want to know where it is relative to the player.

We can find what a vector relative to the player would be defined in world space as using the * operator:

And we can use the * operator in the opposite order to find a what world space position would be if it was defined relative to the player:

If you know in advance that the transform is positioned at (0, 0), you can use the "basis_xform" or "basis_xform_inv" methods instead, which skip dealing with translation.

A common operation, especially in 3D games, is to move an object relative to itself. For example, in first-person shooter games, you would want the character to move forward (-Z axis) when you press W.

Since the basis vectors are the orientation relative to the parent, and the origin vector is the position relative to the parent, we can add multiples of the basis vectors to move an object relative to itself.

This code moves an object 100 units to its own right:

For moving in 3D, you would need to replace "x" with "basis.x".

In actual projects, you can use translate_object_local in 3D or move_local_x and move_local_y in 2D to do this.

One of the most important things to know about transforms is how you can use several of them together. A parent node's transform affects all of its children. Let's dissect an example.

In this image, the child node has a "2" after the component names to distinguish them from the parent node. It might look a bit overwhelming with so many numbers, but remember that each number is displayed twice (next to the arrows and also in the matrices), and that almost half of the numbers are zero.

The only transformations going on here are that the parent node has been given a scale of (2, 1), the child has been given a scale of (0.5, 0.5), and both nodes have been given positions.

All child transformations are affected by the parent transformations. The child has a scale of (0.5, 0.5), so you would expect it to be a 1:1 ratio square, and it is, but only relative to the parent. The child's X vector ends up being (1, 0) in world space, because it is scaled by the parent's basis vectors. Similarly, the child node's origin vector is set to (1, 1), but this actually moves it (2, 1) in world space, due to the parent node's basis vectors.

To calculate a child transform's world space transform manually, this is the code we would use:

In actual projects, we can find the world transform of the child by applying one transform onto another using the * operator:

When multiplying matrices, order matters! Don't mix them up.

Lastly, applying the identity transform will always do nothing.

If you would like additional explanation, you should check out 3Blue1Brown's excellent video about matrix composition: https://www.youtube.com/watch?v=XkY2DOUCWMU

The "affine_inverse" function returns a transform that "undoes" the previous transform. This can be useful in some situations. Let's take a look at a few examples.

Multiplying an inverse transform by the normal transform undoes all transformations:

Transforming a position by a transform and its inverse results in the same position:

One of the great things about transformation matrices is that they work very similarly between 2D and 3D transformations. All the code and formulas used above for 2D work the same in 3D, with 3 exceptions: the addition of a third axis, that each axis is of type Vector3, and also that Godot stores the Basis separately from the Transform3D, since the math can get complex and it makes sense to separate it.

All of the concepts for how translation, rotation, scale, and shearing work in 3D are all the same compared to 2D. To scale, we take each component and multiply it; to rotate, we change where each basis vector is pointing; to translate, we manipulate the origin; and to shear, we change the basis vectors to be non-perpendicular.

If you would like, it's a good idea to play around with transforms to get an understanding of how they work. Godot allows you to edit 3D transform matrices directly from the inspector. You can download this project which has colored lines and cubes to help visualize the Basis vectors and the origin in both 2D and 3D: https://github.com/godotengine/godot-demo-projects/tree/master/misc/matrix_transform

You cannot edit Node2D's transform matrix directly in Godot 4.0's inspector. This may be changed in a future release of Godot.

If you would like additional explanation, you should check out 3Blue1Brown's excellent video about 3D linear transformations: https://www.youtube.com/watch?v=rHLEWRxRGiM

The biggest difference between 2D and 3D transformation matrices is how you represent rotation by itself without the basis vectors.

With 2D, we have an easy way (atan2) to switch between a transformation matrix and an angle. In 3D, rotation is too complex to represent as one number. There is something called Euler angles, which can represent rotations as a set of 3 numbers, however, they are limited and not very useful, except for trivial cases.

In 3D we do not typically use angles, we either use a transformation basis (used pretty much everywhere in Godot), or we use quaternions. Godot can represent quaternions using the Quaternion struct. My suggestion to you is to completely ignore how they work under-the-hood, because they are very complicated and unintuitive.

However, if you really must know how it works, here are some great resources, which you can follow in order:

https://www.youtube.com/watch?v=mvmuCPvRoWQ

https://www.youtube.com/watch?v=d4EgbgTm0Bg

https://eater.net/quaternions

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
var t = Transform2D()
# Scale
t.x *= 2
t.y *= 2
transform = t # Change the node's transform to what we calculated.
```

Example 2 (unknown):
```unknown
Transform2D t = Transform2D.Identity;
// Scale
t.X *= 2;
t.Y *= 2;
Transform = t; // Change the node's transform to what we calculated.
```

Example 3 (unknown):
```unknown
var rot = 0.5 # The rotation to apply.
var t = Transform2D()
t.x.x = cos(rot)
t.y.y = cos(rot)
t.x.y = sin(rot)
t.y.x = -sin(rot)
transform = t # Change the node's transform to what we calculated.
```

Example 4 (unknown):
```unknown
float rot = 0.5f; // The rotation to apply.
Transform2D t = Transform2D.Identity;
t.X.X = t.Y.Y = Mathf.Cos(rot);
t.X.Y = t.Y.X = Mathf.Sin(rot);
t.Y.X *= -1;
Transform = t; // Change the node's transform to what we calculated.
```

---

## Migrating to a new version — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/migrating/index.html

**Contents:**
- Migrating to a new version

Godot loosely follows a semantic versioning system, where compatibility is assumed between minor and patch releases, while major releases can break it. As such, it is generally not recommended to move projects between major versions during their development, especially if you've been working on them for a significant amount of time.

Still, new features, usability improvements, or paradigm shifts in engine's internals may incentivize you to upgrade. Below is a list of articles that should assist you when upgrading your project between versions. Each article would try its best to document every important difference and provide you with a migration path.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Mouse and input coordinates — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/inputs/mouse_and_input_coordinates.html

**Contents:**
- Mouse and input coordinates
- About
- Hardware display coordinates
- Viewport display coordinates
- User-contributed notes

The reason for this small tutorial is to clear up many common mistakes about input coordinates, obtaining mouse position and screen resolution, etc.

Using hardware coordinates makes sense in the case of writing complex UIs meant to run on PC, such as editors, MMOs, tools, etc. However, it does not make as much sense outside of that scope.

Godot uses viewports to display content, and viewports can be scaled by several options (see Multiple resolutions tutorial). Use, then, the functions in nodes to obtain the mouse coordinates and viewport size, for example:

Alternatively, it's possible to ask the viewport for the mouse position:

When the mouse mode is set to Input.MOUSE_MODE_CAPTURED, the event.position value from InputEventMouseMotion is the center of the screen. Use event.relative instead of event.position and event.velocity to process mouse movement and position changes.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
func _input(event):
    # Mouse in viewport coordinates.
    if event is InputEventMouseButton:
        print("Mouse Click/Unclick at: ", event.position)
    elif event is InputEventMouseMotion:
        print("Mouse Motion at: ", event.position)

    # Print the size of the viewport.
    print("Viewport Resolution is: ", get_viewport().get_visible_rect().size)
```

Example 2 (unknown):
```unknown
public override void _Input(InputEvent @event)
{
    // Mouse in viewport coordinates.
    if (@event is InputEventMouseButton eventMouseButton)
    {
        GD.Print("Mouse Click/Unclick at: ", eventMouseButton.Position);
    }
    else if (@event is InputEventMouseMotion eventMouseMotion)
    {
        GD.Print("Mouse Motion at: ", eventMouseMotion.Position);
    }

    // Print the size of the viewport.
    GD.Print("Viewport Resolution is: ", GetViewport().GetVisibleRect().Size);
}
```

Example 3 (unknown):
```unknown
get_viewport().get_mouse_position()
```

Example 4 (unknown):
```unknown
GetViewport().GetMousePosition();
```

---

## Multiple resolutions — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/rendering/multiple_resolutions.html

**Contents:**
- Multiple resolutions
- The problem of multiple resolutions
- One size fits all
- Base size
- Resizing
- Stretch settings
  - Stretch Mode
  - Stretch Aspect
  - Stretch Scale
  - Stretch Scale Mode

Developers often have trouble understanding how to best support multiple resolutions in their games. For desktop and console games, this is more or less straightforward, as most screen aspect ratios are 16:9 and resolutions are standard (720p, 1080p, 1440p, 4K, …).

For mobile games, at first, it was easy. For many years, the iPhone and iPad used the same resolution. When Retina was implemented, they just doubled the pixel density; most developers had to supply assets in default and double resolutions.

Nowadays, this is no longer the case, as there are plenty of different screen sizes, densities, and aspect ratios. Non-conventional sizes are also becoming increasingly popular, such as ultrawide displays.

For 3D rendering, there is not much of a need to support multiple resolutions. Thanks to its vector-based nature, 3D geometry will just fill the screen based on the viewport size. For 2D and game UIs, this is a different matter, as art needs to be created using specific pixel sizes in software such as Photoshop, GIMP or Krita.

Since layouts, aspect ratios, resolutions, and pixel densities can change so much, it is no longer possible to design UIs for every specific screen. Another method must be used.

The most common approach is to use a single base resolution and then fit it to everything else. This resolution is how most players are expected to play the game (given their hardware). For mobile, Google has useful stats online, and for desktop, Steam also does.

As an example, Steam shows that the most common primary display resolution is 1920×1080, so a sensible approach is to develop a game for this resolution, then handle scaling for different sizes and aspect ratios.

Godot provides several useful tools to do this easily.

You can see how Godot's support for multiple resolutions works in action using the Multiple Resolutions and Aspect Ratios demo project.

A base size for the window can be specified in the Project Settings under Display → Window.

However, what it does is not completely obvious; the engine will not attempt to switch the monitor to this resolution. Rather, think of this setting as the "design size", i.e. the size of the area that you work with in the editor. This setting corresponds directly to the size of the blue rectangle in the 2D editor.

There is often a need to support devices with screen and window sizes that are different from this base size. Godot offers many ways to control how the viewport will be resized and stretched to different screen sizes.

On this page, window refers to the screen area allotted to your game by the system, while viewport refers to the root object (accessible from get_tree().root) which the game controls to fill this screen area. This viewport is a Window instance. Recall from the introduction that all Window objects are viewports.

To configure the stretch base size at runtime from a script, use the get_tree().root.content_scale_size property (see Window.content_scale_size). Changing this value can indirectly change the size of 2D elements. However, to provide a user-accessible scaling option, using Stretch Scale is recommended as it's easier to adjust.

Godot follows a modern approach to multiple resolutions. The engine will never change the monitor's resolution on its own. While changing the monitor's resolution is the most efficient approach, it's also the least reliable approach as it can leave the monitor stuck on a low resolution if the game crashes. This is especially common on macOS or Linux which don't handle resolution changes as well as Windows.

Changing the monitor's resolution also removes any control from the game developer over filtering and aspect ratio stretching, which can be important to ensure correct display for pixel art games.

On top of that, changing the monitor's resolution makes alt-tabbing in and out of a game much slower since the monitor has to change resolutions every time this is done.

There are several types of devices, with several types of screens, which in turn have different pixel density and resolutions. Handling all of them can be a lot of work, so Godot tries to make the developer's life a little easier. The Viewport node has several functions to handle resizing, and the root node of the scene tree is always a viewport (scenes loaded are instanced as a child of it, and it can always be accessed by calling get_tree().root or get_node("/root")).

In any case, while changing the root Viewport params is probably the most flexible way to deal with the problem, it can be a lot of work, code and guessing, so Godot provides a set of parameters in the project settings to handle multiple resolutions.

To render 3D at a lower resolution than 2D elements (without needing separate viewports), you can use Godot's resolution scaling support. This is a good way to improve performance significantly in GPU-bottlenecked scenarios. This works with any stretch mode and stretch aspect combination.

Stretch settings are located in the project settings and provide several options:

The Stretch Mode setting defines how the base size is stretched to fit the resolution of the window or screen. The animations below use a "base size" of just 16×9 pixels to demonstrate the effect of different stretch modes. A single sprite, also 16×9 pixels in size, covers the entire viewport, and a diagonal Line2D is added on top of it:

Stretch Mode = Disabled (default): No stretching happens. One unit in the scene corresponds to one pixel on the screen. In this mode, the Stretch Aspect setting has no effect.

Stretch Mode = Canvas Items: In this mode, the base size specified in width and height in the project settings is stretched to cover the whole screen (taking the Stretch Aspect setting into account). This means that everything is rendered directly at the target resolution. 3D is unaffected, while in 2D, there is no longer a 1:1 correspondence between sprite pixels and screen pixels, which may result in scaling artifacts.

Stretch Mode = Viewport: Viewport scaling means that the size of the root Viewport is set precisely to the base size specified in the Project Settings' Display section. The scene is rendered to this viewport first. Finally, this viewport is scaled to fit the screen (taking the Stretch Aspect setting into account).

To configure the stretch mode at runtime from a script, use the get_tree().root.content_scale_mode property (see Window.content_scale_mode and the ContentScaleMode enum).

The second setting is the stretch aspect. Note that this only takes effect if Stretch Mode is set to something other than Disabled.

In the animations below, you will notice gray and black areas. The black areas are added by the engine and cannot be drawn into. The gray areas are part of your scene, and can be drawn to. The gray areas correspond to the region outside the blue frame you see in the 2D editor.

Stretch Aspect = Ignore: Ignore the aspect ratio when stretching the screen. This means that the original resolution will be stretched to exactly fill the screen, even if it's wider or narrower. This may result in nonuniform stretching: things looking wider or taller than designed.

Stretch Aspect = Keep: Keep aspect ratio when stretching the screen. This means that the viewport retains its original size regardless of the screen resolution, and black bars will be added to the top/bottom of the screen ("letterboxing") or the sides ("pillarboxing").

This is a good option if you know the aspect ratio of your target devices in advance, or if you don't want to handle different aspect ratios.

Stretch Aspect = Keep Width: Keep aspect ratio when stretching the screen. If the screen is wider than the base size, black bars are added at the left and right (pillarboxing). But if the screen is taller than the base resolution, the viewport will be grown in the vertical direction (and more content will be visible to the bottom). You can also think of this as "Expand Vertically".

This is usually the best option for creating GUIs or HUDs that scale, so some controls can be anchored to the bottom (Size and anchors).

Stretch Aspect = Keep Height: Keep aspect ratio when stretching the screen. If the screen is taller than the base size, black bars are added at the top and bottom (letterboxing). But if the screen is wider than the base resolution, the viewport will be grown in the horizontal direction (and more content will be visible to the right). You can also think of this as "Expand Horizontally".

This is usually the best option for 2D games that scroll horizontally (like runners or platformers).

Stretch Aspect = Expand: Keep aspect ratio when stretching the screen, but keep neither the base width nor height. Depending on the screen aspect ratio, the viewport will either be larger in the horizontal direction (if the screen is wider than the base size) or in the vertical direction (if the screen is taller than the original size).

To support both portrait and landscape mode with a similar automatically determined scale factor, set your project's base resolution to be a square (1:1 aspect ratio) instead of a rectangle. For instance, if you wish to design for 1280×720 as the base resolution but wish to support both portrait and landscape mode, use 720×720 as the project's base window size in the Project Settings.

To allow the user to choose their preferred screen orientation at runtime, remember to set Display > Window > Handheld > Orientation to sensor.

To configure the stretch aspect at runtime from a script, use the get_tree().root.content_scale_aspect property (see Window.content_scale_aspect and the ContentScaleAspect enum).

The Scale setting allows you to add an extra scaling factor on top of what the Stretch options above already provide. The default value of 1.0 means that no additional scaling occurs.

For example, if you set Scale to 2.0 and leave Stretch Mode on Disabled, each unit in your scene will correspond to 2×2 pixels on the screen. This is a good way to provide scaling options for non-game applications.

If Stretch Mode is set to canvas_items, 2D elements will be scaled relative to the base window size, then multiplied by the Scale setting. This can be exposed to players to allow them to adjust the automatically determined scale to their liking, for better accessibility.

If Stretch Mode is set to viewport, the viewport's resolution is divided by Scale. This makes pixels look larger and reduces rendering resolution (with a given window size), which can improve performance.

To configure the stretch scale at runtime from a script, use the get_tree().root.content_scale_factor property (see Window.content_scale_factor).

You can also adjust the scale at which the default project theme is generated using the GUI > Theme > Default Theme Scale project setting. This can be used to create more logically-sized UIs at base resolutions that are significantly higher or lower than the default. However, this project setting cannot be changed at runtime, as its value is only read once when the project starts.

Since Godot 4.2, the Stretch Scale Mode setting allows you to constrain the automatically determined scale factor (as well as the manually specified Stretch Scale setting) to integer values. By default, this setting is set to fractional, which allows any scale factor to be applied (including fractional values such as 2.5). When set to integer, the value is rounded down to the nearest integer. For example, instead of using a scale factor of 2.5, it would be rounded down to 2.0. This is useful to prevent distortion when displaying pixel art.

Compare this pixel art which is displayed with the viewport stretch mode, with the stretch scale mode set to fractional:

Checkerboard doesn't look "even". Line widths in the logo and text varies wildly.

This pixel art is also displayed with the viewport stretch mode, but the stretch scale mode is set to integer this time:

Checkerboard looks perfectly even. Line widths are consistent.

For example, if your viewport base size is 640×360 and the window size is 1366×768:

When using fractional, the viewport is displayed at a resolution of 1366×768 (scale factor is roughly 2.133×). The entire window space is used. Each pixel in the viewport corresponds to 2.133×2.133 pixels in the displayed area. However, since displays can only display "whole" pixels, this will lead to uneven pixel scaling which results in incorrect appearance of pixel art.

When using integer, the viewport is displayed at a resolution of 1280×720 (scale factor is 2×). The remaining space is filled with black bars on all four sides, so that each pixel in the viewport corresponds to 2×2 pixels in the displayed area.

This setting is effective with any stretch mode. However, when using the disabled stretch mode, it will only affect the Stretch Scale setting by rounding it down to the nearest integer value. This can be used for 3D games that have a pixel art UI, so that the visible area in the 3D viewport doesn't reduce in size (which occurs when using canvas_items or viewport stretch mode with the integer scale mode).

Games should use the Exclusive Fullscreen window mode, as opposed to Fullscreen which is designed to prevent Windows from automatically treating the window as if it was exclusive fullscreen.

Fullscreen is meant to be used by GUI applications that want to use per-pixel transparency without a risk of having it disabled by the OS. It achieves this by leaving a 1-pixel line at the bottom of the screen. By contrast, Exclusive Fullscreen uses the actual screen size and allows Windows to reduce jitter and input lag for fullscreen games.

When using integer scaling, this is particularly important as the 1-pixel height reduction from the Fullscreen mode can cause integer scaling to use a smaller scale factor than expected.

The following settings are recommended to support multiple resolutions and aspect ratios well.

Set the base window width to 1920 and window height to 1080. If you have a display smaller than 1920×1080, set Window Width Override and Window Height Override to lower values to make the window smaller when the project starts.

Alternatively, if you're targeting high-end devices primarily, set the base window width to 3840 and window height to 2160. This allows you to provide higher resolution 2D assets, resulting in crisper visuals at the cost of higher memory usage and file sizes. You'll also want to increase GUI > Theme > Default Theme Scale to a value between 2.0 and 3.0 to ensure UI elements remain readable.

Note that this will make non-mipmapped textures grainy on low resolution devices, so make sure to follow the instructions described in Reducing aliasing on downsampling.

Set the stretch mode to canvas_items.

Set the stretch aspect to expand. This allows for supporting multiple aspect ratios and makes better use of tall smartphone displays (such as 18:9 or 19:9 aspect ratios).

Configure Control nodes' anchors to snap to the correct corners using the Layout menu.

For 3D games, consider exposing Resolution scaling in the game's options menu to allow players to adjust the 3D rendering resolution separately from UI elements. This is useful for performance tuning, especially on lower-end hardware.

Set the base window size to the viewport size you intend to use. Most pixel art games use viewport sizes between 256×224 and 640×480. 640×360 is a good baseline, as it scales to 1280×720, 1920×1080, 2560×1440, and 3840×2160 without any black bars when using integer scaling. Higher viewport sizes will require using higher resolution artwork, unless you intend to show more of the game world at a given time.

Set the stretch mode to viewport.

Set the stretch aspect to keep to enforce a single aspect ratio (with black bars). As an alternative, you can set the stretch aspect to expand to support multiple aspect ratios.

If using the expand stretch aspect, Configure Control nodes' anchors to snap to the correct corners using the Layout menu.

Set the stretch scale mode to integer. This prevents uneven pixel scaling from occurring, which makes pixel art not display as intended.

The viewport stretch mode provides low-resolution rendering that is then stretched to the final window size. If you are OK with sprites being able to move or rotate in "sub-pixel" positions or wish to have a high resolution 3D viewport, you should use the canvas_items stretch mode instead of the viewport stretch mode.

Godot is configured to use landscape mode by default. This means you don't need to change the display orientation project setting.

Set the base window width to 1280 and window height to 720.

Alternatively, if you're targeting high-end devices primarily, set the base window width to 1920 and window height to 1080. This allows you to provide higher resolution 2D assets, resulting in crisper visuals at the cost of higher memory usage and file sizes. Many devices have even higher resolution displays (1440p), but the difference with 1080p is barely visible given the small size of smartphone displays. You'll also want to increase GUI > Theme > Default Theme Scale to a value between 1.5 and 2.0 to ensure UI elements remain readable.

Note that this will make non-mipmapped textures grainy on low resolution devices, so make sure to follow the instructions described in Reducing aliasing on downsampling.

Set the stretch mode to canvas_items.

Set the stretch aspect to expand. This allows for supporting multiple aspect ratios and makes better use of tall smartphone displays (such as 18:9 or 19:9 aspect ratios).

Configure Control nodes' anchors to snap to the correct corners using the Layout menu.

To better support tablets and foldable phones (which frequently feature displays with aspect ratios close to 4:3), consider using a base resolution that has a 4:3 aspect ratio while following the rest of the instructions here. For instance, you can set the base window width to 1280 and the base window height to 960.

Set the base window width to 720 and window height to 1280.

Alternatively, if you're targeting high-end devices primarily, set the base window width to 1080 and window height to 1920. This allows you to provide higher resolution 2D assets, resulting in crisper visuals at the cost of higher memory usage and file sizes. Many devices have even higher resolution displays (1440p), but the difference with 1080p is barely visible given the small size of smartphone displays. You'll also want to increase GUI > Theme > Default Theme Scale to a value between 1.5 and 2.0 to ensure UI elements remain readable.

Note that this will make non-mipmapped textures grainy on low resolution devices, so make sure to follow the instructions described in Reducing aliasing on downsampling.

Set Display > Window > Handheld > Orientation to portrait.

Set the stretch mode to canvas_items.

Set the stretch aspect to expand. This allows for supporting multiple aspect ratios and makes better use of tall smartphone displays (such as 18:9 or 19:9 aspect ratios).

Configure Control nodes' anchors to snap to the correct corners using the Layout menu.

To better support tablets and foldable phones (which frequently feature displays with aspect ratios close to 4:3), consider using a base resolution that has a 3:4 aspect ratio while following the rest of the instructions here. For instance, you can set the base window width to 960 and the base window height to 1280.

Set the base window width and height to the smallest window size that you intend to target. This is not required, but this ensures that you design your UI with small window sizes in mind.

Keep the stretch mode to its default value, disabled.

Keep the stretch aspect to its default value, ignore (its value won't be used since the stretch mode is disabled).

You can define a minimum window size by calling get_window().set_min_size() in a script's _ready() function. This prevents the user from resizing the application below a certain size, which could break the UI layout.

Add a setting in the application's settings to change the root viewport's stretch scale, so that the UI can be made larger to account for hiDPI displays. See also the section on hiDPI support below.

By default, Godot projects are considered DPI-aware by the operating system. This is controlled by the Display > Window > DPI > Allow hiDPI project setting, which should be left enabled whenever possible. Disabling DPI awareness can break fullscreen behavior on Windows.

Since Godot projects are DPI-aware, they may appear at a very small window size when launching on an hiDPI display (proportionally to the screen resolution). For a game, the most common way to work around this issue is to make them fullscreen by default. Alternatively, you could set the window size in an autoload's _ready() function according to the screen size.

To ensure 2D elements don't appear too small on hiDPI displays:

For games, use the canvas_items or viewport stretch modes so that 2D elements are automatically resized according to the current window size.

For non-game applications, use the disabled stretch mode and set the stretch scale to a value corresponding to the display scale factor in an autoload's _ready() function. The display scale factor is set in the operating system's settings and can be queried using screen_get_scale. This method is currently implemented on Android, iOS, Linux (Wayland only), macOS and Web. On other platforms, you'll have to implement a method to guess the display scale factor based on the screen resolution (with a setting to let the user override this if needed). This is the approach currently used by the Godot editor.

The Allow hiDPI setting is only effective on Windows and macOS. It's ignored on all other platforms.

The Godot editor itself is always marked as DPI-aware. Running the project from the editor will only be DPI-aware if Allow hiDPI is enabled in the Project Settings.

If the game has a very high base resolution (e.g. 3840×2160), aliasing might appear when downsampling to something considerably lower like 1280×720.

To resolve this, you can enable mipmaps on all your 2D textures. However, enabling mipmaps will increase memory usage which can be an issue on low-end mobile devices.

Once scaling for different resolutions is accounted for, make sure that your user interface also scales for different aspect ratios. This can be done using anchors and/or containers.

The 3D Camera node's Keep Aspect property defaults to the Keep Height scaling mode (also called Hor+). This is usually the best value for desktop games and mobile games in landscape mode, as widescreen displays will automatically use a wider field of view.

However, if your 3D game is intended to be played in portrait mode, it may make more sense to use Keep Width instead (also called Vert-). This way, smartphones with an aspect ratio taller than 16:9 (e.g. 19:9) will use a taller field of view, which is more logical here.

To render 3D at a different resolution from 2D elements (such as the UI), use Godot's resolution scaling functionality. This allows you to control the resolution scale factor used for 3D without needing to use a separate Viewport node. This can either be used to improve performance by rendering 3D at a lower resolution, or improve quality via supersampling.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Navigation debug tools — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/navigation/navigation_debug_tools.html

**Contents:**
- Navigation debug tools
- Enabling navigation debug
- Navigation debug settings
- Debug navigation mesh polygons
- Debug edge connections
- Debug performance
- User-contributed notes

The debug tools, properties and functions are only available in Godot debug builds. Do not use any of them in code that will be part of a release build.

The navigation debug visualizations are enabled by default inside the editor. To visualize navigation meshes and connections at runtime too, enable the option Visible Navigation in the editor Debug menu.

In Godot debug builds the navigation debug can also be toggled through the NavigationServer singletons from scripts.

Debug visualizations are currently based on Nodes in the SceneTree. If the NavigationServer2D or NavigationServer3D APIs are used exclusively then changes will not be reflected by the debug navigation tools.

The appearance of navigation debug can be changed in the ProjectSettings under debug/shapes/navigation. Certain debug features can also be enabled or disabled at will but may require a scene restart to take effect.

If enable_edge_lines is enabled, the edges of navigation mesh polygons will be highlighted. If enable_edge_lines_xray is also enabled, the edges of navigation meshes will be visible through geometry.

If enable_geometry_face_random_color is enabled, the color of each navigation mesh face will be mixed with a random color that is itself mixed with the color specified in geometry_face_color.

When two navigation meshes are connected within edge_connection_margin distance, the connection is overlaid. The color of the overlay is controlled by edge_connection_color. The connections can be made visible through geometry with enable_edge_connections_xray.

Edge connections are only visible when the NavigationServer is active.

To measure NavigationServer performance a dedicated monitor exists that can be found within the Editor Debugger under Debugger->Monitors->Navigation Process.

Navigation Process shows how long the NavigationServer spends updating its internals this update frame in milliseconds. Navigation Process works similar to Process for visual frame rendering and Physics Process for collision and fixed updates.

Navigation Process accounts for all updates to navigation maps, navigation regions and navigation agents as well as all the avoidance calculations for the update frame.

Navigation Process does NOT include pathfinding performance cause pathfinding operates on the navigation map data independently from the server process update.

Navigation Process should be in general kept as low and as stable as possible for runtime performance to avoid frame rate issues. Note that since the NavigationServer process update happens in the middle of the physics update an increase in Navigation Process will automatically increase Physics Process by the same amount.

Navigation also provides more detailed statistics about the current navigation related objects and navigation map composition on the NavigationServer.

Navigation statistics shown here can not be judged as good or bad for performance as it depends entirely on the project what can be considered as reasonable or horribly excessive.

Navigation statistics help with identifying performance bottlenecks that are less obvious because the source might not always have a visible representation. E.g. pathfinding performance issues created by overly detailed navigation meshes with thousand of edges / polygons or problems caused by procedural navigation gone wrong.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
NavigationServer2D.set_debug_enabled(false)
NavigationServer3D.set_debug_enabled(true)
```

Example 2 (unknown):
```unknown
NavigationServer2D.SetDebugEnabled(false);
NavigationServer3D.SetDebugEnabled(true);
```

---

## Navigation — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/navigation/index.html

**Contents:**
- Navigation

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Networking — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/networking/index.html

**Contents:**
- Networking

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## One-click deploy — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/export/one-click_deploy.html

**Contents:**
- One-click deploy
- What is one-click deploy?
- Supported platforms
- Using one-click deploy
- Troubleshooting
  - Android
  - Web
- User-contributed notes

One-click deploy is a feature that is available once a platform is properly configured and a supported device is connected to the computer. Since things can go wrong at many levels (platform may not be configured correctly, SDK may be incorrectly installed, device may be improperly configured, etc.), it's good to let the user know that it exists.

After adding an Android export preset marked as Runnable, Godot can detect when a USB device is connected to the computer and offer the user to automatically export, install and run the project (in debug mode) on the device. This feature is called one-click deploy.

One-click deploy is only available once you've added an export template marked as Runnable in the Export dialog. You can mark several export presets as runnable, but only one preset per platform may be marked as runnable. If you mark a second preset in a given platform as runnable, the other preset will no longer be marked as runnable.

Android: Exports the project with debugging enabled and runs it on the connected device.

Make sure to follow the steps described in Exporting for Android. Otherwise, the one-click deploy button won't appear.

If you have more than one device connected, Godot will ask you which device the project should be exported to.

iOS: Exports the project with debugging enabled and runs it on the connected device.

Make sure to follow the steps described in Exporting for iOS. Otherwise, the one-click deploy button won't appear.

For each new bundle identifier, export the project, open it in the Xcode, and build at least once to create new provisioning profile or create a provisioning profile in the Apple Developer account dashboard.

If you have more than one device connected, Godot will ask you which device the project should be exported to.

Desktop platforms: Exports the project with debugging enabled and runs it on the remote computer via SSH.

Web: Starts a local web server and runs the exported project by opening the default web browser. This is only accessible on localhost by default. See Troubleshooting for making the exported project accessible on remote devices.

Enable developer mode on your mobile device then enable USB debugging in the device's settings.

After enabling USB debugging, connect the device to your PC using a USB cable.

For advanced users, it should also be possible to use wireless ADB.

Install Xcode, accept Xcode license and login with your Apple Developer account.

If you are using Xcode 14 or earlier, install ios-deploy and set path to ios-deploy in the Editor Settings (see Export ⇾ iOS ⇾ iOS Deploy).

Pair your mobile device with a Mac.

Enable developer mode on your device.

Device can be connected via USB or local network.

Make sure the device is on the same local network and a correct network interface is selected in the editor settings (see Network ⇾ Debug ⇾ Remote Host). By default, the editor is listening for localhost connections only.

Device screen should be unlocked.

Enable SSH Remote Deploy and configure connection settings in the project export setting.

Make sure there is an export preset marked as Runnable for the target platform (Android, iOS or Web).

If everything is configured correctly and with no errors, platform-specific icons will appear in the top-right corner of the editor.

Click the button to export to the desired platform in one click.

If you can't see the device in the list of devices when running the adb devices command in a terminal, it will not be visible by Godot either. To resolve this:

Check if USB debugging is enabled and authorized on the device. Try unlocking your device and accepting the authorization prompt if you see any. If you can't see this prompt, running adb devices on your PC should make the authorization prompt appear on the device.

Try revoking the debugging authorization in the device's developer settings, then follow the steps again.

Try using USB debugging instead of wireless debugging or vice versa. Sometimes, one of those can work better than the other.

On Linux, you may be missing the required udev rules for your device to be recognized.

By default, the web server started by the editor is only accessible from localhost. This means the web server can't be reached by other devices on the local network or the Internet (if port forwarding is set up on the router). This is done for security reasons, as you may not want other devices to be able to access the exported project while you're testing it. Binding to localhost also prevents a firewall popup from appearing when you use one-click deploy for the web platform.

To make the local web server accessible over the local network, you'll need to change the Export > Web > HTTP Host editor setting to 0.0.0.0. You will also need to enable Export > Web > Use TLS as SharedArrayBuffer requires the use of a secure connection to work, unless connecting to localhost. However, since other clients will be connecting to a remote device, the use of TLS is absolutely required here.

To make the local web server accessible over the Internet, you'll also need to forward the Export > Web > HTTP Port port specified in the Editor Settings (8060 by default) in TCP on your router. This is usually done by accessing your router's web interface then adding a NAT rule for the port in question. For IPv6 connections, you should allow the port in the router's IPv6 firewall instead. Like for local network devices, you will also need to enable Export > Web > Use TLS.

When Use TLS is enabled, you will get a warning from your web browser as Godot will use a temporary self-signed certificate. You can safely ignore it and bypass the warning by clicking Advanced and then Proceed to (address).

If you have an SSL/TLS certificate that is trusted by browsers, you can specify the paths to the key and certificate files in the Export > Web > TLS Key and Export > Web > TLS Certificate. This will only work if the project is accessed through a domain name that is part of the TLS certificate.

When using one-click deploy on different projects, it's possible that a previously edited project is being shown instead. This is due to service worker caching not being cleared automatically. See Troubleshooting for instructions on unregistering the service worker, which will effectively clear the cache and resolve the issue.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## OpenXR body tracking — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/xr/openxr_body_tracking.html

**Contents:**
- OpenXR body tracking
- HTC Tracker support
- User-contributed notes

Support for full body tracking in OpenXR is only just becoming available for a select few platforms. As support solidifies information will be added to this page.

An option that has been available for some time is doing full body tracking using HTC trackers. These are currently supported through SteamVR and on HTC Elite XR headsets. They are exposed through the action map system.

These trackers are identified by their roles which are assigned to them when configured. Simply add XRController3D nodes as children to the XROrigin3D node and assign one of the following trackers:

/user/vive_tracker_htcx/role/handheld_object

/user/vive_tracker_htcx/role/left_foot

/user/vive_tracker_htcx/role/right_foot

/user/vive_tracker_htcx/role/left_shoulder

/user/vive_tracker_htcx/role/right_shoulder

/user/vive_tracker_htcx/role/left_elbow

/user/vive_tracker_htcx/role/right_elbow

/user/vive_tracker_htcx/role/left_knee

/user/vive_tracker_htcx/role/right_knee

/user/vive_tracker_htcx/role/waist

/user/vive_tracker_htcx/role/chest

/user/vive_tracker_htcx/role/camera

/user/vive_tracker_htcx/role/keyboard

You can now use these as targets for IK modifiers on a full body avatar.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## OpenXR composition layers — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/xr/openxr_composition_layers.html

**Contents:**
- OpenXR composition layers
- Introduction
- Setting up the SubViewport
- Adding a composition layer
- Making the interface work
- Hole punching
- User-contributed notes

In XR games you generally want to create user interactions that happen in 3D space and involve users touching objects as if they are touching them in real life.

Sometimes however creating a more traditional 2D interface is unavoidable. In XR however you can't just add 2D components to your scene. Godot needs depth information to properly position these elements so they appear at a comfortable place for the user. Even with depth information there are headsets with slanted displays that make it impossible for the standard 2D pipeline to correctly render the 2D elements.

The solution then is to render the UI to a SubViewport and display the result of this using a ViewportTexture on a 3D mesh. The QuadMesh is a suitable option for this.

See the GUI in 3D example project for an example of this approach.

The problem with displaying the viewport in this way is that the rendered result is sampled for lens distortion by the XR runtime and the resulting quality loss can make UI text hard to read.

OpenXR offers a solution to this problem through composition layers. With composition layers it is possible for the contents of a viewport to be projected on a surface after lens distortion resulting in a much higher quality end result.

As not all XR runtimes support all composition layer types, Godot implements a fallback solution where we render the viewport as part of the normal scene but with the aforementioned quality limitations.

When the composition layer is supported, it is the XR runtime that presents the subviewport. This means the UI is only visible in the headset, it will not be accessible by Godot and will thus not be shown when you have a spectator view on the desktop.

There are currently 3 nodes that expose this functionality:

OpenXRCompositionLayerCylinder shows the contents of the SubViewport on the inside of a cylinder (or "slice" of a cylinder).

OpenXRCompositionLayerEquirect shows the contents of the SubViewport on the interior of a sphere (or "slice" of a sphere).

OpenXRCompositionLayerQuad shows the contents of the SubViewport on a flat rectangle.

The first step is adding a SubViewport for our 2D UI, this doesn't require any specific steps. For our example we do mark the viewport as transparent.

You can now create the 2D UI by adding child nodes to the SubViewport as you normally would. It is advisable to save the 2D UI in a subscene, this makes it easier to do your layout.

The update mode "When Visible" will not work as Godot can't determine whether the viewport is visible to the user. When assigning our viewport to a composition layer Godot will automatically adjust this.

The second step is adding our composition layer. We can add the correct composition layer node as a child node of our XROrigin3D node. This is very important as the XR runtime positions everything in relation to our origin.

We want to position the composition layer so it is at eye height and roughly 1 to 1.5 meters away from the player.

We now assign the SubViewport to the Layer Viewport property and enable Alpha Blend.

As the player can walk away from the origin point, you will want to reposition the composition layer when the player recenters the view. Using the reference space Local Floor will apply this logic automatically.

So far we're only displaying our UI, to make it work we need to add some code. For this example we're going to keep things simple and make one of the controllers work as a pointer. We'll then simulate mouse actions with this pointer.

This code also requires a MeshInstance3D node called Pointer to be added as a child to our OpenXRCompositionLayerQuad node. We configure a SphereMesh with a radius 0.01 meters. We'll be using this as a helper to visualize where the user is pointing.

The main function that drives this functionality is the intersects_ray function on our composition layer node. This function takes the global position and orientation of our pointer and returns the UV where our ray intersects our viewport. It returns Vector2(-1.0, -1.0) if we're not pointing at our viewport.

We start with setting up some variables, important here are the export variables which identify our controller node with which we point to our screen.

Next we define a helper function that takes the value returned from intersects_ray and gives us the global position for that intersection point. This implementation only works for our OpenXRCompositionLayerQuad node.

We also define a helper function that takes our intersect value and returns our location in the viewport's local coordinate system:

The main logic happens in our _process function. Here we start by hiding our pointer, we then check if we have a valid controller and viewport, and we call intersects_ray with the position and orientation of our controller:

Next we check if we're intersecting with our viewport. If so, we check if our button is pressed and place our pointer at our intersection point.

If we were intersecting in our previous process call and our pointer has moved, we prepare an InputEventMouseMotion object to simulate our mouse moving and send that to our viewport for further processing.

If we've just released our button we also prepare an InputEventMouseButton object to simulate a button release and send that to our viewport for further processing.

Or if we've just pressed our button we prepare an InputEventMouseButton object to simulate a button press and send that to our viewport for further processing.

Next we remember our state for next frame.

Finally, if we aren't intersecting, we clear our state.

As the composition layer is composited on top of the render result, it can be rendered in front of objects that are actually forward of the viewport.

By enabling hole punch you instruct Godot to render a transparent object where our viewport is displayed. It does this in a way that fills the depth buffer and clears the current rendering result. Anything behind our viewport will now be cleared, while anything in front of our viewport will be rendered as usual.

You also need to set Sort Order to a negative value, the XR compositor will now draw the viewport first, and then overlay our rendering result.

Use case showing how the user's hand is incorrectly obscured by a composition layer when hole punching is not used.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (javascript):
```javascript
extends OpenXRCompositionLayerQuad

const NO_INTERSECTION = Vector2(-1.0, -1.0)

@export var controller : XRController3D
@export var button_action : String = "trigger_click"

var was_pressed : bool = false
var was_intersect : Vector2 = NO_INTERSECTION

...
```

Example 2 (gdscript):
```gdscript
...

func _intersect_to_global_pos(intersect : Vector2) -> Vector3:
    if intersect != NO_INTERSECTION:
        var local_pos : Vector2 = (intersect - Vector2(0.5, 0.5)) * quad_size
        return global_transform * Vector3(local_pos.x, -local_pos.y, 0.0)
    else:
        return Vector3()

...
```

Example 3 (gdscript):
```gdscript
...

func _intersect_to_viewport_pos(intersect : Vector2) -> Vector2i:
    if layer_viewport and intersect != NO_INTERSECTION:
        var pos : Vector2 = intersect * Vector2(layer_viewport.size)
        return Vector2i(pos)
    else:
        return Vector2i(-1, -1)

...
```

Example 4 (gdscript):
```gdscript
...

# Called every frame. 'delta' is the elapsed time since the previous frame.
func _process(_delta):
    # Hide our pointer, we'll make it visible if we're interacting with the viewport.
    $Pointer.visible = false

    if controller and layer_viewport:
        var controller_t : Transform3D = controller.global_transform
        var intersect : Vector2 = intersects_ray(controller_t.origin, -controller_t.basis.z)

...
```

---

## OpenXR hand tracking — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/xr/openxr_hand_tracking.html

**Contents:**
- OpenXR hand tracking
- Introduction
- Demo project
- The Hand Tracking API
  - Hand tracking node
  - Rigged hand mesh
  - The hand skeleton modifier
- The hand tracking data source
- Handling user input
  - The hand interaction profile

This page focuses specifically on the feature set exposed through OpenXR. Parts of the functionality presented here also applies to WebXR and can by provided by other XR interfaces.

When discussing hand tracking it is important to know that there are differences of opinion as to where lines are drawn. The practical result of this is that there are differences in implementation between the different OpenXR runtimes. You may find yourself in a place where chosen hardware doesn't support a piece of the puzzle or does things differently enough from the other platforms that you need to do extra work.

That said, recent improvements to the OpenXR specification are closing these gaps and as platforms implement these improvements we are getting closer to a future where we have either full portability between platforms or at least a clear way to detect the capabilities of a platform.

When we look at the early days of VR the focus of the major platforms was on tracked controller based input. Here we are tracking a physical device that also has buttons for further input. From the tracking data we can infer the location of the player's hands but no further information is known, traditionally it was left up to the game to implement a mechanism to display the player's hand and animate the fingers based on further input from the controller, be it due to buttons being pressed or through proximity sensors. Often fingers are also placed based on context, what the user is holding, and what action a user is performing.

More recently optical hand tracking has become a popular solution, where cameras track the user's hands and full tracking data for the hand and finger positions becomes available. Many vendors saw this as completely separate from controller tracking and introduced independent APIs to access hand and finger positions and orientation data. When handling input, it was up to the game developer to implement a gesture detection mechanism.

This split also exists in OpenXR, where controller tracking is handled primarily by the action map system, while optical hand tracking is primarily handled by the hand tracking API extension.

However, the world is not that black and white and we're seeing a number of scenarios where we cross the line:

Devices that fit in both categories, such as tracked gloves and controllers such as the Index controller that also perform finger tracking.

XR Runtimes that implement inferred hand tracking from controller data as a means to solve proper finger placement for multiple controllers.

XR applications that wish to seamlessly switch between controller and hand tracking offering the same user experience regardless of approach used.

OpenXR is answering this call by introducing further extensions that lets us query the capabilities of the XR runtime/hardware or that add further functionality across this divide. The problem that currently does remain is that there are gaps in adopting these extensions, with some platforms thus not reporting capabilities to their full extent. As such you may need to test for the features available on specific hardware and adjust your approach accordingly.

The information presented on this page was used to create a demo project that can be found here.

As mentioned in our introduction, the hand tracking API is primarily used with optical hand tracking and on many platforms only works when the user is not holding a controller. Some platforms support controller inferred hand tracking meaning that you will get hand tracking data even if the user is holding a controller. This includes SteamVR, Meta Quest (currently native only but Meta link support is likely coming), and hopefully soon others as well.

The hand tracking implementation in Godot has been standardized around the Godot Humanoid Skeleton and works both in OpenXR and WebXR. The instructions below will thus work in both environments.

In order to use the hand tracking API with OpenXR you first need to enable it. This can be done in the project settings:

For some standalone XR devices you also need to configure the hand tracking extension in export settings, for instance for Meta Quest:

Now you need to add 3 components into your scene for each hand:

A tracked node to position the hand.

A properly skinned hand mesh with skeleton.

A skeleton modifier that applies finger tracking data to the skeleton.

The hand tracking system uses separate hand trackers to track the position of the player's hands within our tracking space.

This information has been separated out for the following use cases:

Tracking happens in the local space of the XROrigin3D node. This node must be a child of the XROrigin3D node in order to be correctly placed.

This node can be used as an IK target when an upper body mesh with arms is used instead of separate hand meshes.

Actual placement of the hands may be loosely bound to the tracking in scenarios such as avatar creation UIs, fake mirrors, or similar situations resulting in the hand mesh and finger tracking being localized elsewhere.

We'll concentrate on the first use case only.

For this you need to add an XRNode3D node to your XROrigin3D node.

On this node the tracker should be set to /user/hand_tracker/left or /user/hand_tracker/right for the left or right hand respectively.

The pose should remain set to default, no other option will work here.

The checkbox Show When Tracked will automatically hide this node if no tracking data is available, or make this node visible if tracking data is available.

In order to display our hand we need a hand mesh that is properly rigged and skinned. For this Godot uses the hand bone structure as defined for the Godot Humanoid but optionally supporting an extra tip bone for each finger.

The OpenXR hand tracking demo contains example glTF files of properly rigged hands.

We will be using those here and add them as a child to our XRNode3D node. We also need to enable editable children to gain access to our Skeleton3D node.

Finally we need to add an XRHandModifier3D node as a child to our Skeleton3D node. This node will obtain the finger tracking data from OpenXR and apply it the hand model.

You need to set the Hand Tracker property to either /user/hand_tracker/left or /user/hand_tracker/right depending on whether we are apply the tracking data of respectively the left or right hand.

You can also set the Bone Update mode on this node.

Full applies the hand tracking data fully. This does mean that the skeleton positioning will potentially reflect the size of the actual hand of the user. This can lead to scrunching effect if meshes aren't weighted properly to account for this. Make sure you test your game with players of all sizes when optical hand tracking is used!

Rotation Only will only apply rotation to the bones of the hands and keep the bone length as is. In this mode the size of the hand mesh doesn't change.

With this added, when we run the project we should see the hand correctly displayed if hand tracking is supported.

This is an OpenXR extension that provides information about the source of the hand tracking data. At this moment only a few runtimes implement it but if it is available, Godot will activate it.

If this extension is not supported and thus unknown is returned, you can make the following assumptions:

If you are using SteamVR (including Steam link), only controller based hand tracking is supported.

For any other runtime, if hand tracking is supported, only optical hand tracking is supported (Note, Meta Link currently fall into this category).

In all other cases, no hand tracking is supported at all.

You can access this information through code:

This example logs the state for the left hand.

If in this example no hand tracker is returned by get_tracker, this means the hand tracking API is not supported on the XR runtime at all.

If there is a tracker but has_tracking_data is false, the user's hand is currently not being tracked. This is likely caused by one of the following reasons:

The player's hand is not visible by any of the tracking cameras on the headset

The player is currently using a controller and the headset only supports optical hand tracking

The controller is turned off and only controller hand tracking is supported.

Reacting to actions performed by the user is handled through The XR action map if controllers are used. In the action map you can map various inputs like the trigger or joystick on the controller to an action. This can then drive logic in your game.

When hand tracking is used we originally had no such inputs, inputs are driven by gestures made by the user such as making a fist to grab or pinching the thumb and index finger together to select something. It was up to the game developer to implement this.

Recognizing that there is an increasing demand for applications that can switch seamlessly between controller and hand tracking and the need some form of basic input capability, a number of extensions were added to the specification that provide some basic gesture recognition and can be used with the action map.

The hand interaction profile extension is a new core extension which supports pinch, grasp, and poke gestures and related poses. There is still limited support for this extension but it should become available in more runtimes in the near future.

The pinch gesture is triggered by pinching your thumb and index finger together. This is often used as a select gesture for menu systems, similar to using your controller to point at an object and press the trigger to select and is thus often mapped as such.

The pinch pose is a pose positioned in the middle between the tip of the thumb and the tip of the index finger and oriented such that a ray cast can be used to identify a target.

The pinch float input is a value between 0.0 (the tip of the thumb and index finger are apart) and 1.0 (the tip of the thumb and index finger are touching).

The pinch ready input is true when the tips of the fingers are (close to) touching.

The grasp gesture is triggered by making a fist and is often used to pick items up, similar to engaging the squeeze input on controllers.

The grasp float input is a value between 0.0 (open hand) and 1.0 (fist).

The grasp ready input is true when the user made a fist.

The poke gesture is triggered by extending your index finger, this one is a bit of an exception as the pose at the tip of your index finger is often used to poke an interactable object. The poke pose is a pose positioned on the tip of the index finger.

Finally the aim activate (ready) input is defined as an input that is 1.0/true when the index finger is extended and pointing at a target that can be activated. How runtimes interpret this, is not clear.

With this setup the normal left_hand and right_hand trackers are used and you can thus seamlessly switch between controller and hand tracking input.

You need to enable the hand interaction profile extension in the OpenXR project settings.

The Microsoft hand interaction profile extension was introduced by Microsoft and loosely mimics the simple controller profile. Meta has also added support for this extension but only on their native OpenXR client, it is currently not available over Meta Link.

Pinch support is exposed through the select input, the value of which is 0.0 when the tip of the thumb and index finger are apart and 1.0 when they are together.

Note that in this profile the aim pose is redefined as a pose between thumb and index finger, oriented so a ray cast can be used to identify a target.

Grasp support is exposed through the squeeze input, the value of which is 0.0 when the hand is open, and 1.0 when a fist is made.

With this setup the normal left_hand and right_hand trackers are used and you can thus seamlessly switch between controller and hand tracking input.

The HTC hand interaction profile extension was introduced by HTC and is defined similarly to the Microsoft extension. It is only supported by HTC for the Focus 3 and Elite XR headsets.

See the Microsoft hand interaction profile for the gesture support.

The defining difference is that this extension introduces two new trackers, /user/hand_htc/left and /user/hand_htc/right. This means that extra logic needs to be implemented to switch between the default trackers and the HTC specific trackers when the user puts down, or picks up, their controller.

The simple controller profile is a standard core profile defined as a fallback profile when a controller is used for which no profile exists.

There are a number of OpenXR runtimes that will mimic controllers through the simple controller profile when hand tracking is used.

Unfortunately there is no sound way to determine whether an unknown controller is used or whether hand tracking is emulating a controller through this profile.

XR runtimes are free to define how the simple controller profile operates, so there is also no certainty to how this profile is mapped to gestures.

The most common mapping seems to be that select click is true when the tip of the thumb and index fingers are touching while the user's palm is facing away from the user. menu click will be true when tip of the thumb and index fingers are touching while the user's palm is facing towards the user.

With this setup the normal left_hand and right_hand trackers are used and you can thus seamlessly switch between controller and hand tracking input.

As some of these interaction profiles have overlap it is important to know that you can add each profile to your action map and the XR runtime will choose the best fitting profile.

For instance, a Meta Quest supports both the Microsoft hand interaction profile and simple controller profile. If both are specified the Microsoft hand interaction profile will take precedence and will be used.

The expectation is that once Meta supports the core hand interaction profile extension, that profile will take precedence over both Microsoft and simple controller profiles.

If the platform doesn't support any interaction profiles when hand tracking is used, or if you're building an application where you need more complicated gesture support you're going to need to build your own gesture recognition system.

You can obtain the full hand tracking data through the XRHandTracker resource for each hand. You can obtain the hand tracker by calling XRServer.get_tracker and using either /user/hand_tracker/left or /user/hand_tracker/left as the tracker. This resource provides access to all the joint information for the given hand.

Detailing out a full gesture recognition algorithm goes beyond the scope of this manual however there are a number of community projects you can look at:

Julian Todd's Auto hands library

Malcolm Nixons Hand Pose Detector

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
var hand_tracker : XRHandTracker = XRServer.get_tracker('/user/hand_tracker/left')
if hand_tracker:
    if hand_tracker.has_tracking_data:
        if hand_tracker.hand_tracking_source == XRHandTracker.HAND_TRACKING_SOURCE_UNKNOWN:
            print("Hand tracking source unknown")
        elif hand_tracker.hand_tracking_source == XRHandTracker.HAND_TRACKING_SOURCE_UNOBSTRUCTED:
            print("Hand tracking source is optical hand tracking")
        elif hand_tracker.hand_tracking_source == XRHandTracker.HAND_TRACKING_SOURCE_CONTROLLER:
            print("Hand tracking data is inferred from controller data")
        else:
            print("Unknown hand tracking source ", hand_tracker.hand_tracking_source)
    else:
        print("Hand is currently not being tracked")
else:
    print("No hand tracker registered")
```

---

## OpenXR Render Models — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/xr/openxr_render_models.html

**Contents:**
- OpenXR Render Models
- OpenXR Render models node
  - Render model manager example
- Render model node
- Backend access
- User-contributed notes

A cornerstone of OpenXR's API design is being as platform agnostic as possible. A great example of this is OpenXR's action map system where XR runtimes have to support core interaction profiles to fall back on, if no interaction profile exists for the hardware being used. This ensures that OpenXR applications keep functioning even when used on hardware that didn't exist when the application was released, or that the developers of the application did not have access too.

A consequence of this is that the application developer doesn't know with any certainty what hardware is being used, as the XR runtime could be mimicking other hardware. The application developer thus can't show anything in relation to the actual hardware used, the most common use case being showing the controllers the user is currently holding.

Showing the correct controller models and having these models correctly positioned is important to a proper sense of immersion.

This is where OpenXR's render models API comes in. This API allows us to query the XR runtime for 3D assets that are correct for the physical hardware being used. The API also allows us to query the position of this hardware within the tracking volume and the correct positioning of subcomponents of this hardware.

For instance, we can correctly position and animate the trigger or show buttons being pressed.

For those runtimes that support the controller data source for hand tracking , we can also correctly position the user's fingers and hand according to the shape of the controller. Do note that this works in combination with the hand joints motion range extension to prevent clipping of the fingers.

The OpenXRRenderModelManager node can be used to automate most of the render models functionality. This node keeps track of the active render models currently made available by the XR runtime.

It will create child nodes for each active render model resulting in that render model being displayed.

This node must have an XROrigin3D node as an ancestor.

If tracker is set to Any our node will show all render models currently being tracked. In this scenario this node must be a direct child of our XROrigin3D node.

If tracker is set to None set our node will only show render models for which no tracker has been identified. In this scenario this node must also be a direct child of our XROrigin3D node.

If tracker is set to Left Hand or Right Hand our node will only show render models related to our left or right hand respectively. In this scenario, our node can be placed deeper in the scene tree.

For most XR runtimes this means the render model represents a controller that is actually being held by the user but this is not a guarantee. Some XR runtimes will always set the tracker to either the left or right hand even if the controller is not currently held but is being tracked. You should always test this as this will lead to unwanted behavior.

In this scenario we can also specify an action for a pose in the action map by setting the make_local_to_pose property to the pose action. Use this in combination with an XRController3D node that is using the same pose and you can now add a layer that allows you to deviate from the tracked position of both your controller and the related render model (see example below).

Combining the above with hand tracking does introduce the problem that hand tracking is completely independent from the action map system. You will need to combine the hand tracking and controller tracking poses to properly offset the render models.

This falls beyond the scope of this documentation.

You can download our render models demo which implements the setup described below.

In this setup we find an OpenXRRenderModelManager node directly underneath our XROrigin3D node. On this node our target property is set to None set and will handle showing all render models that are currently not related to our left or right hand controllers.

We then see the same setup for our left and right hand so we'll focus on just the left hand.

We have an XRController3D that will track the location of our hand.

We are using the grip pose in this example. The palm pose is arguably more suitable and predictable however it is not supported by all XR runtimes. See the hand tracking demo project for a solution to switching between these poses based on what is supported.

As a child of the node we have an AnimatableBody3D node that follows the tracked location of the hand but will interact with physics objects to stop the player's hand from going through walls etc. This node has a collision shape that encapsulates the hand.

It is important to set the physics priority so that this logic runs after any physics logic that moves the XROrigin3D node or the hand will lag a frame behind.

The script below shows a basic implementation for this that you can build upon.

Finally we see another OpenXRRenderModelManager node, this one with target set to the appropriate hand and make_local_to_pose set to the correct pose. This will ensure that the render models related to this hand are properly shown and offset if our collision handler has altered the location.

The OpenXRRenderModel node implements all the logic to display and position a given render model provided by the render models API.

Instances of this node are added by the render model manager node we used up above but you can interact with these directly if you wish.

Whenever Godot obtains information about a new render model an RID is created to reference that render model.

By assigning that RID to the render_model property on this node, the node will start displaying the render model and manage both the transform that places the render model in the correct place and animates all the sub objects.

The get_top_level_path function will return the top level path associated with this render model. This will point to either the left or right hand. As the top level path can be set or cleared depending on whether the user picks up, or puts down, the controller you can connect to the render_model_top_level_path_changes signal and react to these changes.

Depending on your setup of the OpenXRRenderModelManager nodes, render models will be removed or added as their top level path changes.

The nodes we've detailed out above handle all the display logic for us but it is possible to interact with the data that drives this directly and create your own implementation.

For this you can access the OpenXRRenderModelExtension singleton.

This object also lets you query whether render models are supported and enabled on the device currently being used by calling the is_active function on this object.

The built-in logic implements the interaction render model API that lists all render models related to controllers and similar devices that are present in the action map. It will automatically create and remove render model entities that are exposed through this API.

As other extensions become available these can be implemented in a GDExtension plugin. Such a plugin can call render_model_create and render_model_destroy to create the object that will provide access to that render model through the core render models API.

You should not destroy a render model outside of this logic.

You can connect to the render_model_added and render_model_removed signals to be informed when new render models are added or removed.

The core methods for working with this API are listed below:

Provides an array of RIDs for all render models that are being tracked.

render_model_new_scene_instance

Provides a new scene that contains all meshes needed to display the render model.

render_model_get_subaction_paths

Provides a list of subaction paths from your action map related to this render mode.

render_model_get_top_level_path

Returns the top level path associated with this render model (if any). Use the render_model_top_level_path_changed signal to react to this changing.

render_model_get_confidence

Returns the tracking confidence for the tracking data for this render model.

render_model_get_root_transform

Returns the root transform for this render model within our current reference space. This can be used to place the render model in space.

render_model_get_animatable_node_count

Returns the number of nodes in our render model scene that can be animated

render_model_get_animatable_node_name

Returns the name of the node that we can animate. Note that this node can be any number of levels deep within the scene.

render_model_is_animatable_node_visible

Returns true if this animatable node should be visible

render_model_get_animatable_node_transform

Returns the transform for this animatable node. This is a local transform that can be directly applied.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
class_name CollisionHands3D
extends AnimatableBody3D

func _ready():
    # Make sure these are set correctly.
    top_level = true
    sync_to_physics = false
    process_physics_priority = -90

func _physics_process(_delta):
    # Follow our parent node around.
    var dest_transform = get_parent().global_transform

    # We just apply rotation for this example.
    global_basis = dest_transform.basis

    # Attempt to move to where our tracked hand is.
    move_and_collide(dest_transform.origin - global_position)
```

---

## OpenXR Settings — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/xr/openxr_settings.html

**Contents:**
- OpenXR Settings
- General settings
  - Enabled
  - Default Action Map
  - Form Factor
  - View Configuration
  - Reference Space
    - Local
    - Stage
    - Local Floor

OpenXR has its own set of settings that are applied when OpenXR starts. While it is possible for OpenXR extensions implemented through Godot plugins to add additional settings, we will only discuss the settings in the core of Godot here.

This setting enables the OpenXR module when Godot starts. This is required when the Vulkan backend is used. For other backends you can enable OpenXR at any time by calling initialize on the OpenXRInterface.

This also needs to be enabled to get access to the action map editor.

You can use the --xr-mode on command line switch to force this to on.

This specifies the path of the action map file that OpenXR will load and communicate to the XR Runtime.

This specifies whether your game is designed for:

Head Mounted devices such as a Meta Quest, Valve Index, or Magic Leap,

Handheld devices such as phones.

If the device on which you run your game does not match the selection here, OpenXR will fail to initialise.

This specifies the view configuration your game is designed for:

Mono, your game provides a single image output. E.g. phone based AR;

Stereo, your game provides stereo image output. E.g. head mounted devices.

If the device on which you run your game does not match the selection here, OpenXR will fail to initialise.

OpenXR has additional view configurations for very specific devices that Godot doesn't support yet. For instance, Varjo headsets have a quad view configuration that outputs two sets of stereo images. These may be supported in the near future.

Within XR all elements like the player's head and hands are tracked within a tracking volume. At the base of this tracking volume is our origin point, which maps our virtual space to the real space. There are however different scenarios that place this point in different locations, depending on the XR system used. In OpenXR these scenarios are well defined and selected by setting a reference space.

The local reference space places our origin point at the player's head by default. Some XR runtimes will do this each time your game starts, others will make the position persist over sessions.

This reference space however does not prevent the user from walking away so you will need to detect if the user does so if you wish to prevent the user from leaving the vehicle they are controlling, which could potentially be game breaking.

This reference space is the best option for games like flight simulators or racing simulators where we want to place the XROrigin3D node where the player's head should be.

When the user enacts the recenter option on their headset, the method of which is different per XR runtime, the XR runtime will move the XRCamera3D to the XROrigin3D node. The OpenXRInterface will also emit the pose_recentered signal so your game can react accordingly.

Any other XR tracked elements such as controllers or anchors will also be adjusted accordingly.

You should not call center_on_hmd when using this reference space.

The stage reference space is our default reference space and places our origin point at the center of our play space. For XR runtimes that allow you to draw out a guardian boundary this location and its orientation is often set by the user. Other XR runtimes may decide on the placement of this point by other means. It is however a stationary point in the real world.

This reference space is the best option for room scale games where the user is expected to walk around a larger space, or for games where there is a need to switch between game modes. See Room Scale for more information.

When the user enacts the recenter option on their headset, the method of which is different per XR runtime, the XR runtime will not change the origin point. The OpenXRInterface will emit the pose_recentered signal and it is up to the game to react appropriately. Not doing so will prevent your game from being accepted on various stores.

In Godot you can do this by calling the center_on_hmd function on the XRServer:

Calling XRServer.center_on_hmd(XRServer.RESET_BUT_KEEP_TILT, false) will move the XRCamera3D node to the XROrigin3D node similar to the Local reference space.

Calling XRServer.center_on_hmd(XRServer.RESET_BUT_KEEP_TILT, true) will move the XRCamera3D node above the XROrigin3D node keeping the player's height, similar to the Local Floor reference space.

Any other XR tracked elements such as controllers or anchors will also be adjusted accordingly.

The local floor reference space is similar to the local reference space as it positions the origin point where the player is. In this mode however the height of the player is kept. Same as with the local reference space, some XR runtimes will persist this location over sessions.

It is thus not guaranteed the player will be standing on the origin point, the only guarantee is that they were standing there when the user last recentered. The player is thus also free to walk away.

This reference space is the best option of games where the user is expected to stand in the same location or for AR type games where the user's interface elements are bound to the origin node and are quickly placed at the player's location on recenter.

When the user enacts the recenter option on their headset, the method of which is different per XR runtime, the XR runtime will move the XRCamera3D above the XROrigin3D node but keeping the player's height. The OpenXRInterface will also emit the pose_recentered signal so your game can react accordingly.

Be careful using this mode in combination with virtual movement of the player. The user recentering in this scenario can be unpredictable unless you counter the move when handling the recenter signal. This can even be game breaking as the effect in this scenario would be the player teleporting to whatever abstract location the origin point was placed at during virtual movement, including the ability for players teleporting into locations that should be off limits. It is better to use the Stage mode in this scenario and limit resetting to orientation only when a pose_recentered signal is received.

Any other XR tracked elements such as controllers or anchors will also be adjusted accordingly.

You should not call center_on_hmd when using this reference space.

The environment blend mode defines how our rendered output is blended into "the real world" provided this is supported by the headset.

Opaque means our output obscures the real world, we are in VR mode.

Additive means our output is added to the real world, this is an AR mode where optics do not allow us to fully obscure the real world (e.g. Hololens),

Alpha means our output is blended with the real world using the alpha output (viewport should have transparent background enabled), this is an AR mode where optics can fully obscure the real world (Magic Leap, all pass through devices, etc.).

If a mode is selected that is not supported by the headset, the first available mode will be selected.

Some OpenXR devices have separate systems for enabling/disabling passthrough. From Godot 4.3 onwards selecting the alpha blend mode will also perform these extra steps. This does require the latest vendor plugin to be installed.

Sets the foveation level used when rendering provided this feature is supported by the hardware used. Foveation is a technique where the further away from the center of the viewport we render content, the lower resolution we render at. Most XR runtimes only support fixed foveation, but some will take eye tracking into account and use the focal point for this effect.

The higher the level, the better the performance gains, but also the more reduction in quality there is in the user's peripheral vision.

Compatibility renderer only, for Mobile and Forward+ renderer, set the vrs_mode property on Viewport to VRS_XR.

This feature is disabled if post effects are used such as glow, bloom, or DOF.

When enabled the foveation level will be adjusted automatically depending on current GPU load. It will be adjusted between low and the select foveation level in the previous setting. It is therefore best to combine this setting with foveation level set to high.

Compatibility renderer only

If enabled an OpenXR supplied depth buffer will be used while rendering which is submitted alongside the rendered image. The XR runtime can use this for improved reprojection.

Enabling this feature will disable stencil support during rendering. Not many XR runtimes make use of this, it is advised to leave this setting off unless it provides noticeable benefits for your use case.

If enabled, this will result in an alert message presented to the user if OpenXR fails to start. We don't always receive feedback from the XR system as to why starting fails. If we do, we log this to the console. Common failure reasons are:

No OpenXR runtime is installed on the host system.

Microsoft's WMR OpenXR runtime is currently active, this only supports DirectX and will fail if OpenGL or Vulkan is used.

SteamVR is used but no headset is connected/turned on.

Disable this if you support a fallback mode in your game so it can be played in desktop mode when no VR headset is connected, or if you're handling the failure condition yourself by checking OpenXRInterface.is_initialized().

This subsection allows you to enable to various optional OpenXR extensions. Keep in mind that the extensions will only work if the OpenXR runtime (SteamVR, Oculus, etc) the project is ran with supports them.

Enabling this will log debug messages from the XR runtime.

This allows you to choose which debug messages are logged.

This enables the hand tracking extension when supported by the device used. This is on by default for legacy reasons. The hand tracking extension provides access to data that allows you to visualise the user's hands with correct finger positions. Depending on platform capabilities the hand tracking data can be inferred from controller inputs, come from data gloves, come from optical hand tracking sensors or any other applicable source.

If your game only supports controllers this should be turned off.

See the page on hand tracking for additional details.

Enabling this means hand tracking may use the exact position of fingers, usually what a headset camera sees.

Enabling this means hand tracking may use the controller itself, and infer where fingers are based on controller input or sensors on the controller.

Enabling this extension allows the use of two new hand tracking poses. Pinch pose which is the location between the thumb and index finger pointing forward, and poke pose which is at the tip of the index finger.

This also allows 3 more gesture based inputs. Pinch, when the user pinches their thumb and index finger together. Aim activation, when the index finger is fully extended. And Grasps, when the user makes a fist.

When a hand interaction profile and controller interaction profile are supplied, the runtime will switch between profiles depending on if optical tracking is used or if the user is holding a controller.

If only a hand interaction profile is supplied any runtime should use hand interaction even if a controller is being held.

This enables the eye gaze interaction extension when supported by the device used. When enabled we will get feedback from eye tracking through a pose situated between the user's eyes orientated in the direction the user is looking. This will be a unified orientation.

In order to use this functionality you need to edit your action map and add a new pose action, say eye_pose. Now add a new interaction profile for the eye gaze interaction and map the eye_pose:

Don't forget to save!

Next add a new XRController3D node to your origin node and set its tracker property to /user/eyes_ext and set its pose property to eye_pose.

Now you can add things to this controller node such as a raycast, and control things with your eyes.

This extension is used to query the XR runtime for 3D assets of the hardware being used, usually a controller, as well as the position of that hardware. You can find a detailed guide on how to use it here.

These control whether or not binding modifiers can be used. Binding modifiers are used to apply thresholds or offset values. You can find information on how to use and set them up on the XR action map page here.

Allow analog threshold binding modifiers.

Allow D-pad binding modifiers.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Optimization using Servers — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/performance/using_servers.html

**Contents:**
- Optimization using Servers
- Servers
- RIDs
- Creating a sprite
- Instantiating a Mesh into 3D space
- Creating a 2D RigidBody and moving a sprite with it
- Getting data from the servers
- User-contributed notes

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

Engines like Godot provide increased ease of use thanks to their high-level constructs and features. Most of them are accessed and used via the Scene System. Using nodes and resources simplifies project organization and asset management in complex games.

There are, of course, always drawbacks:

There is an extra layer of complexity.

Performance is lower than when using simple APIs directly.

It is not possible to use multiple threads to control them.

More memory is needed.

In many cases, this is not really a problem (Godot is very optimized, and most operations are handled with signals, so no polling is required). Still, sometimes it can be. For example, dealing with tens of thousands of instances for something that needs to be processed every frame can be a bottleneck.

This type of situation makes programmers regret they are using a game engine and wish they could go back to a more handcrafted, low-level implementation of game code.

Still, Godot is designed to work around this problem.

You can see how using low-level servers works in action using the Bullet Shower demo project

One of the most interesting design decisions for Godot is the fact that the whole scene system is optional. While it is not currently possible to compile it out, it can be completely bypassed.

At the core, Godot uses the concept of Servers. They are very low-level APIs to control rendering, physics, sound, etc. The scene system is built on top of them and uses them directly. The most common servers are:

RenderingServer: handles everything related to graphics.

PhysicsServer3D: handles everything related to 3D physics.

PhysicsServer2D: handles everything related to 2D physics.

AudioServer: handles everything related to audio.

Explore their APIs and you will realize that all the functions provided are low-level implementations of everything Godot allows you to do.

The key to using servers is understanding Resource ID (RID) objects. These are opaque handles to the server implementation. They are allocated and freed manually. Almost every function in the servers requires RIDs to access the actual resource.

Most Godot nodes and resources contain these RIDs from the servers internally, and they can be obtained with different functions. In fact, anything that inherits Resource can be directly casted to an RID. Not all resources contain an RID, though: in such cases, the RID will be empty. The resource can then be passed to server APIs as an RID.

Resources are reference-counted (see RefCounted), and references to a resource's RID are not counted when determining whether the resource is still in use. Make sure to keep a reference to the resource outside the server, or else both it and its RID will be erased.

For nodes, there are many functions available:

For CanvasItem, the CanvasItem.get_canvas_item() method will return the canvas item RID in the server.

For CanvasLayer, the CanvasLayer.get_canvas() method will return the canvas RID in the server.

For Viewport, the Viewport.get_viewport_rid() method will return the viewport RID in the server.

For 3D, the World3D resource (obtainable in the Viewport and Node3D nodes) contains functions to get the RenderingServer Scenario, and the PhysicsServer Space. This allows creating 3D objects directly with the server API and using them.

For 2D, the World2D resource (obtainable in the Viewport and CanvasItem nodes) contains functions to get the RenderingServer Canvas, and the Physics2DServer Space. This allows creating 2D objects directly with the server API and using them.

The VisualInstance3D class, allows getting the scenario instance and instance base via the VisualInstance3D.get_instance() and VisualInstance3D.get_base() respectively.

Try exploring the nodes and resources you are familiar with and find the functions to obtain the server RIDs.

It is not advised to control RIDs from objects that already have a node associated. Instead, server functions should always be used for creating and controlling new ones and interacting with the existing ones.

This is an example of how to create a sprite from code and move it using the low-level CanvasItem API.

The Canvas Item API in the server allows you to add draw primitives to it. Once added, they can't be modified. The Item needs to be cleared and the primitives re-added (this is not the case for setting the transform, which can be done as many times as desired).

Primitives are cleared this way:

The 3D APIs are different from the 2D ones, so the instantiation API must be used.

This creates a RigidBody2D using the PhysicsServer2D API, and moves a CanvasItem when the body moves.

The 3D version should be very similar, as 2D and 3D physics servers are identical (using RigidBody3D and PhysicsServer3D respectively).

Try to never request any information from RenderingServer, PhysicsServer2D or PhysicsServer3D by calling functions unless you know what you are doing. These servers will often run asynchronously for performance and calling any function that returns a value will stall them and force them to process anything pending until the function is actually called. This will severely decrease performance if you call them every frame (and it won't be obvious why).

Because of this, most APIs in such servers are designed so it's not even possible to request information back, until it's actual data that can be saved.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
extends Node2D


# RenderingServer expects references to be kept around.
var texture


func _ready():
    # Create a canvas item, child of this node.
    var ci_rid = RenderingServer.canvas_item_create()
    # Make this node the parent.
    RenderingServer.canvas_item_set_parent(ci_rid, get_canvas_item())
    # Draw a texture on it.
    # Remember, keep this reference.
    texture = load("res://my_texture.png")
    # Add it, centered.
    RenderingServer.canvas_item_add_texture_rect(ci_rid, Rect2(-texture.get_size() / 2, texture.get_size()), texture)
    # Add the item, rotated 45 degrees and translated.
    var xform = Transform2D().rotated(deg_to_rad(45)).translated(Vector2(20, 30))
    RenderingServer.canvas_item_set_transform(ci_rid, xform)
```

Example 2 (unknown):
```unknown
public partial class MyNode2D : Node2D
{
    // RenderingServer expects references to be kept around.
    private Texture2D _texture;

    public override void _Ready()
    {
        // Create a canvas item, child of this node.
        Rid ciRid = RenderingServer.CanvasItemCreate();
        // Make this node the parent.
        RenderingServer.CanvasItemSetParent(ciRid, GetCanvasItem());
        // Draw a texture on it.
        // Remember, keep this reference.
        _texture = ResourceLoader.Load<Texture2D>("res://MyTexture.png");
        // Add it, centered.
        RenderingServer.CanvasItemAddTextureRect(ciRid, new Rect2(-_texture.GetSize() / 2, _texture.GetSize()), _texture.GetRid());
        // Add the item, rotated 45 degrees and translated.
        Transform2D xform = Transform2D.Identity.Rotated(Mathf.DegToRad(45)).Translated(new Vector2(20, 30));
        RenderingServer.CanvasItemSetTransform(ciRid, xform);
    }
}
```

Example 3 (unknown):
```unknown
RenderingServer.canvas_item_clear(ci_rid)
```

Example 4 (unknown):
```unknown
RenderingServer.CanvasItemClear(ciRid);
```

---

## Optimizing a build for size — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/compiling/optimizing_for_size.html

**Contents:**
- Optimizing a build for size
- Rationale
- Stripping binaries
- Compiling with link-time optimization
- Optimizing for size instead of speed
- Detecting used features from the current project and disabling unused features
- Disabling advanced text server
- Disabling 3D
- Disabling advanced GUI objects
- Disabling physics engines

Sometimes, it is desired to optimize a build for size rather than speed. This means not compiling unused functions from the engine, as well as using specific compiler flags to aid on decreasing build size. Common situations include creating builds for mobile and Web platforms.

This tutorial aims to give an overview on different methods to create a smaller binary. Before continuing, it is recommended to read the previous tutorials on compiling Godot for each platform.

The options below are listed from the most important (greatest size savings) to the least important (lowest size savings).

Space savings: Very high

Performed in official builds: Yes

If you build Windows (MinGW), Linux or macOS binaries from source, remember to strip debug symbols from binaries by installing the strip package from your distribution then running:

On Windows, strip.exe is included in most MinGW toolchain setups.

This will reduce the size of compiled binaries by a factor between 5× and 10×. The downside is that crash backtraces will no longer provide accurate information (which is useful for troubleshooting the cause of a crash). C++ profilers will also no longer be able to display function names (this does not affect the built-in GDScript profiler).

The above command will not work on Windows binaries compiled with MSVC and platforms such as Android and Web. Instead, pass debug_symbols=no on the SCons command line when compiling.

Performed in official builds: Yes

Enabling link-time optimization produces more efficient binaries, both in terms of performance and file size. It works by eliminating duplicate template functions and unused code. It can currently be used with the GCC and MSVC compilers:

Linking becomes much slower and more RAM-consuming with this option, so it should be used only for release builds. You need to have at least 8 GB of RAM available for successful linking with LTO enabled. Since the operating system and programs will take up some RAM, in practice, you need 12 GB of RAM installed in your system (preferably 16 GB) to compile Godot with LTO enabled.

Performed in official builds: Yes, but only for web builds

Godot 3.1 onwards allows compiling using size optimizations (instead of speed). To enable this, set the optimize flag to size:

Some platforms such as WebAssembly already use this mode by default.

Godot 4.5 introduced the size_extra option, which can further reduce size.

Space savings: Moderate to high depending on project

Difficulty: Easy to medium depending on project

Performed in official builds: No

Godot features an Using the engine compilation configuration editor tool that can detect the features used in the current project and create a build profile. Once saved, this build profile can then be passed to SCons when compiling custom export templates:

Note that for certain projects, the feature detection may be too aggressive and disable features that are actually needed at runtime. This can occur if certain features are used in a way that their usage cannot be detected statically (such as a script being procedurally created and run at runtime).

More specific features can be disabled by following the sections below, but remember that many of them are automatically detected by the engine compilation configuration detector.

Performed in official builds: No

By default, Godot uses an advanced text server with the support for the following features:

Right-to-left typesetting and complex scripts, required to write languages such as Arabic and Hebrew.

Font ligatures and OpenType features (such as small capitals, fractions and slashed zero).

Godot provides a fallback text server that isn't compiled by default. This text server can be used as a lightweight alternative to the default advanced text server:

If you only intend on supporting Latin, Greek and Cyrillic-based languages in your project, the fallback text server should suffice.

This fallback text server can also process large amounts of text more quickly than the advanced text server. This makes the fallback text server a good fit for mobile/web projects.

Remember to always pass module_text_server_fb_enabled=yes when using module_text_server_adv_enabled=no. Otherwise, the compiled binary won't contain any text server, which means no text will be displayed at all when running the project.

Space savings: Moderate

Performed in official builds: No

For 2D games, having the whole 3D engine available usually makes no sense. Because of this, there is a build flag to disable it:

Tools must be disabled in order to use this flag, as the editor is not designed to operate without 3D support. Without it, the binary size can be reduced by about 15%.

Space savings: Moderate

Performed in official builds: No

Most small games don't require complex GUI controls such as Tree, ItemList, TextEdit or GraphEdit. They can be disabled using a build flag:

This is everything that will be disabled:

PopupMenu (will make all popup menus unavailable in code for classes that use them, like LineEdit, even though those classes are still available)

Space savings: Low to moderate

Performed in official builds: No

If your 3D project uses Jolt Physics, you can disable GodotPhysics3D at compile-time as it will never be used:

Inversely, if your 3D project uses GodotPhysics3D, you can disable Jolt Physics at compile-time:

If your project uses 3D rendering but not physics (or 2D rendering but not physics), you can also disable 2D or 3D physics entirely. Most 3D projects can take advantage of this, as they don't make use of 2D physics:

Space savings: Very low to moderate depending on modules

Difficulty: Medium to hard depending on modules

Performed in official builds: No

A lot of Godot's functions are offered as modules. You can see a list of modules with the following command:

The list of modules that can be disabled will appear, together with all build options. If you are working on a simple 2D game, you could disable a lot of them:

If this proves not to work for your use case, you should review the list of modules and see which ones you actually still need for your game (e.g. you might want to keep networking-related modules, regex support, minimp3/ogg/vorbis to play music, or theora to play videos).

Alternatively, you can supply a list of disabled modules by creating custom.py at the root of the source, with the contents similar to the following:

Overriding the build options.

This section is only relevant when distributing the files on a desktop platform that doesn't perform its own compression or packing. As such, this advice is relevant when you distribute ZIP archives on itch.io or GitHub Releases.

Platforms like Steam already apply their own compression scheme, so you don't need to create a ZIP archive to distribute files in the first place.

As an aside, you can look into optimizing the distribution of your project itself. This can be done even without recompiling the export template.

7-Zip can be used to create ZIP archives that are more efficient than usual, while remaining compatible with every ZIP extractor (including Windows' own built-in extractor). ZIP size reduction in a large project can reach dozens of megabytes compared to a typical ZIP compressor, although average savings are in the 1-5 MB range. Creating this ZIP archive will take longer than usual, but it will extract just as fast as any other ZIP archive.

When using the 7-Zip GUI, this is done by creating a ZIP archive with the Ultra compression mode. When using the command line, this is done using the following command:

Enabling gzip or Brotli compression for all file types from the web export (especially the .wasm and .pck) can reduce the download size significantly, leading to faster loading times, especially on slow connections.

Creating precompressed gzip or Brotli files with a high compression level can be even more efficient, as long as the web server is configured to serve those files when they exist. When supported, Brotli should be preferred over gzip as it has a greater potential for file size reduction.

See Serving the files for instructions.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
strip path/to/godot.binary
```

Example 2 (unknown):
```unknown
scons target=template_release lto=full
```

Example 3 (unknown):
```unknown
scons target=template_release optimize=size
```

Example 4 (unknown):
```unknown
scons target=template_release optimize=size_extra
```

---

## Optimizing Navigation Performance — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/navigation/navigation_optimizing_performance.html

**Contents:**
- Optimizing Navigation Performance
- Performance problems with parsing scene tree nodes
- Performance problems with navigation mesh baking
- Performance problems with NavigationAgent path queries
- Performance problems with the actual path search
- Performance problems with navigation map synchronization
- User-contributed notes

Common Navigation related performance problems can be categorized into the following topics:

Performance problems with parsing scene tree nodes for navigation mesh baking.

Performance problems with baking the actual navigation mesh.

Performance problems with NavigationAgent path queries.

Performance problems with the actual path search.

Performance problems with synchronizing the navigation map.

In the following sections information can be found on how to identify and fix or at least mitigate their impact on framerates.

Prefer using simple shapes with as few edges as possible e.g. nothing rounded like a circle, sphere or torus.

Prefer using physics collision shapes over complex visual meshes as source geometry as meshes need to be copied from the GPU and are commonly much more detailed than necessary.

In general avoid using very complex geometry as source geometry for baking navigation meshes. E.g. never use a very detailed visual mesh, as parsing its shape to data arrays and voxelizing it for the navigation mesh baking will take a long time for no real quality gain on the final navigation mesh. Instead, use a very simplified level of detail version of a shape. Even better, use very primitive shapes like boxes and rectangles that only roughly cover the same geometry but still yield a baked result good enough for pathfinding.

Prefer using simple physics collision shapes over visual meshes, as the source geometry for baking navigation meshes. Physics shapes are by default very limited and optimized shapes that are easy and quick to parse. A visual mesh on the other hand can range from simple to complex. On top, to gain access to visual mesh data the parser needs to request the mesh data arrays from the RenderingServer as visual mesh data is stored directly on the GPU and is not cached on the CPU. This requires locking the RenderingServer thread and can severely impact framerate at runtime while the rendering runs multi-threaded. If the rendering runs single-threaded, the framerate impact might be even worse and the mesh parsing might freeze the entire game for a few seconds on complex meshes.

At runtime, always prefer to use a background thread for baking navigation meshes.

Increase NavigationMesh cell_size and cell_height to create less voxels.

Change the SamplePartitionType from watershed to monotone or layers to gain baking performance.

NEVER scale source geometry with nodes to avoid precision errors. Most scale applies only visually and shapes that are very large at their base scale require still a lot of extra processing even while downscaled.

Baking navigation meshes at runtime should always be done in a background thread if possible. Even small sized navigation meshes can take far longer to bake than what is possible to squeeze into a single frame, at least if the framerate should stay at a bearable level.

Complexity of source geometry data parsed from scene tree nodes has big impact on baking performance as everything needs to be mapped to a grid / voxels. For runtime baking performance the NavigationMesh cell size and cell height should be set as high as possible without causing navigation mesh quality problems for a game. If cell size or cell height is set too low the baking is forced to create an excessive amount of voxels to process the source geometry. If the source geometry spans over a very large game world it is even possible that the baking process runs out of memory in the middle and crashes the game. The partition type can also be lowered depending on how complex the games source geometry is to gain some performance. E.g. games with mostly flat surfaces with blocky geometry can get away with the monotone or layers mode that are a lot faster to bake (e.g. because they require no distance field pass).

Never scale source geometry with nodes. Not only can it result in a lot of precision errors with wrongly matched vertices and edges but also some scaling only exists as visuals and not in the actual parsed data. E.g. if a mesh is downscaled visually in the Editor, e.g. the scale set to 0.001 on a MeshInstance, the mesh still requires a gigantic and very complex voxel grid to be processed for the baking.

Avoid unnecessary path resets and queries every frame in NavigationAgent scripts.

Avoid updating all NavigationAgent paths in the same frame.

Logical errors and wasteful operations in the custom NavigationAgent scripts are very common causes of performance issues, e.g. watch out for resetting the path every single frame. By default NavigationAgents are optimized to only query new paths when the target position changes, the navigation map changes or they are forced too far away from the desired path distance.

E.g. when AI should move to the player, the target position should not be set to the player position every single frame as this queries a new path every frame. Instead, the distance from the current target position to the player position should be compared and only when the player has moved too far away a new target position should be set.

Do not check beforehand if a target position is reachable every frame. What looks like an innocent check is the equivalent of an expensive path query behind the scene. If the plan is to request a new path anyway should the position be reachable, a path should be queried directly. By looking at the last position of the returned path and if that position is in a "reachable" distance to the checked position it answers the "is this position reachable?" question. This avoids doing the equivalent of two full path queries every frame for the same NavigationAgent.

Divide the total number of NavigationAgents into update groups or use random timers so that they do not all request new paths in the same frame.

Optimize overdetailed navigation meshes by reducing the amount of polygons and edges.

The cost of the actual path search correlates directly with the amount of navigation mesh polygons and edges and not the real size of a game world. If a giant game world uses very optimized navigation meshes with only few polygons that cover large areas, performance should be acceptable. If the game world is splintered into very small navigation meshes that each have tiny polygons (like for TileMaps) pathfinding performance will be reduced.

A common problem is a sudden performance drop when a target position is not reachable in a path query. This performance drop is "normal" and the result of a too large, too unoptimized navigation mesh with way to much polygons and edges to search through. In normal path searches where the target position can be reached quickly the pathfinding will do an early exit as soon as the position is reached which can hide this lack of optimization for a while. If the target position can not be reached the pathfinding has to do a far longer search through the available polygons to confirm that the position is absolutely not reachable.

Merge navigation meshes polygons by vertex instead of by edge connection wherever possible.

When changes are made to e.g. navigation meshes or navigation regions, the NavigationServer needs to synchronize the navigation map. Depending on the complexity of navigation meshes, this can take a significant amount of time which may impact the framerate.

The NavigationServer merges navigation meshes either by vertex or by edge connection. The merge by vertex happens when the two vertex of two different edges land in the same map grid cells. This is a rather quick and low-cost operation. The merge by edge connection happens in a second pass for all still unmerged edges. All the free edges are checked for possible edge connections by both distance and angle which is rather costly.

So apart from the general rule to have as few polygon edges as possible, as many edges as possible should be merged by vertex upfront so only a few edges are left for the more costly edge connection calculation. The debug Navigation PerformanceMonitor can be used to get statistics on how many polygons and edges are available and how many of them are unmerged or not merged by vertex. If the ratio between vertex merged and edge connections is way off (vertex should be significantly higher) the navigation meshes are properly created or placed very inefficient.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Overview of renderers — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/rendering/renderers.html

**Contents:**
- Overview of renderers
- Introduction
  - Renderers, rendering drivers, and RenderingDevice
- Choosing a renderer
  - Switching between renderers
- Feature comparison
  - Overall comparison
  - Lights and shadows
  - Global Illumination
  - Environment and post-processing

This page gives an overview of Godot's renderers, focusing on the differences between their rendering features. For more technical details on the renderers, see Internal rendering architecture.

Godot 4 includes three renderers:

Forward+. The most advanced renderer, suited for desktop platforms only. Used by default on desktop platforms. This renderer uses Vulkan, Direct3D 12, or Metal as the rendering driver, and it uses the RenderingDevice backend.

Mobile. Fewer features, but renders simple scenes faster. Suited for mobile and desktop platforms. Used by default on mobile platforms. This renderer uses Vulkan, Direct3D 12, or Metal as the rendering driver, and it uses the RenderingDevice backend.

Compatibility, sometimes called GL Compatibility. The least advanced renderer, suited for low-end desktop and mobile platforms. Used by default on the web platform. This renderer uses OpenGL as the rendering driver.

Godot's rendering abstraction layers.

The renderer, or rendering method, determines which features are available. Most of the time, this is the only thing you need to think about. Godot's renderers are Forward+, Mobile, and Compatibility.

The rendering driver tells the GPU what to do, using a graphics API. Godot can use the OpenGL, Vulkan, Direct3D 12, and Metal rendering drivers. Not every GPU supports every rendering driver, and therefore not every GPU supports all renderers. Vulkan, Direct3D 12, and Metal are modern, low-level graphics APIs, and requires newer hardware. OpenGL is an older graphics API that runs on most hardware.

RenderingDevice is a rendering backend, an abstraction layer between the renderer and the rendering driver. It is used by the Forward+ and Mobile renderers, and these renderers are sometimes called "RenderingDevice-based renderers".

Choosing a renderer is a complex question, and depends on your hardware and the which platforms you are developing for. As a starting point:

You are developing for desktop.

You have relatively new hardware which supports Vulkan, Direct3D 12, or Metal.

You are developing a 3D game.

You want to use the most advanced rendering features.

You are developing for newer mobile devices, desktop XR, or desktop.

You have relatively new hardware which supports Vulkan, Direct3D 12, or Metal.

You are developing a 3D game.

You want to use advanced rendering features, subject to the limitations of mobile hardware.

Choose Compatibility if:

You are developing for older mobile devices, older desktop devices, or standalone XR. The Compatibility renderer supports the widest range of hardware.

You are developing for web. In this case, Compatibility is the only choice.

You have older hardware which does not support Vulkan. In this case, Compatibility is the only choice.

You are developing a 2D game, or a 3D game which does not need advanced rendering features.

You want the best performance possible on all devices and don't need advanced rendering features.

Keep in mind every game is unique, and this is only a starting point. For example, you might choose to use the Compatibility renderer even though you have the latest GPU, so you can support the widest range of hardware. Or you might want to use the Forward+ renderer for a 2D game, so you can advanced features like compute shaders.

In the editor, you can always switch between renderers by clicking on the renderer name in the upper-right corner of the editor.

Switching between renderers may require some manual tweaks to your scene, lighting, and environment, since each renderer is different. In general, switching between the Mobile and Forward+ renderers will require fewer adjustments than switching between the Compatibility renderer and the Forward+ or Mobile renderers.

Since Godot 4.4, when using Forward+ or Mobile, if Vulkan is not supported, the engine will fall back to Direct3D 12 and vice versa. If the attempted fallback driver is not supported either, the engine will then fall back to Compatibility when the RenderingDevice backend is not supported. This allows the project to run anyway, but it may look different than the intended appearance due to the more limited renderer. This behavior can be disabled in the project settings by unchecking Rendering > Rendering Device > Fallback to OpenGL 3.

This is not a complete list of the features of each renderer. If a feature is not listed here, it is available in all renderers, though it may be much faster on some renderers. For a list of all features in Godot, see List of features.

Hardware with RenderingDevice support is hardware which can run Vulkan, Direct3D 12, or Metal.

Newer or high-end. Requires Vulkan, Direct3D 12, or Metal support.

Newer or high-end. Requires Vulkan, Direct3D 12, or Metal support.

Runs on old and low-end hardware

✔️ Yes, but slower than Compatibility.

✔️ Yes, but slowest of all renderers.

Runs on hardware without RenderingDevice support

Mobile, low-end desktop, web.

⚠️ Supported, but poorly optimized. Use Mobile or Compatibility instead.

✔️ Yes. Recommended for standalone headsets.

✔️ Yes. Recommended for desktop headsets.

⚠️ Supported, but poorly optimized. Use Mobile or Compatibility instead.

✔️ Yes, but Compatibility is usually good enough for 2D.

✔️ Yes, but Compatibility is usually good enough for 2D.

2D and core 3D features.

Most rendering features.

All rendering features.

2D rendering features

Core 3D rendering features

Advanced rendering features

⚠️ Yes, limited by mobile hardware.

✔️ Yes. All rendering features are supported.

⚠️ Some new rendering features are added to Compatibility. Features are added after Mobile and Forward+.

✔️ Most new rendering features are added to Mobile. Mobile usually gets new features as Forward+ does.

✔️ All new features are added to Forward+. As the focus of new development, Forward+ gets features first.

Low base cost, but high scaling cost.

Medium base cost, and medium scaling cost.

Highest base cost, and low scaling cost.

Vulkan, Direct3D 12, or Metal.

Vulkan, Direct3D 12, or Metal.

See 3D lights and shadows for more information.

8 per mesh. Can be increased.

8 per mesh, 256 per view.

512 per cluster. Can be increased.

8 per mesh. Can be increased.

8 per mesh, 256 per view.

512 per cluster. Can be increased.

Maximum DirectionalLights

PCSS for OmniLight and SpotLight

PCSS for DirectionalLight

Light projector textures

See Introduction to global illumination for more information.

✔️ Supported, 2 per mesh.

✔️ Supported, 8 per mesh.

✔️ Supported, unlimited.

⚠️ Rendering of baked lightmaps is supported. Baking requires hardware with RenderingDevice support.

Screen-Space Indirect Lighting (SSIL)

Signed Distance Field Global Illumination (SDFGI)

See Environment and post-processing for more information.

Fog (Depth and Height)

Screen-Space Reflections

Screen-Space Ambient Occlusion (SSAO)

Screen-Space Indirect Lighting (SSIL)

Signed Distance Field Global Illumination (SDFGI)

Custom post-processing with fullscreen quad

Custom post-processing with CompositorEffects

See 3D antialiasing for more information.

Screen-space roughness limiter

See Standard Material 3D and ORM Material 3D for more information.

Sub-surface scattering

See Shading reference for more information.

Normal/Roughness texture

⚠️ Supported, but comes with a performance penalty on older devices.

Variable rate shading

Adaptive and Mailbox VSync modes

RenderingDevice access

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Performance — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/performance/index.html

**Contents:**
- Performance
- Introduction
- Common
- CPU
- GPU
- 3D
- Threads

Godot follows a balanced performance philosophy. In the performance world, there are always tradeoffs, which consist of trading speed for usability and flexibility. Some practical examples of this are:

Rendering large amounts of objects efficiently is easy, but when a large scene must be rendered, it can become inefficient. To solve this, visibility computation must be added to the rendering. This makes rendering less efficient, but at the same time, fewer objects are rendered. Therefore, the overall rendering efficiency is improved.

Configuring the properties of every material for every object that needs to be rendered is also slow. To solve this, objects are sorted by material to reduce the costs. At the same time, sorting has a cost.

In 3D physics, a similar situation happens. The best algorithms to handle large amounts of physics objects (such as SAP) are slow at insertion/removal of objects and raycasting. Algorithms that allow faster insertion and removal, as well as raycasting, will not be able to handle as many active objects.

And there are many more examples of this! Game engines strive to be general-purpose in nature. Balanced algorithms are always favored over algorithms that might be fast in some situations and slow in others, or algorithms that are fast but are more difficult to use.

Godot is not an exception to this. While it is designed to have backends swappable for different algorithms, the default backends prioritize balance and flexibility over performance.

With this clear, the aim of this tutorial section is to explain how to get the maximum performance out of Godot. While the tutorials can be read in any order, it is a good idea to start from General optimization tips.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Platform-specific — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/platform/index.html

**Contents:**
- Platform-specific

Godot supports both running the editor and exporting projects on several platforms. Usage of the engine is generally similar across platforms, but there are some platform-specific considerations, which are covered in this section.

For platform-specific versions of the editor, see Using the XR editor, Using the Android editor, and Using the Web editor. For exporting to specific platforms, see the Export section.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Plugins for iOS — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/platform/ios/plugins_for_ios.html

**Contents:**
- Plugins for iOS
- Accessing plugin singletons
- Asynchronous methods
- Store Kit
  - purchase
    - Parameters
    - Response event
  - request_product_info
    - Parameters
    - Response event

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

Godot provides StoreKit, GameCenter, iCloud services and other plugins. They are using same model of asynchronous calls explained below.

ARKit and Camera access are also provided as plugins.

Latest updates, documentation and source code can be found at Godot iOS plugins repository

To access plugin functionality, you first need to check that the plugin is exported and available by calling the Engine.has_singleton() function, which returns a registered singleton.

Here's an example of how to do this in GDScript:

When requesting an asynchronous operation, the method will look like this:

The parameter will usually be a Dictionary, with the information necessary to make the request, and the call will have two phases. First, the method will immediately return an Error value. If the Error is not 'OK', the call operation is completed, with an error probably caused locally (no internet connection, API incorrectly configured, etc). If the error value is 'OK', a response event will be produced and added to the 'pending events' queue. Example:

Remember that when a call returns OK, the API will always produce an event through the pending_event interface, even if it's an error, or a network timeout, etc. You should be able to, for example, safely block the interface waiting for a reply from the server. If any of the APIs don't behave this way it should be treated as a bug.

The pending event interface consists of two methods:

get_pending_event_count() Returns the number of pending events on the queue.

Variant pop_pending_event() Pops the first event from the queue and returns it.

Implemented in Godot iOS InAppStore plugin.

The Store Kit API is accessible through the InAppStore singleton. It is initialized automatically.

The following methods are available and documented below:

Purchases a product ID through the Store Kit API. You have to call finish_transaction(product_id) once you receive a successful response or call set_auto_finish_transaction(true) prior to calling purchase(). These two methods ensure the transaction is completed.

Takes a dictionary as a parameter, with one field, product_id, a string with your product ID. Example:

The response event will be a dictionary with the following fields:

Requests the product info on a list of product IDs.

Takes a dictionary as a parameter, with a single product_ids key to which a string array of product IDs is assigned. Example:

The response event will be a dictionary with the following fields:

Restores previously made purchases on user's account. This will create response events for each previously purchased product ID.

The response events will be dictionaries with the following fields:

If set to true, once a purchase is successful, your purchase will be finalized automatically. Call this method prior to calling purchase().

Takes a boolean as a parameter which specifies if purchases should be automatically finalized. Example:

If you don't want transactions to be automatically finalized, call this method after you receive a successful purchase response.

Takes a string product_id as an argument. product_id specifies what product to finalize the purchase on. Example:

Implemented in Godot iOS GameCenter plugin.

The Game Center API is available through the GameCenter singleton. It has the following methods:

and the pending events interface:

Authenticates a user in Game Center.

The response event will be a dictionary with the following fields:

Posts a score to a Game Center leaderboard.

Takes a dictionary as a parameter, with two fields:

category a string with the category name

The response event will be a dictionary with the following fields:

Modifies the progress of a Game Center achievement.

Takes a Dictionary as a parameter, with 3 fields:

name (string) the achievement name

progress (float) the achievement progress from 0.0 to 100.0 (passed to GKAchievement::percentComplete)

show_completion_banner (bool) whether Game Center should display an achievement banner at the top of the screen

The response event will be a dictionary with the following fields:

Clears all Game Center achievements. The function takes no parameters.

The response event will be a dictionary with the following fields:

Request all the Game Center achievements the player has made progress on. The function takes no parameters.

The response event will be a dictionary with the following fields:

Request the descriptions of all existing Game Center achievements regardless of progress. The function takes no parameters.

The response event will be a dictionary with the following fields:

Displays the built-in Game Center overlay showing leaderboards, achievements, and challenges.

Takes a Dictionary as a parameter, with two fields:

view (string) (optional) the name of the view to present. Accepts "default", "leaderboards", "achievements", or "challenges". Defaults to "default".

leaderboard_name (string) (optional) the name of the leaderboard to present. Only used when "view" is "leaderboards" (or "default" is configured to show leaderboards). If not specified, Game Center will display the aggregate leaderboard.

The response event will be a dictionary with the following fields:

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
var in_app_store
var game_center

func _ready():
    if Engine.has_singleton("InAppStore"):
        in_app_store = Engine.get_singleton("InAppStore")
    else:
        print("iOS IAP plugin is not available on this platform.")

    if Engine.has_singleton("GameCenter"):
        game_center = Engine.get_singleton("GameCenter")
    else:
        print("iOS Game Center plugin is not available on this platform.")
```

Example 2 (unknown):
```unknown
Error purchase(Variant params);
```

Example 3 (gdscript):
```gdscript
func on_purchase_pressed():
    var result = in_app_store.purchase({ "product_id": "my_product" })
    if result == OK:
        animation.play("busy") # show the "waiting for response" animation
    else:
        show_error()

# put this on a 1 second timer or something
func check_events():
    while in_app_store.get_pending_event_count() > 0:
        var event = in_app_store.pop_pending_event()
        if event.type == "purchase":
            if event.result == "ok":
                show_success(event.product_id)
            else:
                show_error()
```

Example 4 (unknown):
```unknown
Error purchase(Variant params)
   Error request_product_info(Variant params)
   Error restore_purchases()
   void set_auto_finish_transaction(bool enable)
   void finish_transaction(String product_id)

and the pending events interface:

::

   int get_pending_event_count()
   Variant pop_pending_event()
```

---

## Plugins — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/plugins/index.html

**Contents:**
- Plugins

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Project organization — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/best_practices/project_organization.html

**Contents:**
- Project organization
- Introduction
- Organization
- Style guide
- Importing
  - Ignoring specific folders
- Case sensitivity
- User-contributed notes

Since Godot has no restrictions on project structure or filesystem usage, organizing files when learning the engine can seem challenging. This tutorial suggests a workflow which should be a good starting point. We will also cover using version control with Godot.

Godot is scene-based in nature, and uses the filesystem as-is, without metadata or an asset database.

Unlike other engines, many resources are contained within the scene itself, so the amount of files in the filesystem is considerably lower.

Considering that, the most common approach is to group assets as close to scenes as possible; when a project grows, it makes it more maintainable.

As an example, one can usually place into a single folder their basic assets, such as sprite images, 3D model meshes, materials, and music, etc. They can then use a separate folder to store built levels that use them.

For consistency across projects, we recommend following these guidelines:

Use snake_case for folder and file names (with the exception of C# scripts). This sidesteps case sensitivity issues that can crop up after exporting a project on Windows. C# scripts are an exception to this rule, as the convention is to name them after the class name which should be in PascalCase.

Use PascalCase for node names, as this matches built-in node casing.

In general, keep third-party resources in a top-level addons/ folder, even if they aren't editor plugins. This makes it easier to track which files are third-party. There are some exceptions to this rule; for instance, if you use third-party game assets for a character, it makes more sense to include them within the same folder as the character scenes and scripts.

Godot versions prior to 3.0 did the import process from files outside the project. While this can be useful in large projects, it resulted in an organization hassle for most developers.

Because of this, assets are now transparently imported from within the project folder.

To prevent Godot from importing files contained in a specific folder, create an empty file called .gdignore in the folder (the leading . is required). This can be useful to speed up the initial project importing.

To create a file whose name starts with a dot on Windows, place a dot at both the beginning and end of the filename (".gdignore."). Windows will automatically remove the trailing dot when you confirm the name.

Alternatively, you can use a text editor such as Notepad++ or use the following command in a command prompt: type nul > .gdignore

Once the folder is ignored, resources in that folder can't be loaded anymore using the load() and preload() methods. Ignoring a folder will also automatically hide it from the FileSystem dock, which can be useful to reduce clutter.

Note that the .gdignore file's contents are ignored, which is why the file should be empty. It does not support patterns like .gitignore files do.

Windows and recent macOS versions use case-insensitive filesystems by default, whereas Linux distributions use a case-sensitive filesystem by default. This can cause issues after exporting a project, since Godot's PCK virtual filesystem is case-sensitive. To avoid this, it's recommended to stick to snake_case naming for all files in the project (and lowercase characters in general).

You can break this rule when style guides say otherwise (such as the C# style guide). Still, be consistent to avoid mistakes.

On Windows 10, to further avoid mistakes related to case sensitivity, you can also make the project folder case-sensitive. After enabling the Windows Subsystem for Linux feature, run the following command in a PowerShell window:

If you haven't enabled the Windows Subsystem for Linux, you can enter the following line in a PowerShell window running as Administrator then reboot when asked:

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
/project.godot
/docs/.gdignore  # See "Ignoring specific folders" below
/docs/learning.html
/models/town/house/house.dae
/models/town/house/window.png
/models/town/house/door.png
/characters/player/cubio.dae
/characters/player/cubio.png
/characters/enemies/goblin/goblin.dae
/characters/enemies/goblin/goblin.png
/characters/npcs/suzanne/suzanne.dae
/characters/npcs/suzanne/suzanne.png
/levels/riverdale/riverdale.scn
```

Example 2 (unknown):
```unknown
# To enable case-sensitivity:
fsutil file setcasesensitiveinfo <path to project folder> enable

# To disable case-sensitivity:
fsutil file setcasesensitiveinfo <path to project folder> disable
```

Example 3 (unknown):
```unknown
Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
```

---

## Project Settings — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/editor/project_settings.html

**Contents:**
- Project Settings
- Changing project settings
  - Changing project settings from code
- Reading project settings
- Manually editing project.godot
- Advanced project settings
- User-contributed notes

There are dozens of settings you can change to control a project's execution, including physics, rendering, and windowing settings. These settings can be changed from the Project Settings window, from code, or by manually editing the project.godot file. You can see a full list of settings in the ProjectSettings class.

Internally, Godot stores the settings for a project in a project.godot file, a plain text file in INI format. While this is human-readable and version control friendly, it's not the most convenient to edit. For that reason, the Project Settings window is available to edit these settings. To open the Project Settings, select Project > Project Settings from the main menu.

The Project Settings window

The Project Settings window is mainly used to change settings in the General tab. Additionally, there are tabs for the Input Map, Localization, Globals, Plugins, and Import Defaults. Usage of these other tabs is documented elsewhere.

The General tab of the project settings window works much like the inspector. It displays a list of project settings which you can change, just like inspector properties. There is a list of categories on the left, which you can use to select related groups of settings. You can also search for a specific setting with the Filter Settings field.

Each setting has a default value. Settings can be reset to their default values by clicking the circular arrow Reset button next to each property.

You can use set_setting() to change a setting's value from code:

However, many project settings are only read once when the game starts. After that, changing the setting with set_setting() will have no effect. Instead, most settings have a corresponding property or method on a runtime class like Engine or DisplayServer:

In general, project settings are duplicated at runtime in the Engine, PhysicsServer2D, PhysicsServer3D, RenderingServer, Viewport, or Window classes. In the ProjectSettings class reference, settings links to their equivalent runtime property or method.

You can read project settings with get_setting() or get_setting_with_override():

Since many project settings are only read once at startup, the value in the project settings may no longer be accurate. In these cases, it's better to read the value from the runtime equivalent property or method:

You can open the project.godot file using a text editor and manually change project settings. Note that if the project.godot file does not have a stored value for a particular setting, it is implicitly the default value of that setting. This means that if you are manually editing the file, you may have to write in both the setting name and the value.

In general, it is recommended to use the Project Settings window rather than manually edit project.godot.

The advanced project settings

By default, only some project settings are shown. To see all the project settings, enable the Advanced Settings toggle.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
ProjectSettings.set_setting("application/run/max_fps", 60)
ProjectSettings.set_setting("display/window/size/mode", DisplayServer.WINDOW_MODE_WINDOWED)
```

Example 2 (unknown):
```unknown
ProjectSettings.SetSetting("application/run/max_fps", 60);
ProjectSettings.SetSetting("display/window/size/mode", (int)DisplayServer.WindowMode.Windowed);
```

Example 3 (unknown):
```unknown
Engine.max_fps = 60
DisplayServer.window_set_mode(DisplayServer.WINDOW_MODE_WINDOWED)
```

Example 4 (unknown):
```unknown
Engine.MaxFps = 60;
DisplayServer.WindowSetMode(DisplayServer.WindowMode.Windowed);
```

---

## Pseudolocalization — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/i18n/pseudolocalization.html

**Contents:**
- Pseudolocalization
- Introduction
- Enabling and configuring pseudolocalization
- Pseudolocalization configurations
- Configuring pseudolocalization at runtime
- User-contributed notes

When creating a game, the process of localization usually starts when development has finished. This means that translations aren't available during development for testing whether the project is internationalized properly.

Godot offers pseudolocalization as a way to test how robust the project is when it comes to locale changes. Pseudolocalization simulates changes that might take place during localization. This way, any issues regarding internationalization can be recognized early on during development.

You can see how pseudolocalization works in action using the Pseudolocalizaton demo project.

Enabling pseudolocalization and the configurations related to it is as simple as toggling a checkbox in the project settings. These settings can be found in Project → Project Settings → General → Internationalization → Pseudolocalization after enabling the Advanced toggle in the project settings dialog:

Pseudolocalization can also be toggled at runtime from a script.

Pseudolocalization in Godot can be set up according to the specific use case of the project. Here are the pseudolocalization properties that can be configured through project settings:

replace_with_accents: Replaces all characters in the string with their accented variants. "The quick brown fox jumped over the lazy dog" will be converted to "Ŧh̀é q́üíćḱ ḅŕôŵή f́ôx́ ǰüm̀ṕéd́ ôṽéŕ ŧh̀é łáźý d́ôǵ" when this setting is enabled. This can be used to spot untranslated strings that won't have accents, but is also useful to check for missing glyphs in the font(s) used by the project.

double_vowels: Doubles all the vowels in the string. It is a good approximation to simulate expansion of text during localization. This can be used to check for text that would overflow its container (such as buttons).

fake_bidi: Fake bidirectional text (simulates right-to-left text). This is useful to simulate right-to-left writing systems to check for potential layout issues that would occur in languages using right-to-left scripts.

override: Replaces all the characters in the string with an asterisk (*). This is useful for quickly finding text that isn't being localized.

expansion_ratio: Can be used in cases where doubling the vowels isn't a sufficient approximation. This setting pads the string with underscores (_) and expands it by the given ratio. An expansion ratio of 0.3 is sufficient for most practical cases; it will increase the length of the string by 30%.

prefix and suffix: These properties can be used to specify a prefix and suffix to wrap the text in.

skip_placeholders: Skips placeholders for string formatting like %s and %f. This is useful to identify places where more arguments are required for the formatted string to display correctly.

All of these properties can be toggled as needed according to the project's use case.

Pseudolocalization can be toggled at runtime using the pseudolocalization_enabled property in TranslationServer. However, if runtime configuration of pseudolocalization properties is required, they can be directly configured using ProjectSettings.set_setting(property, value) and then calling TranslationServer.reload_pseudolocalization() which reparses the pseudolocalization properties and reloads the pseudolocalization. The following code snippet shall turn on replace_with_accents and double_vowels properties and then call reload_pseudolocalization() for the changes to get reflected:

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
ProjectSettings.set_setting("internationalization/pseudolocalization/replace_with_accents", true)
ProjectSettings.set_setting("internationalization/pseudolocalization/double_vowels", true)
TranslationServer.reload_pseudolocalization()
```

---

## Qt Creator — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/configuring_an_ide/qt_creator.html

**Contents:**
- Qt Creator
- Importing the project
- Debugging the project
- Code style configuration
- User-contributed notes

Qt Creator is a free, open source IDE for all desktop platforms.

From the Qt Creator's main screen select New Project > Import Project > Import Existing Project.

Under Location select the Godot root folder.

Next, you can choose which folders and files will be visible to the project. While C/C++ files are added automatically, other extensions can be potentially useful: *.glsl for shader files, *.py for buildsystem files, *.java for Android platform development, *.mm for macOS platform development.

You can change this configuration later by right-clicking on your project and selecting the Edit Files... option.

Open the project_name.includes file and add a line containing . to it to correctly enable the code completion.

From the left-side menu select Projects and open the Build tab.

Delete the predefined make build step.

Click Add Build Step > Custom Process Step to add a new build step with the following settings:

See Introduction to the buildsystem for a full list of arguments.

If the build fails with Could not start process "scons", it can mean that scons is not in your PATH environment variable. In this case, you'll have to specify the full path to the SCons binary.

From the left-side menu select Projects and open the Run tab.

Under Executable specify the path to your executable located in the <Godot root directory>/bin folder. The name depends on your build configuration, e.g. godot.linuxbsd.editor.dev.x86_64 for 64-bit LinuxBSD platform with platform=editor and dev_build=yes. You can use %{buildDir} to reference the project root, e.g: %{buildDir}/bin/godot.linuxbsd.editor.dev.x86_64.

If you want to run a specific project, specify its root folder under Working directory.

If you want to run the editor, add -e to the Command line arguments field.

To learn more about command line arguments, refer to the command line tutorial.

Developers must follow the project's code style and the IDE should help them follow it. By default, Qt Creator uses spaces for indentation which doesn't match the Godot code style guidelines. You can change this behavior by changing the Code Style in Tools > Options > C++.

Click on Edit to change the current settings, then click on Copy Built-in Code Style button to set a new code style. Set a name for it (e.g. Godot) and change the Tab policy to be Tabs Only.

If you run into any issues, ask for help in one of Godot's community channels.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Random number generation — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/math/random_number_generation.html

**Contents:**
- Random number generation
- Global scope versus RandomNumberGenerator class
- The randomize() method
- Getting a random number
- Get a random array element
- Get a random dictionary value
- Weighted random probability
- "Better" randomness using shuffle bags
- Random noise
- Cryptographically secure pseudorandom number generation

Many games rely on randomness to implement core game mechanics. This page guides you through common types of randomness and how to implement them in Godot.

After giving you a brief overview of useful functions that generate random numbers, you will learn how to get random elements from arrays, dictionaries, and how to use a noise generator in GDScript. Lastly, we'll take a look at cryptographically secure random number generation and how it differs from typical random number generation.

Computers cannot generate "true" random numbers. Instead, they rely on pseudorandom number generators (PRNGs).

Godot internally uses the PCG Family of pseudorandom number generators.

Godot exposes two ways to generate random numbers: via global scope methods or using the RandomNumberGenerator class.

Global scope methods are easier to set up, but they don't offer as much control.

RandomNumberGenerator requires more code to use, but allows creating multiple instances, each with their own seed and state.

This tutorial uses global scope methods, except when the method only exists in the RandomNumberGenerator class.

Since Godot 4.0, the random seed is automatically set to a random value when the project starts. This means you don't need to call randomize() in _ready() anymore to ensure that results are random across project runs. However, you can still use randomize() if you want to use a specific seed number, or generate it using a different method.

In global scope, you can find a randomize() method. This method should be called only once when your project starts to initialize the random seed. Calling it multiple times is unnecessary and may impact performance negatively.

Putting it in your main scene script's _ready() method is a good choice:

You can also set a fixed random seed instead using seed(). Doing so will give you deterministic results across runs:

When using the RandomNumberGenerator class, you should call randomize() on the instance since it has its own seed:

Let's look at some of the most commonly used functions and methods to generate random numbers in Godot.

The function randi() returns a random number between 0 and 2^32 - 1. Since the maximum value is huge, you most likely want to use the modulo operator (%) to bound the result between 0 and the denominator:

randf() returns a random floating-point number between 0 and 1. This is useful to implement a Weighted random probability system, among other things.

randfn() returns a random floating-point number following a normal distribution. This means the returned value is more likely to be around the mean (0.0 by default), varying by the deviation (1.0 by default):

randf_range() takes two arguments from and to, and returns a random floating-point number between from and to:

randi_range() takes two arguments from and to, and returns a random integer between from and to:

We can use random integer generation to get a random element from an array, or use the Array.pick_random method to do it for us:

To prevent the same fruit from being picked more than once in a row, we can add more logic to the above method. In this case, we can't use Array.pick_random since it lacks a way to prevent repetition:

This approach can be useful to make random number generation feel less repetitive. Still, it doesn't prevent results from "ping-ponging" between a limited set of values. To prevent this, use the shuffle bag pattern instead.

We can apply similar logic from arrays to dictionaries as well:

The randf() method returns a floating-point number between 0.0 and 1.0. We can use this to create a "weighted" probability where different outcomes have different likelihoods:

You can also get a weighted random index using the rand_weighted() method on a RandomNumberGenerator instance. This returns a random integer between 0 and the size of the array that is passed as a parameter. Each value in the array is a floating-point number that represents the relative likelihood that it will be returned as an index. A higher value means the value is more likely to be returned as an index, while a value of 0 means it will never be returned as an index.

For example, if [0.5, 1, 1, 2] is passed as a parameter, then the method is twice as likely to return 3 (the index of the value 2) and twice as unlikely to return 0 (the index of the value 0.5) compared to the indices 1 and 2.

Since the returned value matches the array's size, it can be used as an index to get a value from another array as follows:

Taking the same example as above, we would like to pick fruits at random. However, relying on random number generation every time a fruit is selected can lead to a less uniform distribution. If the player is lucky (or unlucky), they could get the same fruit three or more times in a row.

You can accomplish this using the shuffle bag pattern. It works by removing an element from the array after choosing it. After multiple selections, the array ends up empty. When that happens, you reinitialize it to its default value:

When running the above code, there is a chance to get the same fruit twice in a row. Once we picked a fruit, it will no longer be a possible return value unless the array is now empty. When the array is empty, we reset it back to its default value, making it possible to have the same fruit again, but only once.

The random number generation shown above can show its limits when you need a value that slowly changes depending on the input. The input can be a position, time, or anything else.

To achieve this, you can use random noise functions. Noise functions are especially popular in procedural generation to generate realistic-looking terrain. Godot provides FastNoiseLite for this, which supports 1D, 2D and 3D noise. Here's an example with 1D noise:

So far, the approaches mentioned above are not suitable for cryptographically secure pseudorandom number generation (CSPRNG). This is fine for games, but this is not sufficient for scenarios where encryption, authentication or signing is involved.

Godot offers a Crypto class for this. This class can perform asymmetric key encryption/decryption, signing/verification, while also generating cryptographically secure random bytes, RSA keys, HMAC digests, and self-signed X509Certificates.

The downside of CSPRNG is that it's much slower than standard pseudorandom number generation. Its API is also less convenient to use. As a result, CSPRNG should be avoided for gameplay elements.

Example of using the Crypto class to generate 2 random integers between 0 and 2^32 - 1 (inclusive):

See PackedByteArray's documentation for other methods you can use to decode the generated bytes into various types of data, such as integers or floats.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
func _ready():
    randomize()
```

Example 2 (unknown):
```unknown
public override void _Ready()
{
    GD.Randomize();
}
```

Example 3 (unknown):
```unknown
func _ready():
    seed(12345)
    # To use a string as a seed, you can hash it to a number.
    seed("Hello world".hash())
```

Example 4 (unknown):
```unknown
public override void _Ready()
{
    GD.Seed(12345);
    // To use a string as a seed, you can hash it to a number.
    GD.Seed("Hello world".Hash());
}
```

---

## Recording with microphone — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/audio/recording_with_microphone.html

**Contents:**
- Recording with microphone
- The structure of the demo
- User-contributed notes

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

Godot supports in-game audio recording for Windows, macOS, Linux, Android and iOS.

A simple demo is included in the official demo projects and will be used as support for this tutorial: https://github.com/godotengine/godot-demo-projects/tree/master/audio/mic_record.

You will need to enable audio input in the Audio > Driver > Enable Input project setting, or you'll just get empty audio files.

The demo consists of a single scene. This scene includes two major parts: the GUI and the audio.

We will focus on the audio part. In this demo, a bus named Record with the effect Record is created to handle the audio recording. An AudioStreamPlayer named AudioStreamRecord is used for recording.

The audio recording is handled by the AudioEffectRecord resource which has three methods: get_recording(), is_recording_active(), and set_recording_active().

At the start of the demo, the recording effect is not active. When the user presses the RecordButton, the effect is enabled with set_recording_active(true).

On the next button press, as effect.is_recording_active() is true, the recorded stream can be stored into the recording variable by calling effect.get_recording().

To playback the recording, you assign the recording as the stream of the AudioStreamPlayer and call play().

To save the recording, you call save_to_wav() with the path to a file. In this demo, the path is defined by the user via a LineEdit input box.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
var effect
var recording


func _ready():
    # We get the index of the "Record" bus.
    var idx = AudioServer.get_bus_index("Record")
    # And use it to retrieve its first effect, which has been defined
    # as an "AudioEffectRecord" resource.
    effect = AudioServer.get_bus_effect(idx, 0)
```

Example 2 (unknown):
```unknown
private AudioEffectRecord _effect;
private AudioStreamSample _recording;

public override void _Ready()
{
    // We get the index of the "Record" bus.
    int idx = AudioServer.GetBusIndex("Record");
    // And use it to retrieve its first effect, which has been defined
    // as an "AudioEffectRecord" resource.
    _effect = (AudioEffectRecord)AudioServer.GetBusEffect(idx, 0);
}
```

Example 3 (unknown):
```unknown
func _on_record_button_pressed():
    if effect.is_recording_active():
        recording = effect.get_recording()
        $PlayButton.disabled = false
        $SaveButton.disabled = false
        effect.set_recording_active(false)
        $RecordButton.text = "Record"
        $Status.text = ""
    else:
        $PlayButton.disabled = true
        $SaveButton.disabled = true
        effect.set_recording_active(true)
        $RecordButton.text = "Stop"
        $Status.text = "Recording..."
```

Example 4 (unknown):
```unknown
private void OnRecordButtonPressed()
{
    if (_effect.IsRecordingActive())
    {
        _recording = _effect.GetRecording();
        GetNode<Button>("PlayButton").Disabled = false;
        GetNode<Button>("SaveButton").Disabled = false;
        _effect.SetRecordingActive(false);
        GetNode<Button>("RecordButton").Text = "Record";
        GetNode<Label>("Status").Text = "";
    }
    else
    {
        GetNode<Button>("PlayButton").Disabled = true;
        GetNode<Button>("SaveButton").Disabled = true;
        _effect.SetRecordingActive(true);
        GetNode<Button>("RecordButton").Text = "Stop";
        GetNode<Label>("Status").Text = "Recording...";
    }
}
```

---

## Rendering — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/rendering/index.html

**Contents:**
- Rendering

Most rendering topics are covered in 2D rendering and 3D rendering.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Room scale in XR — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/xr/xr_room_scale.html

**Contents:**
- Room scale in XR
- Origin centric solution
- Step 1
- Step 2
- Step 3
- Character body centric solution
- Step 1
- Step 2
- Step 3
- When the player walks to somewhere they shouldn't

One of the staples of XR projects is the ability to walk around freely in a large space. This space is often constrained by the room the player is physically in with tracking sensors placed within this space. With the advent of inside out tracking however ever larger play spaces are possible.

As a developer this introduces a number of interesting challenges. In this document we will look at a number of the challenges you may face and outline some solutions. We'll discuss the issues and challenges for seated XR games in another document.

Often developers sit behind their desk while building the foundation to their game. In this mode the issues with developing for room scale don't show themselves until it is too late. The advice here is to start testing while standing up and walking around as early as possible. Once you are happy your foundation is solid, you can develop in comfort while remaining seated.

In traditional first person games a player is represented by a CharacterBody3D node. This node is moved by processing traditional controller, mouse or keyboard input. A camera is attached to this node at a location roughly where the player's head will be.

Applying this model to the XR setup, we add an XROrigin3D node as a child of the character body, and add an XRCamera3D as a child of the origin node. At face value this seems to work. However, upon closer examination this model does not take into account that there are two forms of movement in XR. The movement through controller input, and the physical movement of the player in the real world.

As a result, the origin node does not represent the position of the player. It represents the center, or start of, the tracking space in which the player can physically move. As the player moves around their room this movement is represented through the tracking of the player's headset. In game this translates to the camera node's position being updated accordingly. For all intents and purposes, we are tracking a disembodied head. Unless body tracking is available, we have no knowledge of the position or orientation of the player's body.

The first problem this causes is fairly obvious. When the player moves with controller input, we can use the same approach in normal games and move the player in a forward direction. However the player isn't where we think they are and as we move forward we're checking collisions in the wrong location.

The second problem really shows itself when the player walks further away from the center of the tracking space and uses controller input to turn. If we rotate our character body, the player will be moved around the room in a circular fashion.

If we fix the above issues, we will find a third issue. When the path for the player is blocked in the virtual world, the player can still physically move forward.

We will look at solving the first two problem with two separate solutions, and then discuss dealing with the third.

Looking at the first approach for solving this we are going to change our structure. This is the approach currently implemented in XR Tools.

In this setup we mark the character body as top level so it does not move with the origin.

We also have a helper node that tells us where our neck joint is in relation to our camera. We use this to determine where our body center is.

Processing our character movement is now done in three steps.

The Origin centric movement demo contains a more elaborate example of the technique described below.

In the first step we're going to process the physical movement of the player. We determine where the player is right now, and attempt to move our character body there.

Note that we're returning true from our _process_on_physical_movement function when we couldn't move our player all the way.

The second step is to handle rotation of the player as a result of user input.

As the input used can differ based on your needs we are simply calling the function _get_rotational_input. This function should obtain the necessary input and return the rotational speed in radians per second.

For our example we are going to keep this simple and straight forward. We are not going to worry about comfort features such as snap turning and applying a vignette. We highly recommend implementing such comfort features.

We've added the call for processing our rotation to our physics process but we are only executing this if we were able to move our player fully. This means that if the player moves somewhere they shouldn't, we don't process further movement.

The third and final step is moving the player forwards, backwards or sideways as a result of user input.

Just like with the rotation the inputs differ from project to project so we are simply calling the function _get_movement_input. This function should obtain the necessary input and return a directional vector scaled to the required velocity.

Just like with rotation we're keeping it simple. Here too it is advisable to look at adding comfort settings.

In this setup we are going to keep our character body as our root node and as such is easier to combine with traditional game mechanics.

Here we have a standard character body with collision shape, and our XR origin node and camera as normal children. We also have our neck helper node.

Processing our character movement is done in the same three steps but implemented slightly differently.

The Character centric movement demo contains a more elaborate example of the technique described below.

In this approach step 1 is where all the magic happens. Just like with our previous approach we will be applying our physical movement to the character body, but we will counter that movement on the origin node.

This will ensure that the player's location stays in sync with the character body's location.

In essence the code above will move the character body to where the player is, and then move the origin node back in equal amounts. The result is that the player stays centered above the character body.

We start with applying the rotation. The character body should be facing where the player was looking the previous frame. We calculate our camera orientation in the space of the character body. We can now calculate the angle by which the player has rotated their head. We rotate our character body by the same amount so our character body faces the same direction as the player. And then we reverse the rotation on the origin node so the camera ends up aligned with the player again.

For the movement we do much the same. The character body should be where the player was standing the previous frame. We calculate by how much the player has moved from this location. Then we attempt to move the character body to this location.

As the player may hit a collision body and be stopped, we only move the origin point back by the amount we actually moved the character body. The player may thus move away from this location but that will be reflected in the positioning of the player.

As with our previous solution we return true if this is the case.

In this step we again apply the rotation based on controller input. However in this case the code is nearly identical to how one would implement this in a normal first person game.

As the input used can differ based on your needs we are simply calling the function _get_rotational_input. This function should obtain the necessary input and return the rotational speed in radians per second.

For step three we again apply the movement based on controller input. However just like at step 2, we can now implement this as we would in a normal first person game.

Just like with the rotation the inputs differ from project to project so we are simply calling the function _get_movement_input. This function should obtain the necessary input and return a directional vector scaled to the required velocity.

Think of a situation where the player is outside a locked room. You don't want the player to go into that room until the door is unlocked. You also don't want the player to see what is in this room.

The logic for moving the player through controller input nicely prevents this. The player encounters a static body, and the code prevents the player from moving into the room.

However with XR, nothing is preventing the player from taking a real step forward.

With both the approaches worked out up above we will prevent the character body from moving where the player can't go. As the player has physically moved to this location, the camera will now have moved into the room.

The logical solution would be to prevent the movement altogether and adjust the placement of the XR origin point so the player stays outside of the room.

The problem with this approach is that physical movement is now not replicated in the virtual space. This will cause nausea for the player.

What many XR games do instead, is to measure the distance between where the player physically is, and where the player's virtual body has been left behind. As this distance increases, usually to a distance of a few centimeters, the screen slowly blacks out.

Our solutions up above would allow us to add this logic into the code at the end of step 1.

Further improvements to the code presented could be:

allowing controller input as long as this distance is still small,

still applying gravity to the player even when controller input is disabled.

The movement demos in our demo repository contain an example of blacking out the screen when a user walks into restricted areas.

The above provides two good options as starting points for implementing room scale XR games.

A few more things that are worth pointing out that you will likely want to implement:

The height of the camera can be used to detect whether the player is standing up, crouching, jumping or lying down. You can adjust the size and orientation of the collision shape accordingly. Extra bonus points for adding multiple collision shapes so the head and body have their own, more accurately sized, shapes.

When a scene first loads, the player may be far away from the center of the tracking space. This could result in the player spawning into a different room than our origin point. The game will now attempt, and fail, to move the player body from the starting point to where the player is standing. You should implement a reset function that moves the origin point so the player is in the correct starting position.

Both of the above improvements require the player to be ready and standing up straight. There is no guarantee as the player may still be putting their headset on.

Many games, including XR Tools, solve this by introducing an intro screen or loading screen where the player must press a button when they are ready. This starting environment is often a large location where the positioning of the player has little impact on what the player sees. When the player is ready, and presses the button, this is the moment you record the position and height of the camera.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
func _process_on_physical_movement(delta):
  # Remember our current velocity, we'll apply that later
  var current_velocity = $CharacterBody3D.velocity

  # Remember where our player body currently is
  var org_player_body: Vector3 = $CharacterBody3D.global_transform.origin

  # Determine where our player body should be
  var player_body_location: Vector3 = $XRCamera3D.transform * $XRCamera3D/Neck.transform.origin
  player_body_location.y = 0.0
  player_body_location = global_transform * player_body_location

  # Attempt to move our character
  $CharacterBody3D.velocity = (player_body_location - org_player_body) / delta
  $CharacterBody3D.move_and_slide()

  # Set back to our current value
  $CharacterBody3D.velocity = current_velocity

  # Check if we managed to move all the way, ignoring height change
  var movement_left = player_body_location - $CharacterBody3D.global_transform.origin
  movement_left.y = 0.0
  if (movement_left).length() > 0.01:
    # We'll talk more about what we'll do here later on
    return true
  else:
    return false

func _physics_process(delta):
  var is_colliding = _process_on_physical_movement(delta)
```

Example 2 (gdscript):
```gdscript
func _get_rotational_input() -> float:
  # Implement this function to return rotation in radians per second.
  return 0.0

func _copy_player_rotation_to_character_body():
  # We only copy our forward direction to our character body, we ignore tilt
  var camera_forward: Vector3 = -$XRCamera3D.global_transform.basis.z
  var body_forward: Vector3 = Vector3(camera_forward.x, 0.0, camera_forward.z)

  $CharacterBody3D.global_transform.basis = Basis.looking_at(body_forward, Vector3.UP)

func _process_rotation_on_input(delta):
  var t1 := Transform3D()
  var t2 := Transform3D()
  var rot := Transform3D()

  # We are going to rotate the origin around the player
  var player_position = $CharacterBody3D.global_transform.origin - global_transform.origin

  t1.origin = -player_position
  t2.origin = player_position
  rot = rot.rotated(Vector3(0.0, 1.0, 0.0), _get_rotational_input() * delta)
  global_transform = (global_transform * t2 * rot * t1).orthonormalized()

  # Now ensure our player body is facing the correct way as well
  _copy_player_rotation_to_character_body()

func _physics_process(delta):
  var is_colliding = _process_on_physical_movement(delta)
  if !is_colliding:
    _process_rotation_on_input(delta)
```

Example 3 (gdscript):
```gdscript
var gravity = ProjectSettings.get_setting("physics/3d/default_gravity")

func _get_movement_input() -> Vector2:
  # Implement this to return requested directional movement in meters per second.
  return Vector2()

func _process_movement_on_input(delta):
  # Remember where our player body currently is
  var org_player_body: Vector3 = $CharacterBody3D.global_transform.origin

  # We start with applying gravity
  $CharacterBody3D.velocity.y -= gravity * delta

  # Now we add in our movement
  var input: Vector2 = _get_movement_input()
  var movement: Vector3 = ($CharacterBody3D.global_transform.basis * Vector3(input.x, 0, input.y))
  $CharacterBody3D.velocity.x = movement.x
  $CharacterBody3D.velocity.z = movement.z

  # Attempt to move our player
  $CharacterBody3D.move_and_slide()

  # And now apply the actual movement to our origin
  global_transform.origin += $CharacterBody3D.global_transform.origin - org_player_body

func _physics_process(delta):
  var is_colliding = _process_on_physical_movement(delta)
  if !is_colliding:
    _process_rotation_on_input(delta)
    _process_movement_on_input(delta)
```

Example 4 (gdscript):
```gdscript
# Helper variables to keep our code readable
@onready var origin_node = $XROrigin3D
@onready var camera_node = $XROrigin3D/XRCamera3D
@onready var neck_position_node = $XROrigin3D/XRCamera3D/Neck

func _process_on_physical_movement(delta) -> bool:
  # Remember our current velocity, we'll apply that later
  var current_velocity = velocity

  # Start by rotating the player to face the same way our real player is
  var camera_basis: Basis = origin_node.transform.basis * camera_node.transform.basis
  var forward: Vector2 = Vector2(camera_basis.z.x, camera_basis.z.z)
  var angle: float = forward.angle_to(Vector2(0.0, 1.0))

  # Rotate our character body
  transform.basis = transform.basis.rotated(Vector3.UP, angle)

  # Reverse this rotation our origin node
  origin_node.transform = Transform3D().rotated(Vector3.UP, -angle) * origin_node.transform

  # Now apply movement, first move our player body to the right location
  var org_player_body: Vector3 = global_transform.origin
  var player_body_location: Vector3 = origin_node.transform * camera_node.transform * neck_position_node.transform.origin
  player_body_location.y = 0.0
  player_body_location = global_transform * player_body_location

  velocity = (player_body_location - org_player_body) / delta
  move_and_slide()

  # Now move our XROrigin back
  var delta_movement = global_transform.origin - org_player_body
  origin_node.global_transform.origin -= delta_movement

  # Return our value
  velocity = current_velocity

  if (player_body_location - global_transform.origin).length() > 0.01:
    # We'll talk more about what we'll do here later on
    return true
  else:
    return false

func _physics_process(delta):
  var is_colliding = _process_on_physical_movement(delta)
```

---

## Running code in the editor — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/plugins/running_code_in_the_editor.html

**Contents:**
- Running code in the editor
- What is @tool?
- How to use @tool
- Important information
- Try @tool out
- Editing variables
- Getting notified when resources change
- Reporting node configuration warnings
- Running one-off scripts using EditorScript
- Instancing scenes

@tool is a powerful line of code that, when added at the top of your script, makes it execute in the editor. You can also decide which parts of the script execute in the editor, which in game, and which in both.

You can use it for doing many things, but it is mostly useful in level design for visually presenting things that are hard to predict ourselves. Here are some use cases:

If you have a cannon that shoots cannonballs affected by physics (gravity), you can draw the cannonball's trajectory in the editor, making level design a lot easier.

If you have jumppads with varying jump heights, you can draw the maximum jump height a player would reach if it jumped on one, also making level design easier.

If your player doesn't use a sprite, but draws itself using code, you can make that drawing code execute in the editor to see your player.

@tool scripts run inside the editor, and let you access the scene tree of the currently edited scene. This is a powerful feature which also comes with caveats, as the editor does not include protections for potential misuse of @tool scripts. Be extremely cautious when manipulating the scene tree, especially via Node.queue_free, as it can cause crashes if you free a node while the editor runs logic involving it.

To turn a script into a tool, add the @tool annotation at the top of your code.

To check if you are currently in the editor, use: Engine.is_editor_hint().

For example, if you want to execute some code only in the editor, use:

On the other hand, if you want to execute code only in game, simply negate the same statement:

Pieces of code that do not have either of the 2 conditions above will run both in-editor and in-game.

Here is how a _process() function might look for you:

The general rule is that any other GDScript that your tool script uses must *also* be a tool. The editor is not able to construct instances from GDScript files without @tool, which means you cannot call methods or reference member variables from them otherwise. However, since static methods, constants and enums can be used without creating an instance, it is possible to call them or reference them from a @tool script onto other non-tool scripts. One exception to this are static variables. If you try to read a static variable's value in a script that does not have @tool, it will always return null but won't print a warning or error when doing so. This restriction does not apply to static methods, which can be called regardless of whether the target script is in tool mode.

Extending a @tool script does not automatically make the extending script a @tool. Omitting @tool from the extending script will disable tool behavior from the super class. Therefore, the extending script should also specify the @tool annotation.

Modifications in the editor are permanent, with no undo/redo possible. For example, in the next section when we remove the script, the node will keep its rotation. Be careful to avoid making unwanted modifications. Consider setting up version control to avoid losing work in case you make a mistake.

Using the debugger and breakpoints on tool scripts is not currently supported. Breakpoints placed in the script editor or using the breakpoint keyword are ignored. You can use print statements to display the contents of variables instead.

Add a Sprite2D node to your scene and set the texture to Godot icon. Attach and open a script, and change it to this:

Save the script and return to the editor. You should now see your object rotate. If you run the game, it will also rotate.

You may need to restart the editor. This is a known bug found in all Godot 4 versions: GH-66381.

If you don't see the changes, reload the scene (close it and open it again).

Now let's choose which code runs when. Modify your _process() function to look like this:

Save the script. Now the object will spin clockwise in the editor, but if you run the game, it will spin counter-clockwise.

Add and export a variable speed to the script. To update the speed and also reset the rotation angle add a setter set(new_speed) which is executed with the input from the inspector. Modify _process() to include the rotation speed.

Code from other nodes doesn't run in the editor. Your access to other nodes is limited. You can access the tree and nodes, and their default properties, but you can't access user variables. If you want to do so, other nodes have to run in the editor too.

Sometimes you want your tool to use a resource. However, when you change a property of that resource in the editor, the set() method of your tool will not be called.

To get around this problem you first have to make your resource a tool and make it emit the changed signal whenever a property is set:

You then want to connect the signal when a new resource is set:

Lastly, remember to disconnect the signal as the old resource being used and changed somewhere else would cause unneeded updates.

Godot uses a node configuration warning system to warn users about incorrectly configured nodes. When a node isn't configured correctly, a yellow warning sign appears next to the node's name in the Scene dock. When you hover or click on the icon, a warning message pops up. You can use this feature in your scripts to help you and your team avoid mistakes when setting up scenes.

When using node configuration warnings, when any value that should affect or remove the warning changes, you need to call update_configuration_warnings . By default, the warning only updates when closing and reopening the scene.

Sometimes, you need to run code just one time to automate a certain task that is not available in the editor out of the box. Some examples might be:

Use as a playground for GDScript or C# scripting without having to run a project. print() output is displayed in the editor Output panel.

Scale all light nodes in the currently edited scene, as you noticed your level ends up looking too dark or too bright after placing lights where desired.

Replace nodes that were copy-pasted with scene instances to make them easier to modify later.

This is available in Godot by extending EditorScript in a script. This provides a way to run individual scripts in the editor without having to create an editor plugin.

To create an EditorScript, right-click a folder or empty space in the FileSystem dock then choose New > Script.... In the script creation dialog, click the tree icon to choose an object to extend from (or enter EditorScript directly in the field on the left, though note this is case-sensitive):

Creating an editor script in the script editor creation dialog

This will automatically select a script template that is suited for EditorScripts, with a _run() method already inserted:

This _run() method is executed when you use File > Run or the keyboard shortcut Ctrl + Shift + X while the EditorScript is the currently open script in the script editor. This keyboard shortcut is only effective when currently focused on the script editor.

Scripts that extend EditorScript must be @tool scripts to function.

EditorScripts can only be run from the Godot script editor. If you are using an external editor, open the script inside the Godot script editor to run it.

EditorScripts have no undo/redo functionality, so make sure to save your scene before running one if the script is designed to modify any data.

To access nodes in the currently edited scene, use the EditorScript.get_scene method which returns the root Node of the currently edited scene. Here's an example that recursively gets all nodes in the currently edited scene and doubles the range of all OmniLight3D nodes:

You can change the currently edited scene at the top of the editor even while the Script view is open. This will affect the return value of EditorScript.get_scene, so make sure you've selected the scene you intend to iterate upon before running the script.

You can instantiate packed scenes normally and add them to the scene currently opened in the editor. By default, nodes or scenes added with Node.add_child(node) are not visible in the Scene tree dock and are not persisted to disk. If you wish the node or scene to be visible in the scene tree dock and persisted to disk when saving the scene, you need to set the child node's owner property to the currently edited scene root.

If you are using @tool:

If you are using EditorScript:

Using @tool improperly can yield many errors. It is advised to first write the code how you want it, and only then add the @tool annotation to the top. Also, make sure to separate code that runs in-editor from code that runs in-game. This way, you can find bugs more easily.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
if Engine.is_editor_hint():
    # Code to execute when in editor.
```

Example 2 (unknown):
```unknown
if (Engine.IsEditorHint())
{
    // Code to execute when in editor.
}
```

Example 3 (unknown):
```unknown
if not Engine.is_editor_hint():
    # Code to execute when in game.
```

Example 4 (unknown):
```unknown
if (!Engine.IsEditorHint())
{
    // Code to execute when in game.
}
```

---

## Running Godot apps on macOS — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/export/running_on_macos.html

**Contents:**
- Running Godot apps on macOS
- App is signed, notarized and distributed via App Store
- App is signed, notarized and distributed outside App Store
- App is signed (including ad-hoc signatures) but not notarized
- App is not signed, executable is linker-signed
- Neither app nor executable is signed (relevant for Apple Silicon Macs only)
- User-contributed notes

This page covers running Godot projects on macOS. If you haven't exported your project yet, read Exporting for macOS first.

By default, macOS will run only applications that are signed and notarized.

When running an app from the Downloads folder or when still in quarantine, Gatekeeper will perform path randomization as a security measure. This breaks access to relative paths from the app, which the app relies upon to work. To resolve this issue, move the app to the /Applications folder.

In general, macOS apps should avoid relying on relative paths from the application folder.

Depending on the way a macOS app is signed and distributed, the following scenarios are possible:

App developers need to join the Apple Developer Program, and configure signing and notarization options during export, then upload the app to the App Store.

The app should run out of the box, without extra user interaction required.

App developers need to join the Apple Developer Program, and configure signing and notarization options during export, then distribute the app as ".DMG" or ".ZIP" archive.

When you run the app for the first time, the following dialog is displayed:

Click Open to start the app.

If you see the following warning dialog, your Mac is set up to allow apps only from the App Store.

To allow third-party apps, open System Preferences, click Security & Privacy, then click General, unlock settings, and select App Store and identified developers.

App developer used self-signed certificate or ad-hoc signing (default Godot behavior for exported project).

When you run the app for the first time, the following dialog is displayed:

To run this app, you can temporarily override Gatekeeper:

Either open System Preferences, click Security & Privacy, then click General, and click Open Anyway.

Or, right-click (Control-click) on the app icon in the Finder window and select Open from the menu.

Then click Open in the confirmation dialog.

Enter your password if you're prompted.

Another option is to disable Gatekeeper entirely. Note that this does decrease the security of your computer by allowing you to run any software you want. To do this, run sudo spctl --master-disable in the Terminal, enter your password, and then the Anywhere option will be available:

Note that Gatekeeper will re-enable itself when macOS updates.

App is built using official export templates, but it is not signed.

When you run the app for the first time, the following dialog is displayed:

To run this app, you should remove the quarantine extended file attribute manually:

Open Terminal.app (press Cmd + Space and enter Terminal).

Navigate to the folder containing the target application.

Use the cd path_to_the_app_folder command, e.g. cd ~/Downloads/ if it's in the Downloads folder.

Run the command xattr -dr com.apple.quarantine "Unsigned Game.app" (including quotation marks and .app extension).

App is built using custom export templates, compiled using OSXCross, and it is not signed at all.

When you run the app for the first time, the following dialog is displayed:

To run this app, you can ad-hoc sign it yourself:

Install Xcode for the App Store, start it and confirm command line tools installation.

Open Terminal.app (press Cmd + Space and enter Terminal).

Navigate to the folder containing the target application.

Use the cd path_to_the_app_folder command, e.g. cd ~/Downloads/ if it's in the Downloads folder.

Run the following commands:

xattr -dr com.apple.quarantine "Unsigned Game.app" (including quotation marks and ".app" extension).

codesign -s - --force --deep "Unsigned Game.app" (including quotation marks and ".app" extension).

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Runtime file loading and saving — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/io/runtime_file_loading_and_saving.html

**Contents:**
- Runtime file loading and saving
- Plain text and binary files
- Images
- Audio/video files
- 3D scenes
- Fonts
- ZIP archives
- User-contributed notes

See Saving games for information on saving and loading game progression.

Sometimes, exporting packs, patches, and mods is not ideal when you want players to be able to load user-generated content in your project. It requires users to generate a PCK or ZIP file through the Godot editor, which contains resources imported by Godot.

Example use cases for runtime file loading and saving include:

Loading texture packs designed for the game.

Loading user-provided audio tracks and playing them back in an in-game radio station.

Loading custom levels or 3D models that can be designed with any 3D DCC that can export to glTF or FBX (including glTF scenes saved by Godot at runtime).

Using user-provided fonts for menus and HUD.

Saving/loading a file format that can contain multiple files but can still easily be read by other applications (ZIP).

Loading files created by another game or program, or even game data files from another game not made with Godot.

Runtime file loading can be combined with HTTP requests to load resources from the Internet directly.

Do not use this runtime loading approach to load resources that are part of the project, as it's less efficient and doesn't allow benefiting from Godot's resource handling functionality (such as translation remaps). See Import process for details.

You can see how saving and loading works in action using the Run-time File Saving and Loading (Serialization) demo project.

Godot's FileAccess class provides methods to access files on the filesystem for reading and writing:

To handle custom binary formats (such as loading file formats not supported by Godot), FileAccess provides several methods to read/write integers, floats, strings and more. These FileAccess methods have names that start with get_ and store_.

If you need more control over reading binary files or need to read binary streams that are not part of a file, PackedByteArray provides several helper methods to decode/encode series of bytes to integers, floats, strings and more. These PackedByteArray methods have names that start with decode_ and encode_. See also Binary serialization API.

Image's Image.load_from_file static method handles everything, from format detection based on file extension to reading the file from disk.

If you need error handling or more control (such as changing the scale an SVG is loaded at), use one of the following methods depending on the file format:

Image.load_jpg_from_buffer

Image.load_ktx_from_buffer

Image.load_png_from_buffer

Image.load_svg_from_buffer or Image.load_svg_from_string

Image.load_tga_from_buffer

Image.load_webp_from_buffer

Several image formats can also be saved by Godot at runtime using the following methods:

Image.save_png or Image.save_png_to_buffer

Image.save_webp or Image.save_webp_to_buffer

Image.save_jpg or Image.save_jpg_to_buffer

Image.save_exr or Image.save_exr_to_buffer (only available in editor builds, cannot be used in exported projects)

The methods with the to_buffer suffix save the image to a PackedByteArray instead of the filesystem. This is useful to send the image over the network or into a ZIP archive without having to write it on the filesystem. This can increase performance by reducing I/O utilization.

If displaying the loaded image on a 3D surface, make sure to call Image.generate_mipmaps so that the texture doesn't look grainy when viewed at a distance. This is also useful in 2D when following instructions on reducing aliasing when downsampling.

Example of loading an image and displaying it in a TextureRect node (which requires conversion to ImageTexture):

Godot supports loading Ogg Vorbis, MP3, and WAV audio at runtime. Note that not all files with a .ogg extension are Ogg Vorbis files. Some may be Ogg Theora videos, or contain Opus audio within an Ogg container. These files will not load correctly as audio files in Godot.

Example of loading an Ogg Vorbis audio file in an AudioStreamPlayer node:

Example of loading an Ogg Theora video file in a VideoStreamPlayer node:

Godot has first-class support for glTF 2.0, both in the editor and exported projects. Using GLTFDocument and GLTFState together, Godot can load and save glTF files in exported projects, in both text (.gltf) and binary (.glb) formats. The binary format should be preferred as it's faster to write and smaller, but the text format is easier to debug.

Since Godot 4.3, FBX scenes can also be loaded (but not saved) at runtime using the FBXDocument and FBXState classes. The code to do so is the same as glTF, but you will need to replace all instances of GLTFDocument and GLTFState with FBXDocument and FBXState in the code samples below. There are known issues with runtime FBX loading, so using glTF instead is preferred for now.

Example of loading a glTF scene and appending its root node to the scene:

When loading a glTF scene, a base path must be set so that external resources like textures can be loaded correctly. When loading from a file, the base path is automatically set to the folder containing the file. When loading from a buffer, this base path must be manually set as there is no way for Godot to infer this path.

To set the base path, set GLTFState.base_path on your GLTFState instance before calling GLTFDocument.append_from_buffer or GLTFDocument.append_from_file.

FontFile.load_dynamic_font supports the following font file formats: TTF, OTF, WOFF, WOFF2, PFB, PFM

On the other hand, FontFile.load_bitmap_font supports the BMFont format (.fnt or .font).

Additionally, it is possible to load any font that is installed on the system using Godot's support for System fonts.

Example of loading a font file automatically according to its file extension, then adding it as a theme override to a Label node:

Godot supports reading and writing ZIP archives using the ZIPReader and ZIPPacker classes. This supports any ZIP file, including files generated by Godot's "Export PCK/ZIP" functionality (although these will contain imported Godot resources rather than the original project files).

Use ProjectSettings.load_resource_pack to load PCK or ZIP files exported by Godot as additional data packs. That approach is preferred for DLCs, as it makes interacting with additional data packs seamless (virtual filesystem).

This ZIP archive support can be combined with runtime image, 3D scene and audio loading to provide a seamless modding experience without requiring users to go through the Godot editor to generate PCK/ZIP files.

Example that lists files in a ZIP archive in an ItemList node, then writes contents read from it to a new ZIP archive (essentially duplicating the archive):

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
func save_file(content):
    var file = FileAccess.open("/path/to/file.txt", FileAccess.WRITE)
    file.store_string(content)

func load_file():
    var file = FileAccess.open("/path/to/file.txt", FileAccess.READ)
    var content = file.get_as_text()
    return content
```

Example 2 (unknown):
```unknown
private void SaveFile(string content)
{
    using var file = FileAccess.Open("/Path/To/File.txt", FileAccess.ModeFlags.Write);
    file.StoreString(content);
}

private string LoadFile()
{
    using var file = FileAccess.Open("/Path/To/File.txt", FileAccess.ModeFlags.Read);
    string content = file.GetAsText();
    return content;
}
```

Example 3 (unknown):
```unknown
# Load an image of any format supported by Godot from the filesystem.
var image = Image.load_from_file(path)
# Optionally, generate mipmaps if displaying the texture on a 3D surface
# so that the texture doesn't look grainy when viewed at a distance.
#image.generate_mipmaps()
$TextureRect.texture = ImageTexture.create_from_image(image)

# Save the loaded Image to a PNG image.
image.save_png("/path/to/file.png")

# Save the converted ImageTexture to a PNG image.
$TextureRect.texture.get_image().save_png("/path/to/file.png")
```

Example 4 (unknown):
```unknown
// Load an image of any format supported by Godot from the filesystem.
var image = Image.LoadFromFile(path);
// Optionally, generate mipmaps if displaying the texture on a 3D surface
// so that the texture doesn't look grainy when viewed at a distance.
// image.GenerateMipmaps();
GetNode<TextureRect>("TextureRect").Texture = ImageTexture.CreateFromImage(image);

// Save the loaded Image to a PNG image.
image.SavePng("/Path/To/File.png");

// Save the converted ImageTexture to a PNG image.
GetNode<TextureRect>("TextureRect").Texture.GetImage().SavePng("/Path/To/File.png");
```

---

## Saving games — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/io/saving_games.html

**Contents:**
- Saving games
- Introduction
- Identify persistent objects
- Serializing
- Saving and reading data
- Some notes
- JSON vs binary serialization
  - JSON limitations
  - Binary serialization
- User-contributed notes

Save games can be complicated. For example, it may be desirable to store information from multiple objects across multiple levels. Advanced save game systems should allow for additional information about an arbitrary number of objects. This will allow the save function to scale as the game grows more complex.

If you're looking to save user configuration, you can use the ConfigFile class for this purpose.

You can see how saving and loading works in action using the Saving and Loading (Serialization) demo project.

Firstly, we should identify what objects we want to keep between game sessions and what information we want to keep from those objects. For this tutorial, we will use groups to mark and handle objects to be saved, but other methods are certainly possible.

We will start by adding objects we wish to save to the "Persist" group. We can do this through either the GUI or script. Let's add the relevant nodes using the GUI:

Once this is done, when we need to save the game, we can get all objects to save them and then tell them all to save with this script:

The next step is to serialize the data. This makes it much easier to read from and store to disk. In this case, we're assuming each member of group Persist is an instanced node and thus has a path. GDScript has the helper class JSON to convert between dictionary and string. Our node needs to contain a save function that returns this data. The save function will look like this:

This gives us a dictionary with the style { "variable_name":value_of_variable }, which will be useful when loading.

As covered in the File system tutorial, we'll need to open a file so we can write to it or read from it. Now that we have a way to call our groups and get their relevant data, let's use the class JSON to convert it into an easily stored string and store them in a file. Doing it this way ensures that each line is its own object, so we have an easy way to pull the data out of the file as well.

Game saved! Now, to load, we'll read each line. Use the parse method to read the JSON string back to a dictionary, and then iterate over the dict to read our values. But we'll need to first create the object and we can use the filename and parent values to achieve that. Here is our load function:

Now we can save and load an arbitrary number of objects laid out almost anywhere across the scene tree! Each object can store different data depending on what it needs to save.

We have glossed over setting up the game state for loading. It's ultimately up to the project creator where much of this logic goes. This is often complicated and will need to be heavily customized based on the needs of the individual project.

Additionally, our implementation assumes no Persist objects are children of other Persist objects. Otherwise, invalid paths would be created. To accommodate nested Persist objects, consider saving objects in stages. Load parent objects first so they are available for the add_child() call when child objects are loaded. You will also need a way to link children to parents as the NodePath will likely be invalid.

For simple game state, JSON may work and it generates human-readable files that are easy to debug.

But JSON has many limitations. If you need to store more complex game state or a lot of it, binary serialization may be a better approach.

Here are some important gotchas to know about when using JSON.

Filesize: JSON stores data in text format, which is much larger than binary formats.

Data types: JSON only offers a limited set of data types. If you have data types that JSON doesn't have, you will need to translate your data to and from types that JSON can handle. For example, some important types that JSON can't parse are: Vector2, Vector3, Color, Rect2, and Quaternion.

Custom logic needed for encoding/decoding: If you have any custom classes that you want to store with JSON, you will need to write your own logic for encoding and decoding those classes.

Binary serialization is an alternative approach for storing game state, and you can use it with the functions get_var and store_var of FileAccess.

Binary serialization should produce smaller files than JSON.

Binary serialization can handle most common data types.

Binary serialization requires less custom logic for encoding and decoding custom classes.

Note that not all properties are included. Only properties that are configured with the PROPERTY_USAGE_STORAGE flag set will be serialized. You can add a new usage flag to a property by overriding the _get_property_list method in your class. You can also check how property usage is configured by calling Object._get_property_list. See PropertyUsageFlags for the possible usage flags.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
var save_nodes = get_tree().get_nodes_in_group("Persist")
for node in save_nodes:
    # Now, we can call our save function on each node.
```

Example 2 (unknown):
```unknown
var saveNodes = GetTree().GetNodesInGroup("Persist");
foreach (Node saveNode in saveNodes)
{
    // Now, we can call our save function on each node.
}
```

Example 3 (gdscript):
```gdscript
func save():
    var save_dict = {
        "filename" : get_scene_file_path(),
        "parent" : get_parent().get_path(),
        "pos_x" : position.x, # Vector2 is not supported by JSON
        "pos_y" : position.y,
        "attack" : attack,
        "defense" : defense,
        "current_health" : current_health,
        "max_health" : max_health,
        "damage" : damage,
        "regen" : regen,
        "experience" : experience,
        "tnl" : tnl,
        "level" : level,
        "attack_growth" : attack_growth,
        "defense_growth" : defense_growth,
        "health_growth" : health_growth,
        "is_alive" : is_alive,
        "last_attack" : last_attack
    }
    return save_dict
```

Example 4 (unknown):
```unknown
public Godot.Collections.Dictionary<string, Variant> Save()
{
    return new Godot.Collections.Dictionary<string, Variant>()
    {
        { "Filename", SceneFilePath },
        { "Parent", GetParent().GetPath() },
        { "PosX", Position.X }, // Vector2 is not supported by JSON
        { "PosY", Position.Y },
        { "Attack", Attack },
        { "Defense", Defense },
        { "CurrentHealth", CurrentHealth },
        { "MaxHealth", MaxHealth },
        { "Damage", Damage },
        { "Regen", Regen },
        { "Experience", Experience },
        { "Tnl", Tnl },
        { "Level", Level },
        { "AttackGrowth", AttackGrowth },
        { "DefenseGrowth", DefenseGrowth },
        { "HealthGrowth", HealthGrowth },
        { "IsAlive", IsAlive },
        { "LastAttack", LastAttack }
    };
}
```

---

## Scene organization — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/best_practices/scene_organization.html

**Contents:**
- Scene organization
- How to build relationships effectively
- Choosing a node tree structure
- User-contributed notes

This article covers topics related to the effective organization of scene content. Which nodes should you use? Where should you place them? How should they interact?

When Godot users begin crafting their own scenes, they often run into the following problem:

They create their first scene and fill it with content only to eventually end up saving branches of their scene into separate scenes as the nagging feeling that they should split things up starts to accumulate. However, they then notice that the hard references they were able to rely on before are no longer possible. Re-using the scene in multiple places creates issues because the node paths do not find their targets and signal connections established in the editor break.

To fix these problems, you must instantiate the sub-scenes without them requiring details about their environment. You need to be able to trust that the sub-scene will create itself without being picky about how it's used.

One of the biggest things to consider in OOP is maintaining focused, singular-purpose classes with loose coupling to other parts of the codebase. This keeps the size of objects small (for maintainability) and improves their reusability.

These OOP best practices have several implications for best practices in scene structure and script usage.

If at all possible, you should design scenes to have no dependencies. That is, you should create scenes that keep everything they need within themselves.

If a scene must interact with an external context, experienced developers recommend the use of Dependency Injection. This technique involves having a high-level API provide the dependencies of the low-level API. Why do this? Because classes which rely on their external environment can inadvertently trigger bugs and unexpected behavior.

To do this, you must expose data and then rely on a parent context to initialize it:

Connect to a signal. Extremely safe, but should be used only to "respond" to behavior, not start it. By convention, signal names are usually past-tense verbs like "entered", "skill_activated", or "item_collected".

Call a method. Used to start behavior.

Initialize a Callable property. Safer than a method as ownership of the method is unnecessary. Used to start behavior.

Initialize a Node or other Object reference.

Initialize a NodePath.

These options hide the points of access from the child node. This in turn keeps the child loosely coupled to its environment. You can reuse it in another context without any extra changes to its API.

Although the examples above illustrate parent-child relationships, the same principles apply towards all object relations. Nodes which are siblings should only be aware of their own hierarchies while an ancestor mediates their communications and references.

The same principles also apply to non-Node objects that maintain dependencies on other objects. Whichever object owns the other objects should manage the relationships between them.

You should favor keeping data in-house (internal to a scene), though, as placing a dependency on an external context, even a loosely coupled one, still means that the node will expect something in its environment to be true. The project's design philosophies should prevent this from happening. If not, the code's inherent liabilities will force developers to use documentation to keep track of object relations on a microscopic scale; this is otherwise known as development hell. Writing code that relies on external documentation to use it safely is error-prone by default.

To avoid creating and maintaining such documentation, you convert the dependent node ("child" above) into a tool script that implements _get_configuration_warnings(). Returning a non-empty PackedStringArray from it will make the Scene dock generate a warning icon with the string(s) as a tooltip by the node. This is the same icon that appears for nodes such as the Area2D node when it has no child CollisionShape2D nodes defined. The editor then self-documents the scene through the script code. No content duplication via documentation is necessary.

A GUI like this can better inform project users of critical information about a Node. Does it have external dependencies? Have those dependencies been satisfied? Other programmers, and especially designers and writers, will need clear instructions in the messages telling them what to do to configure it.

So, why does all this complex switcheroo work? Well, because scenes operate best when they operate alone. If unable to work alone, then working with others anonymously (with minimal hard dependencies, i.e. loose coupling) is the next best thing. Inevitably, changes may need to be made to a class, and if these changes cause it to interact with other scenes in unforeseen ways, then things will start to break down. The whole point of all this indirection is to avoid ending up in a situation where changing one class results in adversely affecting other classes dependent on it.

Scripts and scenes, as extensions of engine classes, should abide by all OOP principles. Examples include...

You might start to work on a game but get overwhelmed by the vast possibilities before you. You might know what you want to do, what systems you want to have, but where do you put them all? How you go about making your game is always up to you. You can construct node trees in countless ways. If you are unsure, this guide can give you a sample of a decent structure to start with.

A game should always have an "entry point"; somewhere you can definitively track where things begin so that you can follow the logic as it continues elsewhere. It also serves as a bird's eye view of all other data and logic in the program. For traditional applications, this is normally a "main" function. In Godot, it's a Main node.

Node "Main" (main.gd)

The main.gd script will serve as the primary controller of your game.

Then you have an in-game "World" (a 2D or 3D one). This can be a child of Main. In addition, you will need a primary GUI for your game that manages the various menus and widgets the project needs.

Node2D/Node3D "World" (game_world.gd)

Control "GUI" (gui.gd)

When changing levels, you can then swap out the children of the "World" node. Changing scenes manually gives you full control over how your game world transitions.

The next step is to consider what gameplay systems your project requires. If you have a system that...

tracks all of its data internally

should be globally accessible

should exist in isolation

... then you should create an autoload 'singleton' node.

For smaller games, a simpler alternative with less control would be to have a "Game" singleton that simply calls the SceneTree.change_scene_to_file() method to swap out the main scene's content. This structure more or less keeps the "World" as the main game node.

Any GUI would also need to be either a singleton, a transitory part of the "World", or manually added as a direct child of the root. Otherwise, the GUI nodes would also delete themselves during scene transitions.

If you have systems that modify other systems' data, you should define those as their own scripts or scenes, rather than autoloads. For more information, see Autoloads versus regular nodes.

Each subsystem within your game should have its own section within the SceneTree. You should use parent-child relationships only in cases where nodes are effectively elements of their parents. Does removing the parent reasonably mean that the children should also be removed? If not, then it should have its own place in the hierarchy as a sibling or some other relation.

In some cases, you need these separated nodes to also position themselves relative to each other. You can use the RemoteTransform / RemoteTransform2D nodes for this purpose. They will allow a target node to conditionally inherit selected transform elements from the Remote* node. To assign the target NodePath, use one of the following:

A reliable third party, likely a parent node, to mediate the assignment.

A group, to pull a reference to the desired node (assuming there will only ever be one of the targets).

When you should do this is subjective. The dilemma arises when you must micro-manage when a node must move around the SceneTree to preserve itself. For example...

Add a "player" node to a "room".

Need to change rooms, so you must delete the current room.

Before the room can be deleted, you must preserve and/or move the player.

If memory is not a concern, you can...

Move the player to the new room.

If memory is a concern, instead you will need to...

Move the player somewhere else in the tree.

Instantiate and add the new room.

Re-add the player to the new room.

The issue is that the player here is a "special case" where the developers must know that they need to handle the player this way for the project. The only way to reliably share this information as a team is to document it. Keeping implementation details in documentation is dangerous. It's a maintenance burden, strains code readability, and unnecessarily bloats the intellectual content of a project.

In a more complex game with larger assets, it can be a better idea to keep the player somewhere else in the SceneTree entirely. This results in:

No "special cases" that must be documented and maintained somewhere.

No opportunity for errors to occur because these details are not accounted for.

In contrast, if you ever need a child node that does not inherit the transform of its parent, you have the following options:

The declarative solution: place a Node in between them. Since it doesn't have a transform, they won't pass this information to its children.

The imperative solution: Use the top_level property for the CanvasItem or Node3D node. This will make the node ignore its inherited transform.

If building a networked game, keep in mind which nodes and gameplay systems are relevant to all players versus those just pertinent to the authoritative server. For example, users do not all need to have a copy of every players' "PlayerController" logic - they only need their own. Keeping them in a separate branch from the "world" can help simplify the management of game connections and the like.

The key to scene organization is to consider the SceneTree in relational terms rather than spatial terms. Are the nodes dependent on their parent's existence? If not, then they can thrive all by themselves somewhere else. If they are dependent, then it stands to reason that they should be children of that parent (and likely part of that parent's scene if they aren't already).

Does this mean nodes themselves are components? Not at all. Godot's node trees form an aggregation relationship, not one of composition. But while you still have the flexibility to move nodes around, it is still best when such moves are unnecessary by default.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
# Parent
$Child.signal_name.connect(method_on_the_object)

# Child
signal_name.emit() # Triggers parent-defined behavior.
```

Example 2 (unknown):
```unknown
// Parent
GetNode("Child").Connect("SignalName", Callable.From(ObjectWithMethod.MethodOnTheObject));

// Child
EmitSignal("SignalName"); // Triggers parent-defined behavior.
```

Example 3 (unknown):
```unknown
// Parent
Node *node = get_node<Node>("Child");
if (node != nullptr) {
    // Note that get_node may return a nullptr, which would make calling the connect method crash the engine if "Child" does not exist!
    // So unless you are 1000% sure get_node will never return a nullptr, it's a good idea to always do a nullptr check.
    node->connect("signal_name", callable_mp(this, &ObjectWithMethod::method_on_the_object));
}

// Child
emit_signal("signal_name"); // Triggers parent-defined behavior.
```

Example 4 (unknown):
```unknown
# Parent
$Child.method_name = "do"

# Child, assuming it has String property 'method_name' and method 'do'.
call(method_name) # Call parent-defined method (which child must own).
```

---

## Setting up XR — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/xr/setting_up_xr.html

**Contents:**
- Setting up XR
- Introduction to the XR system in Godot
- Which Renderer to use
- OpenXR
- Setting up the XR scene
- User-contributed notes

Godot provides a modular XR system that abstracts many of the different XR platform specifics away from the user. At the core sits the XRServer which acts as a central interface to the XR system that allows users to discover interfaces and interact with the components of the XR system.

Each supported XR platform is implemented as an XRInterface. A list of supported platforms can be found on the list of features page here. Supported interfaces register themselves with the XRServer and can be queried with the find_interface method on the XRServer. When the desired interface is found it can be initialized by calling initialize on the interface.

A registered interface means nothing more than that the interface is available, if the interface is not supported by the host system, initialization may fail and return false. This can have many reasons and sadly the reasons differ from platform to platform. It can be because the user hasn't installed the required software, or that the user simply hasn't plugged in their headset. You as a developer must thus react properly on an interface failing to initialize.

Due to the special requirements for output in XR, especially for head mounted devices that supply different images to each eye, the XRServer in Godot will override various features in the rendering system. For stand-alone devices this means the final output is handled by the XRInterface and Godot's usual output system is disabled. For desktop XR devices that work as a second screen it is possible to dedicate a separate Viewport to handle the XR output, leaving the main Godot window available for displaying alternative content.

Note that only one interface can be responsible for handling the output to an XR device, this is known as the primary interface and by default will be the first interface that is initialized. Godot currently thus only supports implementations with a single headset. It is possible, but increasingly uncommon, to have a secondary interface, for example to add tracking to an otherwise 3DOF only device.

There are three XR specific node types that you will find in nearly all XR applications:

XROrigin3D represents, for all intents and purposes, the center point of your play space. That is an oversimplified statement but we'll go into more detail later. All objects tracked in physical space by the XR platform are positioned in relation to this point.

XRCamera3D represents the (stereo) camera that is used when rendering output for the XR device. The positioning of this node is controlled by the XR system and updated automatically using the tracking information provided by the XR platform.

XRController3D represents a controller used by the player, commonly there are two, one held in each hand. These nodes give access to various states on these controllers and send out signals when the player presses buttons on them. The positioning of this node is controlled by the XR system and updated automatically using the tracking information provided by the XR platform.

There are other XR related nodes and there is much more to say about these three nodes, but we'll get into that later on.

Godot has 3 renderer options for projects: Compatibility, Mobile, and Forward+. The current recommendation is to use the Mobile renderer for any desktop VR project, and use the Compatibility renderer for any project running on a standalone headset like the Meta Quest 3. XR projects will run with the Forward+ renderer, but it isn't well optimized for XR right now compared to the other two.

OpenXR is a new industry standard that allows different XR platforms to present themselves through a standardised API to XR applications. This standard is an open standard maintained by the Khronos Group and thus aligns very well with Godot's interests.

The Vulkan implementation of OpenXR is closely integrated with Vulkan, taking over part of the Vulkan system. This requires tight integration of certain core graphics features in the Vulkan renderer which are needed before the XR system is setup. This was one of the main deciding factors to include OpenXR as a core interface.

This also means OpenXR needs to be enabled when Godot starts in order to set things up correctly. Check the Enabled setting in your project settings under XR > OpenXR.

You can find several other settings related to OpenXR here as well. These can't be changed while your application is running. The default settings will get us started, but for more information on what's here see OpenXR Settings.

You'll also need to go to XR > Shaders in the project settings and check the Enabled box to enable them. Once you've done that click the Save & Restart button.

Many post process effects have not yet been updated to support stereoscopic rendering. Using these will have adverse effects.

Every XR application needs at least an XROrigin3D and an XRCamera3D node. Most will have two XRController3D, one for the left hand and one for the right. Keep in mind that the camera and controller nodes should be children of the origin node. Add these nodes to a new scene and rename the controller nodes to LeftHand and RightHand, your scene should look something like this:

The warning icons are expected and should go away after you configure the controllers. Select the left hand and set it up as follows:

Right now all these nodes are on the floor, they will be positioned correctly in runtime. To help during development, it can be helpful to move the camera upwards so its y is set to 1.7, and move the controller nodes to -0.5, 1.0, -0.5 and 0.5, 1.0, -0.5 for respectively the left and right hand.

Next we need to add a script to our root node. Add the following code into this script:

This code fragment assumes we are using OpenXR, if you wish to use any of the other interfaces you can change the find_interface call.

As you can see in the code snippet above, we turn off v-sync. When using OpenXR you are outputting the rendering results to an HMD that often requires us to run at 90Hz or higher. If your monitor is a 60hz monitor and v-sync is turned on, you will limit the output to 60 frames per second.

XR interfaces like OpenXR perform their own sync.

Also note that by default the physics engine runs at 60Hz as well and this can result in choppy physics. You should set Engine.physics_ticks_per_second to a higher value.

If you run your project at this point in time, everything will work but you will be in a dark world. So to finish off our starting point add a DirectionalLight3D and a WorldEnvironment node to your scene. You may wish to also add a mesh instance as a child to each controller node just to temporarily visualise them. Make sure you configure a sky in your world environment.

Now run your project, you should be floating somewhere in space and be able to look around.

While traditional level switching can definitely be used with XR applications, where this scene setup is repeated in each level, most find it easier to set this up once and loading levels as a subscene. If you do switch scenes and replicate the XR setup in each one, do make sure you do not run initialize multiple times. The effect can be unpredictable depending on the XR interface used.

For the rest of this basic tutorial series we will create a game that uses a single scene.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
extends Node3D

var xr_interface: XRInterface

func _ready():
    xr_interface = XRServer.find_interface("OpenXR")
    if xr_interface and xr_interface.is_initialized():
        print("OpenXR initialized successfully")

        # Turn off v-sync!
        DisplayServer.window_set_vsync_mode(DisplayServer.VSYNC_DISABLED)

        # Change our main viewport to output to the HMD
        get_viewport().use_xr = true
    else:
        print("OpenXR not initialized, please check if your headset is connected")
```

Example 2 (unknown):
```unknown
using Godot;

public partial class MyNode3D : Node3D
{
    private XRInterface _xrInterface;

    public override void _Ready()
    {
        _xrInterface = XRServer.FindInterface("OpenXR");
        if(_xrInterface != null && _xrInterface.IsInitialized())
        {
            GD.Print("OpenXR initialized successfully");

            // Turn off v-sync!
            DisplayServer.WindowSetVsyncMode(DisplayServer.VSyncMode.Disabled);

            // Change our main viewport to output to the HMD
            GetViewport().UseXR = true;
        }
        else
        {
            GD.Print("OpenXR not initialized, please check if your headset is connected");
        }
    }
}
```

---

## Size and anchors — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/ui/size_and_anchors.html

**Contents:**
- Size and anchors
- Centering a control
- Anchor Presets
- User-contributed notes

If a game was always going to be run on the same device and at the same resolution, positioning controls would be a simple matter of setting the position and size of each one of them. Unfortunately, that is rarely the case.

While some configurations may be more common than others, devices like phones, tablets and portable gaming consoles can vary greatly. Therefore, we often have to account for different aspect ratios, resolutions and user scaling.

There are several ways to account for this, but for now, let's just imagine that the screen resolution has changed and the controls need to be re-positioned. Some will need to follow the bottom of the screen, others the top of the screen, or maybe the right or left margins.

This is done by editing the anchor offsets of controls, which behave similar to a margin. To access these settings, you will first need to select the Custom anchor preset.

Each control has four anchor offsets: left, right, bottom, and top, which correspond to the respective edges of the control. By default, all of them represent a distance in pixels relative to the top-left corner of the parent control or (in case there is no parent control) the viewport.

So to make the control wider you can make the right offset larger and/or make the left offset smaller. This lets you set the exact placement and shape of the control.

The anchor properties adjust where the offsets are relative to. Each offset has an individual anchor that can be adjusted from the beginning to the end of the parent. So the vertical (top, bottom) anchors adjust from 0.0 (top of parent) to 1.0 (bottom of parent) with 0.5 being the center, and the control offsets will be placed relative to that point. The horizontal (left, right) anchors similarly adjust from left to right of the parent.

Note that when you wish the edge of a control to be above or left of the anchor point, you must change the offset value to be negative.

For example: when horizontal anchors are changed to 1.0, the offset values become relative to the top-right corner of the parent control or viewport.

Adjusting the two horizontal or the two vertical anchors to different values will make the control change size when the parent control does. Here, the control is set to anchor its bottom-right corner to the parent's bottom-right, while the top-left control offsets are still anchored to the top-left of the parent, so when re-sizing the parent, the control will always cover it, leaving a 20 pixel offset:

To center a control in its parent, set its anchors to 0.5 and each offset to half of its relevant dimension. For example, the code below shows how a TextureRect can be centered in its parent:

Setting each anchor to 0.5 moves the reference point for the offsets to the center of its parent. From there, we set negative offsets so that the control gets its natural size.

Instead of manually adjusting the offset and anchor values, you can use the toolbar's Anchor menu, above the viewport. Besides centering, it gives you many options to align and resize control nodes.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
var rect = TextureRect.new()
rect.texture = load("res://icon.png")
rect.anchor_left = 0.5
rect.anchor_right = 0.5
rect.anchor_top = 0.5
rect.anchor_bottom = 0.5
var texture_size = rect.texture.get_size()
rect.offset_left = -texture_size.x / 2
rect.offset_right = texture_size.x / 2
rect.offset_top = -texture_size.y / 2
rect.offset_bottom = texture_size.y / 2
add_child(rect)
```

Example 2 (unknown):
```unknown
var rect = new TextureRect();

rect.Texture = ResourceLoader.Load<Texture>("res://icon.png");
rect.AnchorLeft = 0.5f;
rect.AnchorRight = 0.5f;
rect.AnchorTop = 0.5f;
rect.AnchorBottom = 0.5f;

var textureSize = rect.Texture.GetSize();

rect.OffsetLeft = -textureSize.X / 2;
rect.OffsetRight = textureSize.X / 2;
rect.OffsetTop = -textureSize.Y / 2;
rect.OffsetBottom = textureSize.Y / 2;
AddChild(rect);
```

---

## Submitting to the Asset Library — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/community/asset_library/submitting_to_assetlib.html

**Contents:**
- Submitting to the Asset Library
- Introduction
- Submission guidelines
  - Requirements
  - Recommendations
- Submitting
- User-contributed notes

This tutorial aims to serve as a guide on how you can submit your own assets to the Godot Asset Library and share them with the Godot community.

As mentioned in the Using the Asset Library document, in order to be able to submit assets to the AssetLib, you need to have a registered account, and be logged in.

Before submitting your asset, please ensure it follows all of the requirements, and also consider following the recommendations.

Generally speaking, most assets people submit to the asset library are accepted. However, in order for your asset to be accepted, there are a few requirements your asset needs to meet to be approved.

The asset must work. If the asset doesn't run or otherwise doesn't work in the specified Godot version, then it will be rejected.

The asset must have a proper .gitignore file. It's important to keep redundant data out of the repository. Here's a template.

No submodules, or any submodules must be non-essential. GitHub does not include submodules in the downloaded ZIP file, so if the asset needs the contents of the submodule, your asset won't work.

The license needs to be correct. The license listed on the asset library must match the license in the repository. The repo MUST have a license file, called either "LICENSE" or "LICENSE.md". This file must contain the license text itself and a copyright statement that includes the year(s) and copyright holder.

Use proper English for the name and description of your asset. This includes using correct capitalization, and using full sentences in the description. You can also include other languages, but there should at least be an English version.

The icon link must be a direct link. For icons hosted on GitHub, the link must start with "raw.githubusercontent.com", not "github.com".

These things are not required for your asset to be approved, but if you follow these recommendations, you can help make the asset library a better place for all users.

When creating non-project assets, it is common practice to place your files inside of an addons/asset_name/ folder. Do this to avoid having your files clash with other assets, or with the files of users installing your asset. This folder will not be automatically generated when a user installs your asset.

Fix or suppress all script warnings. The warning system is there to help identify issues with your code, but people using your asset don't need to see them.

Make your code conform to the official style guides. Having a consistent style helps other people read your code, and it also helps if other people wish to contribute to your asset. See: the GDScript style guide or the C# style guide.

If you have screenshots in your repo, place them in their own subfolder and add an empty .gdignore file in the same folder (note: gd, not git). This prevents Godot from importing your screenshots. On Windows, open a command prompt in the project folder and run type nul > .gdignore to create a file whose name starts with a period.

If your asset is a library for working with other files, consider including example files in the asset.

Consider adding a .gitattributes file to your repo. This file allows giving extra instructions to Git, such as specifying line endings and listing files not required for your asset to function with the export-ignore directive. This directive removes such files from the resulting ZIP file, preventing them from being downloaded by the asset library users. These are common examples of .gitattributes:

If you are submitting a plugin, add a copy of your license and readme to the plugin folder itself. This is the folder that users are guaranteed to keep with their project, so a copy ensures they always have those files handy (and helps them fulfill your licensing terms).

While the asset library allows more than just GitHub, consider hosting your asset's source code on GitHub. Other services may not work reliably, and a lack of familiarity can be a barrier to contributors.

Once you are logged in, you will be able to head over to the "Submit Assets" page of the AssetLib, which will look like this:

While it may look like a lot (and there is more as you scroll down), each field is described in terms of what you should put in. We will nonetheless go over what is required in the submission form here as well.

The name of your asset. Should be a unique, descriptive title of what your asset is.

The category that your asset belongs to, and will be shown in search results. The category is split into Addons and Projects. In-editor, assets of the Project type (Templates, Demos, Projects) only show up when viewing the AssetLib from the Project Manager, while assets of the Addon type will only be visible from inside a project.

The version of the engine that the asset works with. Currently, it's not possible to have a single asset entry contain downloads for multiple engine versions, so you may need to re-submit the asset multiple times, with an entry for each Godot version it supports. This is particularly important when dealing with major versions of the engine, such as Godot 2.x and Godot 3.x.

The version number of the asset. While you are free to choose and use any versioning scheme that you like, you may want to look into something such as SemVer if you want your asset's versioning scheme to be clear and consistent. Note that there is also an internal version number, incremented every time the asset download URL is changed or updated.

Assets uploaded to the AssetLib are not hosted on it directly. Instead, they point to repositories hosted on third-party Git providers, such as GitHub, GitLab or Bitbucket. This is where you choose which provider your asset uses, so the site can compute the final download link.

The URL to your asset's files/webpage. This will vary based on your choice of provider, but it should look similar to https://github.com/<user>/<project>.

The URL to your asset's issue tracker. Again, this will differ from repository host to repository host, but will likely look similar to https://github.com/<user>/<project>/issues. You may leave this field empty if you use your provider's issue tracker, and it's part of the same repository.

The commit of the asset. For example, b1d3172f89b86e52465a74f63a74ac84c491d3e1. The site computes the actual download URL from this.

The URL to your asset's icon (which will be used as a thumbnail in the AssetLib search results and on the asset's page). Should be an image in either the PNG or JPG format.

The icon must be square (1:1 aspect ratio). It should have a minimum resolution of 128×128 pixels.

For icons hosted on GitHub, URLs must be provided in the form of https://raw.githubusercontent.com/<user>/<project>/<branch>/Icon.png.

The license under which you are distributing the asset. The list includes a variety of free and open source software licenses, such as GPL (v2 and v3), MIT, BSD and Boost Software License. You can visit OpenSource.org for a detailed description of each of the listed licenses.

Finally, you can use the Description field for a textual overview of your asset, its features and behavior, a changelog, et cetera. In the future, formatting with Markdown will be supported, but currently, your only option is plain text.

You may also include up to three video and/or image previews, which will be shown at the bottom of the asset page. Use the "Enable" checkbox on each of the preview submission boxes to enable them.

Either an image, or a video.

Either a link to the image, or to a video, hosted on YouTube.

A URL to an image that will be used as a thumbnail for the preview. This option will be removed eventually, and thumbnails will be automatically computed instead.

Once you are done, press "Submit". Your asset will be entered into the review queue. You can check all assets currently pending a review here . The approval process is manual and may take up to a few days for your asset to be accepted (or rejected), so please be patient!

You will be informed when your asset is reviewed. If it was rejected, you will be told why that may have been, and you will be able to submit it again with the appropriate changes.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
# Normalize line endings for all files that Git considers text files.
* text=auto eol=lf
```

Example 2 (unknown):
```unknown
# Normalize line endings for all files that Git considers text files.
* text=auto eol=lf

# Only include the addons folder when downloading from the Asset Library.
/**        export-ignore
/addons    !export-ignore
/addons/** !export-ignore
```

---

## Support different actor area access — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/navigation/navigation_different_actor_area_access.html

**Contents:**
- Support different actor area access
- User-contributed notes

A typical example for different area access in gameplay are doors that connect rooms with different navigation meshes and are not accessible by all actors all the time.

Add a NavigationRegion at the door position. Add an appropriate navigation mesh the size of the door that can connect with the surrounding navigation meshes. In order to control access, enable / disable navigation layer bits so path queries that use the same navigation layer bits can find a path through the "door" navigation mesh.

The bitmask can act as a set of door keys or abilities and only actors with at least one matching and enabled bit layer in their pathfinding query will find a path through this region. See Using NavigationLayers for more information on how to work with navigation layers and the bitmask.

The entire "door" region can also be enabled / disable if required but if disabled will block access for all path queries.

Prefer working with navigation layers in path queries whenever possible as enabling or disabling navigation layers on a region triggers a costly recalculation of the navigation map connections.

Changing navigation layers will only affect new path queries but not automatically update existing paths.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Support different actor locomotion — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/navigation/navigation_different_actor_locomotion.html

**Contents:**
- Support different actor locomotion
- User-contributed notes

To support different actor locomotion like crouching and crawling, a similar map setup as supporting Support different actor types is required.

Bake different navigation meshes with an appropriate height for crouched or crawling actors so they can find paths through those narrow sections in your game world.

When an actor changes locomotion state, e.g. stands up, starts crouching or crawling, query the appropriate map for a path.

If the avoidance behavior should also change with the locomotion e.g. only avoid while standing or only avoid other agents in the same locomotion state, switch the actor's avoidance agent to another avoidance map with each locomotion change.

While a path query can be execute immediately for multiple maps, the avoidance agent map switch will only take effect after the next server synchronization.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
func update_path():

    if actor_standing:
        path = NavigationServer3D.map_get_path(standing_navigation_map_rid, start_position, target_position, true)
    elif actor_crouching:
        path = NavigationServer3D.map_get_path(crouched_navigation_map_rid, start_position, target_position, true)
    elif actor_crawling:
        path = NavigationServer3D.map_get_path(crawling_navigation_map_rid, start_position, target_position, true)

func change_agent_avoidance_state():

    if actor_standing:
        NavigationServer3D.agent_set_map(avoidance_agent_rid, standing_navigation_map_rid)
    elif actor_crouching:
        NavigationServer3D.agent_set_map(avoidance_agent_rid, crouched_navigation_map_rid)
    elif actor_crawling:
        NavigationServer3D.agent_set_map(avoidance_agent_rid, crawling_navigation_map_rid)
```

Example 2 (unknown):
```unknown
private void UpdatePath()
{
    if (_actorStanding)
    {
        _path = NavigationServer3D.MapGetPath(_standingNavigationMapRid, _startPosition, _targetPosition, true);
    }
    else if (_actorCrouching)
    {
        _path = NavigationServer3D.MapGetPath(_crouchedNavigationMapRid, _startPosition, _targetPosition, true);
    }
    else if (_actorCrawling)
    {
        _path = NavigationServer3D.MapGetPath(_crawlingNavigationMapRid, _startPosition, _targetPosition, true);
    }
}

private void ChangeAgentAvoidanceState()
{
    if (_actorStanding)
    {
        NavigationServer3D.AgentSetMap(_avoidanceAgentRid, _standingNavigationMapRid);
    }
    else if (_actorCrouching)
    {
        NavigationServer3D.AgentSetMap(_avoidanceAgentRid, _crouchedNavigationMapRid);
    }
    else if (_actorCrawling)
    {
        NavigationServer3D.AgentSetMap(_avoidanceAgentRid, _crawlingNavigationMapRid);
    }
}
```

---

## Support different actor types — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/navigation/navigation_different_actor_types.html

**Contents:**
- Support different actor types
- User-contributed notes

To support different actor types due to e.g. their sizes each type requires its own navigation map and navigation mesh baked with an appropriated agent radius and height. The same approach can be used to distinguish between e.g. landwalking, swimming or flying agents.

Agents are exclusively defined by a radius and height value for baking navigation meshes, pathfinding and avoidance. More complex shapes are not supported.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
# Create a navigation mesh resource for each actor size.
var navigation_mesh_standard_size: NavigationMesh = NavigationMesh.new()
var navigation_mesh_small_size: NavigationMesh = NavigationMesh.new()
var navigation_mesh_huge_size: NavigationMesh = NavigationMesh.new()

# Set appropriated agent parameters.
navigation_mesh_standard_size.agent_radius = 0.5
navigation_mesh_standard_size.agent_height = 1.8
navigation_mesh_small_size.agent_radius = 0.25
navigation_mesh_small_size.agent_height = 0.7
navigation_mesh_huge_size.agent_radius = 1.5
navigation_mesh_huge_size.agent_height = 2.5

# Get the root node to parse geometry for the baking.
var root_node: Node3D = get_node("NavigationMeshBakingRootNode")

# Create the source geometry resource that will hold the parsed geometry data.
var source_geometry_data: NavigationMeshSourceGeometryData3D = NavigationMeshSourceGeometryData3D.new()

# Parse the source geometry from the scene tree on the main thread.
# The navigation mesh is only required for the parse settings so any of the three will do.
NavigationServer3D.parse_source_geometry_data(navigation_mesh_standard_size, source_geometry_data, root_node)

# Bake the navigation geometry for each agent size from the same source geometry.
# If required for performance this baking step could also be done on background threads.
NavigationServer3D.bake_from_source_geometry_data(navigation_mesh_standard_size, source_geometry_data)
NavigationServer3D.bake_from_source_geometry_data(navigation_mesh_small_size, source_geometry_data)
NavigationServer3D.bake_from_source_geometry_data(navigation_mesh_huge_size, source_geometry_data)

# Create different navigation maps on the NavigationServer.
var navigation_map_standard: RID = NavigationServer3D.map_create()
var navigation_map_small: RID = NavigationServer3D.map_create()
var navigation_map_huge: RID = NavigationServer3D.map_create()

# Set the new navigation maps as active.
NavigationServer3D.map_set_active(navigation_map_standard, true)
NavigationServer3D.map_set_active(navigation_map_small, true)
NavigationServer3D.map_set_active(navigation_map_huge, true)

# Create a region for each map.
var navigation_region_standard: RID = NavigationServer3D.region_create()
var navigation_region_small: RID = NavigationServer3D.region_create()
var navigation_region_huge: RID = NavigationServer3D.region_create()

# Add the regions to the maps.
NavigationServer3D.region_set_map(navigation_region_standard, navigation_map_standard)
NavigationServer3D.region_set_map(navigation_region_small, navigation_map_small)
NavigationServer3D.region_set_map(navigation_region_huge, navigation_map_huge)

# Set navigation mesh for each region.
NavigationServer3D.region_set_navigation_mesh(navigation_region_standard, navigation_mesh_standard_size)
NavigationServer3D.region_set_navigation_mesh(navigation_region_small, navigation_mesh_small_size)
NavigationServer3D.region_set_navigation_mesh(navigation_region_huge, navigation_mesh_huge_size)

# Create start and end position for the navigation path query.
var start_pos: Vector3 = Vector3(0.0, 0.0, 0.0)
var end_pos: Vector3 = Vector3(2.0, 0.0, 0.0)
var use_corridorfunnel: bool = true

# Query paths for each agent size.
var path_standard_agent = NavigationServer3D.map_get_path(navigation_map_standard, start_pos, end_pos, use_corridorfunnel)
var path_small_agent = NavigationServer3D.map_get_path(navigation_map_small, start_pos, end_pos, use_corridorfunnel)
var path_huge_agent = NavigationServer3D.map_get_path(navigation_map_huge, start_pos, end_pos, use_corridorfunnel)
```

Example 2 (unknown):
```unknown
// Create a navigation mesh resource for each actor size.
NavigationMesh navigationMeshStandardSize = new NavigationMesh();
NavigationMesh navigationMeshSmallSize = new NavigationMesh();
NavigationMesh navigationMeshHugeSize = new NavigationMesh();

// Set appropriated agent parameters.
navigationMeshStandardSize.AgentRadius = 0.5f;
navigationMeshStandardSize.AgentHeight = 1.8f;
navigationMeshSmallSize.AgentRadius = 0.25f;
navigationMeshSmallSize.AgentHeight = 0.7f;
navigationMeshHugeSize.AgentRadius = 1.5f;
navigationMeshHugeSize.AgentHeight = 2.5f;

// Get the root node to parse geometry for the baking.
Node3D rootNode = GetNode<Node3D>("NavigationMeshBakingRootNode");

// Create the source geometry resource that will hold the parsed geometry data.
NavigationMeshSourceGeometryData3D sourceGeometryData = new NavigationMeshSourceGeometryData3D();

// Parse the source geometry from the scene tree on the main thread.
// The navigation mesh is only required for the parse settings so any of the three will do.
NavigationServer3D.ParseSourceGeometryData(navigationMeshStandardSize, sourceGeometryData, rootNode);

// Bake the navigation geometry for each agent size from the same source geometry.
// If required for performance this baking step could also be done on background threads.
NavigationServer3D.BakeFromSourceGeometryData(navigationMeshStandardSize, sourceGeometryData);
NavigationServer3D.BakeFromSourceGeometryData(navigationMeshSmallSize, sourceGeometryData);
NavigationServer3D.BakeFromSourceGeometryData(navigationMeshHugeSize, sourceGeometryData);

// Create different navigation maps on the NavigationServer.
Rid navigationMapStandard = NavigationServer3D.MapCreate();
Rid navigationMapSmall = NavigationServer3D.MapCreate();
Rid navigationMapHuge = NavigationServer3D.MapCreate();

// Set the new navigation maps as active.
NavigationServer3D.MapSetActive(navigationMapStandard, true);
NavigationServer3D.MapSetActive(navigationMapSmall, true);
NavigationServer3D.MapSetActive(navigationMapHuge, true);

// Create a region for each map.
Rid navigationRegionStandard = NavigationServer3D.RegionCreate();
Rid navigationRegionSmall = NavigationServer3D.RegionCreate();
Rid navigationRegionHuge = NavigationServer3D.RegionCreate();

// Add the regions to the maps.
NavigationServer3D.RegionSetMap(navigationRegionStandard, navigationMapStandard);
NavigationServer3D.RegionSetMap(navigationRegionSmall, navigationMapSmall);
NavigationServer3D.RegionSetMap(navigationRegionHuge, navigationMapHuge);

// Set navigation mesh for each region.
NavigationServer3D.RegionSetNavigationMesh(navigationRegionStandard, navigationMeshStandardSize);
NavigationServer3D.RegionSetNavigationMesh(navigationRegionSmall, navigationMeshSmallSize);
NavigationServer3D.RegionSetNavigationMesh(navigationRegionHuge, navigationMeshHugeSize);

// Create start and end position for the navigation path query.
Vector3 startPos = new Vector3(0.0f, 0.0f, 0.0f);
Vector3 endPos = new Vector3(2.0f, 0.0f, 0.0f);
bool useCorridorFunnel = true;

// Query paths for each agent size.
var pathStandardAgent = NavigationServer3D.MapGetPath(navigationMapStandard, startPos, endPos, useCorridorFunnel);
var pathSmallAgent = NavigationServer3D.MapGetPath(navigationMapSmall, startPos, endPos, useCorridorFunnel);
var pathHugeAgent = NavigationServer3D.MapGetPath(navigationMapHuge, startPos, endPos, useCorridorFunnel);
```

---

## Sync the gameplay with audio and music — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/audio/sync_with_audio.html

**Contents:**
- Sync the gameplay with audio and music
- Introduction
- Using the system clock to sync
- Using the sound hardware clock to sync
- User-contributed notes

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

In any application or game, sound and music playback will have a slight delay. For games, this delay is often so small that it is negligible. Sound effects will come out a few milliseconds after any play() function is called. For music this does not matter as in most games it does not interact with the gameplay.

Still, for some games (mainly, rhythm games), it may be required to synchronize player actions with something happening in a song (usually in sync with the BPM). For this, having more precise timing information for an exact playback position is useful.

Achieving very low playback timing precision is difficult. This is because many factors are at play during audio playback:

Audio is mixed in chunks (not continuously), depending on the size of audio buffers used (check latency in project settings).

Mixed chunks of audio are not played immediately.

Graphics APIs display two or three frames late.

When playing on TVs, some delay may be added due to image processing.

The most common way to reduce latency is to shrink the audio buffers (again, by editing the latency setting in the project settings). The problem is that when latency is too small, sound mixing will require considerably more CPU. This increases the risk of skipping (a crack in sound because a mix callback was lost).

This is a common tradeoff, so Godot ships with sensible defaults that should not need to be altered.

The problem, in the end, is not this slight delay but synchronizing graphics and audio for games that require it. Some helpers are available to obtain more precise playback timing.

As mentioned before, If you call AudioStreamPlayer.play(), sound will not begin immediately, but when the audio thread processes the next chunk.

This delay can't be avoided but it can be estimated by calling AudioServer.get_time_to_next_mix().

The output latency (what happens after the mix) can also be estimated by calling AudioServer.get_output_latency().

Add these two and it's possible to guess almost exactly when sound or music will begin playing in the speakers during _process():

In the long run, though, as the sound hardware clock is never exactly in sync with the system clock, the timing information will slowly drift away.

For a rhythm game where a song begins and ends after a few minutes, this approach is fine (and it's the recommended approach). For a game where playback can last a much longer time, the game will eventually go out of sync and a different approach is needed.

Using AudioStreamPlayer.get_playback_position() to obtain the current position for the song sounds ideal, but it's not that useful as-is. This value will increment in chunks (every time the audio callback mixed a block of sound), so many calls can return the same value. Added to this, the value will be out of sync with the speakers too because of the previously mentioned reasons.

To compensate for the "chunked" output, there is a function that can help: AudioServer.get_time_since_last_mix().

Adding the return value from this function to get_playback_position() increases precision:

To increase precision, subtract the latency information (how much it takes for the audio to be heard after it was mixed):

The result may be a bit jittery due how multiple threads work. Just check that the value is not less than in the previous frame (discard it if so). This is also a less precise approach than the one before, but it will work for songs of any length, or synchronizing anything (sound effects, as an example) to music.

Here is the same code as before using this approach:

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
var time_begin
var time_delay


func _ready():
    time_begin = Time.get_ticks_usec()
    time_delay = AudioServer.get_time_to_next_mix() + AudioServer.get_output_latency()
    $Player.play()


func _process(delta):
    # Obtain from ticks.
    var time = (Time.get_ticks_usec() - time_begin) / 1000000.0
    # Compensate for latency.
    time -= time_delay
    # May be below 0 (did not begin yet).
    time = max(0, time)
    print("Time is: ", time)
```

Example 2 (unknown):
```unknown
private double _timeBegin;
private double _timeDelay;

public override void _Ready()
{
    _timeBegin = Time.GetTicksUsec();
    _timeDelay = AudioServer.GetTimeToNextMix() + AudioServer.GetOutputLatency();
    GetNode<AudioStreamPlayer>("Player").Play();
}

public override void _Process(double delta)
{
    double time = (Time.GetTicksUsec() - _timeBegin) / 1000000.0d;
    time = Math.Max(0.0d, time - _timeDelay);
    GD.Print(string.Format("Time is: {0}", time));
}
```

Example 3 (unknown):
```unknown
var time = $Player.get_playback_position() + AudioServer.get_time_since_last_mix()
```

Example 4 (unknown):
```unknown
double time = GetNode<AudioStreamPlayer>("Player").GetPlaybackPosition() + AudioServer.GetTimeSinceLastMix();
```

---

## System requirements — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/about/system_requirements.html

**Contents:**
- System requirements
- Godot editor
  - Desktop or laptop PC - Minimum
  - Mobile device (smartphone/tablet) - Minimum
  - Desktop or laptop PC - Recommended
  - Mobile device (smartphone/tablet) - Recommended
- Exported Godot project
  - Desktop or laptop PC - Minimum
  - Mobile device (smartphone/tablet) - Minimum
  - Desktop or laptop PC - Recommended

This page contains system requirements for the editor and exported projects. These specifications are given for informative purposes only, but they can be referred to if you're looking to build or upgrade a system to use Godot on.

These are the minimum specifications required to run the Godot editor and work on a simple 2D or 3D project:

Windows: x86_32 CPU with SSE2 support, x86_64 CPU with SSE4.2 support, ARMv8 CPU

Example: Intel Core 2 Duo E8200, AMD FX-4100, Snapdragon X Elite

macOS: x86_64 or ARM CPU (Apple Silicon)

Example: Intel Core 2 Duo SU9400, Apple M1

Linux: x86_32 CPU with SSE2 support, x86_64 CPU with SSE4.2 support, ARMv7 or ARMv8 CPU

Example: Intel Core 2 Duo E8200, AMD FX-4100, Raspberry Pi 4

Forward+ renderer: Integrated graphics with full Vulkan 1.0 support

Example: Intel HD Graphics 510 (Skylake), AMD Radeon R5 Graphics (Kaveri)

Mobile renderer: Integrated graphics with full Vulkan 1.0 support

Example: Intel HD Graphics 510 (Skylake), AMD Radeon R5 Graphics (Kaveri)

Compatibility renderer: Integrated graphics with full OpenGL 3.3 support

Example: Intel HD Graphics 2500 (Ivy Bridge), AMD Radeon R5 Graphics (Kaveri)

200 MB (used for the executable, project files and cache). Exporting projects requires downloading export templates separately (1.3 GB after installation).

Native editor: Windows 10, macOS 10.13 (Compatibility) or macOS 10.15 (Forward+/Mobile), Linux distribution released after 2018

Web editor: Recent versions of mainstream browsers: Firefox and derivatives (including ESR), Chrome and Chromium derivatives, Safari and WebKit derivatives.

If your x86_64 CPU does not support SSE4.2, you can still run the 32-bit Godot executable which only has a SSE2 requirement (all x86_64 CPUs support SSE2).

While supported on Linux, we have no official minimum requirements for running on rv64 (RISC-V), ppc64 & ppc32 (PowerPC), and loongarch64. In addition you must compile the editor for that platform (as well as export templates) yourself, no official downloads are currently provided. RISC-V compiling instructions can be found on the Compiling for Linux, *BSD page.

Android: SoC with any 32-bit or 64-bit ARM or x86 CPU

Example: Qualcomm Snapdragon 430, Samsung Exynos 5 Octa 5430

iOS: Cannot run the editor

Forward+ renderer: SoC featuring GPU with full Vulkan 1.0 support

Example: Qualcomm Adreno 505, Mali-G71 MP2

Mobile renderer: SoC featuring GPU with full Vulkan 1.0 support

Example: Qualcomm Adreno 505, Mali-G71 MP2

Compatibility renderer: SoC featuring GPU with full OpenGL ES 3.0 support

Example: Qualcomm Adreno 306, Mali-T628 MP6

200 MB (used for the executable, project files and cache) Exporting projects requires downloading export templates separately (1.3 GB after installation)

Native editor: Android 6.0 (Compatibility) or Android 9.0 (Forward+/Mobile)

Web editor: Recent versions of mainstream browsers: Firefox and derivatives (including ESR), Chrome and Chromium derivatives, Safari and WebKit derivatives.

These are the recommended specifications to get a smooth experience with the Godot editor on a simple 2D or 3D project:

Windows: x86_64 CPU with SSE4.2 support, with 4 physical cores or more, ARMv8 CPU

Example: Intel Core i5-6600K, AMD Ryzen 5 1600, Snapdragon X Elite

macOS: x86_64 or ARM CPU (Apple Silicon)

Example: Intel Core i5-8500, Apple M1

Linux: x86_64 CPU with SSE4.2 support, ARMv7 or ARMv8 CPU

Example: Intel Core i5-6600K, AMD Ryzen 5 1600, Raspberry Pi 5 with overclocking

Forward+ renderer: Dedicated graphics with full Vulkan 1.2 support

Example: NVIDIA GeForce GTX 1050 (Pascal), AMD Radeon RX 460 (GCN 4.0)

Mobile renderer: Dedicated graphics with full Vulkan 1.2 support

Example: NVIDIA GeForce GTX 1050 (Pascal), AMD Radeon RX 460 (GCN 4.0)

Compatibility renderer: Dedicated graphics with full OpenGL 4.6 support

Example: NVIDIA GeForce GTX 650 (Kepler), AMD Radeon HD 7750 (GCN 1.0)

1.5 GB (used for the executable, project files, all export templates and cache)

Native editor: Windows 10, macOS 10.15, Linux distribution released after 2020

Web editor: Latest version of Firefox, Chrome, Edge, Safari, Opera

Android: SoC with 64-bit ARM or x86 CPU, with 3 "performance" cores or more

Example: Qualcomm Snapdragon 845, Samsung Exynos 9810

iOS: Cannot run the editor

Forward+ renderer: SoC featuring GPU with full Vulkan 1.2 support

Example: Qualcomm Adreno 630, Mali-G72 MP18

Mobile renderer: SoC featuring GPU with full Vulkan 1.2 support

Example: Qualcomm Adreno 630, Mali-G72 MP18

Compatibility renderer: SoC featuring GPU with full OpenGL ES 3.2 support

Example: Qualcomm Adreno 630, Mali-G72 MP18

1.5 GB (used for the executable, project files, all export templates and cache)

Native editor: Android 9.0

Web editor: Latest version of Firefox, Chrome, Edge, Safari, Opera, Samsung Internet

The requirements below are a baseline for a simple 2D or 3D project, with basic scripting and few visual flourishes. CPU, GPU, RAM and storage requirements will heavily vary depending on your project's scope, its renderer, viewport resolution and graphics settings chosen. Other programs running on the system while the project is running will also compete for resources, including RAM and video RAM.

It is strongly recommended to do your own testing on low-end hardware to make sure your project runs at the desired speed. To provide scalability for low-end hardware, you will also need to introduce a graphics options menu to your project.

These are the minimum specifications required to run a simple 2D or 3D project exported with Godot:

Windows: x86_32 CPU with SSE2 support, x86_64 CPU with SSE4.2 support, ARMv8 CPU

Example: Intel Core 2 Duo E8200, AMD FX-4100, Snapdragon X Elite

macOS: x86_64 or ARM CPU (Apple Silicon)

Example: Intel Core 2 Duo SU9400, Apple M1

Linux: x86_32 CPU with SSE2 support, x86_64 CPU with SSE4.2 support, ARMv7 or ARMv8 CPU

Example: Intel Core 2 Duo E8200, AMD FX-4100, Raspberry Pi 4

Forward+ renderer: Integrated graphics with full Vulkan 1.0 support, Metal 3 support (macOS) or Direct3D 12 (12_0 feature level) support (Windows)

Example: Intel HD Graphics 510 (Skylake), AMD Radeon R5 Graphics (Kaveri)

Mobile renderer: Integrated graphics with full Vulkan 1.0 support, Metal 3 support (macOS) or Direct3D 12 (12_0 feature level) support (Windows)

Example: Intel HD Graphics 510 (Skylake), AMD Radeon R5 Graphics (Kaveri)

Compatibility renderer: Integrated graphics with full OpenGL 3.3 support or Direct3D 11 support (Windows).

Example: Intel HD Graphics 2500 (Ivy Bridge), AMD Radeon R5 Graphics (Kaveri)

For native exports: 2 GB

For web exports: 4 GB

150 MB (used for the executable, project files and cache)

For native exports: Windows 10, macOS 10.13 (Compatibility), macOS 10.15 (Forward+/Mobile, Vulkan), macOS 13.0 (Forward+/Mobile, Metal), Linux distribution released after 2018

Web editor: Recent versions of mainstream browsers: Firefox and derivatives (including ESR), Chrome and Chromium derivatives, Safari and WebKit derivatives.

Android: SoC with any 32-bit or 64-bit ARM or x86 CPU

Example: Qualcomm Snapdragon 430, Samsung Exynos 5 Octa 5430

iOS: SoC with any 64-bit ARM CPU

Example: Apple A7 (iPhone 5S)

Forward+ renderer: SoC featuring GPU with full Vulkan 1.0 support, or Metal 3 support (iOS/iPadOS)

Example (Vulkan): Qualcomm Adreno 505, Mali-G71 MP2, Apple A12 (iPhone XR/XS)

Example (Metal): Apple A11 (iPhone 8/X)

Mobile renderer: SoC featuring GPU with full Vulkan 1.0 support, or Metal 3 support (iOS/iPadOS)

Example (Vulkan): Qualcomm Adreno 505, Mali-G71 MP2, Apple A12 (iPhone XR/XS)

Example (Metal): Apple A11 (iPhone 8/X)

Compatibility renderer: SoC featuring GPU with full OpenGL ES 3.0 support

Example: Qualcomm Adreno 306, Mali-T628 MP6, Apple A7 (iPhone 5S)

For native exports: 1 GB

For web exports: 2 GB

150 MB (used for the executable, project files and cache)

For native exports: Android 6.0 (Compatibility), Android 9.0 (Forward+/Mobile), iOS 12.0 (Forward+/Mobile, Vulkan), iOS 16.0 (Forward+/Mobile, Metal)

Web editor: Recent versions of mainstream browsers: Firefox and derivatives (including ESR), Chrome and Chromium derivatives, Safari and WebKit derivatives.

These are the recommended specifications to get a smooth experience with a simple 2D or 3D project exported with Godot:

Windows: x86_64 CPU with SSE4.2 support, with 4 physical cores or more, ARMv8 CPU

Example: Intel Core i5-6600K, AMD Ryzen 5 1600, Snapdragon X Elite

macOS: x86_64 or ARM CPU (Apple Silicon)

Example: Intel Core i5-8500, Apple M1

Linux: x86_64 CPU with SSE4.2 support, with 4 physical cores or more, ARMv7 or ARMv8 CPU

Example: Intel Core i5-6600K, AMD Ryzen 5 1600, Raspberry Pi 5 with overclocking

Forward+ renderer: Dedicated graphics with full Vulkan 1.2 support, Metal 3 support (macOS), or Direct3D 12 (12_0 feature level) support (Windows)

Example: NVIDIA GeForce GTX 1050 (Pascal), AMD Radeon RX 460 (GCN 4.0)

Mobile renderer: Dedicated graphics with full Vulkan 1.2 support, Metal 3 support (macOS), or Direct3D 12 (12_0 feature level) support (Windows)

Example: NVIDIA GeForce GTX 1050 (Pascal), AMD Radeon RX 460 (GCN 4.0)

Compatibility renderer: Dedicated graphics with full OpenGL 4.6 support

Example: NVIDIA GeForce GTX 650 (Kepler), AMD Radeon HD 7750 (GCN 1.0)

For native exports: 4 GB

For web exports: 8 GB

150 MB (used for the executable, project files and cache)

For native exports: Windows 10, macOS 10.15 (Forward+/Mobile, Vulkan), macOS 13.0 (Forward+/Mobile, Metal), Linux distribution released after 2020

For web exports: Latest version of Firefox, Chrome, Edge, Safari, Opera

Android: SoC with 64-bit ARM or x86 CPU, with 3 "performance" cores or more

Example: Qualcomm Snapdragon 845, Samsung Exynos 9810

iOS: SoC with 64-bit ARM CPU

Example: Apple A14 (iPhone 12)

Forward+ renderer: SoC featuring GPU with full Vulkan 1.2 support, or Metal 3 support (iOS/iPadOS)

Example: Qualcomm Adreno 630, Mali-G72 MP18, Apple A14 (iPhone 12)

Mobile renderer: SoC featuring GPU with full Vulkan 1.2 support, or Metal 3 support (iOS/iPadOS)

Example: Qualcomm Adreno 630, Mali-G72 MP18, Apple A14 (iPhone 12)

Compatibility renderer: SoC featuring GPU with full OpenGL ES 3.2 support

Example: Qualcomm Adreno 630, Mali-G72 MP18, Apple A14 (iPhone 12)

For native exports: 2 GB

For web exports: 4 GB

150 MB (used for the executable, project files and cache)

For native exports: Android 9.0, iOS 14.1 (Forward+/Mobile, Vulkan), iOS 16.0 (Forward+/Mobile, Metal)

For web exports: Latest version of Firefox, Chrome, Edge, Safari, Opera, Samsung Internet

Godot doesn't use OpenGL/OpenGL ES extensions introduced after OpenGL 3.3/OpenGL ES 3.0, but GPUs supporting newer OpenGL/OpenGL ES versions generally have fewer driver issues.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Text to speech — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/audio/text_to_speech.html

**Contents:**
- Text to speech
- Basic Usage
- Requirements for functionality
  - Distro-specific one-liners
- Troubleshooting
- Best practices
- Caveats and Other Information
- User-contributed notes

Basic usage of text-to-speech involves the following one-time steps:

Enable TTS in the Godot editor for your project

Query the system for a list of usable voices

Store the ID of the voice you want to use

By default, the Godot project-level setting for text-to-speech is disabled, to avoid unnecessary overhead. To enable it:

Go to Project > Project Settings

Make sure the Advanced Settings toggle is enabled

Click on Audio > General

Ensure the Text to Speech option is checked

Restart Godot if prompted to do so.

Text-to-speech uses a specific voice. Depending on the user's system, they might have multiple voices installed. Once you have the voice ID, you can use it to speak some text:

Godot includes text-to-speech functionality. You can find these under the DisplayServer class.

Godot depends on system libraries for text-to-speech functionality. These libraries are installed by default on Windows, macOS, Web, Android and iOS, but not on all Linux distributions. If they are not present, text-to-speech functionality will not work. Specifically, the tts_get_voices() method will return an empty list, indicating that there are no usable voices.

Both Godot users on Linux and end-users on Linux running Godot games need to ensure that their system includes the system libraries for text-to-speech to work. Please consult the table below or your own distribution's documentation to determine what libraries you need to install.

If you get the error Invalid get index '0' (on base: 'PackedStringArray'). for the line var voice_id = voices[0], check if there are any items in voices. If not:

All users: make sure you enabled Text to Speech in project settings

Linux users: ensure you installed the system-specific libraries for text to speech

The best practices for text-to-speech, in terms of the ideal player experience for blind players, is to send output to the player's screen reader. This preserves the choice of language, speed, pitch, etc. that the user set, as well as allows advanced features like allowing players to scroll backward and forward through text. As of now, Godot doesn't provide this level of integration.

With the current state of the Godot text-to-speech APIs, best practices include:

Develop the game with text-to-speech enabled, and ensure that everything sounds correct

Allow players to control which voice to use, and save/persist that selection across game sessions

Allow players to control the speech rate, and save/persist that selection across game sessions

This provides your blind players with the most flexibility and comfort available when not using a screen reader, and minimizes the chance of frustrating and alienating them.

Expect delays when you call tts_speak and tts_stop. The actual delay time varies depending on both the OS and on your machine's specifications. This is especially critical on Android and Web, where some of the voices depend on web services, and the actual time to playback depends on server load, network latency, and other factors.

Non-English text works if the correct voices are installed and used. On Windows, you can consult the instructions in this article to enable additional language voices on Windows.

Non-ASCII characters, such as umlaut, are pronounced correctly if you select the correct voice.

Blind players use a number of screen readers, including JAWS, NVDA, VoiceOver, Narrator, and more.

Windows text-to-speech APIs generally perform better than their equivalents on other systems (e.g. tts_stop followed by tts_speak immediately speaks the new message).

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
# One-time steps.
# Pick a voice. Here, we arbitrarily pick the first English voice.
var voices = DisplayServer.tts_get_voices_for_language("en")
var voice_id = voices[0]

# Say "Hello, world!".
DisplayServer.tts_speak("Hello, world!", voice_id)

# Say a longer sentence, and then interrupt it.
# Note that this method is asynchronous: execution proceeds to the next line immediately,
# before the voice finishes speaking.
var long_message = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur"
DisplayServer.tts_speak(long_message, voice_id)

# Immediately stop the current text mid-sentence and say goodbye instead.
DisplayServer.tts_stop()
DisplayServer.tts_speak("Goodbye!", voice_id)
```

Example 2 (unknown):
```unknown
// One-time steps.
// Pick a voice. Here, we arbitrarily pick the first English voice.
string[] voices = DisplayServer.TtsGetVoicesForLanguage("en");
string voiceId = voices[0];

// Say "Hello, world!".
DisplayServer.TtsSpeak("Hello, world!", voiceId);

// Say a longer sentence, and then interrupt it.
// Note that this method is asynchronous: execution proceeds to the next line immediately,
// before the voice finishes speaking.
string longMessage = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur";
DisplayServer.TtsSpeak(longMessage, voiceId);

// Immediately stop the current text mid-sentence and say goodbye instead.
DisplayServer.TtsStop();
DisplayServer.TtsSpeak("Goodbye!", voiceId);
```

Example 3 (unknown):
```unknown
pacman -S speech-dispatcher festival espeakup
```

---

## Theme type variations — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/ui/gui_theme_type_variations.html

**Contents:**
- Theme type variations
- Creating a type variation
- Using a type variation
- User-contributed notes

When designing a user interface there may be times when a Control node needs to have a different look than what is normally defined by a Theme. Every control node has theme property overrides, which allow you to redefine the styling for each individual UI element.

This approach quickly becomes hard to manage, if you need to share the same custom look between several controls. Imagine that you use gray, blue, and red variants of Button throughout your project. Setting it up every time you add a new button element to your interface is a tedious task.

To help with the organization and to better utilize the power of themes you can use theme type variations. These work like normal theme types, but instead of being self-sufficient and standalone they extend another, base type.

Following the previous example, your theme can have some styles, colors, and fonts defined for the Button type, customizing the looks of every button element in your UI. To then have a gray, red, or blue button you would create a new type, e.g. GrayButton, and mark it as a variation of the base Button type.

Type variations can replace some aspects of the base type, but keep others. They can also define properties that the base style hasn't defined. For example, your GrayButton can override the normal style from the base Button and add font_color that Button has never defined. The control will use a combination of both types giving priority to the type variation.

The way controls resolve what theme items they use from each type and each theme is better described in the Customizing a project section of the "Introduction to GUI skinning" article.

To create a type variation open the theme editor, then click the plus icon next to the Type dropdown on the right side of the editor. Type in what you want to name your theme type variation in the text box, then click Add Type.

Below the Type dropdown are the property tabs. Switch to the tab with a wrench and screwdriver icon.

Click on the plus icon next to the Base Type field. You can select the base type there, which would typically be the name of a control node class (e.g., Button, Label, etc). Type variations can also chain and extend other type variations. This works in the same way control nodes inherit styling of their base class. For example, CheckButton inherits styles from Button because corresponding node types extend each other.

After you select the base type, you should now be able to see its properties on the other tabs in the theme editor. You can edit them as usual.

Now that a type variation has been created you can apply it to your nodes. In the inspector dock, under the Theme property of a control node, you can find the Theme Type Variation property. It is empty by default, which means that only the base type has an effect on this node.

You can either select a type variation from a dropdown list, or input its name manually. Variations appear on the list only if the type variation belongs to the project-wide theme, which you can configure in the project settings. For any other case you have to input the name of the variation manually. Click on the pencil icon to the right. Then type in the name of the type variation and click the check mark icon or press enter. If a type variation with that name exists it will now be used by the node.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## The Compositor — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/rendering/compositor.html

**Contents:**
- The Compositor
- Compositor effects
- User-contributed notes

The compositor is a new feature in Godot 4 that allows control over the rendering pipeline when rendering the contents of a Viewport.

It can be configured on a WorldEnvironment node where it applies to all Viewports, or it can be configured on a Camera3D and apply only to the Viewport using that camera.

The Compositor resource is used to configure the compositor. To get started, create a new compositor on the appropriate node:

The compositor is currently a feature that is only supported by the Mobile and Forward+ renderers.

Compositor effects allow you to insert additional logic into the rendering pipeline at various stages. This is an advanced feature that requires a high level of understanding of the rendering pipeline to use to its best advantage.

As the core logic of the compositor effect is called from the rendering pipeline it is important to note that this logic will thus run within the thread on which rendering takes place. Care needs to be taken to ensure we don't run into threading issues.

To illustrate how to use compositor effects we'll create a simple post processing effect that allows you to write your own shader code and apply this full screen through a compute shader. You can find the finished demo project here.

We start by creating a new script called post_process_shader.gd. We'll make this a tool script so we can see the compositor effect work in the editor. We need to extend our node from CompositorEffect. We must also give our script a class name.

Next we're going to define a constant for our shader template code. This is the boilerplate code that makes our compute shader work.

For more information on how compute shaders work, please check Using compute shaders.

The important bit here is that for every pixel on our screen, our main function is executed and inside of this we load the current color value of our pixel, execute our user code, and write our modified color back to our color image.

#COMPUTE_CODE gets replaced by our user code.

In order to set our user code, we need an export variable. We'll also define a few script variables we'll be using:

Note the use of a Mutex in our code. Most of our implementation gets called from the rendering engine and thus runs within our rendering thread.

We need to ensure that we set our new shader code, and mark our shader code as dirty, without our render thread accessing this data at the same time.

Next we initialize our effect.

The main thing here is setting our effect_callback_type which tells the rendering engine at what stage of the render pipeline to call our code.

Currently we only have access to the stages of the 3D rendering pipeline!

We also get a reference to our rendering device, which will come in very handy.

We also need to clean up after ourselves, for this we react to the NOTIFICATION_PREDELETE notification:

Note that we do not use our mutex here even though we create our shader inside of our render thread. The methods on our rendering server are thread safe and free_rid will be postponed cleaning up the shader until after any frames currently being rendered are finished.

Also note that we are not freeing our pipeline. The rendering device does dependency tracking and as the pipeline is dependent on the shader, it will be automatically freed when the shader is destructed.

From this point onwards our code will run on the rendering thread.

Our next step is a helper function that will recompile the shader if the user code was changed.

At the top of this method we again use our mutex to protect accessing our user shader code and our is dirty flag. We make a local copy of the user shader code if our user shader code is dirty.

If we don't have a new code fragment, we return true if we already have a valid pipeline.

If we do have a new code fragment we embed it in our template code and then compile it.

The code shown here compiles our new code in runtime. This is great for prototyping as we can immediately see the effect of the changed shader.

This prevents precompiling and caching this shader which may be an issues on some platforms such as consoles. Note that the demo project comes with an alternative example where a glsl file contains the entire compute shader and this is used. Godot is able to precompile and cache the shader with this approach.

Finally we need to implement our effect callback, the rendering engine will call this at the right stage of rendering.

At the start of this method we check if we have a rendering device, if our callback type is the correct one, and check if we have our shader.

The check for the effect type is only a safety mechanism. We've set this in our _init function, however it is possible for the user to change this in the UI.

Our p_render_data parameter gives us access to an object that holds data specific to the frame we're currently rendering. We're currently only interested in our render scene buffers, which provide us access to all the internal buffers used by the rendering engine. Note that we cast this to RenderSceneBuffersRD to expose the full API to this data.

Next we obtain our internal size which is the resolution of our 3D render buffers before they are upscaled (if applicable), upscaling happens after our post processes have run.

From our internal size we calculate our group size, see our local size in our template shader.

We also populate our push constant so our shader knows our size. Godot does not support structs here yet so we use a PackedFloat32Array to store this data into. Note that we have to pad this array with a 16 byte alignment. In other words, the length of our array needs to be a multiple of 4.

Now we loop through our views, this is in case we're using multiview rendering which is applicable for stereo rendering (XR). In most cases we will only have one view.

There is no performance benefit to use multiview for post processing here, handling the views separately like this will still enable the GPU to use parallelism if beneficial.

Next we obtain the color buffer for this view. This is the buffer into which our 3D scene has been rendered.

We then prepare a uniform set so we can communicate the color buffer to our shader.

Note the use of our UniformSetCacheRD cache which ensures we can check for our uniform set each frame. As our color buffer can change from frame to frame and our uniform cache will automatically clean up uniform sets when buffers are freed, this is the safe way to ensure we do not leak memory or use an outdated set.

Finally we build our compute list by binding our pipeline, binding our uniform set, pushing our push constant data, and calling dispatch for our groups.

With our compositor effect completed, we now need to add it to our compositor.

On our compositor we expand the compositor effects property and press Add Element.

Now we can add our compositor effect:

After selecting our PostProcessShader we need to set our user shader code:

With that all done, our output is in grayscale.

For a more advanced example of post effects, check out the Radial blur based sky rays example project created by Bastiaan Olij.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
@tool
extends CompositorEffect
class_name PostProcessShader
```

Example 2 (javascript):
```javascript
const template_shader: String = """
#version 450

// Invocations in the (x, y, z) dimension
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(rgba16f, set = 0, binding = 0) uniform image2D color_image;

// Our push constant
layout(push_constant, std430) uniform Params {
    vec2 raster_size;
    vec2 reserved;
} params;

// The code we want to execute in each invocation
void main() {
    ivec2 uv = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = ivec2(params.raster_size);

    if (uv.x >= size.x || uv.y >= size.y) {
        return;
    }

    vec4 color = imageLoad(color_image, uv);

    #COMPUTE_CODE

    imageStore(color_image, uv, color);
}
"""
```

Example 3 (unknown):
```unknown
@export_multiline var shader_code: String = "":
    set(value):
        mutex.lock()
        shader_code = value
        shader_is_dirty = true
        mutex.unlock()

var rd: RenderingDevice
var shader: RID
var pipeline: RID

var mutex: Mutex = Mutex.new()
var shader_is_dirty: bool = true
```

Example 4 (unknown):
```unknown
# Called when this resource is constructed.
func _init():
    effect_callback_type = EFFECT_CALLBACK_TYPE_POST_TRANSPARENT
    rd = RenderingServer.get_rendering_device()
```

---

## The JavaScriptBridge singleton — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/platform/web/javascript_bridge.html

**Contents:**
- The JavaScriptBridge singleton
- Interacting with JavaScript
- Callbacks
- Can I use my favorite library?
- The eval interface
- Downloading files
- User-contributed notes

In web builds, the JavaScriptBridge singleton allows interaction with JavaScript and web browsers, and can be used to implement some functionalities unique to the web platform.

Sometimes, when exporting Godot for the Web, it might be necessary to interface with external JavaScript code like third-party SDKs, libraries, or simply to access browser features that are not directly exposed by Godot.

The JavaScriptBridge singleton provides methods to wrap a native JavaScript object into a Godot JavaScriptObject that tries to feel natural in the context of Godot scripting (e.g. GDScript and C#).

The JavaScriptBridge.get_interface() method retrieves an object in the global scope.

The JavaScriptBridge.create_object() creates a new object via the JavaScript new constructor.

As you can see, by wrapping JavaScript objects into JavaScriptObject you can interact with them like they were native Godot objects, calling their methods, and retrieving (or even setting) their properties.

Base types (int, floats, strings, booleans) are automatically converted (floats might lose precision when converted from Godot to JavaScript). Anything else (i.e. objects, arrays, functions) are seen as JavaScriptObjects themselves.

Calling JavaScript code from Godot is nice, but sometimes you need to call a Godot function from JavaScript instead.

This case is a bit more complicated. JavaScript relies on garbage collection, while Godot uses reference counting for memory management. This means you have to explicitly create callbacks (which are returned as JavaScriptObjects themselves) and you have to keep their reference.

Arguments passed by JavaScript to the callback will be passed as a single Godot Array.

Callback methods created via JavaScriptBridge.get_interface() (_my_callback in the above example) must take exactly one Array argument, which is going to be the JavaScript arguments object converted to an array. Otherwise, the callback method will not be called.

Here is another example that asks the user for the Notification permission and waits asynchronously to deliver a notification if the permission is granted:

You most likely can. First, you have to include your library in the page. You can customize the Head Include during export (see below), or even write your own template.

In the example below, we customize the Head Include to add an external library (axios) from a content delivery network, and a second <script> tag to define our own custom function:

We can then access both the library and the function from Godot, like we did in previous examples:

The eval method works similarly to the JavaScript function of the same name. It takes a string as an argument and executes it as JavaScript code. This allows interacting with the browser in ways not possible with script languages integrated into Godot.

The value of the last JavaScript statement is converted to a GDScript value and returned by eval() under certain circumstances:

JavaScript number is returned as float

JavaScript boolean is returned as bool

JavaScript string is returned as String

JavaScript ArrayBuffer, TypedArray, and DataView are returned as PackedByteArray

Any other JavaScript value is returned as null.

HTML5 export templates may be built without support for the singleton to improve security. With such templates, and on platforms other than HTML5, calling JavaScriptBridge.eval will also return null. The availability of the singleton can be checked with the web feature tag:

GDScript's multi-line strings, surrounded by 3 quotes """ as in my_func3() above, are useful to keep JavaScript code readable.

The eval method also accepts a second, optional Boolean argument, which specifies whether to execute the code in the global execution context, defaulting to false to prevent polluting the global namespace:

Downloading files (e.g. a save game) from the Godot Web export to the user's computer can be done by directly interacting with JavaScript, but given it is a very common use case, Godot exposes this functionality to scripting via a dedicated JavaScriptBridge.download_buffer() function which lets you download any generated buffer.

Here is a minimal example on how to use it:

And here is a more complete example on how to download a previously saved file:

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
extends Node

func _ready():
    # Retrieve the `window.console` object.
    var console = JavaScriptBridge.get_interface("console")
    # Call the `window.console.log()` method.
    console.log("test")
```

Example 2 (gdscript):
```gdscript
extends Node

func _ready():
    # Call the JavaScript `new` operator on the `window.Array` object.
    # Passing 10 as argument to the constructor:
    # JS: `new Array(10);`
    var arr = JavaScriptBridge.create_object("Array", 10)
    # Set the first element of the JavaScript array to the number 42.
    arr[0] = 42
    # Call the `pop` function on the JavaScript array.
    arr.pop()
    # Print the value of the `length` property of the array (9 after the pop).
    print(arr.length)
```

Example 3 (gdscript):
```gdscript
extends Node

# Here we create a reference to the `_my_callback` function (below).
# This reference will be kept until the node is freed.
var _callback_ref = JavaScriptBridge.create_callback(_my_callback)

func _ready():
    # Get the JavaScript `window` object.
    var window = JavaScriptBridge.get_interface("window")
    # Set the `window.onbeforeunload` DOM event listener.
    window.onbeforeunload = _callback_ref

func _my_callback(args):
    # Get the first argument (the DOM event in our case).
    var js_event = args[0]
    # Call preventDefault and set the `returnValue` property of the DOM event.
    js_event.preventDefault()
    js_event.returnValue = ''
```

Example 4 (gdscript):
```gdscript
extends Node

# Here we create a reference to the `_on_permissions` function (below).
# This reference will be kept until the node is freed.
var _permission_callback = JavaScriptBridge.create_callback(_on_permissions)

func _ready():
    # NOTE: This is done in `_ready` for simplicity, but SHOULD BE done in response
    # to user input instead (e.g. during `_input`, or `button_pressed` event, etc.),
    # otherwise it might not work.

    # Get the `window.Notification` JavaScript object.
    var notification = JavaScriptBridge.get_interface("Notification")
    # Call the `window.Notification.requestPermission` method which returns a JavaScript
    # Promise, and bind our callback to it.
    notification.requestPermission().then(_permission_callback)

func _on_permissions(args):
    # The first argument of this callback is the string "granted" if the permission is granted.
    var permission = args[0]
    if permission == "granted":
        print("Permission granted, sending notification.")
        # Create the notification: `new Notification("Hi there!")`
        JavaScriptBridge.create_object("Notification", "Hi there!")
    else:
        print("No notification permission.")
```

---

## The XR action map — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/xr/xr_action_map.html

**Contents:**
- The XR action map
- The default action map
- Action sets
- Actions
- Profiles
- Our first controller binding
- The simple controller
- Binding Modifiers
  - Binding modifiers on an interaction profile
    - Dpad Binding modifier

Godot has an action map feature as part of the XR system. At this point in time this system is part of the OpenXR module. There are plans to encompass WebXR into this in the near future hence we call it the XR action map system in this document. It implements the built-in action map system of OpenXR mostly exactly as it is offered.

The XR action map system exposes input, positional data and output for XR controllers to your game/application. It does this by exposing named actions that can be tailored to your game/application and binding these to the actual inputs and outputs on your XR devices.

As the XR action map is currently part of the OpenXR module, OpenXR needs to be enabled in your project settings to expose it:

You will then find the XR Action Map interface in the bottom of the screen:

Godot's built-in input system has many things in common with the XR action map system. In fact our original idea was to add functionality to the existing input system and expose the data to the OpenXR action map system. We may revisit that idea at some point but as it turns out there were just too many problems to overcome. To name a few:

Godot's input system mainly centers around button inputs, XR adds triggers, axis, poses and haptics (output) into the mix. This would greatly complicate the input system with features that won't work for normal controllers or contrast with the current approach. It was felt this would lead to confusion for the majority of Godot users.

Godot's input system works with raw input data that is parsed and triggers emitting actions. This input data is made available to the end user. OpenXR completely hides raw data and does all the parsing for us, we only get access to already parsed action data. This inconsistency is likely to lead to bugs when an unsuspecting user tries to use an XR device as a normal input device.

Godot's input system allows changes to what inputs are bound to actions in runtime, OpenXR does not.

Godot's input system is based on device ids which are meaningless in OpenXR.

This does mean that a game/application that mixes traditional inputs with XR controllers will have a separation. For most applications either one or the other is used and this is not seen as a problem. In the end, it's a limitation of the system.

Godot will automatically create a default action map if no action map file is found.

This default map was designed to help developers port their XR games/applications from Godot 3 to Godot 4. As a result this map essentially binds all known inputs on all controllers supported by default, to actions one on one. This is not a good example of setting up an action map. It does allow a new developer to have a starting point when they want to become familiar with Godot XR. It prevents having to design a proper action map for their game/application first.

For this walkthrough we're going to start with a blank action map. You can delete the "Godot action set" entry at the top by pressing the trash can icon. This will clear out all actions. You might also want to remove the controllers that you do not wish to setup, more on this later.

Before we dive in, you will see the term XR runtime used throughout this document. With XR runtime we mean the software that is controlling and interacting with the AR or VR headset. The XR runtime then exposes this to us through an API such as OpenXR. So:

for Steam this is SteamVR,

for Meta on desktop this is the Oculus Client (including when using Quest link),

for Meta on Quest this is the Quest's native OpenXR client,

on Linux this could be Monado, etc.

The action map allows us to organize our actions in sets. Each set can be enabled or disabled on its own.

The concept here is that you could have different sets that provide bindings in different scenarios. You could have:

a Character control set for when you're walking around,

a Vehicle control set for when you're operating a vehicle,

a Menu set for when a menu is open.

Only the action set applicable to the current state of your game/application can then be enabled.

This is especially important if you wish to bind the same input on a controller to a different action. For instance:

in your Character control set you may have an action Jump,

in your Vehicle control set you may have an action Accelerate,

in your Menu set you may have an action Select.

All are bound to the trigger on your controller.

OpenXR will only bind an input or output to a single action. If the same input or output is bound to multiple actions the one in the active action set with the highest priority will be the one updated/used. So in our above example it will thus be important that only one action set is active.

For your first XR game/application we highly recommend starting with just a single action set and to not over-engineer things.

For our walkthrough in this document we will thus create a single action set called my_first_action_set. We do this by pressing the Add action set button:

The columns in our table are as follows:

This is the internal name of the action set. OpenXR doesn't specify specific restrictions on this name other then size, however some XR runtimes will not like spaces or special characters.

This is a human-readable name for the action set. Some XR runtimes will display this name to the end user, for example in configuration dialogs.

This is the priority of the action set. If multiple active action sets have actions bound to the same controller's inputs or outputs, the action set with the highest priority value will determine the action that is updated.

In the XR action map, actions are the entities that your game/application will interact with. For instance, we can define an action Shoot and the input bound to that action will trigger the button_pressed signal on the relevant XRController3D node in your scene with Shoot as the name parameter of the signal.

You can also poll the current state of an action. XRController3D for instance has an is_button_pressed method.

Actions can be used for both input and output and each action has a type that defines its behavior.

The Bool type is used for discrete input like buttons.

The Float type is used for analogue input like triggers.

These two are special as they are the only ones that are interchangeable. OpenXR will handle conversions between Bool and Float inputs and actions. You can get the value of a Float type action by calling the method get_float on your XRController3D node. It emits the input_float_changed signal when changed.

Where analogue inputs are queried as buttons a threshold is applied. This threshold is currently managed exclusively by the XR runtime. There are plans to extend Godot to provide some level of control over these thresholds in the future.

The Vector2 type defines the input as an axis input. Touchpads, thumbsticks and similar inputs are exposed as vectors. You can get the value of a Vector2 type action by calling the method get_vector2 on your XRController3D node. It emits the input_vector2_changed signal when changed.

The Pose type defines a spatially tracked input. Multiple "pose" inputs are available in OpenXR: aim, grip and palm. Your XRController3D node is automatically positioned based on the pose action assigned to pose property of this node. More about poses later.

The OpenXR implementation in Godot also exposes a special pose called Skeleton. This is part of the hand tracking implementation. This pose is exposed through the skeleton action that is supported outside of the action map system. It is thus always present if hand tracking is supported. You don't need to bind actions to this pose to use it.

Finally, the only output type is Haptic and it allows us to set the intensity of haptic feedback, such as controller vibration. Controllers can have multiple haptic outputs and support for haptic vests is coming to OpenXR.

So lets add an action for our aim pose, we do this by clicking on the + button for our action set:

The columns in our table are as follows:

This is the internal name of the action. OpenXR doesn't specify specific restrictions on this name other then size, however some XR runtimes will not like spaces or special characters.

This is a human-readable name for the action. Some XR runtimes will display this name to the end user, for example in configuration dialogs.

The type of this action.

OpenXR defines a number of bindable input poses that are commonly available for controllers. There are no rules for which poses are supported for different controllers. The poses OpenXR currently defines are:

The aim pose on most controllers is positioned slightly in front of the controller and aims forward. This is a great pose to use for laser pointers or to align the muzzle of a weapon with.

The grip pose on most controllers is positioned where the grip button is placed on the controller. The orientation of this pose differs between controllers and can differ for the same controller on different XR runtimes.

The palm pose on most controllers is positioned in the center of the palm of the hand holding the controller. This is a new pose that is not available on all XR runtimes.

If hand tracking is used, there are currently big differences in implementations between the different XR runtimes. As a result the action map is currently not suitable for hand tracking. Work is being done on this so stay tuned.

Let's complete our list of actions for a very simple shooting game/application:

The actions we have added are:

movement, which allows the user to move around outside of normal room scale tracking.

grab, which detects that the user wants to hold something.

shoot, which detects that the user wants to fire the weapon they are holding.

haptic, which allows us to output haptic feedback.

Now note that we don't distinguish between the left and right hand. This is something that is determined at the next stage. We've implemented the action system in such a way that you can bind the same action to both hands. The appropriate XRController3D node will emit the signal.

For both grab and shoot we've used the Bool type. As mentioned before, OpenXR does automatic conversions from an analogue controls however not all XR Runtimes currently apply sensible thresholds.

We recommend as a workaround to use the Float type when interacting with triggers and grip buttons and apply your own threshold.

For buttons like A/B/X/Y and similar where there is no analogue option, the Bool type works fine.

You can bind the same action to multiple inputs for the same controller on the same profile. In this case the XR runtime will attempt to combine the inputs.

For Bool inputs, this will perform an OR operation between the buttons.

For Float inputs, this will take the highest value of the bound inputs.

The behavior for Pose inputs is undefined, but the first bound input is likely to be used.

You shouldn't bind multiple actions of the same action set to the same controller input. If you do this, or if actions are bound from multiple action sets but they have overlapping priorities, the behavior is undefined. The XR runtime may simply not accept your action map, or it may take this on a first come first serve basis.

We are still investigating the restrictions around binding multiple actions to the same output as this scenario makes sense. The OpenXR specification seems to not allow this.

Now that we have our basic actions defined, it's time to hook them up.

In OpenXR controller bindings are captured in so-called "Interaction Profiles". We've shortened it to "Profiles" because it takes up less space.

This generic name is chosen because controllers don't cover the entire system. Currently there are also profiles for trackers, remotes and tracked pens. There are also provisions for devices such as treadmills, haptic vests and such even though those are not part of the specification yet.

It is important to know that OpenXR has strict checking on supported devices. The core specification identifies a number of controllers and similar devices with their supported inputs and outputs. Every XR runtime must accept these interaction profiles even if they aren't applicable.

New devices are added through extensions and XR runtimes must specify which ones they support. XR runtimes that do not support a device added through extensions will not accept these profiles. XR runtimes that do not support added input or output types will often crash if supplied.

As such Godot keeps meta data of all available devices, their inputs and outputs and which extension adds support for them. You can create interaction profiles for all devices you wish to support. Godot will filter out those not supported by the XR runtime the user is using.

This does mean that in order to support new devices, you might need to update to a more recent version of Godot.

It is however also important to note that the action map has been designed with this in mind. When new devices enter the market, or when your users use devices that you do not have access to, the action map system relies on the XR runtime. It is the XR runtime's job to choose the best fitting interaction profile that has been specified and adapt it for the controller the user is using.

How the XR runtime does this is left to the implementation of the runtime and there are thus vast differences between the runtimes. Some runtimes might even permit users to edit the bindings themselves.

A common approach for a runtime is to look for a matching interaction profile first. If this is not found it will check the most common profiles such as that of the "Touch controller" and do a conversion. If all else fails, it will check the generic "Simple controller".

There is an important conclusion to be made here: When a controller is found, and the action map is applied to it, the XR runtime is not limited to the exact configurations you set up in Godot's action map editor. While the runtime will generally choose a suitable mapping based on one of the bindings you set up in the action map, it can deviate from it.

For example, when the Touch controller profile is used any of the following scenarios could be true:

we could be using a Quest 1 controller,

we could be using a Quest 2 controller,

we could be using a Quest Pro controller but no Quest Pro profile was given or the XR runtime being used does not support the Quest Pro controller,

it could be a completely different controller for which no profile was given but the XR runtime is using the touch bindings as a base.

Ergo, there currently is no way to know with certainty, which controller the user is actually using.

Finally, and this trips up a lot of people, the bindings aren't set in stone. It is fully allowed, and even expected, that an XR runtime allows a user to customise the bindings.

At the moment none of the XR runtimes offer this functionality though SteamVR has an existing UI from OpenVRs action map system that is still accessible. This is actively being worked on however.

Let's set up our first controller binding, using the Touch controller as an example.

Press "Add profile", find the Touch controller, and add it. If it is not in the list, then it may already have been added.

Our UI now shows panels for both the left and right controllers. The panels contain all of the possible inputs and outputs for each controller. We can use the + next to each entry to bind it to an action:

Let's finish our configuration:

Each action is bound the given input or output for both controllers to indicate that we support the action on either controller. The exception is the movement action which is bound only to the right hand controller. It is likely that we would want to use the left hand thumbstick for a different purpose, say a teleport function.

In developing your game/application you have to account for the possibility that the user changes the binding and binds the movement to the left hand thumbstick.

Also note that our shoot and grab boolean actions are linked to inputs of type Float. As mentioned before OpenXR will do conversions between the two, but do read the warning given on that subject earlier in this document.

Some of the inputs seem to appear in our list multiple times.

For instance we can find the X button twice, once as X click and then as X touch. This is due to the Touch controller having a capacitive sensor.

X touch will be true if the user is merely touching the X button.

X click will be true when the user is actually pressing down on the button.

Similarly for the thumbstick we have:

Thumbstick touch which will be true if the user is touching the thumbstick.

Thumbstick which gives a value for the direction the thumbstick is pushed to.

Thumbstick click which is true when the user is pressing down on the thumbstick.

It is important to note that only a select number of XR controllers support touch sensors or have click features on thumbsticks. Keep that in mind when designing your game/application. Make sure these are used for optional features of your game/application.

The "Simple controller" is a generic controller that OpenXR offers as a fallback. We'll apply our mapping:

As becomes painfully clear, the simple controller is often far too simple and falls short for anything but the simplest of VR games/applications.

This is why many XR runtimes only use it as a last resort and will attempt to use bindings from one of the more popular systems as a fallback first.

Due to the simple controller likely not covering the needs of your game, it is tempting to provide bindings for every controller supported by OpenXR. The default action map seems to suggest this as a valid course of action. As mentioned before, the default action map was designed for ease of migration from Godot 3.

It is the recommendation from the OpenXR Working Group that only bindings for controllers actually tested by the developer are setup. The XR runtimes are designed with this in mind. They can perform a better job of rebinding a provided binding than a developer can make educated guesses. Especially as the developer can't test if this leads to a comfortable experience for the end user.

This is our advice as well: limit your action map to the interaction profiles for devices you have actually tested your game with. The Oculus Touch controller is widely used as a fallback controller by many runtimes. If you are able to test your game using a Meta Rift or Quest and add this profile there is a high probability your game will work with other headsets.

One of the main goals of the action map is to remove the need for the application to know the hardware used. However, sometimes the hardware has physical differences that require inputs to be altered in ways other than how they are bound to actions. This need ranges from setting thresholds, to altering the inputs available on a controller.

Binding modifiers are not enabled by default and require enabling in the OpenXR project settings. Also there is no guarantee that these modifiers are supported by every runtime. You will need to consult the support for the runtimes you are targeting and decide whether to rely on the modifiers or implement some form of fallback mechanism.

If you are targeting multiple runtimes that have support for the same controllers, you may need to create separate action maps for each runtime. You can control which action map Godot uses by using different export templates for each runtime and using a custom feature tag to set the action map.

In Godot, binding modifiers are divided into two groups: modifiers that work on the interaction profile level, and modifiers that work on individual bindings.

Binding modifiers that are applied to the whole interaction profile can be accessed through the modifier button on the right side of the interaction profile editor.

You can add a new modifier by pressing the Add binding modifier button.

As Godot doesn't know which controllers and runtimes support a modifier, there is no restriction to adding modifiers. Unsupported modifiers will be ignored.

The dpad binding modifier adds new inputs to an interaction profile for each joystick and thumbpad input on this controller. It turns the input into a dpad with separate up, down, left and right inputs that are exposed as buttons:

Inputs related to extensions are denoted with an asterix.

In order to use the dpad binding modifier you need to enable the dpad binding modifier extension in project settings:

Enabling the extension is enough to make this functionality work using default settings.

Adding the modifier is optional and allows you to fine tune the way the dpad functionality behaves. You can add the modifier multiple times to set different settings for different inputs.

These settings are used as follows:

Action Set defines the action set to which these settings are applied.

Input Path defines the original input that is mapped to the new dpad inputs.

Threshold specifies the threshold value that will enable a dpad action, e.g. a value of 0.6 means that if the distance from center goes above 0.6 the dpad action is pressed.

Threshold Released specifies the threshold value that will disable a dpad action, e.g. a value of 0.4 means that if the distance from center goes below 0.4 the dpad action is released.

Center Region specifies the distance from center that enabled the center action, this is only supported for trackpads.

Wedge Angle specifies the angle of each wedge. A value of 90 degrees or lower means that up, down, left and right each have a separate slice in which they are in the pressed state. A value above 90 degrees means that the slices overlap and that multiple actions can be in the pressed state.

Is Sticky, when enabled means that an action stays in the pressed state until the thumbstick or trackpad moves into another wedge even if it has left the wedge for that action.

On Haptic lets us define a haptic output that is automatically activated when an action becomes pressed.

Off Haptic lets us define a haptic output that is automatically activated when an action is released.

Binding modifiers that are applied to individual bindings can be accessed through the binding modifier button next to action attached to an input:

You can add a new modifier by pressing the Add binding modifier button.

As Godot doesn't know which inputs on each runtime support a modifier, there is no restriction to adding modifiers. If the modifier extension is unsupported, modifiers will be filtered out at runtime. Modifiers added to the wrong input may result in a runtime error.

You should test your action map on the actual hardware and runtime to verify the proper setup.

The analog threshold modifier allows you to specify the thresholds used for any analog input, like the trigger, that has a boolean input. This controls when the input is in the pressed state.

In order to use this modifier you must enable the analog threshold extension in the project settings:

The analog threshold modifier has the following settings:

These are defined as follows:

On Threshold specifies the threshold value that will enable the action, e.g. a value of 0.6 means that when the analog value gets above 0.6 the action is set to the pressed state.

Off Threshold specifies the threshold value that will disable the action, e.g. a value of 0.4 means that when the analog value goes below 0.4 the action is set in to the released state.

On Haptic lets us define a haptic output that is automatically activated when the input is pressed.

Off Haptic lets us define a haptic output that is automatically activated when the input is released.

Modifiers can support automatic haptic output that is triggered when thresholds are reached.

Currently both available modifiers support this feature however there is no rule future modifiers also have this capability. Only one type of haptic feedback is supported but in the future other options may become available.

The haptic vibration allows us to specify a simple haptic pulse:

It has the following options:

Duration is the duration of the pulse in nanoseconds. -1 lets the runtime choose an optimal value for a short pulse suitable for the current hardware.

Frequency is the frequency of the pulse in Hz. 0 lets the runtime choose an optimal frequency for a short pulse suitable for the current hardware.

Amplitude is the amplitude of the pulse.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## TLS/SSL certificates — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/networking/ssl_certificates.html

**Contents:**
- TLS/SSL certificates
- Introduction
- Obtain a certificate from a certificate authority
- Generate a self-signed certificate
- User-contributed notes

It is often desired to use TLS connections (also known as SSL connections) for communications to avoid "man in the middle" attacks. Godot has a connection wrapper, StreamPeerTLS, which can take a regular connection and add security around it. The HTTPClient and HTTPRequest classes also support HTTPS using this same wrapper.

Godot will try to use the TLS certificate bundle provided by the operating system, but also includes the TLS certificate bundle from Mozilla as a fallback.

You can alternatively force your own certificate bundle in the Project Settings:

Setting the TLS certificate bundle override project setting

When set, this file overrides the operating system provided bundle by default. This file should contain any number of public certificates in PEM format.

There are two ways to obtain certificates:

The main approach to getting a certificate is to use a certificate authority (CA) such as Let's Encrypt. This is a more cumbersome process than a self-signed certificate, but it's more "official" and ensures your identity is clearly represented. The resulting certificate is also trusted by applications such as web browsers, unlike a self-signed certificate which requires additional configuration on the client side before it's considered trusted.

These certificates do not require any configuration on the client to work, since Godot already bundles the Mozilla certificate bundle in the editor and exported projects.

For most use cases, it's recommended to go through certificate authority as the process is free with certificate authorities such as Let's Encrypt. However, if using a certificate authority is not an option, then you can generate a self-signed certificate and tell the client to consider your self-signed certificate as trusted.

To create a self-signed certificate, generate a private and public key pair and add the public key (in PEM format) to the CRT file specified in the Project Settings.

The private key should only go to your server. The client must not have access to it: otherwise, the security of the certificate will be compromised.

When specifying a self-signed certificate as TLS bundle in the project settings, normal domain name validation is enforced via the certificate CN and alternative names. See TLSOptions to customize domain name validation.

For development purposes Godot can generate self-signed certificates via Crypto.generate_self_signed_certificate.

Alternatively, OpenSSL has some documentation about generating keys and certificates.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Troubleshooting — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/troubleshooting.html

**Contents:**
- Troubleshooting
- The editor runs slowly and uses all my CPU and GPU resources, making my computer noisy
- The editor stutters and flickers on my variable refresh rate monitor (G-Sync/FreeSync)
- The editor or project takes a very long time to start
- The Godot editor appears frozen after clicking the system console
- The Godot editor's macOS dock icon gets duplicated every time it is manually moved
- Some text such as "NO DC" appears in the top-left corner of the Project Manager and editor window
- A microphone or "refresh" icon appears in the bottom-right corner of the Project Manager and editor window
- The editor or project appears overly sharp or blurry
- The editor or project appears to have washed out colors

This page lists common issues encountered when using Godot and possible solutions.

See Using the Web editor for caveats specific to the Web version of the Godot editor.

This is a known issue, especially on macOS since most Macs have Retina displays. Due to Retina displays' higher pixel density, everything has to be rendered at a higher resolution. This increases the load on the GPU and decreases perceived performance.

There are several ways to improve performance and battery life:

In 3D, click the Perspective button in the top left corner and enable Half Resolution. The 3D viewport will now be rendered at half resolution, which can be up to 4 times faster.

Open the Editor Settings and increase the value of Low Processor Mode Sleep (µsec) to 33000 (30 FPS). This value determines the amount of microseconds between frames to render. Higher values will make the editor feel less reactive, but will help decrease CPU and GPU usage significantly.

If you have a node that causes the editor to redraw continuously (such as particles), hide it and show it using a script in the _ready() method. This way, it will be hidden in the editor, but will still be visible in the running project.

This is a known issue. Variable refresh rate monitors need to adjust their gamma curves continuously to emit a consistent amount of light over time. This can cause flicker to appear in dark areas of the image when the refresh rate varies a lot, which occurs as the Godot editor only redraws when necessary.

There are several workarounds for this:

Enable Interface > Editor > Update Continuously in the Editor Settings. Keep in mind this will increase power usage and heat/noise emissions since the editor will now be rendering constantly, even if nothing has changed on screen. To alleviate this, you can increase Low Processor Mode Sleep (µsec) to 33000 (30 FPS) in the Editor Settings. This value determines the amount of microseconds between frames to render. Higher values will make the editor feel less reactive, but will help decrease CPU and GPU usage significantly.

Alternatively, disable variable refresh rate on your monitor or in the graphics driver.

VRR flicker can be reduced on some displays using the VRR Control or Fine Tune Dark Areas options in your monitor's OSD. These options may increase input lag or result in crushed blacks.

If using an OLED display, use the Black (OLED) editor theme preset in the Editor Settings. This hides VRR flicker thanks to OLED's perfect black levels.

When using one of the Vulkan-based renderers (Forward+ or Mobile), the first startup is expected to be relatively long. This is because shaders need to be compiled before they can be cached. Shaders also need to be cached again after updating Godot, after updating graphics drivers or after switching graphics cards.

If the issue persists after the first startup, this is a known bug on Windows when you have specific USB peripherals connected. In particular, Corsair's iCUE software seems to cause this bug. Try updating your USB peripherals' drivers to their latest version. If the bug persists, you need to disconnect the specific peripheral before opening the editor. You can then connect the peripheral again.

Firewall software such as Portmaster may also cause the debug port to be blocked. This causes the project to take a long time to start, while being unable to use debugging features in the editor (such as viewing print() output). You can work this around by changing the debug port used by the project in the Editor Settings (Network > Debug > Remote Port). The default is 6007; try another value that is greater than 1024, such as 7007.

On Windows, when loading the project for the first time after the PC is turned on, Windows Defender will cause the filesystem cache validation on project startup to take significantly longer. This is especially noticeable in projects with a large number of files. Consinder adding the project folder to the list of exclusions by going to Virus & threat protection > Virus & threat protection settings > Add or remove exclusions.

When running Godot on Windows with the system console enabled, you can accidentally enable selection mode by clicking inside the command window. This Windows-specific behavior pauses the application to let you select text inside the system console. Godot cannot override this system-specific behavior.

To solve this, select the system console window and press Enter to leave selection mode.

If you open the Godot editor and manually change the position of the dock icon, then restart the editor, you will get a duplicate dock icon all the way to the right of the dock.

This is due to a design limitation of the macOS dock. The only known way to resolve this would be to merge the project manager and editor into a single process, which means the project manager would no longer spawn a separate process when starting the editor. While using a single process instance would bring several benefits, it isn't planned to be done in the near future due to the complexity of the task.

To avoid this issue, keep the Godot editor's dock icon at its default location as created by macOS.

This is caused by the NVIDIA graphics driver injecting an overlay to display information.

To disable this overlay on Windows, restore your graphics driver settings to the default values in the NVIDIA Control Panel.

To disable this overlay on Linux, open nvidia-settings, go to X Screen 0 > OpenGL Settings then uncheck Enable Graphics API Visual Indicator.

This is caused by the NVIDIA graphics driver injecting an overlay to display instant replay information on ShadowPlay recording. This overlay can only be seen on Windows, as Linux does not have support for ShadowPlay.

To disable this overlay, press Alt + Z (default shortcut for the NVIDIA overlay) and disable Settings > HUD Layout > Status Indicator in the NVIDIA overlay.

Alternatively, you can install the new NVIDIA app <https://www.nvidia.com/en-us/software/nvidia-app/> which replaces GeForce Experience and does not suffer from this issue. Unlike GeForce Experience, the NVIDIA app draws the replay indicator in the corner of the screen as opposed to the corner of each window.

Correct appearance (left), oversharpened appearance due to graphics driver sharpening (right)

If the editor or project appears overly sharp, this is likely due to image sharpening being forced on all Vulkan or OpenGL applications by your graphics driver. You can disable this behavior in the graphics driver's control panel:

NVIDIA (Windows): Open the start menu and choose NVIDIA Control Panel. Open the Manage 3D settings tab on the left. In the list in the middle, scroll to Image Sharpening and set it to Sharpening Off.

AMD (Windows): Open the start menu and choose AMD Software. Click the settings "cog" icon in the top-right corner. Go to the Graphics tab then disable Radeon Image Sharpening.

If the editor or project appears overly blurry, this is likely due to FXAA being forced on all Vulkan or OpenGL applications by your graphics driver.

NVIDIA (Windows): Open the start menu and choose NVIDIA Control Panel. Open the Manage 3D settings tab on the left. In the list in the middle, scroll to Fast Approximate Antialiasing and set it to Application Controlled.

NVIDIA (Linux): Open the applications menu and choose NVIDIA X Server Settings. Select to Antialiasing Settings on the left, then uncheck Enable FXAA.

AMD (Windows): Open the start menu and choose AMD Software. Click the settings "cog" icon in the top-right corner. Go to the Graphics tab, scroll to the bottom and click Advanced to unfold its settings. Disable Morphological Antialiasing.

Third-party vendor-independent utilities such as vkBasalt may also force sharpening or FXAA on all Vulkan applications. You may want to check their configuration as well.

After changing options in the graphics driver or third-party utilities, restart Godot to make the changes effective.

If you still wish to force sharpening or FXAA on other applications, it's recommended to do so on a per-application basis using the application profiles system provided by graphics drivers' control panels.

On Windows, this is usually caused by incorrect OS or monitor settings, as Godot currently does not support HDR output (even though it may internally render in HDR).

As most displays are not designed to display SDR content in HDR mode, it is recommended to disable HDR in the Windows settings when not running applications that use HDR output. On Windows 11, this can be done by pressing Windows + Alt + B (this shortcut is part of the Xbox Game Bar app). To toggle HDR automatically based on applications currently running, you can use AutoActions.

If you insist on leaving HDR enabled, it is possible to somewhat improve the result by ensuring the display is configured to use HGIG tonemapping (as opposed to DTM), then using the Windows HDR calibration app. It is also strongly recommended to use Windows 11 instead of Windows 10 when using HDR. The end result will still likely be inferior to disabling HDR on the display, though.

Support for HDR output is planned in a future release.

This is a known issue on Linux with NVIDIA graphics when using the proprietary driver. There is no definitive fix yet, as suspend on Linux + NVIDIA is often buggy when OpenGL or Vulkan is involved. The Compatibility rendering method (which uses OpenGL) is generally less prone to suspend-related issues compared to the Forward+ and Mobile renderers (which use Vulkan).

The NVIDIA driver offers an experimental option to preserve video memory after suspend which may resolve this issue. This option has been reported to work better with more recent NVIDIA driver versions.

To avoid losing work, save scenes in the editor before putting the PC to sleep.

This is usually caused by forgetting to specify a filter for non-resource files in the Export dialog. By default, Godot will only include actual resources into the PCK file. Some files commonly used, such as JSON files, are not considered resources. For example, if you load test.json in the exported project, you need to specify *.json in the non-resource export filter. See Resource options for more information.

Also, note that files and folders whose names begin with a period will never be included in the exported project. This is done to prevent version control folders like .git from being included in the exported PCK file.

On Windows, this can also be due to case sensitivity issues. If you reference a resource in your script with a different case than on the filesystem, loading will fail once you export the project. This is because the virtual PCK filesystem is case-sensitive, while Windows's filesystem is case-insensitive by default.

This could be caused by a number of things such as an editor plugin, GDExtension addon, or something else. In this scenario it's recommended that you open the project in recovery mode, and attempt to find and fix whatever is causing the crashes. See the Project Manager page for more information.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## TSCN file format — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/file_formats/tscn.html

**Contents:**
- TSCN file format
- File structure
  - Entries inside the file
- The scene tree
  - NodePath
  - Skeleton3D
  - BoneAttachment3D
  - AnimationPlayer
- Resources
  - External resources

The TSCN (text scene) file format represents a single scene tree inside Godot. Unlike binary SCN files, TSCN files have the advantage of being mostly human-readable and easy for version control systems to manage.

The ESCN (exported scene) file format is identical to the TSCN file format, but is used to indicate to Godot that the file has been exported from another program and should not be edited by the user from within Godot. Unlike SCN and TSCN files, during import, ESCN files are compiled to binary SCN files stored inside the .godot/imported/ folder. This reduces the data size and speeds up loading, as binary formats are faster to load compared to text-based formats.

To make files more compact, properties equal to the default value are not stored in scene/resource files. It is possible to write them manually, but they will be discarded when saving the file.

For those looking for a complete description, the parsing is handled in the file resource_format_text.cpp in the ResourceFormatLoaderText class.

The scene and resource file formats have changed significantly in Godot 4, with the introduction of string-based UIDs to replace incremental integer IDs.

Mesh, skeleton and animation data is also stored differently compared to Godot 3. You can read about some of the changes in this article: Animation data rework for 4.0

Scenes and resources saved with Godot 4.x contain format=3 in their header, whereas Godot 3.x uses format=2 instead.

There are five main sections inside the TSCN file:

The file descriptor looks like [gd_scene load_steps=4 format=3 uid="uid://cecaux1sm7mo0"] and should be the first entry in the file. The load_steps parameter is equal to the total amount of resources (internal and external) plus one (for the file itself). If the file has no resources, load_steps is omitted. The engine will still load the file correctly if load_steps is incorrect, but this will affect loading bars and any other piece of code relying on that value.

uid is a unique string-based identifier representing the scene. This is used by the engine to track files that are moved around, even while the editor is closed. Scripts can also load UID-based resources using the uid:// path prefix to avoid relying on filesystem paths. This makes it possible to move around a file in the project, but still be able to load it in scripts without having to modify the script. Godot does not use external files to keep track of IDs, which means no central metadata storage location is required within the project. See this pull request for detailed information.

These sections should appear in order, but it can be hard to distinguish them. The only difference between them is the first element in the heading for all of the items in the section. For example, the heading of all external resources should start with [ext_resource ...].

A TSCN file may contain single-line comments starting with a semicolon (;). However, comments will be discarded when saving the file using the Godot editor. Whitespace within a TSCN file is not significant (except within strings), but extraneous whitespace will be discarded when saving the file.

A heading looks like [<resource_type> key1=value1 key2=value2 key3=value3 ...] where resource_type is one of:

Below every heading comes zero or more key = value pairs. The values can be complex datatypes such as Arrays, Transforms, Colors, and so on. For example, a Node3D looks like:

The scene tree is made up of… nodes! The heading of each node consists of its name, parent and (most of the time) a type. For example: [node name="PlayerCamera" type="Camera" parent="Player/Head"]

Other valid keywords include:

index (sets the order of appearance in the tree; if absent, inherited nodes will take precedence over plain ones)

The first node in the file, which is also the scene root, must not have a parent="Path/To/Node" entry in its heading. All scene files should have exactly one scene root. If it doesn't, Godot will fail to import the file. The parent path of other nodes should be absolute, but shouldn't contain the scene root's name. If the node is a direct child of the scene root, the path should be ".". Here is an example scene tree (but without any node content):

To make the file structure easier to grasp, you can save a file with any given node or resource and then inspect it yourself in an external editor. You can also make incremental changes in the Godot editor, and keep an external text editor open on the .tscn or .tres file with auto-reload enabled to see what changes.

Here is an example of a scene containing a RigidBody3D-based ball with collision, visuals (mesh + light) and a camera parented to the RigidBody3D:

A tree structure is not enough to represent the whole scene. Godot uses a NodePath(Path/To/Node) structure to refer to another node or attribute of the node anywhere in the scene tree. Paths are relative to the current node, with NodePath(".") pointing to the current node and NodePath("") pointing to no node at all.

For instance, MeshInstance3D uses NodePath() to point to its skeleton. Likewise, Animation tracks use NodePath() to point to node properties to animate.

NodePath can also point to a property using a :property_name suffix, and even point to a specific component for vector, transform and color types. This is used by Animation resources to point to specific properties to animate. For example, NodePath("MeshInstance3D:scale.x") points to the x component of the scale Vector3 property in MeshInstance3D.

For example, the skeleton property in the MeshInstance3D node called mesh points to its parent, Armature01:

The Skeleton3D node inherits the Node3D node, but may also have a list of bones described in key-value pairs in the format bones/<id>/<attribute> = value. The bone attributes consist of:

These attributes are all optional. For instance, a bone may only define position or rotation without defining the other properties.

Here's an example of a skeleton node with two bones:

The BoneAttachment3D node is an intermediate node to describe some node being parented to a single bone in a Skeleton node. The BoneAttachment has a bone_name = "name of bone" property, as well as a property for the matching bone index.

An example of a Marker3D node parented to a bone in Skeleton:

The AnimationPlayer node works with one or more animation libraries stored in AnimationLibrary resources. An animation library is a collection of individual Animation resources, whose structure is documented here.

This split between animations themselves and animation libraries was done in Godot 4, so that animations can be imported separately from 3D meshes, which is a common workflow in 3D animation software. See the original pull request for details.

If the library name is empty, then it acts acts the unique source of animations for this AnimationPlayer. This allows using <animation_name> directly to play animations from script. If you name the library, then you must play it as <library_name>/<animation_name>. This ensures backwards compatibility and keeps the existing workflow if you don't want to use multiple animation libraries.

Resources are components that make up the nodes. For example, a MeshInstance3D node will have an accompanying ArrayMesh resource. The ArrayMesh resource may be either internal or external to the TSCN file.

References to the resources are handled by unique string-based IDs in the resource's heading. This is different from the uid property, which each external resource also has (but subresources don't).

External resources and internal resources are referred to with ExtResource("id") and SubResource("id"), respectively. Because there have different methods to refer to internal and external resources, you can have the same ID for both an internal and external resource.

For example, to refer to the resource [ext_resource type="Material" uid="uid://c4cp0al3ljsjv" path="res://material.tres" id="1_7bt6s"], you would use ExtResource("1_7bt6s").

External resources are links to resources not contained within the TSCN file itself. An external resource consists of a path, a type, a UID (used to map its filesystem location to a unique identifier) and an ID (used to refer to the resource in the scene file).

Godot always generates absolute paths relative to the resource directory and thus prefixed with res://, but paths relative to the TSCN file's location are also valid.

Some example external resources are:

Like TSCN files, a TRES file may contain single-line comments starting with a semicolon (;). However, comments will be discarded when saving the resource using the Godot editor. Whitespace within a TRES file is not significant (except within strings), but extraneous whitespace will be discarded when saving the file.

A TSCN file can contain meshes, materials and other data. These are contained in the internal resources section of the file. The heading for an internal resource looks similar to those of external resources, except that it doesn't have a path. Internal resources also have key=value pairs under each heading. For example, a capsule collision shape looks like:

Some internal resources contain links to other internal resources (such as a mesh having a material). In this case, the referring resource must appear before the reference to it. This means that order matters in the file's internal resources section.

An ArrayMesh consists of several surfaces contained in the _surfaces array (notice the leading underscore). Each surface's data is stored in a dictionary with the following keys:

aabb: The computed axis-aligned bounding box for visibility.

attribute_data: Vertex attribute data, such as normals, tangents, vertex colors, UV1, UV2 and custom vertex data.

bone_aabbs: The axis-aligned bounding box of each bone for visibility.

format: The surface's buffer format.

index_count: The number of indices in the surface. This must match index_data's size.

index_data: The index data, which determines which vertices from vertex_data are drawn.

lods: Level of detail variations, stored as an array. Each LOD level represents two values in the array. The first value is the percentage of screen space the LOD level is most suited for (edge length); the second value is the list of indices that should be drawn for the given LOD level.

material: The material used when drawing the surface.

name: The surface's name. This can be used in scripts and is imported from 3D DCCs.

primitive: The surface's primitive type, matching the Mesh.PrimitiveType Godot enum. 0 = points, 1 = lines, 2 = line strip, 3 = triangles (most common), 4 = triangle strip.

skin_data: Bone weight data.

vertex_count: Number of vertices in the surface. This must match vertex_data's size.

vertex_data: The vertex position data.

Here's an example of an ArrayMesh saved to its own .tres file. Some fields were shortened with ... for brevity:

Each animation has the following properties:

length: The animation's length in seconds. Note that keyframes may be placed outside the [0; length] interval, but they may have no effect depending on the interpolation mode chosen.

loop_mode: 0 = no looping, 1 = wrap-around looping, 2 = clamped looping.

step: The step size to use when editing this animation in the editor. This is only used in the editor; it doesn't affect animation playback in any way.

Each track is described by a list of key-value pairs in the format tracks/<id>/<attribute>. Each track includes:

type: The track's type. This defines what kind of properties may be animated by this track, and how it'll be exposed to the user in the editor. Valid types are value (generic property track), position_3d, rotation_3d, scale_3d, blend_shape (optimized 3D animation tracks), method (method call tracks), bezier (Bezier curve tracks), audio (audio playback tracks), animation (tracks that play other animations).

imported: true if the track was created from an imported 3D scene, false if it was manually created by the user in the Godot editor or using a script.

enabled: true if the track is effective, false if it was disabled in the editor.

path: Path to the node property that will be affected by the track. The property is written after the node path with a : separator.

interp: The interpolation mode to use. 0 = nearest, 1 = linear, 2 = cubic, 3 = linear angle, 4 = cubic angle.

loop_wrap: true if the track is designed to wrap around when the animation is looping, false if the track clamps to the first/last keyframes.

keys: The animation track's values. This attribute's structure depends on the type.

Here is a scene containing an AnimationPlayer that scales down a cube over time using a generic property track. The AnimationLibrary workflow was not used, so the animation library has an empty name (but the animation is still given a scale_down name). Note that the RESET track was not created in this AnimationPlayer for brevity:

For generic property value tracks, keys is a dictionary containing 3 arrays with positions in times (PackedFloat32Array), easing values in transitions (PackedFloat32Array) and values in values (Array). There is an additional update property, which is an integer with the values 0 = continuous, 1 = discrete, 2 = capture.

Here is a second Animation resource that makes use of the 3D Position and 3D Rotation tracks. These tracks (in addition to the 3D Scale track) replace Transform tracks from Godot 3. They are optimized for fast playback and can optionally be compressed.

The downside of these optimized track types is that they can't use custom easing values. Instead, all keyframes use linear interpolation. That said, you can still opt for using nearest or cubic interpolation for all keyframes in a given track by changing the track's interpolation mode.

For 3D position, rotation and scale tracks, keys is a PackedFloat32Array with all values stored in a sequence.

In the visual guide below, T is the keyframe's time in seconds since the start of the animation, E is the keyframe's transition (currently always 1). For 3D position and scale tracks, X, Y, Z are the Vector3's coordinates. For 3D rotation tracks, X, Y, Z and W are the Quaternion's coordinates.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
[node name="Cube" type="Node3D"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 2, 3)
```

Example 2 (unknown):
```unknown
[node name="Player" type="Node3D"]                    ; The scene root
[node name="Arm" type="Node3D" parent="."]            ; Parented to the scene root
[node name="Hand" type="Node3D" parent="Arm"]         ; Child of "Arm"
[node name="Finger" type="Node3D" parent="Arm/Hand"]  ; Child of "Hand"
```

Example 3 (unknown):
```unknown
[gd_scene load_steps=4 format=3 uid="uid://cecaux1sm7mo0"]

[sub_resource type="SphereShape3D" id="SphereShape3D_tj6p1"]

[sub_resource type="SphereMesh" id="SphereMesh_4w3ye"]

[sub_resource type="StandardMaterial3D" id="StandardMaterial3D_k54se"]
albedo_color = Color(1, 0.639216, 0.309804, 1)

[node name="Ball" type="RigidBody3D"]

[node name="CollisionShape3D" type="CollisionShape3D" parent="."]
shape = SubResource("SphereShape3D_tj6p1")

[node name="MeshInstance3D" type="MeshInstance3D" parent="."]
mesh = SubResource("SphereMesh_4w3ye")
surface_material_override/0 = SubResource("StandardMaterial3D_k54se")

[node name="OmniLight3D" type="OmniLight3D" parent="."]
light_color = Color(1, 0.698039, 0.321569, 1)
omni_range = 10.0

[node name="Camera3D" type="Camera3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 0.939693, 0.34202, 0, -0.34202, 0.939693, 0, 1, 3)
```

Example 4 (unknown):
```unknown
[node name="mesh" type="MeshInstance3D" parent="Armature01"]
skeleton = NodePath("..")
```

---

## Tutorials and resources — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/community/tutorials.html

**Contents:**
- Tutorials and resources
- Where to start
- Video tutorials
- Text tutorials
- Resources
- User-contributed notes

This is a list of third-party tutorials and resources created by the Godot community. For resources, remember that there is the official Godot Asset Library full of official and community resources too!

Think there is something missing here? Feel free to submit a Pull Request as always.

The Godot video tutorials by GDQuest are well-regarded in the community and often recommended as a gentle introduction to beginners.

GDQuest's Learn GDScript From Zero is a free and open source interactive tutorial for absolute beginners to learn to program with Godot's GDScript language. It is available as a desktop application or in the browser.

Some tutorials mentioned below cover more advanced subjects, e.g. on 3D or shaders.

For video tutorials we recommend looking on YouTube. There are many great channels covering a wide array of subjects.

FinePointCGI website by Mitch

Catlike Coding by Jasper Flick

GDScript website by Andrew Wilkes

Godot Recipes by KidsCanCode

Godot Tutorials by SomethingLikeGames

GameDev Academy by Zenva

Game Dev Artisan website

Night Quest Games Blog

awesome-godot: A curated list of free/libre plugins, scripts and add-ons

Godot Shaders: A community-driven shader library

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Unit testing — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/architecture/unit_testing.html

**Contents:**
- Unit testing
- Platform and target support
- Running tests
  - Filtering tests
- Writing tests
  - Subcases
  - Assertions
  - Logging
  - Testing failure paths
  - Special tags in test case names

Godot Engine allows to write unit tests directly in C++. The engine integrates the doctest unit testing framework which gives ability to write test suites and test cases next to production code, but since the tests in Godot go through a different main entry point, the tests reside in a dedicated tests/ directory instead, which is located at the root of the engine source code.

C++ unit tests can be run on Linux, macOS, and Windows operating systems.

Tests can only be run with editor tools enabled, which means that export templates cannot be tested currently.

Before tests can be actually run, the engine must be compiled with the tests build option enabled (and any other build option you typically use), as the tests are not compiled as part of the engine by default:

Once the build is done, run the tests with a --test command-line option:

The test run can be configured with the various doctest-specific command-line options. To retrieve the full list of supported options, run the --test command with the --help option:

Any other options and arguments after the --test command are treated as arguments for doctest.

Tests are compiled automatically if you use the dev_mode=yes SCons option. dev_mode=yes is recommended if you plan on contributing to the engine development as it will automatically treat compilation warnings as errors. The continuous integration system will fail if any compilation warnings are detected, so you should strive to fix all warnings before opening a pull request.

By default, all tests are run if you don't supply any extra arguments after the --test command. But if you're writing new tests or would like to see the successful assertions output coming from those tests for debugging purposes, you can run the tests of interest with the various filtering options provided by doctest.

The wildcard syntax * is supported for matching any number of characters in test suites, test cases, and source file names:

For instance, to run only the String unit tests, run:

Successful assertions output can be enabled with the --success (-s) option, and can be combined with any combination of filtering options above, for instance:

Specific tests can be skipped with corresponding -exclude options. As of now, some tests include random stress tests which take a while to execute. In order to skip those kind of tests, run the following command:

Test suites represent C++ header files which must be included as part of the main test entry point in tests/test_main.cpp. Most test suites are located directly under tests/ directory.

All header files are prefixed with test_, and this is a naming convention which the Godot build system relies on to detect tests throughout the engine.

Here's a minimal working test suite with a single test case written:

You can quickly generate new tests using the create_test.py script found in the tests/ directory. This script automatically creates a new test file with the required boilerplate code in the appropriate location. It's also able to automatically include the new header in tests/test_main.cpp using invasive mode (-i flag). To view usage instructions, run the script with the -h flag.

The tests/test_macros.h header encapsulates everything which is needed for writing C++ unit tests in Godot. It includes doctest assertion and logging macros such as CHECK as seen above, and of course the definitions for writing test cases themselves.

tests/test_macros.h source code for currently implemented macros and aliases for them.

Test cases are created using TEST_CASE function-like macro. Each test case must have a brief description written in parentheses, optionally including custom tags which allow to filter the tests at runtime, such as [String], [Stress] etc.

Test cases are written in a dedicated namespace. This is not required, but allows to prevent naming collisions for when other static helper functions are written to accommodate the repeating testing procedures such as populating common test data for each test, or writing parameterized tests.

Godot supports writing tests per C++ module. For instructions on how to write module tests, refer to Writing custom unit tests.

In situations where you have a common setup for several test cases with only slight variations, subcases can be very helpful. Here's an example:

Each SUBCASE causes the TEST_CASE to be executed from the beginning. Subcases can be nested to an arbitrary depth, but it is advised to limit nesting to no more than one level deep.

A list of all commonly used assertions used throughout the Godot tests, sorted by severity.

Test if condition holds true. Fails the entire test immediately if the condition does not hold true.

Test if condition does not hold true. Fails the entire test immediately if the condition holds true.

Test if condition holds true. Marks the test run as failing, but allow to run other assertions.

Test if condition does not hold true. Marks the test run as failing, but allow to run other assertions.

Test if condition holds true. Does not fail the test under any circumstance, but logs a warning if something does not hold true.

Test if condition does not hold true. Does not fail the test under any circumstance, but logs a warning if something holds true.

All of the above assertions have corresponding *_MESSAGE macros, which allow to print optional message with rationale of what should happen.

Prefer to use CHECK for self-explanatory assertions and CHECK_MESSAGE for more complex ones if you think that it deserves a better explanation.

doctest: Assertion macros.

The test output is handled by doctest itself, and does not rely on Godot printing or logging functionality at all, so it's recommended to use dedicated macros which allow to log test output in a format written by doctest.

Marks the test as failing, but continue the execution. Can be wrapped in conditionals for complex checks.

Fails the test immediately. Can be wrapped in conditionals for complex checks.

Different reporters can be chosen at runtime. For instance, here's how the output can be redirected to an XML file:

doctest: Logging macros.

Sometimes, it's not always feasible to test for an expected result. With the Godot development philosophy of that the engine should not crash and should gracefully recover whenever a non-fatal error occurs, it's important to check that those failure paths are indeed safe to execute without crashing the engine.

Unexpected behavior can be tested in the same way as anything else. The only problem this creates is that the error printing shall unnecessarily pollute the test output with errors coming from the engine itself (even if the end result is successful).

To alleviate this problem, use ERR_PRINT_OFF and ERR_PRINT_ON macros directly within test cases to temporarily disable the error output coming from the engine, for instance:

These tags can be added to the test case name to modify or extend the test environment:

Required for test cases that rely on a scene tree with MessageQueue to be available. It also enables a mock rendering server and ThemeDB.

Like [SceneTree], but with additional editor-related infrastructure available, such as EditorSettings.

Initializes the AudioServer using a mock audio driver.

Creates the default 2D navigation server and makes it available for testing.

Creates the default 3D navigation server and makes it available for testing.

You can use them together to combine multiple test environment extensions.

The following macros can be use to test signals:

SIGNAL_WATCH(object, "signal_name")

Starts watching the specified signal on the given object.

SIGNAL_UNWATCH(object, "signal_name")

Stops watching the specified signal on the given object.

SIGNAL_CHECK("signal_name", Vector<Vector<Variant>>)

Checks the arguments of all fired signals. The outer vector contains each fired signal, while the inner vector contains the list of arguments for that signal. The order of signals is significant.

SIGNAL_CHECK_FALSE("signal_name")

Checks if the specified signal was not fired.

SIGNAL_DISCARD("signal_name")

Discards all records of the specified signal.

Below is an example demonstrating the use of these macros:

Test tools are advanced methods which allow you to run arbitrary procedures to facilitate the process of manual testing and debugging the engine internals.

These tools can be run by supplying the name of a tool after the --test command-line option. For instance, the GDScript module implements and registers several tools to help the debugging of the tokenizer, parser, and compiler:

If any such tool is detected, then the rest of the unit tests are skipped.

Test tools can be registered anywhere throughout the engine as the registering mechanism closely resembles of what doctest provides while registering test cases using dynamic initialization technique, but usually these can be registered at corresponding register_types.cpp sources (per module or core).

Here's an example of how GDScript registers test tools in modules/gdscript/register_types.cpp:

The custom command-line parsing can be performed by a test tool itself with the help of OS get_cmdline_args method.

Godot uses doctest to prevent regressions in GDScript during development. There are several types of test scripts which can be written:

tests for expected errors;

Therefore, the process of writing integration tests for GDScript is the following:

Pick a type of a test script you'd like to write, and create a new GDScript file under the modules/gdscript/tests/scripts directory within corresponding sub-directory.

Write GDScript code. The test script must have a function called test() which takes no arguments. Such function will be called by the test runner. The test should not have any dependency unless it's part of the test too. Global classes (using class_name) are registered before the runner starts, so those should work if needed.

Here's an example test script:

Change directory to the Godot source repository root.

Generate *.out files to update the expected results from the output:

You may add the --print-filenames option to see filenames as their test outputs are generated. If you are working on a new feature that is causing hard crashes, you can use this option to quickly find which test file causes the crash and debug from there.

Run GDScript tests with:

This also accepts the --print-filenames option (see above).

If no errors are printed and everything goes well, you're done!

Make sure the output does have the expected values before submitting a pull request. If --gdscript-generate-tests produces *.out files which are unrelated to newly added tests, you should revert those files back and only commit *.out files for new tests.

The GDScript test runner is meant for testing the GDScript implementation, not for testing user scripts nor testing the engine using scripts. We recommend writing new tests for already resolved issues related to GDScript at GitHub, or writing tests for currently working features.

If your test case requires that there is no test() function present inside the script file, you can disable the runtime section of the test by naming the script file so that it matches the pattern *.notest.gd. For example, "test_empty_file.notest.gd".

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
scons tests=yes
```

Example 2 (unknown):
```unknown
./bin/<godot_binary> --test
```

Example 3 (unknown):
```unknown
./bin/<godot_binary> --test --help
```

Example 4 (unknown):
```unknown
./bin/<godot_binary> --test --test-case="*[String]*"
```

---

## Upgrading from Godot 3 to Godot 4 — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/migrating/upgrading_to_godot_4.html

**Contents:**
- Upgrading from Godot 3 to Godot 4
- Should I upgrade to Godot 4?
  - Advantages of upgrading
  - Disadvantages of upgrading
  - Caveats of upgrading
- Preparing before the upgrade (optional)
- Running the project upgrade tool
  - Using the Project Manager
  - Using the command line
- Fixing the project after running the project upgrade tool

Before beginning the upgrade process, it's worth thinking about the advantages and disadvantages that upgrading would bring to your project.

Along with the new features present in 4.0, upgrading gives the following advantages:

Many bugs are fixed in 4.0, but cannot be resolved in 3.x for various reasons (such as graphics API differences or backwards compatibility).

4.x will enjoy a longer support period. Godot 3.x will continue to be supported for some time after 4.0 is released, but it will eventually stop receiving support.

See Documentation changelog for a list of pages documenting new features in Godot 4.0, and List of features for a list of all features in Godot.

If you don't need any features present in Godot 4.x, you may want to stay on Godot 3.x for the following reasons:

Godot 4's baseline hardware requirements (such as memory usage) are slightly higher, both for the editor and exported projects. This was required for the implementation of some core optimizations.

Since Godot 4 includes more features than Godot 3, Godot 4's binary size for exported projects is larger. While this can be mitigated by optimizing a build for size, a 4.0 build with a given set of enabled modules will remain larger compared to a 3.x build with the same modules. This can be an issue for exporting to the Web, as binary size directly influences how fast the engine can initialize (regardless of download speed).

Godot 4 does not and will not have support for GLES2 rendering. (There is still support for GLES3 rendering using the new Compatibility renderer, which means that devices without Vulkan support can still run Godot 4.)

If you are targeting very old hardware such as Intel Sandy Bridge (2nd generation) integrated graphics, this will prevent the project from running on such hardware after upgrading. Software OpenGL implementations can be used to bypass this limitation, but they're too slow for gaming.

Since Godot 4 is a complete rewrite in many aspects, some features have unfortunately been lost in the process. Some of these features may be restored in future Godot releases:

Bullet physics was removed in favor of GodotPhysics. This only affects 3D projects that used the default physics engine (which was Bullet) and didn't manually change it to GodotPhysics. There are no plans to re-add Bullet physics in core, but a third-party add-on could be created for it thanks to GDExtension.

By default, rendering in 2D is no longer performed in HDR, which means "overbright" modulate values have no visible effect. Since Godot 4.2, you can enable the project setting HDR 2D to perform 2D rendering in HDR. See also Using glow in 2D.

While rendering still happens in HDR in 3D when using the Forward+ or Mobile renderers, Viewports cannot return HDR data anymore. This is planned to be restored at some point in the future.

Mono was replaced by .NET 6. This means exporting C# projects to Android, iOS and HTML5 is no longer supported for now. Exporting C# projects to desktop platforms is still supported, and as of 4.2 there's experimental support for exporting to mobile platforms. Support for exporting C# projects to more platforms will be restored in future 4.x releases as upstream support improves.

You can find a more complete list of functional regressions by searching for issues labeled "regression" but not "bug" on GitHub.

If you want to be ready to upgrade to Godot 4 in the future, consider using Tweener and the Time singleton in your project. These classes are both available in Godot 3.5 and later.

This way, you won't be relying on the deprecated Tween node and OS time functions, both of which are removed in Godot 4.0.

It's also a good idea to rename external shaders so that their extension is .gdshader instead of .shader. Godot 3.x supports both extensions, but only .gdshader is supported in Godot 4.0.

Make a full backup of your project before upgrading! The project upgrade tool will not perform any backups of the project that is being upgraded.

You can backup a project by using version control, or by copying the project folder to another location.

To use the project upgrade tool:

Open the Godot 4 Project Manager.

Import the Godot 3.x project using the Import button, or use the Scan button to find the project within a folder.

Double-click the imported project (or select the project then choose Edit).

You will see a dialog appearing with two options: Convert project.godot Only and Convert Full Project. After ensuring your project is backed up (see the above warning), choose Convert Full Project. Convert project.godot Only is intended to be used for advanced use cases only, in case the conversion tool fails.

Wait until the project conversion process finishes. This can take up to a few minutes for large projects with lots of scenes.

When the Project Manager interface becomes available again, double-click the project (or select the project then choose Edit) to open it in the editor.

If you hit conversion issues due to some project files being too large or long, you can use the command line to upgrade the project (see below). This will allow you to override the converter's size limits.

To use the project upgrade tool from the command line, it's recommended to validate the project conversion by running the Godot editor binary with the following arguments:

If the list of planned upgrades looks good to you, run the following command on the Godot editor binary to upgrade project files:

[<max_file_kb>] and [<max_line_size>] are optional arguments to specify the maximum size of files to be converted (in kilobytes and lines). The default limits are 4 MB and 100,000 lines respectively. If a file hits either of those limits, it will not be upgraded by the project converter. This is useful to prevent large resources from slowing down the upgrade to a crawl.

If you still want large files to be converted by the project upgrade tool, increase the size limits when running the project upgrade tool. For example, running the Godot editor binary with those arguments increases both limits by a 10× factor:

Only Godot 3.0 and later projects can be upgraded using the project conversion tool found in the Godot 4 editor.

It's recommended to ensure that your project is up-to-date with the latest 3.x stable release before running the project upgrade tool.

After upgrading the project, you may notice that certain things don't look as they should. Scripts will likely contain various errors as well (possibly hundreds in large projects). This is because the project upgrade tool cannot cater to all situations. Therefore, a large part of the upgrade process remains manual.

The list below refers to nodes which were simply renamed for consistency or clarity in Godot 4.0. The project upgrade tool renames them automatically in your scripts.

One noteworthy set of renames is 3D nodes, which all got a 3D suffix added for consistency with their 2D counterparts. For example, Area is now Area3D.

For ease of searching, this table lists all nodes and resources that were renamed and are automatically converted, excluding the ones which only involved adding a 3D suffix to the old name:

ARVRPositionalTracker

EditorSpatialGizmoPlugin

EditorNode3DGizmoPlugin

NavigationMeshInstance

NavigationPolygonInstance

ParticleProcessMaterial

Physics2DDirectBodyState

PhysicsDirectBodyState2D

Physics2DDirectSpaceState

PhysicsDirectSpaceState2D

Physics2DShapeQueryParameters

PhysicsShapeQueryParameters2D

Physics2DTestMotionResult

PhysicsTestMotionResult2D

VisibleOnScreenEnabler3D

VisibleOnScreenNotifier3D

VisibleOnScreenNotifier2D

VisibleOnScreenNotifier3D

VisualShaderNodeScalarConstant

VisualShaderNodeFloatConstant

VisualShaderNodeScalarFunc

VisualShaderNodeFloatFunc

VisualShaderNodeScalarOp

VisualShaderNodeFloatOp

VisualShaderNodeScalarClamp

VisualShaderNodeClamp

VisualShaderNodeVectorClamp

VisualShaderNodeClamp

VisualShaderNodeScalarInterp

VisualShaderNodeVectorInterp

VisualShaderNodeVectorScalarMix

VisualShaderNodeScalarSmoothStep

VisualShaderNodeSmoothStep

VisualShaderNodeVectorSmoothStep

VisualShaderNodeSmoothStep

VisualShaderNodeVectorScalarSmoothStep

VisualShaderNodeSmoothStep

VisualShaderNodeVectorScalarStep

VisualShaderNodeScalarSwitch

VisualShaderNodeSwitch

VisualShaderNodeScalarTransformMult

VisualShaderNodeTransformOp

VisualShaderNodeScalarDerivativeFunc

VisualShaderNodeDerivativeFunc

VisualShaderNodeVectorDerivativeFunc

VisualShaderNodeDerivativeFunc

VisualShaderNodeBooleanUniform

VisualShaderNodeBooleanParameter

VisualShaderNodeColorUniform

VisualShaderNodeColorParameter

VisualShaderNodeScalarUniform

VisualShaderNodeFloatParameter

VisualShaderNodeCubeMapUniform

VisualShaderNodeCubeMapParameter

VisualShaderNodeTextureUniform

VisualShaderNodeTexture2DParameter

VisualShaderNodeTextureUniformTriplanar

VisualShaderNodeTextureParameterTriplanar

VisualShaderNodeTransformUniform

VisualShaderNodeTransformParameter

VisualShaderNodeVec3Uniform

VisualShaderNodeVec3Parameter

VisualShaderNodeUniform

VisualShaderNodeParameter

VisualShaderNodeUniformRef

VisualShaderNodeParameterRef

Due to how the project upgrade tool works, not all API renames can be performed automatically. The list below contains all renames that must be performed manually using the script editor.

If you cannot find a node or resource in the list below, refer to the above table to find its new name.

You can use the Replace in Files dialog to speed up replacement by pressing Ctrl + Shift + R while the script editor is open. However, be careful as the Replace in Files dialog doesn't offer any way to undo a replacement. Use version control to commit your upgrade work regularly. Command line tools such as sd can also be used if you need something more flexible than the editor's Replace in Files dialog.

If using C#, remember to search for outdated API usage with PascalCase notation in the project (and perform the replacement with PascalCase notation).

File and Directory classes were replaced by FileAccess and DirAccess, which have an entirely different API. Several methods are now static, which means you can call them directly on FileAccess or DirAccess without having to create an instance of that class.

Screen and window-related methods from the OS singleton (such as OS.get_screen_size()) were moved to the DisplayServer singleton. Method naming was also changed to use the DisplayServer.<object>_<get/set>_property() form instead. For example, OS.get_screen_size() becomes DisplayServer.screen_get_size().

Time and date methods from the OS singleton were moved to the Time singleton. (The Time singleton is also available in Godot 3.5 and later.)

You may have to replace some instance() calls with instantiate(). The converter should handle this automatically, but this relies on custom code that may not work in 100% of situations.

AcceptDialog's set_autowrap() is now set_autowrap_mode().

AnimationNode's process() is now _process() (note the leading underscore, which denotes a virtual method).

AnimationPlayer's add_animation() is now add_animation_library() and now uses an AnimationLibrary.

AnimationTree's set_process_mode() is now set_process_callback().

Array's empty() is now is_empty().

Array's invert() is now reverse().

Array's remove() is now remove_at().

AStar2D and AStar3D's get_points() is now get_points_id().

BaseButton's set_event() is now set_shortcut().

Camera2D's get_h_offset() is now get_drag_horizontal_offset().

Camera2D's get_v_offset() is now get_drag_vertical_offset().

Camera2D's set_h_offset() is now set_drag_horizontal_offset().

Camera2D's set_v_offset() is now set_drag_vertical_offset().

CanvasItem's raise() is now move_to_front().

CanvasItem's update() is now queue_redraw().

Control's get_stylebox() is now get_theme_stylebox().

Control's set_tooltip() is now set_tooltip_text().

EditorNode3DGizmoPlugin's create_gizmo() is now _create_gizmo() (note the leading underscore, which denotes a virtual method).

ENetMultiplayerPeer's get_peer_port() is now get_peer().

FileDialog's get_mode() is now get_file_mode().

FileDialog's set_mode() is now set_file_mode().

GraphNode's get_offset() is now get_position_offset().

GridMap's map_to_world() is now map_to_local().

GridMap's world_to_map() is now local_to_map().

Image's get_rect() is now get_region().

ImmediateGeometry's set_normal() is now surface_set_normal().

ImmediateMesh's set_color() is now surface_set_color().

ImmediateMesh's set_uv() is now surface_set_uv().

ItemList's get_v_scroll() is now get_v_scroll_bar().

MultiPlayerAPI's get_network_connected_peers() is now get_peers().

MultiPlayerAPI's get_network_peer() is now get_peer().

MultiPlayerAPI's get_network_unique_id() is now get_unique_id().

MultiPlayerAPI's has_network_peer() is now has_multiplayer_peer().

MultiplayerAPI's is_refusing_new_network_connections() is now is_refusing_new_connections().

PacketPeerUDP's is_listening() is now is_bound().

PacketPeerUDP's listen() is now bind().

ParticleProcessMaterial's set_flag() is now set_particle_flag().

PhysicsTestMotionResult2D's get_motion() is now get_travel().

RenderingServer's get_render_info() is now get_rendering_info().

ResourceFormatLoader's get_dependencies() is now _get_dependencies() (note the leading underscore, which denotes a virtual method).

ResourceFormatLoader's load() is now _load().

SceneTree's change_scene() is now change_scene_to_file().

Shortcut's is_valid() is now has_valid_event().

TileMap's map_to_world() is now map_to_local().

TileMap's world_to_map() is now local_to_map().

Transform2D's xform() is mat * vec and xform_inv() is vec * mat.

XRPositionalTracker's get_name() is now get_tracker_name().

XRPositionalTracker's get_type() is now get_tracker_type().

XRPositionalTracker's _set_name() is now get_tracker_name().

If a property is listed here, its associated getter and setter methods must also be renamed manually if used in the project. For example, PathFollow2D and PathFollow3D's set_offset() and get_offset() must be renamed to set_progress() and get_progress() respectively.

AudioServer's device is now output_device.

BaseButton's group is now button_group.

Camera3D's zfar is now far.

Camera3D's znear is now near

Control's margin is now offset.

InputEventMouseButton's doubleclick is now double_click.

InputEventWithModifiers's alt is now alt_pressed.

InputEventWithModifiers's command is now command_pressed.

InputEventWithModifiers's control is now ctrl_pressed.

InputEventWithModifiers's meta is now meta_pressed.

InputEventWithModifiers's shift is now shift_pressed.

Label's percent_visible is now visible_ratio.

MultiPlayerAPI's refuse_new_network_connections is now refuse_new_connections.

Node's filename is now scene_file_path.

PathFollow2D's rotate is now rotates.

PathFollow2D and PathFollow3D's offset is now progress.

RectangleShape2D's extents is now size

TextureProgressBar's percent_visible is now show_percentage.

Theme's off is now unchecked.

Theme's ofs is now offset.

Theme's on is now checked.

Window's window_title is now title.

WorldMarginShape2D's d is now distance.

The extents property on CSG nodes and VoxelGI will have to be replaced with size, with the set value halved (as they're no longer half-extents). This also affects its setter/getter methods set_extents() and get_extents().

The Engine.editor_hint property was removed in favor of the Engine.is_editor_hint() method. This is because it's read-only, and properties in Godot are not used for read-only values.

CPUParticles2D's FLAG_MAX is now PARTICLE_FLAG_MAX.

FileSystemDock's instantiate is now instance.

CanvasItem's hide is now hidden. This rename does not apply to the hide() method, only the signal.

Tween's tween_all_completed is now loop_finished.

EditorSettings' changed is now settings_changed.

Color names are now uppercase and use underscores between words. For example, Color.palegreen is now Color.PALE_GREEN.

MainLoop's NOTIFICATION_ constants were duplicated to Node which means you can remove the MainLoop. prefix when referencing them.

MainLoop's NOTIFICATION_WM_QUIT_REQUEST is now NOTIFICATION_WM_CLOSE_REQUEST.

Several project settings were renamed, and some of them had their enums changed in incompatible ways (such as shadow filter quality). This means you may need to set some project settings' values again. Make sure the Advanced toggle is enabled in the project settings dialog so you can see all project settings.

Graphics quality settings were moved from Environment properties to project settings. This was done to make runtime quality adjustments easier, without having to access the currently active Environment resource then modify its properties.

As a result, you will have to configure Environment quality settings in the project settings as old Environment quality settings aren't converted automatically to project settings.

If you have a graphics settings menu that changed environment properties in Godot 3.x, you will have to change its code to call RenderingServer methods that affect environment effects' quality. Only the "base" toggle of each environment effect and its visual knobs remain within the Environment resource.

There have been some changes to shaders that aren't covered by the upgrade tool. You will need to make some manual changes, especially if your shader uses coordinate space transformations or a custom light() function.

The .shader file extension is no longer supported, which means you must rename .shader files to .gdshader and update references accordingly in scene/resource files using an external text editor.

Some notable changes you will need to perform in shaders are:

Texture filter and repeat modes are now set on individual uniforms, rather than the texture files themselves.

hint_albedo is now source_color.

hint_color is now source_color.

Built in matrix variables were renamed.

Particles shaders no longer use the vertex() processor function. Instead they use start() and process().

In the Forward+ and Mobile renderers, normalized device coordinates now have a Z-range of [0.0,1.0] instead of [-1.0,1.0]. When reconstructing NDC from SCREEN_UV and depth, use vec3 ndc = vec3(SCREEN_UV * 2.0 - 1.0, depth); instead of vec3 ndc = vec3(SCREEN_UV, depth) * 2.0 - 1.0;. The Compatibility renderer is unchanged, using the same NDC Z-range as 3.x.

The lighting model changed. If your shader has a custom light() function, you may need to make changes to get the same visual result.

In 4.3 and up, the reverse Z depth buffer technique is now implemented, which may break advanced shaders. See Introducing Reverse Z (AKA I'm sorry for breaking your shader).

See Shading language for more information.

This list is not exhaustive. If you made all the changes mentioned here and your shader still doesn't work, try asking for help in one of the community channels.

Some changes performed between Godot 3.x and 4 are not renames, but they still break backwards compatibility due to different default behavior.

The most notable examples of this are:

Lifecycle functions such as _ready() and _process() no longer implicitly call parent classes' functions that have the same name. Instead, you must use super() at the top of a lifecycle function in the child class so that the parent class function is called first.

Both String and StringName are now exposed to GDScript. This allows for greater optimization, as StringName is specifically designed to be used for "constant" strings that are created once and reused many times. These types are not strictly equivalent to each other, which means is_same("example", &"example") returns false. Although in most cases they are interchangeable ("example" == &"example" returns true), sometimes you may have to replace "example" with &"example".

GDScript setter and getter syntax was changed, but it's only partially converted by the conversion tool. In most cases, manual changes are required to make setters and getters working again.

GDScript signal connection syntax was changed. The conversion tool will use the string-based syntax which is still present in Godot 4, but it's recommended to switch to the Signal-based syntax described on the linked page. This way, strings are no longer involved, which avoids issues with signal name errors that can only be discovered at runtime.

Built-in scripts that are tool scripts do not get the tool keyword converted to the @tool annotation.

The Tween node was removed in favor of Tweeners, which are also available in Godot 3.5 and later. See the original pull request for details.

randomize() is now automatically called on project load, so deterministic randomness with the global RandomNumberGenerate instance requires manually setting a seed in a script's _ready() function.

call_group(), set_group() and notify_group() are now immediate by default. If calling an expensive function, this may result in stuttering when used on a group containing a large number of nodes. To use deferred calls like before, replace call_group(...) with call_group_flags(SceneTree.GROUP_CALL_DEFERRED, ...) (and do the same with set_group() and notify_group() respectively).

Instead of rotation_degrees, the rotation property is exposed to the editor, which is automatically displayed as degrees in the Inspector dock. This may break animations, as the conversion is not handled automatically by the conversion tool.

AABB's has_no_surface() was inverted and renamed to has_surface().

AABB and Rect2's has_no_area() was inverted and renamed to has_area().

AnimatedTexture's fps property was replaced by speed_scale, which works the same as AnimationPlayer's playback_speed property.

AnimatedSprite2D and AnimatedSprite3D now allow negative speed_scale values. This may break animations if you relied on speed_scale being internally clamped to 0.0.

AnimatedSprite2D and AnimatedSprite3D's playing property was removed. Use play()/stop() method instead OR configure autoplay animation via the SpriteFrames bottom panel (but not both at once).

Array's slice() second parameter (end) is now exclusive, instead of being inclusive. For example, this means that [1, 2, 3].slice(0, 1) now returns [1] instead of [1, 2].

BaseButton's signals are now button_up and button_down. The pressed property is now button_pressed.

Camera2D's rotating property was replaced by ignore_rotation, which has inverted behavior.

Camera2D's zoom property was inverted: higher values are now more zoomed in, instead of less.

Node's remove_and_skip() method was removed. If you need to reimplement it in a script, you can use the old C++ implementation as a reference.

OS.get_system_time_secs() should be converted to Time.get_time_dict_from_system()["second"].

ResourceSaver's save() method now has its arguments swapped around (resource: Resource, path: String). This also applies to ResourceFormatSaver's _save() method.

A StreamPeerTCP must have poll() called on it to update its state, instead of relying on get_status() automatically polling: GH-59582

String's right() method has changed behavior: it now returns a number of characters from the right of the string, rather than the right side of the string from a given position. If you need the old behavior, you can use substr() instead.

is_connected_to_host() was removed from StreamPeerTCP and PacketPeerUDP as per GH-59582. get_status() can be used in StreamPeerTCP instead. is_socket_connected() can be used in PacketPeerUDP instead.

In _get_property_list(), the or_lesser property hint string is now or_less.

In _get_property_list(), the noslider property hint string is now no_slider.

VisualShaderNodeVec4Parameter now takes a Vector4 as parameter instead of a Quaternion.

Removed or replaced nodes/resources

This lists all nodes that were replaced by another node requiring different configuration. The setup must be done from scratch again, as the project converter doesn't support updating existing setups:

Closest approximation

AnimationTreePlayer was deprecated since Godot 3.1.

See Using Lightmap global illumination.

Camera's pyramid shape was moved to :ref:'class_Camera3D'.

Replaced by other 2D Navigation nodes.

Replaced by other 3D Navigation nodes.

Has different parameters and more noise types such as cellular. No support for 4D noise as it's absent from the FastNoiseLite library.

ToolButton was Button with the Flat property enabled by default.

CanvasItem has a new Y Sort Enabled property in 4.0.

VisibleOnScreenNotifier3D can act as a replacement.

Portal and room occlusion culling was replaced by raster occlusion culling (OccluderInstance3D node), which requires a different setup process.

Geometry occlusion culling was replaced by raster occlusion culling (OccluderInstance3D node), which requires a different setup process.

If loading an old project, the node will be replaced with its Closest approximation automatically (even if not using the project upgrade tool).

Threading APIs have changed in 4.0. For example, the following code snippet in Godot 3.x must be modified to work in 4.0:

Thread.is_active() is no longer used and should be converted to Thread.is_alive().

See the changelog for a full list of changes between Godot 3.x and 4.

If you've saved an ArrayMesh resource to a .res or .tres file, the format used in 4.0 is not compatible with the one used in 3.x. You will need to go through the process of importing the source mesh file and saving it as an ArrayMesh resource again.

The editor/renames_map_3_to_4.cpp source file lists all automatic renames performed by the project upgrade tool. Lines that are commented out refer to API renames that cannot be performed automatically.

Godot 3.x and 4.0 use different editor settings files. This means their settings can be changed independently from each other.

If you wish to port over your Godot 3.x settings to Godot 4, open the editor settings folder and copy editor_settings-3.tres to editor_settings-4.tres while the Godot 4 editor is closed.

Many settings' names and categories have changed since Godot 3.x. Editor settings whose name or category has changed won't carry over to Godot 4.0; you will have to set their values again.

Godot 3.x and 4.x have entirely different lists of files and folders that should be ignored by your version control system.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
# [<max_file_kb>] [<max_line_size>] are optional arguments.
# Remove them if you aren't changing their values.
path/to/godot.binary --path /path/to/project/folder --validate-conversion-3to4 [<max_file_kb>] [<max_line_size>]
```

Example 2 (unknown):
```unknown
# [<max_file_kb>] [<max_line_size>] are optional arguments.
# Remove them if you aren't changing their values.
path/to/godot.binary --path /path/to/project/folder --convert-3to4 [<max_file_kb>] [<max_line_size>]
```

Example 3 (unknown):
```unknown
path/to/godot.binary --path /path/to/project/folder --convert-3to4 40000 1000000
```

Example 4 (unknown):
```unknown
# 3.x
var start_success = new_thread.start(self, "__threaded_background_loader",
    [resource_path, thread_num]
)

# 4.0
var start_success = new_thread.start(__threaded_background_loader.bind(resource_path, thread_num))
```

---

## Upgrading from Godot 4.0 to Godot 4.1 — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/migrating/upgrading_to_godot_4.1.html

**Contents:**
- Upgrading from Godot 4.0 to Godot 4.1
- Breaking changes
  - Core
  - Animation
  - 2D nodes
  - 3D nodes
  - GUI nodes
  - Physics
  - Rendering
  - Navigation

For most games and apps made with 4.0, it should be relatively safe to migrate to 4.1. This page intends to cover everything you need to pay attention to when migrating your project.

If you are migrating from 4.0 to 4.1, the breaking changes listed here might affect you. Changes are grouped by areas/systems.

The GDExtension API completely breaks compatibility in 4.1, so it's not included in the table below. See the Updating your GDExtension for 4.1 section for more information.

This article indicates whether each breaking change affects GDScript and whether the C# breaking change is binary compatible or source compatible:

Binary compatible - Existing binaries will load and execute successfully without recompilation, and the runtime behavior won't change.

Source compatible - Source code will compile successfully without changes when upgrading Godot.

Method looking_at adds a new use_model_front optional parameter

Method get_meta_list changes return type from PackedStringArray to Array[StringName]

Method looking_at adds a new use_model_front optional parameter

Method create_action adds a new backward_undo_ops optional parameter

Method wait_for_task_completion changes return type from void to Error

Method _process adds a new test_only parameter

Method blend_input adds a new test_only optional parameter

Method blend_node adds a new test_only optional parameter

AnimationNodeStateMachinePlayback

Method get_travel_path changes return type from PackedStringArray to Array[StringName]

Property lookahead removed

Method segment_intersects_convex changes planes parameter type from untyped Array to Array[Plane]

Method create_multiple_convex_collisions adds a new settings optional parameter

Method look_at adds a new use_model_front optional parameter

Method look_at_from_position adds a new use_model_front optional parameter

Method add_code_completion_option adds a new location optional parameter

Method push_list adds a new bullet optional parameter

Method push_paragraph adds a new justification_flags optional parameter

Method push_paragraph adds a new tab_stops optional parameter

Method edit_selected adds a new force_edit optional parameter

Property priority changes type from float to int

Property priority changes type from float to int

PhysicsDirectSpaceState2D

Method collide_shape changes return type from Array[PackedVector2Array] to Array[Vector2]

PhysicsDirectSpaceState3D

Method collide_shape changes return type from Array[PackedVector3Array] to Array[Vector3]

Method get_version_list changes return type from PackedStringArray to Array[StringName]

Method draw_list_begin changes storage_textures parameter type from untyped Array to Array[RID]

Method global_shader_parameter_get_list changes return type from PackedStringArray to Array[StringName]

Method add_triangle_fan changes tangents parameter type from untyped Array to Array[Plane]

Method set_velocity replaced with velocity property

Property time_horizon split into time_horizon_agents and time_horizon_obstacles

Property agent_height_offset renamed to path_height_offset

Property ignore_y removed

Method set_velocity replaced with velocity property

Property time_horizon split into time_horizon_agents and time_horizon_obstacles

Property estimate_radius removed

Method get_rid renamed to get_agent_rid

Property estimate_radius removed

Method get_rid renamed to get_agent_rid

Method agent_set_callback renamed to agent_set_avoidance_callback

Method agent_set_target_velocity removed

Method agent_set_time_horizon split into agent_set_time_horizon_agents and agent_set_time_horizon_obstacles

Method agent_set_callback renamed to agent_set_avoidance_callback

Method agent_set_target_velocity removed

Method agent_set_time_horizon split into agent_set_time_horizon_agents and agent_set_time_horizon_obstacles

WebRTCPeerConnectionExtension

Method _create_data_channel changes return type from Object to WebRTCDataChannel

AnimationTrackEditPlugin

Type AnimationTrackEditPlugin removed

Type EditorInterface changes inheritance from Node to Object

Method set_movie_maker_enabled replaced with movie_maker_enabled property

Method is_movie_maker_enabled replaced with movie_maker_enabled property

EditorResourcePreviewGenerator

Method _generate adds a new metadata parameter

Method _generate_from_path adds a new metadata parameter

EditorUndoRedoManager

Method create_action adds a new backward_undo_ops optional parameter

In 4.1, some behavior changes have been introduced, which might require you to adjust your project.

When input events should reach SubViewports and their children, SubViewportContainer.mouse_filter now needs to be MOUSE_FILTER_STOP or MOUSE_FILTER_PASS. See GH-79271 for details.

Multiple layered SubViewportContainer nodes, that should all receive mouse input events, now need to be replaced by Area2D nodes. See GH-79128 for details.

Viewport nodes, that have Physics Picking enabled, now automatically set InputEvents as handled. See GH-79897 for workarounds.

In order to fix a serious bug, in Godot 4.1 we had to break binary compatibility in a big way and source compatibility in a small way.

This means that GDExtensions made for Godot 4.0 will need to be recompiled for Godot 4.1 (using the 4.1 branch of godot-cpp), with a small change to their source code.

In Godot 4.0, your "entry_symbol" function looks something like this:

However, for Godot 4.1, it should look like:

There are two small changes:

The first argument changes from const GDExtensionInterface *p_interface to GDExtensionInterfaceGetProcAddress p_get_proc_address

The constructor for the init_obj variable now receives p_get_proc_address as its first parameter

You also need to add an extra compatibility_minimum line to your .gdextension file, so that it looks something like:

This lets Godot know that your GDExtension has been updated and is safe to load in Godot 4.1.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (javascript):
```javascript
GDExtensionBool GDE_EXPORT example_library_init(const GDExtensionInterface *p_interface, const GDExtensionClassLibraryPtr p_library, GDExtensionInitialization *r_initialization) {
    godot::GDExtensionBinding::InitObject init_obj(p_interface, p_library, r_initialization);

    init_obj.register_initializer(initialize_example_module);
    init_obj.register_terminator(uninitialize_example_module);
    init_obj.set_minimum_library_initialization_level(MODULE_INITIALIZATION_LEVEL_SCENE);

    return init_obj.init();
}
```

Example 2 (javascript):
```javascript
GDExtensionBool GDE_EXPORT example_library_init(GDExtensionInterfaceGetProcAddress p_get_proc_address, const GDExtensionClassLibraryPtr p_library, GDExtensionInitialization *r_initialization) {
    godot::GDExtensionBinding::InitObject init_obj(p_get_proc_address, p_library, r_initialization);

    init_obj.register_initializer(initialize_example_module);
    init_obj.register_terminator(uninitialize_example_module);
    init_obj.set_minimum_library_initialization_level(MODULE_INITIALIZATION_LEVEL_SCENE);

    return init_obj.init();
}
```

Example 3 (unknown):
```unknown
[configuration]

entry_symbol = "example_library_init"
compatibility_minimum = 4.1
```

---

## Upgrading from Godot 4.1 to Godot 4.2 — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/migrating/upgrading_to_godot_4.2.html

**Contents:**
- Upgrading from Godot 4.1 to Godot 4.2
- Breaking changes
  - Core
  - Animation
  - GUI nodes
  - Rendering
  - Text
  - GraphEdit
  - TileMap
  - XR

For most games and apps made with 4.1 it should be relatively safe to migrate to 4.2. This page intends to cover everything you need to pay attention to when migrating your project.

If you are migrating from 4.1 to 4.2, the breaking changes listed here might affect you. Changes are grouped by areas/systems.

The Mesh resource format has changed in 4.2 to allow for vertex and attribute compression. This allows for improved rendering performance, especially on platforms constrained by memory bandwidth such as mobile.

It is still possible to load the Godot 4.0-4.1 Mesh formats, but it is not possible to load the Godot 4.2 Mesh format in prior Godot versions. When opening a Godot project made with a version prior to 4.2, you may be presented with an upgrade dialog that offers two options:

Restart & Upgrade: Upgrades the mesh format for all meshes in the project and saves the result to disk. Once chosen, this option prevents downgrading the project to a Godot version prior to 4.2. Set up a version control system and push your changes before choosing this option!

Upgrade Only: Upgrades the mesh format in-memory without writing it to disk. This allows downgrading the project to a Godot version older than 4.2 if you need to do so in the future. The downside is that loading the project will be slower every time as the mesh format needs to be upgraded every time the project is loaded. These increased loading times will also affect the exported project. The number and complexity of Mesh resources determines how much loading times are affected.

If this dialog doesn't appear, use Project > Tools > Upgrade Mesh Surfaces… at the top of the editor.

This article indicates whether each breaking change affects GDScript and whether the C# breaking change is binary compatible or source compatible:

Binary compatible - Existing binaries will load and execute successfully without recompilation, and the runtime behavior won't change.

Source compatible - Source code will compile successfully without changes when upgrading Godot.

Constant NOTIFICATION_NODE_RECACHE_REQUESTED removed

Method _post_process_key_value moved to base class AnimationMixer

Method add_animation_library moved to base class AnimationMixer

Method advance moved to base class AnimationMixer

Signal animation_finished moved to base class AnimationMixer

Signal animation_started moved to base class AnimationMixer

Signal animation_libraries_updated moved to base class AnimationMixer

Signal animation_list_changed moved to base class AnimationMixer

Property audio_max_polyphony moved to base class AnimationMixer

Signal caches_cleared moved to base class AnimationMixer

Method clear_caches moved to base class AnimationMixer

Method find_animation moved to base class AnimationMixer

Method find_animation_library moved to base class AnimationMixer

Method get_animation moved to base class AnimationMixer

Method get_animation_library moved to base class AnimationMixer

Method get_animation_library_list moved to base class AnimationMixer

Method get_animation_list moved to base class AnimationMixer

Method has_animation moved to base class AnimationMixer

Method has_animation_library moved to base class AnimationMixer

Property method_call_mode renamed to callback_mode_method and moved to base class AnimationMixer

Property playback_active renamed to active and moved to base class AnimationMixer

Property playback_process_mode renamed to callback_mode_process and moved to base class AnimationMixer

Method remove_animation_library moved to base class AnimationMixer

Method rename_animation_library moved to base class AnimationMixer

Property reset_on_save moved to base class AnimationMixer

Property root_node moved to base class AnimationMixer

Method set_reset_on_save_enabled moved to base class AnimationMixer

Method seek adds a new update_only optional parameter

Method _post_process_key_value moved to base class AnimationMixer

Property active moved to base class AnimationMixer

Method advance moved to base class AnimationMixer

Signal animation_finished moved to base class AnimationMixer

Signal animation_started moved to base class AnimationMixer

Property audio_max_polyphony moved to base class AnimationMixer

Method get_root_motion_position moved to base class AnimationMixer

Method get_root_motion_position_accumulator moved to base class AnimationMixer

Method get_root_motion_rotation moved to base class AnimationMixer

Method get_root_motion_rotation_accumulator moved to base class AnimationMixer

Method get_root_motion_scale moved to base class AnimationMixer

Method get_root_motion_scale_accumulator moved to base class AnimationMixer

Property process_callback renamed to callback_mode_process and moved to base class AnimationMixer

Property root_motion_track moved to base class AnimationMixer

Property tree_root changes type from AnimationNode to AnimationRootNode

Method add_icon_shortcut adds a new allow_echo optional parameter

Method add_shortcut adds a new allow_echo optional parameter

Method clear adds a new free_submenus optional parameter

Method add_image adds new key, pad, tooltip, and size_in_percent optional parameters

Method add_surface changes flags parameter type from uint32 to uint64

Method get_surface_format changes return type from uint32 to uint64

Method commit_to_surface adds a new compression_flags optional parameter

Method get_format changes return type from uint32 to uint64

Enum field BarrierMask.BARRIER_MASK_RASTER changes value from 1 to 9

Enum field BarrierMask.BARRIER_MASK_ALL_BARRIERS changes value from 7 to 32767

Enum field BarrierMask.BARRIER_MASK_NO_BARRIER changes value from 8 to 32768

Method shader_create_from_bytecode adds a new placeholder_rid optional parameter

Method shader_get_vertex_input_attribute_ask changes return type from uint32 to uint64

Method commit changes flags parameter type from uint32 to uint64

Method set_fallbacks replaced with fallbacks property

Method get_fallbacks replaced with fallbacks property

Method find_variation adds new spacing_top, spacing_bottom, spacing_space, and spacing_glyph optional parameters

Property arrange_nodes_button_hidden renamed to show_arrange_button

Method get_zoom_hbox renamed to get_menu_hbox

Property snap_distance renamed to snapping_distance

Property use_snap renamed to snapping_enabled

Property comment removed

Signal close_request renamed to delete_request and moved to base class GraphElement

Property draggable moved to base class GraphElement

Property draggable moved to base class GraphElement

Signal dragged moved to base class GraphElement

Method get_connection_input_color removed

Method get_connection_input_count removed

Method get_connection_input_height removed

Method get_connection_input_position removed

Method get_connection_input_slot removed

Method get_connection_input_type removed

Method get_connection_output_color removed

Method get_connection_output_count removed

Method get_connection_output_height removed

Method get_connection_output_position removed

Method get_connection_output_slot removed

Method get_connection_output_type removed

Property language removed

Signal node_deselected moved to base class GraphElement

Signal node_selected moved to base class GraphElement

Property overlay removed

Property position_offset moved to base class GraphElement

Signal position_offset_changed moved to base class GraphElement

Signal raise_request moved to base class GraphElement

Property resizable moved to base class GraphElement

Signal resize_request moved to base class GraphElement

Property selectable moved to base class GraphElement

Property selected moved to base class GraphElement

Property show_close removed

Property text_direction removed

Property cell_quadrant_size renamed to rendering_quadrant_size

Property environment_blend_mode added

This change breaks compatibility in C# because the new property conflicts with the name of an existing enum and the C# bindings generator gives priority to properties, so the enum type was renamed from EnvironmentBlendMode to EnvironmentBlendModeEnum.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Upgrading from Godot 4.2 to Godot 4.3 — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/migrating/upgrading_to_godot_4.3.html

**Contents:**
- Upgrading from Godot 4.2 to Godot 4.3
- Breaking changes
  - GDExtension
  - Animation
  - GUI nodes
  - Physics
  - Rendering
  - Text
  - Audio
  - Navigation

For most games and apps made with 4.2 it should be relatively safe to migrate to 4.3. This page intends to cover everything you need to pay attention to when migrating your project.

If you are migrating from 4.2 to 4.3, the breaking changes listed here might affect you. Changes are grouped by areas/systems.

This article indicates whether each breaking change affects GDScript and whether the C# breaking change is binary compatible or source compatible:

Binary compatible - Existing binaries will load and execute successfully without recompilation, and the runtime behavior won't change.

Source compatible - Source code will compile successfully without changes when upgrading Godot.

Method close_library removed

Method initialize_library removed

Method open_library removed

Since it was basically impossible to use these methods in any useful way, these methods have been removed. Use GDExtensionManager::load_extension and GDExtensionManager::unload_extension instead to correctly load and unload a GDExtension.

Method position_track_interpolate adds a new backward optional parameter

Method rotation_track_interpolate adds a new backward optional parameter

Method scale_track_interpolate adds a new backward optional parameter

Method blend_shape_track_interpolate adds a new backward optional parameter

Method value_track_interpolate adds a new backward optional parameter

Method track_find_key adds a new limit optional parameter

Method track_find_key adds a new backward optional parameter

Method _post_process_key_value changes object parameter type from Object to uint64

Method add_bone changes return type from void to int32

Signal bone_pose_changed replaced by skeleton_updated

Method on_bone_pose_update replaced by on_skeleton_update

Method register_text_enter changes parameter line_edit type from Control to LineEdit

Method remove_button changes parameter button type from Control to Button

PhysicsShapeQueryParameters3D

Property motion changes type from Vector2 to Vector3

In C#, the enum PhysicsServer3D.G6DofJointAxisFlag breaks compatibility because of the way the bindings generator detects the enum prefix. New members were added in GH-89851 to the enum that caused the enum members to be renamed.

Enum field FinalAction.FINAL_ACTION_CONTINUE changes value from 2 to 0

Enum field InitialAction.INITIAL_ACTION_CLEAR changes value from 0 to 1

Enum field InitialAction.INITIAL_ACTION_CLEAR_REGION_CONTINUE changes value from 2 to 1

Enum field InitialAction.INITIAL_ACTION_CONTINUE changes value from 5 to 0

Enum field InitialAction.INITIAL_ACTION_DROP changes value from 4 to 2

Enum field InitialAction.INITIAL_ACTION_KEEP changes value from 3 to 0

Method buffer_clear removes post_barrier parameter

Method buffer_update removes post_barrier parameter

Method compute_list_begin removes allow_draw_overlap parameter

Method compute_list_end removes post_barrier parameter

Method draw_list_begin removes storage_textures parameter

Method draw_list_end removes post_barrier parameter

Method texture_clear removes post_barrier parameter

Method texture_copy removes post_barrier parameter

Method texture_resolve_multisample removes post_barrier parameter

Method texture_update removes post_barrier parameter

Method environment_set_fog adds a new fog_mode optional parameter

Method get_color_layer adds a new msaa optional parameter

Method get_depth_layer adds a new msaa optional parameter

Method get_velocity_layer adds a new msaa optional parameter

Method get_color_texture adds a new msaa optional parameter

Method get_depth_texture adds a new msaa optional parameter

Method get_velocity_texture adds a new msaa optional parameter

While the values of the enum fields in RenderingDevice.InitialAction and RenderingDevice.FinalAction changed, the only method that consumed them (draw_list_begin) added a compatibility method which supports the old values. So in practice it doesn't break compatibility.

In C#, the enum RenderingDevice.DriverResource breaks compatibility because of the way the bindings generator detects the enum prefix. New members were added in GH-83452 to the enum that caused the enum members to be renamed.

Method find_variation adds a new baseline_offset optional parameter

Method push_meta adds a new underline_mode optional parameter

Method shaped_text_get_word_breaks adds a new optional skip_grapheme_flags parameter

Method _shaped_text_get_word_breaks adds a new skip_grapheme_flags parameter

AudioStreamPlaybackPolyphonic

Method play_stream adds new playback_type, and bus optional parameters

Method get_id_path adds new allow_partial_path optional parameter

Method get_point_path adds new allow_partial_path optional parameter

Method get_id_path adds new allow_partial_path optional parameter

Method get_point_path adds new allow_partial_path optional parameter

Method get_id_path adds new allow_partial_path optional parameter

Method get_point_path adds new allow_partial_path optional parameter

Property avoidance_layers removed

Property constrain_avoidance removed

Method get_avoidance_layer_value removed

Method set_avoidance_layer_value removed

The constrain avoidance feature in NavigationRegion2D was experimental and has been discontinued with no replacement.

Method get_navigation_polygon adds new flip_h, flip_v, and transpose optional parameters

Method get_occluder adds new flip_h, flip_v, and transpose optional parameters

Method get_input_source_tracker changes return type from XRPositionalTracker to XRControllerTracker

Method get_tracker changes return type from XRPositionalTracker to XRTracker

EditorInspectorPlugin

Method add_property_editor adds a new label optional parameter

Method add_control_to_bottom_panel adds a new shortcut optional parameter

Method add_control_to_dock adds a new shortcut optional parameter

EditorSceneFormatImporterFBX

Type renamed to EditorSceneFormatImporterFBX2GLTF

In 4.3, some behavior changes have been introduced, which might require you to adjust your project.

Binary serialization was modified to fix some issues with the serialization of scripted Objects and typed Arrays (GH-78219). This breaks compat with script encoding/decoding.

PackedByteArray is now able to use a more compact base64 encoding for storage. But the trade-off is that it breaks compatibility, meaning that older versions of Godot may not be able to open resources saved by 4.3 (GH-89186).

To maximize compatibility, this new storage format will only be enabled for resources and scenes that contain large PackedByteArrays for now. Support for this new format will also be added in patch updates for older versions of Godot. Once all supported Godot versions are able to read the new format, we will gradually retire the compatibility measures and have all resources and scenes use the new storage format.

In C#, the Transform3D.InterpolateWith implementation was fixed to use the right order of operations, applying the rotation before the scale (GH-89843).

In C#, the Aabb.GetSupport implementation was fixed to properly return the support vector (GH-88919).

In C#, the Variant types' ToString implementation now defaults to using the InvariantCulture (GH-89547) which means Vector2(1.2, 3.4) is formatted using . as the decimal separator independently of the language of the operating system that the program is running on.

AnimationMixer replaced its Capture mode with a new Capture feature that works much better than the old one, this replaces the existing cache (GH-86715).

AnimationNode has a reworked process for retrieving the semantic time info. This ensures that time-related behavior works as expected, but changes the blending behavior. Implementors of the _process virtual method should also note that this method is now deprecated and will be replaced by a new one in the future (GH-87171).

More information about the changes to Animation can be found in the Migrating Animations from Godot 4.0 to 4.3 article.

The default font outline color was changed from white to black (GH-54641).

The auto_translate property is deprecated in favor of the auto_translate_mode property which is now in Node (GH-87530). The default value for auto_translate_mode is AUTO_TRANSLATE_INHERIT, which means nodes inherit the auto_translate_mode value from their parent. This means, existing nodes with the auto_translate property set to true may no longer be translated if they are children of a node with the auto_translate property set to false.

The SceneMultiplayer caching protocol was changed to send the received ID instead of the Node path when sending a node removal confirmation packet (GH-90027).

This is a breaking change for the high-level multiplayer protocol making it incompatible with previous Godot versions. Upgrade both your server and client versions to Godot 4.3 to handle this change gracefully.

Note that high-level multiplayer facilities are only ever meant to be compatible with server and client using the same Godot version. It is recommended to implement some kind of version checking.

Decals now convert the modulate color from an sRGB color to a linear color, like all other inputs, to ensure proper blending (GH-89849). Existing projects that were using the decal's modulate property will notice a change in their visuals.

The reverse Z depth buffer technique is now implemented. This may break compatibility for some shaders. Read the Introducing Reverse Z (AKA I'm sorry for breaking your shader) article for more information and guidance on how to fix common scenarios.

TileMap layers were moved to individual nodes (GH-87379 and GH-89179).

Android permissions are no longer requested automatically because it goes against the recommended best practices (GH-87080). Use the request_permission method in OS and the on_request_permissions_result signal on MainLoop to request permissions and wait for the user response.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Upgrading from Godot 4.3 to Godot 4.4 — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/migrating/upgrading_to_godot_4.4.html

**Contents:**
- Upgrading from Godot 4.3 to Godot 4.4
- Breaking changes
  - Core
  - GUI nodes
  - Physics
  - Rendering
  - Navigation
  - Editor plugins
- Behavior changes
  - Core

For most games and apps made with 4.3 it should be relatively safe to migrate to 4.4. This page intends to cover everything you need to pay attention to when migrating your project.

If you are migrating from 4.3 to 4.4, the breaking changes listed here might affect you. Changes are grouped by areas/systems.

This article indicates whether each breaking change affects GDScript and whether the C# breaking change is binary compatible or source compatible:

Binary compatible - Existing binaries will load and execute successfully without recompilation, and the run-time behavior won't change.

Source compatible - Source code will compile successfully without changes when upgrading Godot.

Method open_encrypted adds a new iv optional parameter

Method store_8 changes return type from void to bool

Method store_16 changes return type from void to bool

Method store_32 changes return type from void to bool

Method store_64 changes return type from void to bool

Method store_buffer changes return type from void to bool

Method store_csv_line changes return type from void to bool

Method store_double changes return type from void to bool

Method store_float changes return type from void to bool

Method store_half changes return type from void to bool

Method store_line changes return type from void to bool

Method store_pascal_string changes return type from void to bool

Method store_real changes return type from void to bool

Method store_string changes return type from void to bool

Method store_var changes return type from void to bool

Method execute_with_pipe adds a new blocking optional parameter

Method read_string_from_stdin adds a new buffer_size parameter [1]

Method compile adds a new show_error optional parameter

Method create_from_string adds a new show_error optional parameter

Method post adds a new count optional parameter

Method standardize_locale adds a new add_defaults optional parameter

The behavior of @export_file changed in Godot 4.4. When assigning a new value from the Inspector, the path is now stored and returned as a uid:// reference instead of the traditional res:// path(GH-97912). This is a breaking change and may cause issues if you're expecting res://-based paths in scripts or serialized files.

For example, exported arrays of files may now contain a mix of uid:// and res:// paths, especially if they were partially edited in the Inspector.

In 4.4, the only way to retain the res:// format is to manually edit the .tscn or .tres files in a text editor. Starting in Godot 4.5, a new annotation @export_file_path can be used to explicitly retain the old behavior and export raw res:// paths.

Default buffer size in 4.3 is 1024.

Method push_meta adds a new tooltip optional parameter

Method set_table_column_expand adds a new shrink optional parameter

Method connect_node adds a new keep_alive optional parameter

Signal frame_rect_changed changes new_rect parameter type from Vector2 to Rect2

Method set_point_pinned adds a new insert_at optional parameter

Method restart adds a new keep_seed optional parameter

Method restart adds a new keep_seed optional parameter

Method restart adds a new keep_seed optional parameter

Method restart adds a new keep_seed optional parameter

Method draw_list_begin adds a new breadcrumb optional parameter

Method draw_list_begin removes many parameters

Method index_buffer_create adds a new enable_device_address optional parameter

Method uniform_buffer_create adds a new enable_device_address optional parameter

Method vertex_buffer_create adds a new enable_device_address optional parameter

Method multimesh_allocate_data adds a new use_indirect optional parameter

Method get_default_texture_parameter changes return type from Texture2D to Texture

Method set_default_texture_parameter changes texture parameter type from Texture2D to Texture

VisualShaderNodeCubemap

Property cube_map changes type from Cubemap to TextureLayered

VisualShaderNodeTexture2DArray

Property texture_array changes type from Texture2DArray to TextureLayered

In C#, the enum RenderingDevice.StorageBufferUsage breaks compatibility because of the way the bindings generator detects the enum prefix. New members where added in GH-100062 to the enum that caused the enum members to be renamed.

Method query_path adds a new callback optional parameter

Method query_path adds a new callback optional parameter

Method open_scene_from_path adds a new set_inherited optional parameter

Method popup_node_selector adds a new current_value optional parameter

Method popup_property_selector adds a new current_value optional parameter

EditorSceneFormatImporter

Method _get_import_flags removed

EditorTranslationParserPlugin

Method _parse_file changes return type to Array and removes msgids and msgids_context_plural parameters

The method _get_import_flags was never used by the engine. It was removed despite the compatibility breakage as there's no way for users to rely on this affecting engine behavior.

The Curve resource now enforces its value range, so min_value and max_value need to be changed if any of the points fall outside of the default [0, 1] range.

The VisualShaderNodeVec4Constant shader node had its input type changed to Vector4. Users need to recreate the values in their constants.

The CSG implementation now uses Emmett Lalish's Manifold library (GH-94321). The new implementation is more consistent with manifold definitions and fixes a number of bugs and stability issues. As a result, non-manifold meshes are no longer supported. You can use MeshInstance3D for rendering non-manifold geometry, such as quads or planes.

Android sensor events are no longer enabled by default (GH-94799). Projects that use sensor events can enable them as needed in Project Settings under Input Devices > Sensors.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Upgrading from Godot 4.4 to Godot 4.5 — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/migrating/upgrading_to_godot_4.5.html

**Contents:**
- Upgrading from Godot 4.4 to Godot 4.5
- Breaking changes
  - Core
  - Rendering
  - GLTF
  - Text
  - XR
  - Editor plugins
- Behavior changes
  - TileMapLayer

For most games and apps made with 4.4 it should be relatively safe to migrate to 4.5. This page intends to cover everything you need to pay attention to when migrating your project.

If you are migrating from 4.4 to 4.5, the breaking changes listed here might affect you. Changes are grouped by areas/systems.

In order to support new Google Play requirements Android now requires targeting .NET 9 when exporting C# projects to Android, other platforms continue to use .NET 8 as the minimum required version but newer versions are supported and encouraged.

If you are using C# in your project and want to export to Android, you will need to upgrade your project to .NET 9 (see Upgrading to a new .NET version for instructions).

This article indicates whether each breaking change affects GDScript and whether the C# breaking change is binary compatible or source compatible:

Binary compatible - Existing binaries will load and execute successfully without recompilation, and the run-time behavior won't change.

Source compatible - Source code will compile successfully without changes when upgrading Godot.

Method set_scope replaced by set_method

Method get_rpc_config renamed to get_node_rpc_config

Method set_name changes name parameter type from String to StringName

Method file_dialog_show adds a new parent_window_id optional parameter

Method file_dialog_with_options_show adds a new parent_window_id optional parameter

Method texture_create_from_extension adds a new mipmaps optional parameter

Method instance_reset_physics_interpolation removed

Method instance_set_interpolated removed

In C#, the enum RenderingDevice.Features breaks compatibility because of the way the bindings generator detects the enum prefix. New members were added to the enum in GH-103941 that caused the enum member Address to be renamed to BufferDeviceAddress.

Property byte_offset changes type metadata from int32 to int64

Property component_type changes type from int to GLTFAccessor::GLTFComponentType

Property count changes type metadata from int32 to int64

Property sparse_count changes type metadata from int32 to int64

Property sparse_indices_byte_offset changes type metadata from int32 to int64

Property sparse_indices_component_type changes type from int to GLTFAccessor::GLTFComponentType

Property sparse_values_byte_offset changes type metadata from int32 to int64

Property byte_length changes type metadata from int32 to int64

Property byte_offset changes type metadata from int32 to int64

Property byte_stride changes type metadata from int32 to int64

As a result of changing the type metadata, the C# bindings changed the type from int (32-bytes) to long (64-bytes).

Method draw_char adds a new oversampling optional parameter

Method draw_char_outline adds a new oversampling optional parameter

Method draw_multiline_string adds a new oversampling optional parameter

Method draw_multiline_string_outline adds a new oversampling optional parameter

Method draw_string adds a new oversampling optional parameter

Method draw_string_outline adds a new oversampling optional parameter

Method draw_char adds a new oversampling optional parameter

Method draw_char_outline adds a new oversampling optional parameter

Method draw_multiline_string adds a new oversampling optional parameter

Method draw_multiline_string_outline adds a new oversampling optional parameter

Method draw_string adds a new oversampling optional parameter

Method draw_string_outline adds a new oversampling optional parameter

Method add_image adds a new alt_text optional parameter

Method add_image replaced size_in_percent parameter by width_in_percent and height_in_percent

Method push_strikethrough adds optional color parameter

Method push_table adds a new name optional parameter

Method push_underline adds optional color parameter

Method update_image replaced size_in_percent parameter by width_in_percent and height_in_percent

Method draw adds a new oversampling optional parameter

Method draw_outline adds a new oversampling optional parameter

Method draw adds a new oversampling optional parameter

Method draw_dropcap adds a new oversampling optional parameter

Method draw_dropcap_outline adds a new oversampling optional parameter

Method draw_line adds a new oversampling optional parameter

Method draw_line_outline adds a new oversampling optional parameter

Method draw_outline adds a new oversampling optional parameter

Method font_draw_glyph adds a new oversampling optional parameter

Method font_draw_glyph_outline adds a new oversampling optional parameter

Method shaped_text_draw adds a new oversampling optional parameter

Method shaped_text_draw_outline adds a new oversampling optional parameter

Method add_button adds a new alt_text optional parameter

Method _font_draw_glyph adds a new oversampling optional parameter

Method _font_draw_glyph_outline adds a new oversampling optional parameter

Method _shaped_text_draw adds a new oversampling optional parameter

Method _shaped_text_draw_outline adds a new oversampling optional parameter

Method register_composition_layer_provider changes extension parameter type from OpenXRExtensionWrapperExtension to OpenXRExtensionWrapper

Method register_projection_views_extension changes extension parameter type from OpenXRExtensionWrapperExtension to OpenXRExtensionWrapper

Method unregister_composition_layer_provider changes extension parameter type from OpenXRExtensionWrapperExtension to OpenXRExtensionWrapper

Method unregister_projection_views_extension changes extension parameter type from OpenXRExtensionWrapperExtension to OpenXRExtensionWrapper

OpenXRBindingModifierEditor

Type OpenXRBindingModifierEditor changed API type from Core to Editor

OpenXRInteractionProfileEditor

Type OpenXRInteractionProfileEditor changed API type from Core to Editor

OpenXRInteractionProfileEditorBase

Type OpenXRInteractionProfileEditorBase changed API type from Core to Editor

Classes OpenXRBindingModifierEditor, OpenXRInteractionProfileEditor, and OpenXRInteractionProfileEditorBase are only available in the editor. Using them outside of the editor will result in a compilation error.

In C#, this means the types are moved from the GodotSharp assembly to the GodotSharpEditor assembly. Make sure to wrap code that uses these types in a #if TOOLS block to ensure they are not included in an exported game.

This change was also backported to 4.4.1.

Method get_forced_export_files adds a new preset optional parameter

EditorUndoRedoManager

Method create_action adds a new mark_unsaved optional parameter

EditorExportPlatformExtension

Method _get_option_icon changes return type from ImageTexture to Texture2D

In 4.5, some behavior changes have been introduced, which might require you to adjust your project.

TileMapLayer.get_coords_for_body_rid() will return different values in 4.5 compared to 4.4, as TileMapLayer physics chunking is enabled by default. Higher values of TileMapLayer.physics_quadrant_size will make this function less precise. To get the exact cell coordinates like in 4.4 and prior versions, you need to set TileMapLayer.physics_quadrant_size to 1, which disables physics chunking.

A fix has been made to the 3D model importers to correctly handle non-joint nodes within a skeleton hierarchy (GH-104184). To preserve compatibility, the default behavior is to import existing files with the same behavior as before (GH-107352). New .gltf, .glb, .blend, and .fbx files (without a corresponding .import file) will be imported with the new behavior. However, for existing files, if you want to use the new behavior, you must change the "Naming Version" option at the bottom of the Import dock:

Resource.duplicate(true) (which performs deep duplication) now only duplicates resources internal to the resource file it's called on. In 4.4, this duplicated everything instead, including external resources. If you were deep-duplicating a resource that contained references to other external resources, those external resources aren't duplicated anymore. You must call Resource.duplicate_deep(RESOURCE_DEEP_DUPLICATE_ALL) instead to keep the old behavior.

ProjectSettings.add_property_info() now prints a warning when the dictionary parameter has missing keys or invalid keys. Most importantly, it will now warn when a usage key is passed, as this key is not used. This was also the case before 4.5, but it was silently ignored instead. As a reminder, to set property usage information correctly, you must use ProjectSettings.set_as_basic(), ProjectSettings.set_restart_if_changed(), or ProjectSettings.set_as_internal() instead.

In C#, StringExtensions.PathJoin now avoids adding an extra path separator when the original string is empty, or when the appended path starts with a path separator (GH-105281).

In C#, StringExtensions.GetExtension now returns an empty string instead of the original string when the original string does not contain an extension (GH-108041).

In C#, the Quaternion(Vector3, Vector3) constructor now correctly creates a quaternion representing the shortest arc between the two input vectors. Previously, it would return incorrect values for certain inputs (GH-107618).

By default, the regions in a NavigationServer map now update asynchronously using threads to improve performance. This can cause additional delay in the update due to thread synchronisation. The asynchronous region update can be toggled with the navigation/world/region_use_async_iterations project setting.

The merging of navmeshes in the NavigationServer has changed processing order. Regions now merge and cache internal navmeshes first, then the remaining free edges are merged by the navigation map. If a project had navigation map synchronisation errors before, it might now have shifted affected edges, making already existing errors in a layout more noticeable in the pathfinding. The navigation/2d_or_3d/merge_rasterizer_cell_scale project setting can be set to a lower value to increase the detail of the rasterization grid (with 0.01 being the smallest cell size possible). If edge merge errors still persist with the lowest possible rasterization scale value, the error may be caused by overlap: two navmeshes are stacked on top of each other, causing geometry conflict.

When the 3D physics engine is set to Jolt Physics, you will now always have overlaps between Area3D and static bodies reported by default, as the physics/jolt_physics_3d/simulation/areas_detect_static_bodies project setting has been removed (GH-105746). If you still want such overlaps to be ignored, you will need to change the collision mask or layer of either the Area3D or the static body instead.

In GDScript, calls to functions RichTextLabel::add_image and RichTextLabel::update_image will continue to work, but the size_in_percent argument will now be used as the value for width_in_percent and height_in_percent will default to false (GH-107347). To restore the previous behavior, you can explicitly set height_in_percent to the same value you were passing as size_in_percent.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## User interface (UI) — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/ui/index.html

**Contents:**
- User interface (UI)
- UI building blocks
- GUI skinning and themes
- Control node tutorials

In this section of the tutorial we explain the basics of creating a graphical user interface (GUI) in Godot.

Like everything else in Godot the user interface is built using nodes, specifically Control nodes. There are many different types of controls which are useful for creating specific types of GUIs. For simplicity we can separate them into two groups: content and layout.

Typical content controls include:

LineEdits and TextEdits

Typical layout controls include:

The following pages explain the basics of using such controls.

Godot features an in-depth skinning/theming system for control nodes. The pages in this section explain the benefits of that system and how to set it up in your projects.

The following articles cover specific details of using particular control nodes.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Using an external text editor — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/editor/external_editor.html

**Contents:**
- Using an external text editor
- Automatically reloading your changes
- Using External Editor in Debugger
- Official editor plugins
- LSP/DAP support
  - Visual Studio Code
  - Emacs
- User-contributed notes

This page explains how to code using an external text editor.

To code C# in an external editor, see the C# guide to configure an external editor.

Godot can be used with an external text editor, such as Sublime Text or Visual Studio Code. Browse to the relevant editor settings: Editor > Editor Settings > Text Editor > External

Text Editor > External section of the Editor Settings

There are two text fields: the executable path and command-line flags. The flags allow you to integrate the editor with Godot, passing it the file path to open and other relevant arguments. Godot will replace the following placeholders in the flags string:

The absolute path to the project directory

The absolute path to the file

The column number of the error

The line number of the error

Some example Exec Flags for various editors include:

{file} --line {line} --column {col}

{project} --line {line} {file}

{project} --goto {file}:{line}:{col}

"+call cursor({line}, {col})" {file}

emacs +{line}:{col} {file}

{project} {file}:{line}:{col}

*: Arguments are not automatically detected, so you must fill them in manually.

Since Godot 4.5, Exec Flags are automatically detected for all editors listed above (unless denoted with an asterisk). You don't need to paste them from this page for it to work, unless your editor has an executable name not recognized automatically (e.g. a fork of an editor listed here).

For Visual Studio Code on Windows, you will have to point to the code.cmd file.

For Emacs, you can call emacsclient instead of emacs if you use the server mode.

For Visual Studio, you will have to open the solution file .sln manually to get access to the IDE features. Additionally, it will not go to a specific line.

To have the Godot Editor automatically reload any script that has been changed by an external text editor, enable Editor > Editor Settings > Text Editor > Behavior > Auto Reload Scripts on External Change.

Using external editor in debugger is determined by a separate option in settings. For details, see Script editor debug tools and options.

We have official plugins for the following code editors:

Godot supports the Language Server Protocol (LSP) for code completion and the Debug Adapter Protocol (DAP) for debugging. You can check the LSP client list and DAP client list to find if your editor supports them. If this is the case, you should be able to take advantage of these features without the need of a custom plugin.

To use these protocols, a Godot instance must be running on your current project. You should then configure your editor to communicate to the running adapter ports in Godot, which by default are 6005 for LSP, and 6006 for DAP. You can change these ports and other settings in the Editor Settings, under the Network > Language Server and Network > Debug Adapter sections respectively.

Below are some configuration steps for specific editors:

You need to install the official Visual Studio Code plugin.

For LSP, follow these instructions to change the default LSP port. The connection status can be checked on the status bar:

For DAP, specify the debugServer property in your launch.json file:

Check the official instructions to configure LSP, and DAP.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "GDScript Godot",
            "type": "godot",
            "request": "launch",
            "project": "${workspaceFolder}",
            "port": 6007,
            "debugServer": 6006,
        }
    ]
}
```

---

## Using Containers — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/ui/gui_containers.html

**Contents:**
- Using Containers
- Container layout
- Sizing options
- Container types
  - Box Containers
  - Grid Container
  - Margin Container
  - Tab Container
  - Split Container
  - PanelContainer

Anchors are an efficient way to handle different aspect ratios for basic multiple resolution handling in GUIs.

For more complex user interfaces, they can become difficult to use.

This is often the case of games, such as RPGs, online chats, tycoons or simulations. Another common case where more advanced layout features may be required is in-game tools (or simply just tools).

All these situations require a more capable OS-like user interface, with advanced layout and formatting. For that, Containers are more useful.

Containers provide a huge amount of layout power (as an example, the Godot editor user interface is entirely done using them):

When a Container-derived node is used, all children Control nodes give up their own positioning ability. This means the Container will control their positioning and any attempt to manually alter these nodes will be either ignored or invalidated the next time their parent is resized.

Likewise, when a Container derived node is resized, all its children will be re-positioned according to it, with a behavior based on the type of container used:

Example of HBoxContainer resizing children buttons.

The real strength of containers is that they can be nested (as nodes), allowing the creation of very complex layouts that resize effortlessly.

When adding a node to a container, the way the container treats each child depends mainly on their container sizing options. These options can be found by inspecting the layout of any Control that is a child of a Container.

Sizing options are independent for vertical and horizontal sizing and not all containers make use of them (but most do):

Fill: Ensures the control fills the designated area within the container. No matter if a control expands or not (see below), it will only fill the designated area when this is toggled on (it is by default).

Expand: Attempts to use as much space as possible in the parent container (in each axis). Controls that don't expand will be pushed away by those that do. Between expanding controls, the amount of space they take from each other is determined by the Stretch Ratio (see below). This option is only available when the parent Container is of the right type, for example the HBoxContainer has this option for horizontal sizing.

Shrink Begin When expanding, try to remain at the left or top of the expanded area.

Shrink Center When expanding, try to remain at the center of the expanded area.

Shrink End When expanding, try to remain at the right or bottom of the expanded area.

Stretch Ratio: The ratio of how much expanded controls take up the available space in relation to each other. A control with "2", will take up twice as much available space as one with "1".

Experimenting with these flags and different containers is recommended to get a better grasp on how they work.

Godot provides several container types out of the box as they serve different purposes:

Arranges child controls vertically or horizontally (via HBoxContainer and VBoxContainer). In the opposite of the designated direction (as in, vertical for a horizontal container), it just expands the children.

These containers make use of the Stretch Ratio property for children with the Expand flag set.

Arranges child controls in a grid layout (via GridContainer, amount of columns must be specified). Uses both the vertical and horizontal expand flags.

Child controls are expanded towards the bounds of this control (via MarginContainer). Padding will be added on the margins depending on the theme configuration.

Again, keep in mind that the margins are a Theme value, so they need to be edited from the constants overrides section of each control:

Allows you to place several child controls stacked on top of each other (via TabContainer), with only the current one visible.

Changing the current one is done via tabs located at the top of the container, via clicking:

The titles are generated from the node names by default (although they can be overridden via TabContainer API).

Settings such as tab placement and StyleBox can be modified in the TabContainer theme overrides.

Accepts only one or two children controls, then places them side to side with a divisor (via HSplitContainer and VSplitContainer). Respects both horizontal and vertical flags, as well as Ratio.

The divisor can be dragged around to change the size relation between both children:

A container that draws a StyleBox, then expands children to cover its whole area (via PanelContainer, respecting the StyleBox margins). It respects both the horizontal and vertical sizing options.

This container is useful as a top-level control, or just to add custom backgrounds to sections of a layout.

A container that can be expanded/collapsed (via FoldableContainer). Child controls are hidden when it is collapsed.

Accepts a single child node. If the child node is bigger than the container, scrollbars will be added to allow panning the node around (via ScrollContainer). Both vertical and horizontal size options are respected, and the behavior can be turned on or off per axis in the properties.

Mouse wheel and touch drag (when touch is available) are also valid ways to pan the child control around.

As in the example above, one of the most common ways to use this container is together with a VBoxContainer as child.

A container type that arranges its child controls in a way that preserves their proportions automatically when the container is resized. (via AspectRatioContainer). It has multiple stretch modes, providing options for adjusting the child controls' sizes concerning the container: "fill," "width control height," "height control width," and "cover."

It is useful when you have a container that needs to be dynamic and responsive to different screen sizes, and you want the child elements to scale proportionally without losing their intended shapes.

FlowContainer is a container that arranges its child controls either horizontally or vertically (via HFlowContainer and via VFlowContainer). When the available space runs out, it wraps the children to the next line or column, similar to how text wraps in a book.

It is useful for creating flexible layouts where the child controls adjust automatically to the available space without overlapping.

CenterContainer is a container that automatically keeps all of its child controls centered within it at their minimum size. It ensures that the child controls are always aligned to the center, making it easier to create centered layouts without manual positioning (via CenterContainer).

This is a special control that will only accept a single Viewport node as child, and it will display it as if it was an image (via SubViewportContainer).

It is possible to create a custom container using a script. Here is an example of a container that fits children to its size:

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
extends Container

func _notification(what):
    if what == NOTIFICATION_SORT_CHILDREN:
        # Must re-sort the children
        for c in get_children():
            # Fit to own size
            fit_child_in_rect(c, Rect2(Vector2(), size))

func set_some_setting():
    # Some setting changed, ask for children re-sort.
    queue_sort()
```

Example 2 (unknown):
```unknown
using Godot;

public partial class CustomContainer : Container
{
    public override void _Notification(int what)
    {
        if (what == NotificationSortChildren)
        {
            // Must re-sort the children
            foreach (Control c in GetChildren())
            {
                // Fit to own size
                FitChildInRect(c, new Rect2(new Vector2(), Size));
            }
        }
    }

    public void SetSomeSetting()
    {
        // Some setting changed, ask for children re-sort.
        QueueSort();
    }
}
```

---

## Using C++ profilers — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/debugging/using_cpp_profilers.html

**Contents:**
- Using C++ profilers
- Recommended profilers
- Setting up Godot
- Benchmarking startup/shutdown times
- Profiler-specific instructions
  - VerySleepy
  - HotSpot
  - Xcode Instruments
- User-contributed notes

To optimize Godot's performance, you need to know what to optimize first. To this end, profilers are useful tools.

There is a built-in GDScript profiler in the editor, but using C++ profiler may be useful in cases where the GDScript profiler is not accurate enough or is missing information due to bugs in the profiler.

VerySleepy (Windows only)

Xcode Instruments (macOS only)

These profilers may not be the most powerful or flexible options, but their standalone operation and limited feature set tends to make them easier to use.

To get useful profiling information, it is absolutely required to use a Godot build that includes debugging symbols. Official binaries do not include debugging symbols, since these would make the download size significantly larger.

To get profiling data that best matches the production environment (but with debugging symbols), you should compile binaries with the production=yes debug_symbols=yes SCons options.

It is possible to run a profiler on less optimized builds (e.g. target=template_debug without LTO), but results will naturally be less representative of real world conditions.

Do not strip debugging symbols on the binaries using the strip command after compiling the binaries. Otherwise, you will no longer get useful profiling information when running a profiler.

If you're looking into optimizing Godot's startup/shutdown performance, you can tell the profiler to use the --quit command line option on the Godot binary. This will exit Godot just after it finished starting. The --quit option works with --editor, --project-manager or --path <path to project directory> (which runs a project directly).

See Command line tutorial for more command line arguments supported by Godot.

Start the Godot editor or your project first. If you start the Project Manager, make sure to edit or run a project first. Otherwise, the profiler will not track the child process since the Project Manager will spawn a child process for every project edited or run.

Open VerySleepy and select the Godot executable in the list of processes on the left:

Click the Profile All button on the right to start profiling.

Perform the actions you wish to profile in the editor or project. When you're done, click Stop (not Abort).

Wait for the results window to appear.

Once the results window appears, filter the view to remove external modules (such as the graphics driver). You can filter by module by finding a line whose Module matches the Godot executable name, right-clicking that line then choosing Filter Module to <Godot executable name> in the dropdown that appears.

Your results window should now look something like this:

Open HotSpot. Click Record Data:

In the next window, specify the path to the Godot binary that includes debug symbols.

Specify command line arguments to run a specific project, with or without the editor.

The path to the working directory can be anything if an absolute path is used for the --path command line argument. Otherwise, it must be set to that the relative path to the project is valid.

Make sure Elevate Privileges is checked if you have administrative privileges. While not essential for profiling Godot, this will ensure all events can be captured. Otherwise, some events may be missing in the capture. Your settings should now look something like this:

Click Start Recording and perform the actions you wish to profile in the editor/project.

Quit the editor/project normally or use the Stop Profiling button in HotSpot to stop profiling early. Stopping profiling early can result in cleaner profiles if you're not interested in the engine's quit procedure.

Click View Results and wait for the profiling visualization to be generated:

Use the tabs at the top to navigate between the different views. These views show the same data, but in different ways. The Flame Graph tab is a good way to see which functions take up the most time at a glance. These functions are therefore the most important ones to optimize, since optimizing them will improve performance the most.

At the bottom of all tabs except Summary, you will also see a list of CPU threads started by the engine among with the CPU utilization for each thread. This lets you see threads that can be a bottleneck at a given point in time.

If you don't want the startup procedure to be included in the profile, you can also attach HotSpot to a running process by clicking Record Data then setting the Launch Application dropdown option to Attach To Process(es).

This process attachment-based workflow is similar to the one used by VerySleepy.

Open Xcode. Select Open Developer Tool - Instruments from the Xcode app menu:

Double-click on Time Profiler in the Instruments window:

In the Time Profiler window, click on the Target menu, select Choose target... and specify the path to the Godot binary, command line arguments and environment variables in the next window.

You can also attach the Time Profiler to a running process by selecting it from the Target menu.

Click the Start an immediate mode recording button to start profiling.

Perform the actions you wish to profile in the editor or project. When you're done, click the Stop button.

Wait for the results to appear.

At the bottom of the window you will see a call tree for all CPU threads started, and the Heaviest Stack Trace overview.

Select Hide system libraries in the Call Tree menu (at the bottom of window) to remove external modules.

You can use the timeline at the top of the window to display details for the specific time period.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Using Fonts — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/ui/gui_using_fonts.html

**Contents:**
- Using Fonts
- Dynamic fonts
- Bitmap fonts
- Loading a font file
- Font outlines and shadows
- Advanced font features
  - Antialiasing
  - Hinting
  - Subpixel positioning
  - Mipmaps

Godot allows you to set specific fonts for different UI nodes.

There are three different places where you can setup font usage. The first is the theme editor. Choose the node you want to set the font for and select the font tab. The second is in the inspector for control nodes under Theme Overrides > Fonts. Lastly, in the inspector settings for themes under Default Font.

If no font override is specified anywhere, Open Sans SemiBold is used as the default project font.

Since Godot 4.0, font sizes are no longer defined in the font itself but are instead defined in the node that uses the font. This is done in the Theme Overrides > Font Sizes section of the inspector.

This allows changing the font size without having to duplicate the font resource for every different font size.

There are 2 kinds of font files: dynamic (TTF/OTF/WOFF/WOFF2 formats) and bitmap (BMFont .fnt format or monospaced image). Dynamic fonts are the most commonly used option, as they can be resized and still look crisp at higher sizes. Thanks to their vector-based nature, they can also contain a lot more glyphs while keeping a reasonable file size compared to bitmap fonts. Dynamic fonts also support some advanced features that bitmap fonts cannot support, such as ligatures (several characters transforming into a single different design).

You can find freely licensed font files on websites such as Google Fonts and Font Library.

Fonts are covered by copyright. Double-check the license of a font before using it, as not all fonts allow commercial use without purchasing a license.

You can see how fonts work in action using the BiDI and Font Features demo project.

Godot supports the following dynamic font formats:

TrueType Font or Collection (.ttf, .ttc)

OpenType Font or Collection (.otf, .otc)

Web Open Font Format 1 (.woff)

Web Open Font Format 2 (.woff2, since Godot 3.5)

While .woff and especially .woff2 tend to result in smaller file sizes, there is no universally "better" font format. In most situations, it's recommended to use the font format that was shipped on the font developer's website.

Godot supports the BMFont (.fnt) bitmap font format. This is a format created by the BMFont program. Many BMFont-compatible programs also exist, like BMGlyph or web-based fontcutter.

Alternatively, you can import any image to be used as a bitmap font. To do so, select the image in the FileSystem dock, go to the Import dock, change its import type to Font Data (Image Font) then click Reimport:

Changing import type to Font Data (Image Font)

The font's character set layout can be in any order, but orders that match standard Unicode are recommended as they'll require far less configuration to import. For example, the bitmap font below contains ASCII characters and follows standard ASCII ordering:

Credit: LibreQuake (scaled and cropped to exclude extended range)

The following import options can be used to import the above font image successfully:

Import options to use for the above example font

The Character Ranges option is an array that maps each position on the image (in tile coordinates, not pixels). The font atlas is traversed from left to right and top to bottom. Characters can be specified with decimal numbers (127), hexadecimal numbers (0x007f) or between single quotes ('~'). Ranges can be specified with a hyphen between characters.

For instance, 0-127 (or 0x0000-0x007f) denotes the full ASCII range. As another example, ' '-'~' is equivalent to 32-127 and denotes the range of printable (visible) ASCII characters.

Make sure the Character Ranges option doesn't exceed the number of Columns × Rows defined. Otherwise, the font will fail to import.

If your font image contains margins not used for font glyphs (such as attribution information), try adjusting Image Margin. This is a margin applied only once around the whole image.

If your font image contains guides (in the form of lines between glyphs) or if spacing between characters appears incorrect, try adjusting Character Margin. This margin is applied for every imported glyph.

If you need finer control over character spacing than what the Character Margin options provide, you have more options.

For one, Character Ranges supports 3 additional arguments after the specified range of characters. These additional arguments control their positioning and spacing. They represent space advance, X axis offset, and Y axis offset in that order. They will change the space advance and offset of each character by the amount of pixels written. Space advance is most useful if, for example, your lowercase letters are thinner than your uppercase letters.

Do note that the offsets can cause your text to be cropped off the edge of your label boundaries.

Secondly, you can also set up Kerning Pairs for individual characters. Specify your kerning pair by typing two sets of characters separated by a space, then followed by another space, a number to specify how many extra/less pixels to space those two sets of characters when placed next to each other.

If needed, your kerning pair characters can be specified by Unicode character code by entering \uXXXX where XXXX is the hexadecimal value of the Unicode character.

To load a font file (dynamic or bitmap), use the resource dropdown's Quick Load or Load option next to a font property, then navigate to the font file in question:

You can also drag-and-drop a font file from the FileSystem dock to the inspector property that accepts a Font resource.

In Godot 4.0 and later, texture filter and repeat properties are defined in the location where the texture is used, rather than on the texture itself. This also applies to fonts (both dynamic fonts and bitmap fonts).

Fonts that have a pixel art appearance should have bilinear filtering disabled by changing the Rendering > Textures > Canvas Textures > Default Texture Filter project setting to Nearest.

The font size must also be an integer multiple of the design size (which varies on a per-font basis), and the Control node using the font must be scaled by an integer multiple as well. Otherwise, the font may look blurry. Font sizes in Godot are specified in pixels (px), not points (pt). Keep this in mind when comparing font sizes across different software.

The texture filter mode can also be set on individual nodes that inherit from CanvasItem by setting CanvasItem.texture_filter.

Font outlines and shadows can be used to improve readability when the background color isn't known in advance. For instance, this is the case for HUD elements that are drawn over a 2D/3D scene.

Font outlines are available in most nodes that derive from Control, in addition to Label3D.

To enable outline for a font on a given node, configure the theme overrides Font Outline Color and Outline Size in the inspector. The result should look like this:

Font outline example

If using a font with MSDF rendering, its MSDF Pixel Range import option be set to at least twice the value of the outline size for outline rendering to look correct. Otherwise, the outline may appear to be cut off earlier than intended.

Support for font shadows is more limited: they are only available in Label and RichTextLabel. Additionally, font shadows always have a hard edge (but you can reduce their opacity to make them look more subtle). To enable font shadows on a given node, configure the Font Shadow Color, Shadow Offset X, and Shadow Offset Y theme overrides in a Label or RichTextLabel node accordingly:

Configuring font shadow in a Label node

The result should look like this:

You can create local overrides to font display in Label nodes by creating a LabelSettings resource that you reuse across Label nodes. This resource takes priority over theme properties.

You can adjust how the font should be smoothed out when rendering by adjusting antialiasing and hinting. These are different properties, with different use cases.

Antialiasing controls how glyph edges should be smoothed out when rasterizing the font. The default antialiasing method (Grayscale) works well on every display technology. However, at small sizes, grayscale antialiasing may result in fonts looking blurry.

The antialiasing sharpness can be improved by using LCD subpixel optimization, which exploits the subpixel patterns of most LCD displays by offsetting the font antialiasing on a per-channel basis (red/green/blue). The downside is that this can introduce "fringing" on edges, especially on display technologies that don't use standard RGB subpixels (such as OLED displays).

In most games, it's recommended to stick to the default Grayscale antialiasing. For non-game applications, LCD subpixel optimization is worth exploring.

From top to bottom: Disabled, Grayscale, LCD Subpixel (RGB)

Antialiasing cannot be changed on MSDF-rendered fonts – these are always rendered with grayscale antialiasing.

Hinting controls how aggressively glyph edges should be snapped to pixels when rasterizing the font. None results in the smoothest appearance, which can make the font look blurry at small sizes. Light (default) is sharper by snapping glyph edges to pixels on the Y axis only, while Full is even sharper by snapping glyph edges to pixels on both X and Y axes. Depending on personal preference, you may prefer using one hinting mode over the other.

From top to bottom: None, Light, Full hinting

If changing the hinting mode has no visible effect after clicking Reimport, it's usually because the font doesn't include hinting instructions. This can be resolved by looking for a version of the font file that includes hinting instructions, or enabling Force Autohinter in the Import dock. This will use FreeType's autohinter to automatically add hinting instructions to the imported font.

Subpixel positioning can be adjusted. This is a FreeType feature that allows glyphs to be rendered more closely to their intended form. The default setting of Auto automatically enables subpixel positioning at small sizes, but disables it at large font sizes to improve rasterization performance.

You can force the subpixel positioning mode to Disabled, One half of a pixel or One quarter of a pixel. One quarter of a pixel provides the best quality, at the cost of longer rasterization times.

Changing antialiasing, hinting and subpixel positioning has the most visible effect at smaller font sizes.

Fonts that have a pixel art appearance should have their subpixel positioning mode set to Disabled. Otherwise, the font may appear to have uneven pixel sizes.

This step is not required for bitmap fonts, as subpixel positioning is only relevant for dynamic fonts (which are usually made of vector elements).

By default, fonts do not have mipmaps generated to reduce memory usage and speed up rasterization. However, this can cause downscaled fonts to become grainy. This can be especially noticeable with 3D text that doesn't have Fixed Size enabled. This can also occur when displaying text with a traditional rasterized (non-MSDF) font in a Control node that has its scale lower than (1, 1).

After selecting a font in the FileSystem dock, you can enable the Mipmaps in the Import dock to improve downscaled font rendering appearance.

Mipmaps can be enabled on MSDF fonts as well. This can improve font rendering quality a little at smaller-than-default sizes, but MSDF fonts are already resistant to graininess out of the box.

Multi-channel signed distance field (MSDF) font rendering allows rendering fonts at any size, without having to re-rasterize them when their size changes.

MSDF font rendering has 2 upsides over traditional font rasterization, which Godot uses by default:

The font will always look crisp, even at huge sizes.

There is less stuttering when rendering characters at large font sizes for the first time, as there is no rasterization performed.

The downsides of MSDF font rendering are:

Higher baseline cost for font rendering. This is usually not noticeable on desktop platforms, but it can have an impact on low-end mobile devices.

Fonts at small sizes will not look as clear as rasterized fonts, due to the lack of hinting.

Rendering new glyphs for the first time at small font sizes may be more expensive compared to traditional rasterized fonts. Font prerendering can be used to alleviate this.

LCD subpixel optimization cannot be enabled for MSDF fonts.

Fonts with self-intersecting outlines will not render correctly in MSDF mode. If you notice rendering issues on fonts downloaded from websites such as Google Fonts, try downloading the font from the font author's official website instead.

Comparison of font rasterization methods. From top to bottom: rasterized without oversampling, rasterized with oversampling, MSDF

To enable MSDF rendering for a given font, select it in the FileSystem dock, go to the Import dock, enable Multichannel Signed Distance Field, then click Reimport:

Enabling MSDF in the font's import options

Godot has limited support for emoji fonts:

CBDT/CBLC (embedded PNGs) and SVG emoji fonts are supported.

COLR/CPAL emoji fonts (custom vector format) are not supported.

EMJC bitmap image compression (used by iOS' system emoji font) is not supported. This means that to support emoji on iOS, you must use a custom font that uses SVG or PNG bitmap compression instead.

For Godot to be able to display emoji, the font used (or one of its fallbacks) needs to include them. Otherwise, emoji won't be displayed and placeholder "tofu" characters will appear instead:

Default appearance when trying to use emoji in a label

After adding a font to display emoji such as Noto Color Emoji, you get the expected result:

Correct appearance after adding an emoji font to the label

To use a regular font alongside emoji, it's recommended to specify a fallback font that points to the emoji font in the regular font's advanced import options. If you wish to use the default project font while displaying emoji, leave the Base Font property in FontVariation empty while adding a font fallback pointing to the emoji font:

Emoji fonts are quite large in size, so you may want to load a system font to provide emoji glyphs rather than bundling it with your project. This allows providing full emoji support in your project without increasing the size of its exported PCK. The downside is that emoji will look different depending on the platform, and loading system fonts is not supported on all platforms.

It's possible to use a system font as a fallback font too.

Tools like Fontello can be used to generate font files containing vectors imported from SVG files. This can be used to render custom vector elements as part of your text, or to create extruded 3D icons with 3D text and TextMesh.

Fontello currently does not support creating multicolored fonts (which Godot can render). As of November 2022, support for multicolored fonts in icon font generation tools remains scarce.

Depending on your use cases, this may lead to better results compared to using the img tag in RichTextLabel. Unlike bitmap images (including SVGs which are rasterized on import by Godot), true vector data can be resized to any size without losing quality.

After downloading the generated font file, load it in your Godot project then specify it as a custom font for a Label, RichTextLabel or Label3D node. Switch over to the Fontello web interface, then copy the character by selecting it then pressing Ctrl + C (Cmd + C on macOS). Paste the character in the Text property of your Label node. The character will appear as a placeholder glyph in the inspector, but it should appear correctly in the 2D/3D viewport.

To use an icon font alongside a traditional font in the same Control, you can specify the icon font as a fallback. This works because icon fonts use the Unicode private use area, which is reserved for use by custom fonts and doesn't contain standard glyphs by design.

Several modern icon fonts such as Font Awesome 6 have a desktop variant that uses ligatures to specify icons. This allows you to specify icons by entering their name directly in the Text property of any node that can display fonts. Once the icon's name is fully entered as text (such as house), it will be replaced by the icon.

While easier to use, this approach cannot be used with font fallbacks as the main font's characters will take priority over the fallback font's ligatures.

Godot supports defining one or more fallbacks when the main font lacks a glyph to be displayed. There are 2 main use cases for defining font fallbacks:

Use a font that only supports Latin character sets, but use another font to be able to display text another character set such as Cyrillic.

Use a font to render text, and another font to render emoji or icons.

Open the Advanced Import Settings dialog by double-clicking the font file in the FileSystem dock. You can also select the font in the FileSystem dock, go to the Import dock then choose Advanced… at the bottom:

In the dialog that appears, look for Fallbacks section on the sidebar on the right, click the Array[Font] (size 0) text to expand the property, then click Add Element:

Adding font fallback

Click the dropdown arrow on the new element, then choose a font file using the Quick Load or Load options:

Loading font fallback

It is possible to add fallback fonts while using the default project font. To do so, leave the Base Font property empty while adding one or more font fallbacks.

Font fallbacks can also be defined on a local basis similar to OpenType font features, but this is not covered here for brevity reasons.

Godot has full support for variable fonts, which allow you to use a single font file to represent various font weights and styles (regular, bold, italic, …). This must be supported by the font file you're using.

To use a variable font, create a FontVariation resource in the location where you intend to use the font, then load a font file within the FontVariation resource:

Creating a FontVariation resource

Loading a font file into the FontVariation resource

Scroll down to the FontVariation's Variation section, then click the Variation Coordinates text to expand the list of axes that can be adjusted:

List of variation axes

The set of axes you can adjust depends on the font loaded. Some variable fonts only support one axis of adjustment (typically weight or slant), while others may support multiple axes of adjustment.

For example, here's the Inter V font with a weight of 900 and a slant of -10:

Variable font example (Inter V)

While variable font axis names and scales aren't standardized, some common conventions are usually followed by font designers. The weight axis is standardized in OpenType to work as follows:

Effective font weight

Extra Light (Ultra Light)

Semi-Bold (Demi-Bold)

Extra Bold (Ultra Bold)

Extra Black (Ultra Black)

You can save the FontVariation to a .tres resource file to reuse it in other places:

Saving FontVariation to an external resource file

When writing text in bold or italic, using font variants specifically designed for this looks better. Spacing between glyphs will be more consistent when using a bold font, and certain glyphs' shapes may change entirely in italic variants (compare "a" and "a").

However, real bold and italic fonts require shipping more font files, which increases distribution size. A single variable font file can also be used, but this file will be larger than a single non-variable font. While file size is usually not an issue for desktop projects, it can be a concern for mobile/web projects that strive to keep distribution size as low as possible.

To allow bold and italic fonts to be displayed without having to ship additional fonts (or use a variable font that is larger in size), Godot supports faux bold and italic.

Faux bold/italic (top), real bold/italic (bottom). Normal font used: Open Sans SemiBold

Faux bold and italic is automatically used in RichTextLabel's bold and italic tags if no custom fonts are provided for bold and/or italic.

To use faux bold, create a FontVariation resource in a property where a Font resource is expected. Set Variation > Embolden to a positive value to make a font bolder, or to a negative value to make it less bold. Recommended values are between 0.5 and 1.2 depending on the font.

Faux italic is created by skewing the text, which is done by modifying the per-character transform. This is also provided in FontVariation using the Variation > Transform property. Setting the yx component of the character transform to a positive value will italicize the text. Recommended values are between 0.2 and 0.4 depending on the font.

For stylistic purposes or for better readability, you may want to adjust how a font is presented in Godot.

Create a FontVariation resource in a property where a Font resource is expected. There are 4 properties available in the Variation > Extra Spacing section, which accept positive and negative values:

Glyph: Additional spacing between every glyph.

Space: Additional spacing between words.

Top: Additional spacing above glyphs. This is used for multiline text, but also to calculate the minimum size of controls such as Label and Button.

Bottom: Additional spacing below glyphs. This is used for multiline text, but also to calculate the minimum size of controls such as Label and Button.

The Variation > Transform property can also be adjusted to stretch characters horizontally or vertically. This is specifically done by adjusting the xx (horizontal scale) and yy (vertical scale) components. Remember to adjust glyph spacing to account for any changes, as glyph transform doesn't affect how much space each glyph takes in the text. Non-uniform scaling of this kind should be used sparingly, as fonts are generally not designed to be displayed with stretching.

Godot supports enabling OpenType font features, which are a standardized way to define alternate characters that can be toggled without having to swap font files entirely. Despite being named OpenType font features, these are also supported in TrueType (.ttf) and WOFF/WOFF2 font files.

Support for OpenType features highly depends on the font used. Some fonts don't support any OpenType features, while other fonts can support dozens of toggleable features.

There are 2 ways to use OpenType font features:

Globally on a font file

Open the Advanced Import Settings dialog by double-clicking the font file in the FileSystem dock. You can also select the font in the FileSystem dock, go to the Import dock then choose Advanced… at the bottom:

In the dialog that appears, look for the Metadata Overrides > OpenType Features section on the sidebar on the right, click the Features (0 of N set) text to expand the property, then click Add Feature:

OpenType feature overrides in Advanced Import Settings

In a specific font usage (FontVariation)

To use a font feature, create a FontVariation resource like you would do for a variable font, then load a font file within the FontVariation resource:

Creating a FontVariation resource

Loading a font file into a FontVariation resource

Scroll down to the FontVariation's OpenType Features section, click the Features (0 of N set) text to expand the property, then click Add Feature and select the desired feature in the dropdown:

Specifying OpenType features in a FontVariation resource

For example, here's the Inter font without the Slashed Zero feature (top), then with the Slashed Zero OpenType feature enabled (bottom):

OpenType feature comparison (Inter)

You can disable ligatures and/or kerning for a specific font by adding OpenType features, then unchecking them in the inspector:

Disabling ligatures and kerning for a font

Loading system fonts is only supported on Windows, macOS, Linux, Android and iOS.

However, loading system fonts on Android is unreliable as there is no official API for doing so. Godot has to rely on parsing system configuration files, which can be modified by third-party Android vendors. This may result in non-functional system font loading.

System fonts are a different type of resource compared to imported fonts. They are never actually imported into the project, but are loaded at runtime. This has 2 benefits:

The fonts are not included within the exported PCK file, leading to a smaller file size for the exported project.

Since fonts are not included with the exported project, this avoids licensing issues that would occur if proprietary system fonts were distributed alongside the project.

The engine automatically uses system fonts as fallback fonts, which makes it possible to display CJK characters and emoji without having to load a custom font. There are some restrictions that apply though, as mentioned in the Using emoji section.

Create a SystemFont resource in the location where you desire to use the system font:

Creating a SystemFont resource

Specifying a font name to use in a SystemFont resource

You can either specify one or more font names explicitly (such as Arial), or specify the name of a font alias that maps to a "standard" default font for the system:

Handled by fontconfig

Handled by fontconfig

Handled by fontconfig

Handled by fontconfig

Handled by fontconfig

On Android, Roboto is used for Latin/Cyrillic text and Noto Sans is used for other languages' glyphs such as CJK. On third-party Android distributions, the exact font selection may differ.

If specifying more than one font, the first font that is found on the system will be used (from top to bottom). Font names and aliases are case-insensitive on all platforms.

Like for font variations, you can save the SystemFont arrangement to a resource file to reuse it in other places.

Remember that different system fonts have different metrics, which means that text that can fit within a rectangle on one platform may not be doing so on another platform. Always reserve some additional space during development so that labels can extend further if needed.

Unlike Windows and macOS/iOS, the set of default fonts shipped on Linux depends on the distribution. This means that on different Linux distributions, different fonts may be displayed for a given system font name or alias.

It is also possible to load fonts at runtime even if they aren't installed on the system. See Runtime loading and saving for details.

When using traditional rasterized fonts, Godot caches glyphs on a per-font and per-size basis. This reduces stuttering, but it can still occur the first time a glyph is displayed when running the project. This can be especially noticeable at higher font sizes or on mobile devices.

When using MSDF fonts, they only need to be rasterized once to a special signed distance field texture. This means caching can be done purely on a per-font basis, without taking the font size into consideration. However, the initial rendering of MSDF fonts is slower compared to a traditional rasterized font at a medium size.

To avoid stuttering issues related to font rendering, it is possible to prerender certain glyphs. This can be done for all glyphs you intend to use (for optimal results), or only for common glyphs that are most likely to appear during gameplay (to reduce file size). Glyphs that aren't pre-rendered will be rasterized on-the-fly as usual.

In both cases (traditional and MSDF), font rasterization is done on the CPU. This means that the GPU performance doesn't affect how long it takes for fonts to be rasterized.

Open the Advanced Import Settings dialog by double-clicking the font file in the FileSystem dock. You can also select the font in the FileSystem dock, go to the Import dock then choose Advanced… at the bottom:

Move to the Pre-render Configurations tab of the Advanced Import Settings dialog, then add a configuration by clicking the "plus" symbol:

Adding a new prerendering configuration in the Advanced Import Settings dialog

After adding a configuration, make sure it is selected by clicking its name once. You can also rename the configuration by double-clicking it.

There are 2 ways to add glyphs to be prerendered to a given configuration. It is possible to use both approaches in a cumulative manner:

Using text from translations

For most projects, this approach is the most convenient to use, as it automatically sources text from your language translations. The downside is that it can only be used if your project supports internationalization. Otherwise, stick to the "Using custom text" approach described below.

After adding translations to the Project Settings, use the Glyphs from the Translations tab to check translations by double-clicking them, then click Shape All Strings in the Translations and Add Glyphs at the bottom:

Enabling prerendering in the Advanced Import Settings dialog with the Glyphs from the Translations tab

The list of prerendered glyphs is not automatically updated when translations are updated, so you need to repeat this process if your translations have changed significantly.

While it requires manually specifying text that will appear in the game, this is the most efficient approach for games which don't feature user text input. This approach is worth exploring for mobile games to reduce the file size of the distributed app.

To use existing text as a baseline for prerendering, go to the Glyphs from the Text sub-tab of the Advanced Import Settings dialog, enter text in the window on the right, then click Shape Text and Add Glyphs at the bottom of the dialog:

Enabling prerendering in the Advanced Import Settings dialog with the Glyphs from the Text tab

If your project supports internationalization, you can paste the contents of your CSV or PO files in the above box to quickly prerender all possible characters that may be rendered during gameplay (excluding user-provided or non-translatable strings).

By enabling character sets

The second method requires less configuration and fewer updates if your game's text changes, and is more suited to text-heavy games or multiplayer games with chat. On the other hand, it may cause glyphs that never show up in the game to be prerendered, which is less efficient in terms of file size.

To use existing text as a baseline for prerendering, go to the Glyphs from the Character Map sub-tab of the Advanced Import Settings dialog, then double-click character sets to be enabled on the right:

Enabling prerendering in the Advanced Import Settings dialog with the Glyphs from the Character Map tab

To ensure full prerendering, the character sets you need to enable depend on which languages are supported in your game. For English, only Basic Latin needs to be enabled. Enabling Latin-1 Supplement as well allows fully covering many more languages, such as French, German and Spanish. For Russian, Cyrillic needs to be enabled, and so on.

In the GUI > Theme section of the advanced Project Settings, you can choose how the default font should be rendered:

Default Font Antialiasing: Controls the antialiasing method used for the default project font.

Default Font Hinting: Controls the hinting method used for the default project font.

Default Font Subpixel Positioning: Controls the subpixel positioning method for the default project font.

Default Font Multichannel Signed Distance Field: If true, makes the default project font use MSDF font rendering instead of traditional rasterization.

Default Font Generate Mipmaps: If true, enables mipmap generation and usage for the default project font.

These project settings only affect the default project font (the one that is hardcoded in the engine binary).

Custom fonts' properties are governed by their respective import options instead. You can use the Import Defaults section of the Project Settings dialog to override default import options for custom fonts.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Using InputEvent — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/inputs/inputevent.html

**Contents:**
- Using InputEvent
- What is it?
- How does it work?
- Anatomy of an InputEvent
- Input actions
- InputMap
- User-contributed notes

Managing input is usually complex, no matter the OS or platform. To ease this a little, a special built-in type is provided, InputEvent. This datatype can be configured to contain several types of input events. Input events travel through the engine and can be received in multiple locations, depending on the purpose.

Here is a quick example, closing your game if the escape key is hit:

However, it is cleaner and more flexible to use the provided InputMap feature, which allows you to define input actions and assign them different keys. This way, you can define multiple keys for the same action (e.g. the keyboard escape key and the start button on a gamepad). You can then more easily change this mapping in the project settings without updating your code, and even build a key mapping feature on top of it to allow your game to change the key mapping at runtime!

You can set up your InputMap under Project > Project Settings > Input Map and then use those actions like this:

Every input event is originated from the user/player (though it's possible to generate an InputEvent and feed them back to the engine, which is useful for gestures). The DisplayServer for each platform will read events from the operating system, then feed them to the root Window.

The window's Viewport does quite a lot of stuff with the received input, in order:

If the Viewport is embedding Windows, the Viewport tries to interpret the event in its capability as a Window-Manager (e.g. for resizing or moving Windows).

Next if an embedded Window is focused, the event is sent to that Window and processed in the Window's Viewport and afterwards treated as handled. If no embedded Window is focused, the event is sent to the nodes of the current viewport in the following order.

First of all, the standard Node._input() function will be called in any node that overrides it (and hasn't disabled input processing with Node.set_process_input()). If any function consumes the event, it can call Viewport.set_input_as_handled(), and the event will not spread any more. This ensures that you can filter all events of interest, even before the GUI. For gameplay input, Node._unhandled_input() is generally a better fit, because it allows the GUI to intercept the events.

Second, it will try to feed the input to the GUI, and see if any control can receive it. If so, the Control will be called via the virtual function Control._gui_input() and the signal "gui_input" will be emitted (this function is re-implementable by script by inheriting from it). If the control wants to "consume" the event, it will call Control.accept_event() and the event will not spread any more. Use the Control.mouse_filter property to control whether a Control is notified of mouse events via Control._gui_input() callback, and whether these events are propagated further.

If so far no one consumed the event, the Node._shortcut_input() callback will be called if overridden (and not disabled with Node.set_process_shortcut_input()). This happens only for InputEventKey, InputEventShortcut and InputEventJoypadButton. If any function consumes the event, it can call Viewport.set_input_as_handled(), and the event will not spread any more. The shortcut input callback is ideal for treating events that are intended as shortcuts.

If so far no one consumed the event, the Node._unhandled_key_input() callback will be called if overridden (and not disabled with Node.set_process_unhandled_key_input()). This happens only if the event is an InputEventKey. If any function consumes the event, it can call Viewport.set_input_as_handled(), and the event will not spread any more. The unhandled key input callback is ideal for key events.

If so far no one consumed the event, the Node._unhandled_input() callback will be called if overridden (and not disabled with Node.set_process_unhandled_input()). If any function consumes the event, it can call Viewport.set_input_as_handled(), and the event will not spread any more. The unhandled input callback is ideal for full-screen gameplay events, so they are not received when a GUI is active.

If no one wanted the event so far, and Object Picking is turned on, the event is used for object picking. For the root viewport, this can also be enabled in Project Settings. In the case of a 3D scene if a Camera3D is assigned to the Viewport, a ray to the physics world (in the ray direction from the click) will be cast. If this ray hits an object, it will call the CollisionObject3D._input_event() function in the relevant physics object. In the case of a 2D scene, conceptually the same happens with CollisionObject2D._input_event().

When sending events to its child and descendant nodes, the viewport will do so, as depicted in the following graphic, in a reverse depth-first order, starting with the node at the bottom of the scene tree, and ending at the root node. Excluded from this process are Windows and SubViewports.

This order doesn't apply to Control._gui_input(), which uses a different method based on event location or focused Control. GUI mouse events also travel up the scene tree, subject to the Control.mouse_filter restrictions described above. However, since these events target specific Controls, only direct ancestors of the targeted Control node receive the event. GUI keyboard and joypad events do not travel up the scene tree, and can only be handled by the Control that received them. Otherwise, they will be propagated as non-GUI events through Node._unhandled_input().

Since Viewports don't send events to other SubViewports, one of the following methods has to be used:

Use a SubViewportContainer, which automatically sends events to its child SubViewports after Node._input() or Control._gui_input().

Implement event propagation based on the individual requirements.

In accordance with Godot's node-based design, this enables specialized child nodes to handle and consume particular events, while their ancestors, and ultimately the scene root, can provide more generalized behavior if needed.

InputEvent is just a base built-in type, it does not represent anything and only contains some basic information, such as event ID (which is increased for each event), device index, etc.

There are several specialized types of InputEvent, described in the table below:

Contains a keycode and Unicode value, as well as modifiers.

InputEventMouseButton

Contains click information, such as button, modifiers, etc.

InputEventMouseMotion

Contains motion information, such as relative and absolute positions and speed.

InputEventJoypadMotion

Contains Joystick/Joypad analog axis information.

InputEventJoypadButton

Contains Joystick/Joypad button information.

InputEventScreenTouch

Contains multi-touch press/release information. (only available on mobile devices)

Contains multi-touch drag information. (only available on mobile devices)

InputEventMagnifyGesture

Contains a position, a factor as well as modifiers.

Contains a position, a delta as well as modifiers.

Contains MIDI-related information.

Contains a generic action. These events are often generated by the programmer as feedback. (more on this below)

Input actions are a grouping of zero or more InputEvents into a commonly understood title (for example, the default "ui_left" action grouping both joypad-left input and a keyboard's left arrow key). They are not required to represent an InputEvent but are useful because they abstract various inputs when programming the game logic.

The same code to work on different devices with different inputs (e.g., keyboard on PC, Joypad on console).

Input to be reconfigured at runtime.

Actions to be triggered programmatically at runtime.

Actions can be created from the Project Settings menu in the Input Map tab and assigned input events.

Any event has the methods InputEvent.is_action(), InputEvent.is_pressed() and InputEvent.is_echo().

Alternatively, it may be desired to supply the game back with an action from the game code (a good example of this is detecting gestures). The Input singleton has a method for this: Input.parse_input_event(). You would normally use it like this:

See Creating input actions for a tutorial on adding input actions in the project settings.

Customizing and re-mapping input from code is often desired. If your whole workflow depends on actions, the InputMap singleton is ideal for reassigning or creating different actions at runtime. This singleton is not saved (must be modified manually) and its state is run from the project settings (project.godot). So any dynamic system of this type needs to store settings in the way the programmer best sees fit.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
func _unhandled_input(event):
    if event is InputEventKey:
        if event.pressed and event.keycode == KEY_ESCAPE:
            get_tree().quit()
```

Example 2 (unknown):
```unknown
public override void _UnhandledInput(InputEvent @event)
{
    if (@event is InputEventKey eventKey)
    {
        if (eventKey.Pressed && eventKey.Keycode == Key.Escape)
        {
            GetTree().Quit();
        }
    }
}
```

Example 3 (unknown):
```unknown
func _process(delta):
    if Input.is_action_pressed("ui_right"):
        # Move right.
```

Example 4 (unknown):
```unknown
public override void _Process(double delta)
{
    if (Input.IsActionPressed("ui_right"))
    {
        // Move right.
    }
}
```

---

## Using NavigationAgents — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/navigation/navigation_using_navigationagents.html

**Contents:**
- Using NavigationAgents
- NavigationAgent Pathfinding
- NavigationAgent Pathfollowing
  - Pathfollowing common problems
- NavigationAgent Avoidance
- NavigationAgent Script Templates
- User-contributed notes

NavigationsAgents are helper nodes that combine functionality for pathfinding, path following and agent avoidance for a Node2D/3D inheriting parent node. They facilitate common calls to the NavigationServer API on behalf of the parent actor node in a more convenient manner for beginners.

2D and 3D version of NavigationAgents are available as NavigationAgent2D and NavigationAgent3D respectively.

New NavigationAgent nodes will automatically join the default navigation map on the World2D/World3D.

NavigationsAgent nodes are optional and not a hard requirement to use the navigation system. Their entire functionality can be replaced with scripts and direct calls to the NavigationServer API.

For more advanced uses consider Using NavigationPathQueryObjects over NavigationAgent nodes.

NavigationAgents query a new navigation path on their current navigation map when their target_position is set with a global position.

The result of the pathfinding can be influenced with the following properties.

The navigation_layers bitmask can be used to limit the navigation meshes that the agent can use.

The pathfinding_algorithm controls how the pathfinding travels through the navigation mesh polygons in the path search.

The path_postprocessing sets if or how the raw path corridor found by the pathfinding is altered before it is returned.

The path_metadata_flags enable the collection of additional path point meta data returned by the path.

The simplify_path and simplify_epsilon properties can be used to remove less critical points from the path.

Disabling path meta flags will disable related signal emissions on the agent.

After a target_position has been set for the agent, the next position to follow in the path can be retrieved with the get_next_path_position() function.

Once the next path position is received, move the parent actor node of the agent towards this path position with your own movement code.

The navigation system never moves the parent node of a NavigationAgent. The movement is entirely in the hands of users and their custom scripts.

NavigationAgents have their own internal logic to proceed with the current path and call for updates.

The get_next_path_position() function is responsible for updating many of the agent's internal states and properties. The function should be repeatedly called once every physics_process until is_navigation_finished() tells that the path is finished. The function should not be called after the target position or path end has been reached as it can make the agent jitter in place due to the repeated path updates. Always check very early in script with is_navigation_finished() if the path is already finished.

The following distance properties influence the path following behavior.

At path_desired_distance from the next path position, the agent advances its internal path index to the subsequent next path position.

At target_desired_distance from the target path position, the agent considers the target position to be reached and the path at its end.

At path_max_distance from the ideal path to the next path position, the agent requests a new path because it was pushed too far off.

The important updates are all triggered with the get_next_path_position() function when called in _physics_process().

NavigationAgents can be used with process but are still limited to a single update that happens in physics_process.

Script examples for various nodes commonly used with NavigationAgents can be found further below.

There are some common user problems and important caveats to consider when writing agent movement scripts.

If an agent queries a path before the navigation map synchronisation, e.g. in a _ready() function, the path might return empty. In this case the get_next_path_position() function will return the same position as the agent parent node and the agent will consider the path end reached. This is fixed by making a deferred call or using a callback e.g. waiting for the navigation map changed signal.

This is usually caused by very frequent path updates every single frame, either deliberate or by accident (e.g. max path distance set too short). The pathfinding needs to find the closest position that are valid on navigation mesh. If a new path is requested every single frame the first path positions might end up switching constantly in front and behind the agent's current position, causing it to dance between the two positions.

If an agent moves very fast it might overshoot the path_desired_distance check without ever advancing the path index. This can lead to the agent backtracking to the path point now behind it until it passes the distance check to increase the path index. Increase the desired distances accordingly for your agent speed and update rate usually fixes this as well as a more balanced navigation mesh polygon layout with not too many polygon edges cramped together in small spaces.

Same as with stuck dancing agents between two positions, this is usually caused by very frequent path updates every single frame. Depending on your navigation mesh layout, and especially when an agent is directly placed over a navigation mesh edge or edge connection, expect path positions to be sometimes slightly "behind" your actors current orientation. This happens due to precision issues and can not always be avoided. This is usually only a visible problem if actors are instantly rotated to face the current path position.

This section explains how to use the navigation avoidance specific to NavigationAgents.

In order for NavigationAgents to use the avoidance feature the avoidance_enabled property must be set to true.

The velocity_computed signal of the NavigationAgent node must be connected to receive the safe velocity calculation result.

Set the velocity of the NavigationAgent node in _physics_process() to update the agent with the current velocity of the agent's parent node.

While avoidance is enabled on the agent the safe_velocity vector will be received with the velocity_computed signal every physics frame. This velocity vector should be used to move the NavigationAgent's parent node in order to avoidance collision with other avoidance using agents or avoidance obstacles.

Only other agents on the same map that are registered for avoidance themself will be considered in the avoidance calculation.

The following NavigationAgent properties are relevant for avoidance:

The property height is available in 3D only. The height together with the current global y-axis position of the agent determines the vertical placement of the agent in the avoidance simulation. Agents using the 2D avoidance will automatically ignore other agents or obstacles that are below or above them.

The property radius controls the size of the avoidance circle, or in case of 3D sphere, around the agent. This area describes the agents body and not the avoidance maneuver distance.

The property neighbor_distance controls the search radius of the agent when searching for other agents that should be avoided. A lower value reduces processing cost.

The property max_neighbors controls how many other agents are considered in the avoidance calculation if they all have overlapping radius. A lower value reduces processing cost but a too low value may result in agents ignoring the avoidance.

The properties time_horizon_agents and time_horizon_obstacles control the avoidance prediction time for other agents or obstacles in seconds. When agents calculate their safe velocities they choose velocities that can be kept for this amount of seconds without colliding with another avoidance object. The prediction time should be kept as low as possible as agents will slow down their velocities to avoid collision in that timeframe.

The property max_speed controls the maximum velocity allowed for the agents avoidance calculation. If the agents parents moves faster than this value the avoidance safe_velocity might not be accurate enough to avoid collision.

The property use_3d_avoidance switches the agent between the 2D avoidance (xz axis) and the 3D avoidance (xyz axis) on the next update. Note that 2D avoidance and 3D avoidance run in separate avoidance simulations so agents split between them do not affect each other.

The properties avoidance_layers and avoidance_mask are bitmasks similar to e.g. physics layers. Agents will only avoid other avoidance objects that are on an avoidance layer that matches at least one of their own avoidance mask bits.

The avoidance_priority makes agents with a higher priority ignore agents with a lower priority. This can be used to give certain agents more importance in the avoidance simulation, e.g. important non-playable characters, without constantly changing their entire avoidance layers or mask.

Avoidance exists in its own space and has no information from navigation meshes or physics collision. Behind the scene avoidance agents are just circles with different radius on a flat 2D plane or spheres in an otherwise empty 3D space. NavigationObstacles can be used to add some environment constrains to the avoidance simulation, see Using NavigationObstacles.

Avoidance does not affect the pathfinding. It should be seen as an additional option for constantly moving objects that cannot be (re)baked to a navigation mesh efficiently in order to move around them.

RVO avoidance makes implicit assumptions about natural agent behavior. E.g. that agents move on reasonable passing sides that can be assigned when they encounter each other. This means that very clinical avoidance test scenarios will commonly fail. E.g. agents moved directly against each other with perfect opposite velocities will fail because the agents can not get their passing sides assigned.

Using the NavigationAgent avoidance_enabled property is the preferred option to toggle avoidance. The following code snippets can be used to toggle avoidance on agents, create or delete avoidance callbacks or switch avoidance modes.

The following sections provides script templates for nodes commonly used with NavigationAgents.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
extends NavigationAgent2D

func _ready() -> void:
    var agent: RID = get_rid()
    # Enable avoidance
    NavigationServer2D.agent_set_avoidance_enabled(agent, true)
    # Create avoidance callback
    NavigationServer2D.agent_set_avoidance_callback(agent, Callable(self, "_avoidance_done"))

    # Disable avoidance
    NavigationServer2D.agent_set_avoidance_enabled(agent, false)
    # Delete avoidance callback
    NavigationServer2D.agent_set_avoidance_callback(agent, Callable())
```

Example 2 (unknown):
```unknown
using Godot;

public partial class MyNavigationAgent2D : NavigationAgent2D
{
    public override void _Ready()
    {
        Rid agent = GetRid();
        // Enable avoidance
        NavigationServer2D.AgentSetAvoidanceEnabled(agent, true);
        // Create avoidance callback
        NavigationServer2D.AgentSetAvoidanceCallback(agent, Callable.From(AvoidanceDone));

        // Disable avoidance
        NavigationServer2D.AgentSetAvoidanceEnabled(agent, false);
        //Delete avoidance callback
        NavigationServer2D.AgentSetAvoidanceCallback(agent, default);
    }

    private void AvoidanceDone() { }
}
```

Example 3 (gdscript):
```gdscript
extends NavigationAgent3D

func _ready() -> void:
    var agent: RID = get_rid()
    # Enable avoidance
    NavigationServer3D.agent_set_avoidance_enabled(agent, true)
    # Create avoidance callback
    NavigationServer3D.agent_set_avoidance_callback(agent, Callable(self, "_avoidance_done"))
    # Switch to 3D avoidance
    NavigationServer3D.agent_set_use_3d_avoidance(agent, true)

    # Disable avoidance
    NavigationServer3D.agent_set_avoidance_enabled(agent, false)
    # Delete avoidance callback
    NavigationServer3D.agent_set_avoidance_callback(agent, Callable())
    # Switch to 2D avoidance
    NavigationServer3D.agent_set_use_3d_avoidance(agent, false)
```

Example 4 (unknown):
```unknown
using Godot;

public partial class MyNavigationAgent3D : NavigationAgent3D
{
    public override void _Ready()
    {
        Rid agent = GetRid();
        // Enable avoidance
        NavigationServer3D.AgentSetAvoidanceEnabled(agent, true);
        // Create avoidance callback
        NavigationServer3D.AgentSetAvoidanceCallback(agent, Callable.From(AvoidanceDone));
        // Switch to 3D avoidance
        NavigationServer3D.AgentSetUse3DAvoidance(agent, true);

        // Disable avoidance
        NavigationServer3D.AgentSetAvoidanceEnabled(agent, false);
        //Delete avoidance callback
        NavigationServer3D.AgentSetAvoidanceCallback(agent, default);
        // Switch to 2D avoidance
        NavigationServer3D.AgentSetUse3DAvoidance(agent, false);
    }

    private void AvoidanceDone() { }
}
```

---

## Using NavigationMaps — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/navigation/navigation_using_navigationmaps.html

**Contents:**
- Using NavigationMaps
- Default navigation maps
- Creating new navigation maps
- User-contributed notes

A NavigationMap is an abstract navigation world on the NavigationServer identified by a NavigationServer RID.

A map can hold and connect a near infinite number of navigation regions with navigation meshes to build the traversable areas of a game world for pathfinding.

A map can contain avoidance agents. Collision avoidance will be calculated based on the agents present in the map.

Different NavigationMaps are completely isolated from each other but navigation regions and avoidance agents can switch between different maps. Switches will become effective on NavigationServer synchronization.

By default Godot creates a navigation map for each World2D and World3D of the root viewport.

The 2D default navigation map RID can be obtained with get_world_2d().get_navigation_map() from any Node2D inheriting Node.

The 3D default navigation map RID can be obtained with get_world_3d().get_navigation_map() from any Node3D inheriting Node.

The NavigationServer can create and support as many navigation maps as required for specific gameplay. Additional navigation maps are created and handled by using the NavigationServer API directly e.g. to support different avoidance agent or actor locomotion types.

For example uses of different navigation maps see Support different actor types and Support different actor locomotion.

Each navigation map individually synchronizes queued changes to its navigation regions and avoidance agents. A navigation map that has not received changes will consume little to no processing time. Navigation regions and avoidance agents can only be part of a single navigation map but they can switch map at any time.

A navigation map switch will take effect only after the next NavigationServer synchronization.

There is no difference between navigation maps created with the NavigationServer2D API or the NavigationServer3D API.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
extends Node2D

func _ready() -> void:
    var default_navigation_map_rid: RID = get_world_2d().get_navigation_map()
```

Example 2 (unknown):
```unknown
public partial class MyNode2D : Node2D
{
    public override void _Ready()
    {
        Rid defaultNavigationMapRid = GetWorld2D().NavigationMap;
    }
}
```

Example 3 (gdscript):
```gdscript
extends Node3D

func _ready() -> void:
    var default_navigation_map_rid: RID = get_world_3d().get_navigation_map()
```

Example 4 (unknown):
```unknown
public partial class MyNode3D : Node3D
{
    public override void _Ready()
    {
        Rid defaultNavigationMapRid = GetWorld3D().NavigationMap;
    }
}
```

---

## Using NavigationPathQueryObjects — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/navigation/navigation_using_navigationpathqueryobjects.html

**Contents:**
- Using NavigationPathQueryObjects
- Creating a basic path query
- Path postprocessing options
- Path simplification
- Path metadata
- Excluding or including regions
- Path clipping and limits
- User-contributed notes

Path query parameters expose various options to improve pathfinding performance or lower memory consumption.

They cater to more advanced pathfinding needs that the high-level nodes can not always cover.

See the respective option sections below.

NavigationPathQueryObjects can be used together with NavigationServer.query_path() to obtain a heavily customized navigation path including optional metadata about the path.

This requires more setup compared to obtaining a normal NavigationPath but lets you tailor the pathfinding and provided path data to the different needs of a project.

NavigationPathQueryObjects consist of a pair of objects, a NavigationPathQueryParameters object holding the customization options for the query and a NavigationPathQueryResult that receives (regular) updates with the resulting path and metadata from the query.

2D and 3D versions of NavigationPathQueryParameters are available as NavigationPathQueryParameters2D and NavigationPathQueryParameters3D respectively.

2D and 3D versions of NavigationPathQueryResult are available as NavigationPathQueryResult2D and NavigationPathQueryResult3D respectively.

Both parameters and result are used as a pair with the NavigationServer.query_path() function.

For the available customization options, see further below. See also the descriptions for each parameter in the class reference.

While not a strict requirement, both objects are intended to be created once in advance, stored in a persistent variable for the agent and reused for every followup path query with updated parameters.

Reusing the same objects improves performance when frequently creating objects or allocating memory.

The following script creates the objects and provides a query_path() function to create new navigation paths. The resulting path is identical to using NavigationServer.map_get_path() while reusing the objects.

Path post-processing differences depending on navigation mesh polygon layout.

A path query search travels from the closest navigation mesh polygon edge to the closest edge along the available polygons. If possible it builds a polygon corridor towards the target position polygon.

This raw "search" polygon corridor path is not very optimized and usually a bad fit for agents to travel along. E.g. the closest edge point on a navigation mesh polygon might cause a huge detour for agents on larger polygons. In order to improve the quality of paths returned by the query various path_postprocessing options exist.

The PATH_POSTPROCESSING_CORRIDORFUNNEL post-processing shortens paths by funneling paths around corners inside the available polygon corridor.

This is the default post-processing and usually also the most useful as it gives the shortest path result inside the available polygon corridor. If the polygon corridor is already suboptimal, e.g. due to a suboptimal navigation mesh layout, the funnel can snap to unexpected polygon corners causing detours.

The PATH_POSTPROCESSING_EDGECENTERED post-processing forces all path points to be placed in the middle of the crossed polygon edges inside the available polygon corridor.

This post-processing is usually only useful when used with strictly tile-like navigation mesh polygons that are all evenly sized and where the expected path following is also constrained to cell centers, e.g. typical grid game with movement constrained to grid cell centers.

The PATH_POSTPROCESSING_NONE post-processing returns the path as is how the pathfinding traveled inside the available polygon corridor.

This post-processing is very useful for debug as it shows how the path search traveled from closest edge point to closet edge point and what polygons it picked. A lot of unexpected or suboptimal path results can be immediately explained by looking at this raw path and polygon corridor.

Path simplification can help steering agents or agents that jitter on thin polygon edges.

Path point difference with or without path simplification.

If simplify_path is enabled a variant of the Ramer-Douglas-Peucker path simplification algorithm is applied to the path. This algorithm straightens paths by removing less relevant path points depending on the simplify_epsilon used.

Path simplification helps with all kinds of agent movement problems in "open fields" that are caused by having many unnecessary polygon edges. E.g. a terrain mesh when baked to a navigation mesh can cause an excessive polygon count due to all the small (but for pathfinding almost meaningless) height variations in the terrain.

Path simplification also helps with "steering" agents because they only have more critical corner path points to aim for.

Path simplification is an additional final post-processing of the path. It adds extra performance costs to the query so only enable when actually needed.

Path simplification is exposed on the NavigationServer as a generic function. It can be used outside of navigation queries for all kinds of position arrays as well.

Disabling unneeded path metadata options can improve performance and lower memory consumption.

A path query can return additional metadata for every path point.

The PATH_METADATA_INCLUDE_TYPES flag collects an array with the primitive information about the point owners, e.g. if a point belongs to a region or link.

The PATH_METADATA_INCLUDE_RIDS flag collects an array with the RIDs of the point owners. Depending on point owner primitive, these RIDs can be used with the various NavigationServer functions related to regions or links.

The PATH_METADATA_INCLUDE_OWNERS flag collects an array with the ObjectIDs of the point owners. These object IDs can be used with @GlobalScope.instance_from_id() to retrieve the node behind that object instance, e.g. a NavigationRegion or NavigationLink node.

By default all path metadata is collected as this metadata can be essential for more advanced navigation gameplay.

E.g. to know what path point maps to what object or node owner inside the SceneTree.

E.g. to know if a path point is the start or end of a navigation link that requires scripted takeover.

For the most basic path uses metadata is not always needed. Path metadata collection can be selectively disabled to gain some performance and reduce memory consumption.

Region filters can greatly help with performance on large navigation maps that are region partitioned.

Query parameters allow limiting the pathfinding to specific region navigation meshes.

If a large navigation map is well partitioned into smaller regions this can greatly help with performance as the query can skip a large number of polygons at one of the earliest checks in the path search.

By default and if left empty all regions of the queried navigation map are included.

If a region RID is added to the excluded_regions array the region's navigation mesh will be ignored in the path search.

If a region RID is added to the included_regions array the region's navigation mesh will be considered in the path search and also all other regions not included will be ignored as well.

If a region ends up both included and excluded it is considered excluded.

Region filters are very effective for performance when paired with navigation region chunks that are aligned on a grid. This way the filter can be set to only include the start position chunk and surrounding chunks instead of the entire navigation map.

Even if the target might be outside these surrounding chunks (can always add more "rings") the pathfinding will try to create a path to the polygon closest to the target. This usually creates half-paths heading in the general direction that are good enough, all for a fraction of the performance cost of a full map search.

The following addition to the basic path query script showcases the idea how to integrate a region chunk mapping with the region filters. This is not a full working example.

Sensibly set limits can greatly help with performance on large navigation maps, especially when targets end up being unreachable.

Clipping returned paths to specific distances.

Query parameters allow clipping returned paths to specific lengths. These options clip the path as a part of post-processing. The path is still searched as if at full length, so it will have the same quality. Path length clipping can be helpful in creating paths that better fit constrained gameplay, e.g. tactical games with limited movement ranges.

The path_return_max_length property can be used to clip the returned path to a specific max length.

The path_return_max_radius property can be used to clip the returned path inside a circle (2D) or sphere (3D) radius around the start position.

Query parameters allow limiting the path search to only search up to a specific distance or a specific number of searched polygons. These options are for performance and affect the path search directly.

The path_search_max_distance property can be used to stop the path search when going over this distance from the start position.

The path_search_max_polygons property can be used to stop the path search when going over this searched polygon number.

When the path search is stopped by reaching a limit the path resets and creates a path from the start position polygon to the polygon found so far that is closest to the target position.

While good for performance, if path search limit values are set too low they can affect the path quality very negatively. Depending on polygon layout and search pattern the returned paths might go into completely wrong directions instead of the direction of the target.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
extends Node2D

# Prepare query objects.
var query_parameters := NavigationPathQueryParameters2D.new()
var query_result := NavigationPathQueryResult2D.new()

func query_path(p_start_position: Vector2, p_target_position: Vector2, p_navigation_layers: int = 1) -> PackedVector2Array:
    if not is_inside_tree():
        return PackedVector2Array()

    var map: RID = get_world_2d().get_navigation_map()

    if NavigationServer2D.map_get_iteration_id(map) == 0:
        # This map has never synced and is empty, no point in querying it.
        return PackedVector2Array()

    query_parameters.map = map
    query_parameters.start_position = p_start_position
    query_parameters.target_position = p_target_position
    query_parameters.navigation_layers = p_navigation_layers

    NavigationServer2D.query_path(query_parameters, query_result)
    var path: PackedVector2Array = query_result.get_path()

    return path
```

Example 2 (gdscript):
```gdscript
extends Node3D

# Prepare query objects.
var query_parameters := NavigationPathQueryParameters3D.new()
var query_result := NavigationPathQueryResult3D.new()

func query_path(p_start_position: Vector3, p_target_position: Vector3, p_navigation_layers: int = 1) -> PackedVector3Array:
    if not is_inside_tree():
        return PackedVector3Array()

    var map: RID = get_world_3d().get_navigation_map()

    if NavigationServer3D.map_get_iteration_id(map) == 0:
        # This map has never synced and is empty, no point in querying it.
        return PackedVector3Array()

    query_parameters.map = map
    query_parameters.start_position = p_start_position
    query_parameters.target_position = p_target_position
    query_parameters.navigation_layers = p_navigation_layers

    NavigationServer3D.query_path(query_parameters, query_result)
    var path: PackedVector3Array = query_result.get_path()

    return path
```

Example 3 (gdscript):
```gdscript
extends Node2D

# ...

var chunk_id_to_region_rid: Dictionary[Vector2i, RID] = {}

func query_path(p_start_position: Vector2, p_target_position: Vector2, p_navigation_layers: int = 1) -> PackedVector2Array:

    # ...

    var regions_around_start_position: Array[RID] = []

    var chunk_rings: int = 1 # Increase for very small regions or more quality.
    var start_chunk_id: Vector2i = floor(p_start_position / float(chunk_size))

    for y: int in range(start_chunk_id.y - chunk_rings, start_chunk_id.y + chunk_rings):
        for x: int in range(start_chunk_id.x - chunk_rings, start_chunk_id.x + chunk_rings):
            var chunk_id: Vector2i = Vector2i(x, y)
            if chunk_id_to_region_rid.has(chunk_id):
                var region: RID = chunk_id_to_region_rid[chunk_id]
                regions_around_start_position.push_back(region)

    query_parameters.included_regions = regions_around_start_position

    # ...
```

Example 4 (gdscript):
```gdscript
extends Node3D

# ...

var chunk_id_to_region_rid: Dictionary[Vector3i, RID] = {}

func query_path(p_start_position: Vector3, p_target_position: Vector3, p_navigation_layers: int = 1) -> PackedVector3Array:

    # ...

    var regions_around_start_position: Array[RID] = []

    var chunk_rings: int = 1 # Increase for very small regions or more quality.
    var start_chunk_id: Vector3i = floor(p_start_position / float(chunk_size))
    var y: int = 0 # Assume a planar navigation map for simplicity.

    for z: int in range(start_chunk_id.z - chunk_rings, start_chunk_id.z + chunk_rings):
        for x: int in range(start_chunk_id.x - chunk_rings, start_chunk_id.x + chunk_rings):
            var chunk_id: Vector3i = Vector3i(x, y, z)
            if chunk_id_to_region_rid.has(chunk_id):
                var region: RID = chunk_id_to_region_rid[chunk_id]
                regions_around_start_position.push_back(region)

    query_parameters.included_regions = regions_around_start_position

    # ...
```

---

## Using NavigationServer — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/navigation/navigation_using_navigationservers.html

**Contents:**
- Using NavigationServer
- Communicating with the NavigationServer
- Threading and Synchronization
- 2D and 3D NavigationServer differences
- Waiting for synchronization
- Server Avoidance Callbacks
- User-contributed notes

2D and 3D version of the NavigationServer are available as NavigationServer2D and NavigationServer3D respectively.

To work with the NavigationServer means to prepare parameters for a query that can be sent to the NavigationServer for updates or requesting data.

To reference the internal NavigationServer objects like maps, regions and agents RIDs are used as identification numbers. Every navigation related node in the scene tree has a function that returns the RID for this node.

The NavigationServer does not update every change immediately but waits until the end of the physics frame to synchronize all the changes together.

Waiting for synchronization is required to apply changes to all maps, regions and agents. Synchronization is done because some updates like a recalculation of the entire navigation map are very expensive and require updated data from all other objects. Also the NavigationServer uses a threadpool by default for some functionality like avoidance calculation between agents.

Waiting is not required for most get() functions that only request data from the NavigationServer without making changes. Note that not all data will account for changes made in the same frame. E.g. if an avoidance agent changed the navigation map this frame the agent_get_map() function will still return the old map before the synchronization. The exception to this are nodes that store their values internally before sending the update to the NavigationServer. When a getter on a node is used for a value that was updated in the same frame it will return the already updated value stored on the node.

The NavigationServer is thread-safe as it places all API calls that want to make changes in a queue to be executed in the synchronization phase. Synchronization for the NavigationServer happens in the middle of the physics frame after scene input from scripts and nodes are all done.

The important takeaway is that most NavigationServer changes take effect after the next physics frame and not immediately. This includes all changes made by navigation related nodes in the scene tree or through scripts.

All setters and delete functions require synchronization.

NavigationServer2D and NavigationServer3D are equivalent in functionality for their dimension.

Technically it is possible to use the tools for creating navigation meshes in one dimension for the other dimension, e.g. baking a 2D navigation mesh with the 3D NavigationMesh when using flat 3D source geometry or creating 3D flat navigation meshes with the polygon outline draw tools of NavigationRegion2D and NavigationPolygons.

At the start of the game, a new scene or procedural navigation changes any path query to a NavigationServer will return empty or wrong.

The navigation map is still empty or not updated at this point. All nodes from the scene tree need to first upload their navigation related data to the NavigationServer. Each added or changed map, region or agent need to be registered with the NavigationServer. Afterward the NavigationServer requires a physics frame for synchronization to update the maps, regions and agents.

One workaround is to make a deferred call to a custom setup function (so all nodes are ready). The setup function makes all the navigation changes, e.g. adding procedural stuff. Afterwards the function waits for the next physics frame before continuing with path queries.

If RVO avoidance agents are registered for avoidance callbacks the NavigationServer dispatches their velocity_computed signals just before the PhysicsServer synchronization.

To learn more about NavigationAgents see Using NavigationAgents.

The simplified order of execution for NavigationAgents that use avoidance:

physics frame starts.

_physics_process(delta).

velocity property is set on NavigationAgent Node.

Agent sends velocity and position to NavigationServer.

NavigationServer waits for synchronization.

NavigationServer synchronizes and computes avoidance velocities for all registered avoidance agents.

NavigationServer sends safe velocity vector with signals for each registered avoidance agents.

Agents receive the signal and move their parent e.g. with move_and_slide or linear_velocity.

PhysicsServer synchronizes.

Therefore moving a physicsbody actor in the callback function with the safe velocity is perfectly thread- and physics-safe as all happens inside the same physics frame before the PhysicsServer commits to changes and does its own calculations.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
extends Node3D

func _ready():
    # Use call deferred to make sure the entire scene tree nodes are setup
    # else await on 'physics_frame' in a _ready() might get stuck.
    custom_setup.call_deferred()

func custom_setup():

    # Create a new navigation map.
    var map: RID = NavigationServer3D.map_create()
    NavigationServer3D.map_set_up(map, Vector3.UP)
    NavigationServer3D.map_set_active(map, true)

    # Create a new navigation region and add it to the map.
    var region: RID = NavigationServer3D.region_create()
    NavigationServer3D.region_set_transform(region, Transform3D())
    NavigationServer3D.region_set_map(region, map)

    # Create a procedural navigation mesh for the region.
    var new_navigation_mesh: NavigationMesh = NavigationMesh.new()
    var vertices: PackedVector3Array = PackedVector3Array([
        Vector3(0, 0, 0),
        Vector3(9.0, 0, 0),
        Vector3(0, 0, 9.0)
    ])
    new_navigation_mesh.set_vertices(vertices)
    var polygon: PackedInt32Array = PackedInt32Array([0, 1, 2])
    new_navigation_mesh.add_polygon(polygon)
    NavigationServer3D.region_set_navigation_mesh(region, new_navigation_mesh)

    # Wait for NavigationServer sync to adapt to made changes.
    await get_tree().physics_frame

    # Query the path from the navigation server.
    var start_position: Vector3 = Vector3(0.1, 0.0, 0.1)
    var target_position: Vector3 = Vector3(1.0, 0.0, 1.0)
    var optimize_path: bool = true

    var path: PackedVector3Array = NavigationServer3D.map_get_path(
        map,
        start_position,
        target_position,
        optimize_path
    )

    print("Found a path!")
    print(path)
```

Example 2 (unknown):
```unknown
using Godot;

public partial class MyNode3D : Node3D
{
    public override void _Ready()
    {
        // Use call deferred to make sure the entire scene tree nodes are setup
        // else await on 'physics_frame' in a _Ready() might get stuck.
        CallDeferred(MethodName.CustomSetup);
    }

    private async void CustomSetup()
    {
        // Create a new navigation map.
        Rid map = NavigationServer3D.MapCreate();
        NavigationServer3D.MapSetUp(map, Vector3.Up);
        NavigationServer3D.MapSetActive(map, true);

        // Create a new navigation region and add it to the map.
        Rid region = NavigationServer3D.RegionCreate();
        NavigationServer3D.RegionSetTransform(region, Transform3D.Identity);
        NavigationServer3D.RegionSetMap(region, map);

        // Create a procedural navigation mesh for the region.
        var newNavigationMesh = new NavigationMesh()
        {
            Vertices =
            [
                new Vector3(0.0f, 0.0f, 0.0f),
                new Vector3(9.0f, 0.0f, 0.0f),
                new Vector3(0.0f, 0.0f, 9.0f),
            ],
        };
        int[] polygon = [0, 1, 2];
        newNavigationMesh.AddPolygon(polygon);
        NavigationServer3D.RegionSetNavigationMesh(region, newNavigationMesh);

        // Wait for NavigationServer sync to adapt to made changes.
        await ToSignal(GetTree(), SceneTree.SignalName.PhysicsFrame);

        // Query the path from the navigation server.
        var startPosition = new Vector3(0.1f, 0.0f, 0.1f);
        var targetPosition = new Vector3(1.0f, 0.0f, 1.0f);

        Vector3[] path = NavigationServer3D.MapGetPath(map, startPosition, targetPosition, optimize: true);

        GD.Print("Found a path!");
        GD.Print((Variant)path);
    }
}
```

---

## Using sanitizers — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/debugging/using_sanitizers.html

**Contents:**
- Using sanitizers
- What are sanitizers?
- Using sanitizers on Godot
- Address sanitizer (ASAN)
- Leak sanitizer (LSAN)
- Memory sanitizer (MSAN)
- Thread sanitizer (TSAN)
- Undefined behavior sanitizer (UBSAN)
- Platform-specific sanitizers
  - Web

Sanitizers are static instrumentation tools that help find bugs that traditional debuggers usually cannot catch. This is particularly useful when combined with Unit testing in continuous integration.

Sanitizers can be used on Windows, macOS and Linux by using the Clang (LLVM), GCC or Visual Studio compilers. Certain platforms may also have their own sanitizers available. In situations where a single sanitizer is provided by several different compilers, remember that their output and behavior will differ slightly.

Sanitizers require recompiling the binary. This means you cannot use official Godot binaries to run sanitizers.

When compiling with any of the sanitizers enabled, the resulting binary will have the .san suffix added to its name to distinguish it from a binary without sanitizers.

There is a performance impact as many additional runtime checks need to be performed. Memory utilization will also increase. It is possible to enable certain combinations of multiple sanitizers in a single build. Beware of the performance impact when using multiple sanitizers at once though, as the resulting binary may be excessively slow.

Certain options can be passed to sanitizers without having to recompile the binary using environment variables.

Available in Clang and GCC.

Supported platforms: Linux, macOS, Windows (Visual Studio), Web

Clang ASAN documentation

The address sanitizer is generally the most frequently used sanitizer. It can diagnose issues such as buffer overruns and out-of-bounds access. If the engine crashes with a message such as free(): invalid pointer, this is typically the result of a buffer overrun. (This message is printed by the C runtime, not Godot.)

In certain situations (such as detecting uninitialized memory reads), the address sanitizer doesn't suffice. The Memory sanitizer (MSAN) should be used instead.

It is also possible to detect use-after-return situations by specifying the ASAN_OPTIONS=detect_stack_use_after_return=1 environment variable before running Godot (not when compiling it). This increases the address sanitizer's runtime overhead, so only enable this feature when you actually need it.

To enable the address sanitizer in a Godot build, pass the use_asan=yes SCons option when compiling. Enabling ASAN generally makes the resulting binary about 2× slower.

Due to a design decision, the address, memory and thread sanitizers are mutually exclusive. This means you can only use one of those sanitizers in a given binary.

Available in Clang and GCC.

Supported platforms: Linux, Web

Clang LSAN documentation

The leak sanitizer can detect memory leaks, which are situations where memory that is no longer in use is never freed by the running program. This can potentially lead to out-of-memory situations if the program runs for long enough. Since Godot may run on dedicated servers for months or even years without a restart, it's important to fix memory leaks when they occur.

To enable the leak sanitizer in a Godot build, pass the use_lsan=yes SCons option when compiling. Enabling LSAN only has a small performance overhead, but the program will be much slower to exit as leak detection occurs when the program exits.

Available in Clang only, not GCC.

Supported platforms: Linux

Clang MSAN documentation

The memory sanitizer complements the Address sanitizer (ASAN). Unlike the address sanitizer, the memory sanitizer can detect uninitialized memory reads.

To enable the memory sanitizer in a Godot build, pass the use_msan=yes SCons option when compiling. Enabling MSAN generally makes the resulting binary about 3× slower.

Due to a design decision, the address, memory and thread sanitizers are mutually exclusive. This means you can only use one of those sanitizers in a given binary.

Available in Clang and GCC.

Supported platforms: Linux, macOS

Clang TSAN documentation

The thread sanitizer is used to track down race conditions related to multithreading. A race condition is when multiple threads try to modify the same data at the same time. Since thread scheduling can be ordered in any fashion by the operating system, this leads to incorrect behavior that only occurs occasionally (and can be difficult to track as a result). To prevent a race condition, you need to add a lock to ensure only one thread can access the shared data at a given time.

To enable the thread sanitizer in a Godot build, pass the use_tsan=yes SCons option when compiling. Enabling TSAN generally makes the resulting binary 10× slower, while also multiplying memory usage by an approximately 8× factor.

Due to a design decision, the address, memory and thread sanitizers are mutually exclusive. This means you can only use one of those sanitizers in a given binary.

On Linux, if you stumble upon the following error:

FATAL: ThreadSanitizer: unexpected memory mapping

You may need to temporarily lower the Address Space Layout Randomization (ASLR) entropy in your system with:

Or preferably disable it entirely with:

And as soon as you are done with the thread sanitizer, increase the ASLR entropy with:

Or re-enable ASLR with:

Rebooting your machine will also revert the ASLR state to its default values.

It's important to revert the changes as soon as possible because lowering the ASLR entropy or disabling ASLR entirely can be a security risk.

Available in Clang and GCC.

Supported platforms: Linux, macOS, Web

Clang UBSAN documentation

The undefined behavior sanitizer is used to track down situations where the program exhibits random and unpredictable behavior. This is due to C/C++ code that is accepted by the compiler, but is not correct. Compiling with a different set of optimizations can also change the observed results of undefined behavior.

To enable the undefined behavior sanitizer in a Godot build, pass the use_ubsan=yes SCons option when compiling. Enabling UBSAN only has a small performance overhead.

When compiling for the Web, there are 2 additional sanitizer SCons options available:

use_assertions=yes enables runtime Emscripten assertions, which can catch various issues.

use_safe_heap=yes enables Emscripten's SAFE_HEAP sanitizer. It provides similar functionality to ASAN, but it focuses on issues that are specific to WebAssembly. SAFE_HEAP is not guaranteed to be compatible with ASAN and UBSAN in the same binary, so you may have to build it separately.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
sudo sysctl vm.mmap_rnd_bits=28
```

Example 2 (unknown):
```unknown
sudo sysctl kernel.randomize_va_space=0
```

Example 3 (unknown):
```unknown
sudo sysctl vm.mmap_rnd_bits=32
```

Example 4 (unknown):
```unknown
sudo sysctl kernel.randomize_va_space=2
```

---

## Using the Android editor — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/editor/using_the_android_editor.html

**Contents:**
- Using the Android editor
- Android devices support
- Runtime Permissions
- Tips & Tricks
- Limitations & known issues
- User-contributed notes

In 2023, we added an Android port of the editor that can be used to create, develop, and export 2D and 3D projects on Android devices.

The app can be downloaded from the Godot download page or from the Google Play Store.

The Android editor is in early access, while we continue to refine the experience. See Limitations & known issues below.

The Android editor requires devices running Android 5 Lollipop or higher, with at least OpenGL 3 support. This includes (not exhaustive):

Android tablets, foldables and large phones

Android-powered netbooks

Chromebooks supporting Android apps

All files access permission: Enables the editor to create, import, and read project files from any file locations on the device. Without this permission, the editor is still functional, but has limited access to the device's files and directories.

REQUEST_INSTALL_PACKAGES: Enables the editor to install exported project APKs.

RECORD_AUDIO: Requested when the audio/driver/enable_input project setting is enabled.

For the best experience and high level of productivity, connecting a bluetooth keyboard & mouse is recommended to interact with the Android editor. The Android editor supports all of the usual shortcuts and key mappings.

When interacting with keyboard & mouse, you can decrease the size of the scrollbar using the interface/touchscreen/increase_scrollbar_touch_area editor setting.

For 2D projects, the block coding plugin can provide a block-based visual alternative to composing scripts when lacking a connected hardware keyboard.

On smaller devices, enabling and using picture-in-picture (PiP) mode provides the ability to easily transition between the Editor and the Play window.

PiP can be enabled via the run/window_placement/play_window_pip_mode editor setting.

The run/window_placement/android_window editor setting can be used to specify whether the Play window should always launch in PiP mode.

Note: In PiP mode, the Play window does not have input access.

Syncing projects via Git can be done by downloading an Android Git client. We recommend the Termux terminal, an Android terminal emulator which provides access to common terminal utilities such Git and SSH.

Note: To use Git with the Termux terminal, you'll need to grant WRITE permission to the terminal. This can be done by running the following command from within the terminal: termux-setup-storage

GDExtension plugins work as expected, but require the plugin developer to provide native Android binaries.

Here are the known limitations and issues of the Android editor:

No gradle build support.

No support for Android plugins as they require gradle build support. GDExtensions plugins are supported.

No support for external script editors.

While available, the Vulkan Forward+ renderer is not recommended due to severe performance issues.

UX not optimized for Android phones form-factor.

Android Go devices lacks the All files access permission required for device read/write access. As a workaround, when using an Android Go device, it's recommended to create new projects only in the Android Documents or Downloads directories.

The editor doesn't properly resume when Don't keep activities is enabled in the Developer Options.

There is a bug with the Samsung keyboard that causes random input to be inserted when writing scripts. It's recommended to use the Google keyboard (Gboard) instead.

See the list of open issues on GitHub related to the Android editor for a list of known bugs.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Using the Asset Library — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/community/asset_library/using_assetlib.html

**Contents:**
- Using the Asset Library
- On the website
  - Overview
  - Searching
  - Breakdown of an asset
  - Registering and logging in
- In the editor
- User-contributed notes

As mentioned before, you can access the web frontend of the Asset Library on Godot's official website. This is what it looks like when you first visit it:

At the top, you see the header, which takes you to various other parts of the AssetLib - at the moment, it's empty, as we are not logged in.

In the left sidebar is the search bar + settings section, and the assets section takes up the main content area on the right. Below the search bar, you can filter assets by category (such as 2D tools, scripts and demos), support level, engine version, and license. You can also change the sorting order to sort by license, name, or update date.

While most other filter settings should be fairly self-explanatory, it's worth going over what "support level" means in the Asset Library. Currently there are three support levels, and each asset can belong to only one.

Featured assets are hand-picked resources recognized for their value to the community.

Community assets are submitted and maintained by the members of the Godot community.

Testing assets are works-in-progress, and may contain bugs and usability issues. They are not recommended for use in serious projects, but you are encouraged to download, test them, and submit issues to the original authors.

You can mix and match any of the search filters and criteria, and upon clicking the Search button, receive the list of all assets in the Library that match them.

Note that the search results are not updated in real-time, so you will have to re-submit the search query each time you change the query settings.

Now let's take a look at what an asset's page looks like and what it contains.

Asset's thumbnail/icon.

Current version number of the asset.

Asset's category, Godot version, and support status.

Asset's original author/submitter.

The license the asset is distributed under.

The date of the asset's latest edit/update.

A textual description of the asset.

Links related to the asset (download link, file list, issue tracker).

Images and videos showcasing the asset.

In order to upload assets to the AssetLib, you need to be logged in, and to do that, you need a registered user account. In the future, this may also give you access to other features, such as commenting on or rating the existing assets. You do not need to be logged in to browse and download the assets.

The login/registration page can be accessed from the AssetLib header.

From here, you can register your account, which requires a valid email address, a username, and a (preferably strong) password.

Then, you can use your username and password to log in.

This will change the look of the AssetLib header. Now you get access to a handful of new functions:

The feed, which shows a list of status updates on your submitted assets (and possibly more in the future).

A list of your uploaded assets.

The ability to submit new assets.

You can learn how to submit assets to the Library, and what the asset submission guidelines are, in the next part of this tutorial, Submitting to the Asset Library.

The editor will display different categories of assets depending on whether you're browsing the Project Manager's Asset Library Projects tab or the editor's AssetLib tab.

The Project Manager's Asset Library Projects tab will only display assets that are standalone projects by themselves. This is denoted on the asset library with the Templates, Demos and Projects categories.

The editor's AssetLib tab will only display assets that are not standalone projects by themselves. In other words, it will display assets from all categories except Templates, Demos and Projects.

You can also access the AssetLib directly from Godot:

Click on it, and Godot will fetch info about the assets from the AssetLib. Once it's finished, you will see a window similar to what the AssetLib website looks like, with some differences:

Similarly to the web version of the AssetLib, here you can search for assets by category, name, and sort them by factors such as name or edit date.

Notably, you can only fetch assets for the current version of Godot you are running. Projects, Demos and Templates can be downloaded from the Project Manager view of the AssetLib. Addons (tools, scripts, materials etc.) can be downloaded from the in-project AssetLib and added to the current project. In addition, unlike when using the web frontend, the search results are updated in real-time (you do not have to press Search after every change to your search query for the changes to take place).

In the future, you will be able to choose a different AssetLib provider to fetch assets from (using the Site dropdown menu), however currently only the official Godot website version of the AssetLib is supported, as well as the version that may be running on your local machine's web server (the localhost option).

When you click on an asset, you will see more information about it.

If you click on the Install button, Godot will fetch an archive of the asset, and will track download progress of it at the bottom of the editor window. If the download fails, you can retry it using the Retry button.

When it finishes, you can proceed to install it using the Install button. This will bring up the Package Installer window.

Here you can see a list of all the files that will be installed. You can tick off any of the files that you do not wish to install, and Godot will also inform you about any problems with files that it cannot install. These files will be shown in red, and hovering over them will show you a message stating why it cannot be installed.

Once you are done, you can press the Install button, which will unzip all the files in the archive, and import any assets contained therein, such as images or 3D models. Once this is done, you should see a message stating that the Package installation is complete.

You may also use the Import button to import asset archives obtained elsewhere (such as downloading them directly from the AssetLib web frontend), which will take you through the same package installation procedure as with the assets downloaded directly via Godot that we just covered.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Using the engine compilation configuration editor — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/editor/using_engine_compilation_configuration_editor.html

**Contents:**
- Using the engine compilation configuration editor
- Limitations
- User-contributed notes

Godot comes with a large set of built-in features. While this is convenient, this also means its binary size is larger than it could be, especially for projects that only use a small portion of its feature set.

To help reduce binary size, it is possible to compile custom export templates with certain features disabled. This is described in detail in Optimizing a build for size. However, determining which features need to be disabled can be a tedious task. The engine compilation configuration editor aims to address this by providing an interface to view and manage these features easily, while also being able to detect the features currently being used in the project.

The Project > Tools > Engine Compilation Configuration Editor allows you to create and manage build profiles for your Godot project.

From now on, you have two possibilities:

View the list and manually uncheck features that you don't need.

Use the Detect from Project button to automatically detect features currently used in the project and disable unused features. Note that this will override the existing list of features, so if you have manually unchecked some items, their state will be reset based on whether the project actually uses the feature.

Opening the Engine Compilation Configuration Editor

Once you click Detect from Project, the project detection step will run. This can take from a few seconds up to several minutes depending on the project size. Once detection is complete, you'll see an updated list of features with some features disabled:

Updated features list after using feature detection (example from the 3D platformer demo)

Unchecking features in this dialog will not reduce binary size directly on export. Since it is only possible to actually remove features from the binary at compile-time, you still need to compile custom export templates with the build profile specified to actually benefit from the engine compilation configuration editor.

You can now save the build profile by clicking Save As at the top. The build profile can be saved in any location, but it's a good idea to save it somewhere in your project folder and add it to version control to be able to go back to it later when needed. This also allows using version control to track changes to the build profile.

The build profile is a JSON file (and .gdbuild extension) that looks like this after detection in the above example:

This file can be passed as a SCons option when compiling export templates:

The buildsystem will use this to disable unused classes and reduce binary size as a result.

The Detect from Project functionality relies on reading the project's scenes and scripts. It will not be able to detect used features in the following scenarios:

Features that are used in GDScripts that are procedurally created then run at runtime.

Features that are used in expressions.

Features that are used in GDExtensions, unless the language binding allows for defining used classes and the extension makes use of the functionality. See GH-104129 for details.

Features that are used in external PCKs loaded at runtime.

Certain edge cases may exist. If unsure, please open an issue on GitHub with a minimal reproduction project attached.

You can achieve further size reductions by passing other options that reduce binary size. See Optimizing a build for size for more information.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
{
    "disabled_build_options": {
        "disable_navigation_3d": true,
        "disable_xr": true,
        "module_godot_physics_3d_enabled": false,
        "module_msdfgen_enabled": false,
        "module_openxr_enabled": false
    },
    "disabled_classes": [
        "AESContext",
        ...
        "ZIPReader"
    ],
    "type": "build_profile"
}
```

Example 2 (unknown):
```unknown
scons target=template_release build_profile=/path/to/profile.gdbuild
```

---

## Using the Project Manager — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/editor/project_manager.html

**Contents:**
- Using the Project Manager
- Creating and importing projects
  - Using the file browser
- Opening and importing projects
- Downloading demos and templates
- Managing projects with tags
- Recovery Mode
- User-contributed notes

When you launch Godot, the first window you see is the Project Manager. It lets you create, remove, import, or play game projects:

To change the editors language click on the Settings Button in the top right corner:

In Project Manager Settings, you can change the interface language from the language dropdown menu, which is the system default language by default.

You can also change the theme of the editor, the display scale for different interface element sizes, and the availability of online functionality using network mode. If network mode is online, Godot will also check and inform you about new versions of Godot.

The directory naming convention can also be changed to replace spaces according to the chosen format when creating folders automatically.

To create a new project:

Click the Create button on the top-left of the window.

Give the project a name, then open the file browser using the Browse button, and choose an empty folder on your computer to save the files. Alternatively, you can enable Create Folder option to automatically create a new sub-folder with the project name, following the directory naming convention set in the settings. An empty folder will show a green tick on the right.

Select one of the renderers (this can also be changed later).

Click the Create & Edit button to create the project folder and open it in the editor.

You can optionally choose a version control system. Currently, only git is supported and it needs the Godot Git Plugin to be installed, either manually or using the Asset Library. To learn more about the Godot Git Plugin, see its wiki.

From the Create New Project window, click the Browse button to open Godot's file browser. You can pick a location or type the folder's path in the Path field, after choosing a drive.

Left of the path field on the top row contains arrows to navigate backward and forward through the last visited locations. The up arrow navigates to parent folder. On the right side of the path field, there are buttons to refresh the current folder's contents, favorite/unfavorite the current folder, and show/hide hidden folders.

Next, the buttons to switch the display type of the folders and files between grid view and list view are seen.

The last button on the right will create a new folder.

Favorited folders will be displayed on the left side under the Favorites section. You can sort the favorites using the up and down buttons in this section. Last chosen folders will be listed under the Recent list.

The next time you open the Project Manager, you'll see your new project in the list. Double click on it to open it in the editor.

You can similarly import existing projects using the Import button. Locate the folder that contains the project or the project.godot file to import and edit it.

Alternatively, it is possible to choose a zip file to be automatically extracted by Godot.

When the folder path is correct, you'll see a green checkmark.

From the Asset Library tab you can download open source project templates and demos from the Asset Library to help you get started faster.

The first time you open this tab you'll notice that it's asking you to go online. For privacy reasons the project manager, and Godot editor, can't access the internet by default. To enable accessing the internet click the Go Online button. This will also allow project manager to notify you about updates. If you wish to turn this off in the future go into project manager settings and change Network Mode to "Offline"

Now that Godot is connected to the internet you can download a demo or template, to do this:

On the page that opens, click the download button.

Once it finished downloading, click install and choose where you want to save the project.

For users with a lot of projects on one PC it can be a lot to keep track of. To aid in this Godot allows you to create project tags. To add a tag to a project click on the project in the project manager, then click on the Manage Tags button

This will open up the manage project tags window. To add a tag click the plus button.

Type out the tag name, and click OK. Your project will now have a tag added to it. These tags can be used for any other project in your project manager.

To show projects with a specific tag only, you can click on the tags or write tag: and type the tag you would like to search for in the filter bar. To limit the results using multiple tags, you can click on another tag or add tag: after a space and type another tag in the filter bar.

In addition, tags will stay with projects. So if you tag your project, send it to another machine, and import it into the project manager you will see the tags you created.

To remove a tag from your project manager it must be removed from all the projects it's used by. Once that's done close the project manager, open it up again, and the tag should be gone.

If a project is immediately crashing on startup, or crashing frequently during editing it can be opened in recovery mode, to attempt to make it more stable while looking for the source of the crashing to fix it.

Usually a project should open in recovery mode automatically when you re-open it after a crash. If it doesn't you can manually open recovery mode by selecting the project in the project manager, to do that select the project from your list of projects, click the dropdown button next to the edit node, and select Edit in recovery mode.

While in recovery mode the following are disabled:

Automatic scene restoring

It is recommended that you backup your project before editing it in recovery mode.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Using the theme editor — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/ui/gui_using_theme_editor.html

**Contents:**
- Using the theme editor
- Creating a theme
- Theme editor overview
  - Theme previews
  - Theme types and items
- Manage and import items
- User-contributed notes

This article explains how to create and manage UI themes using the Godot editor and its theme editor tool. We recommend getting familiar with the basics behind GUI skinning/theming by reading Introduction to GUI skinning before starting.

The theme editor is a bottom panel tool that activates automatically, when a Theme resource is selected for editing. It contains the necessary UI for adding, removing, and adjusting theme types and theme items. It features a preview section for testing your changes live, as well as a window dialog for doing bulk operations of the theme items.

Like any other resources, themes can be created directly in the file system dock by right-clicking and selecting New Resource..., then selecting Theme and clicking Create. This is especially useful for creating project-wide themes.

Themes also can be created from any control node. Select a control node in the scene hierarchy, then in the inspector go to the theme property. From there you can select New Theme.

This will create an empty theme and open up the theme editor. Keep in mind that resources created this way are bundled with the scene by default. Use the context menu to save the new theme to a file instead.

While the theme editor provides the tools to manage theme types and items, themes also include the default, fallback font that you can edit only using the Inspector dock. Same applies to the contents of complex resource types, such as StyleBoxes and icons — they open for editing in the Inspector.

The theme editor has two main parts. The main theme editor, located at the bottom of the Godot editor, aims to provide users with tools to quickly create, edit, and delete theme items and types. It gives visual tools for picking and changing controls, abstracting the underlying theme concepts. The Manage Theme Items dialog, on the other hand, tries to address the needs of those who want to change themes manually. It's also useful for creating a new editor theme.

The left-hand side of the main editor has a set of preview tabs. The Default Preview tab is visible out of the box and contains most of the frequently used controls in various states. Previews are interactive, so intermediate states (e.g. hover) can be previewed as well.

Additional tabs can be created from arbitrary scenes in your project. The scene must have a control node as its root to function as a preview. To add a new tab click the Add Preview button and select the saved scene from your file system.

If you make changes to the scene, they will not be reflected in the preview automatically. To update the preview click the reload button on the toolbar.

Previews can also be used to quickly select the theme type to edit. Select the picker tool from the toolbar and hover over the preview area to highlight control nodes. Highlighted control nodes display their class name, or type variation if available. Clicking on the highlighted control opens it for editing on the right-hand side.

The right-hand side of the theme editor provides a list of theme types available in the edited theme resource, and the contents of the selected type. The list of type's items is divided into several tabs, corresponding to each data type available in the theme (colors, constants, styles, etc.). If the Show Default option is enabled, then for each built-in type its default theme values are displayed, greyed out. If the option is disabled, only the items available in the edited theme itself are displayed.

Individual items from the default theme can be added to the current theme by clicking on the Override button next to the item. You can also override all the default items of the selected theme type by clicking on the Override All button. Overridden properties can then be removed with the Remove Item button. Properties can also be renamed using the Rename Item button, and completely custom properties can be added to the list using the text field below it.

Overridden theme items can be edited directly in the right-hand panel, unless they are resources. Resources have rudimentary controls available for them, but must be edited in the Inspector dock instead.

Styleboxes have a unique feature available, where you can pin an individual stylebox from the list. Pinned stylebox acts like the leader of the pack, and all styleboxes of the same type are updated alongside it when you change its properties. This allows you to edit properties of several styleboxes at the same time.

While theme types can be picked from a preview, they can also be added manually. Clicking the plus button next to the type list opens the Add item Type menu. In that menu you can either select a type from the list, or you can enter an arbitrary name to create a custom type. Text field also filters the list of control nodes.

Clicking the Manage Items button brings up the Manage Theme Items dialog.

In the Edit Items tab you can view and add theme types, as well as view and edit the theme items of the selected type.

You can create, rename and remove individual theme items here by clicking the corresponding Add X Item and specifying their name. You can also mass delete theme items either by their data type (using the brush icon in the list) or by their quality. Remove Class Items will remove all built-in theme items you have customized for a control node type. Remove Custom Items will remove all the custom theme items for the selected type. Finally, Remove All Items will remove everything from the type.

From the Import Items tab you can import theme items from other themes. You can import items from the default Godot theme, the Godot editor theme, or another custom theme. You can import individual or multiple items, and you can decide whether to copy or omit their data as well. There are several ways you can select and deselect the items, including by hand, by hierarchy, by data type, and everything. Opting to include the data will copy all theme items as they are to your theme. Omitting the data will create the items of the corresponding data type and name, but will leave them empty, creating a template of a theme in a way.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Using the Web editor — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/editor/using_the_web_editor.html

**Contents:**
- Using the Web editor
- Browser support
- Limitations
- Importing a project
- Editing and running a project
- Where are my project files?
- User-contributed notes

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

There is a Web editor you can use to work on new or existing projects.

The web editor is in a preliminary stage. While its feature set may be sufficient for educational purposes, it is currently not recommended for production work. See Limitations below.

The Web editor requires support for WebAssembly's SharedArrayBuffer. This is in turn required to support threading in the browser. The following desktop browsers support WebAssembly threading and can therefore run the web editor:

Opera and Safari are not supported yet. Safari may work in the future once proper threading support is added.

Mobile browsers are currently not supported.

The web editor only supports the Compatibility rendering method, as there is no stable way to run Vulkan applications on the web yet.

If you use Linux, due to poor Firefox WebGL performance, it's recommended to use a Chromium-based browser instead of Firefox.

Due to limitations on the Godot or Web platform side, the following features are currently missing:

No GDExtension support.

No debugging support. This means GDScript debugging/profiling, live scene editing, the Remote Scene tree dock and other features that rely on the debugger protocol will not work.

No project exporting. As a workaround, you can download the project source using Project > Tools > Download Project Source and export it using a native version of the Godot editor.

The editor won't warn you when closing the tab with unsaved changes.

No lightmap baking support. You can still use existing lightmaps if they were baked with a native version of the Godot editor (e.g. by importing an existing project).

The following features are unlikely to be supported due to inherent limitations of the Web platform:

No support for external script editors.

No support for Android one-click deploy.

See the list of open issues on GitHub related to the web editor for a list of known bugs.

To import an existing project, the current process is as follows:

Specify a ZIP file to preload on the HTML5 filesystem using the Preload project ZIP input.

Run the editor by clicking Start Godot editor. The Godot Project Manager should appear after 10-20 seconds. On slower machines or connections, loading may take up to a minute.

In the dialog that appears at the middle of the window, specify a name for the folder to create then click the Create Folder button (it doesn't have to match the ZIP archive's name).

Click Install & Edit and the project will open in the editor.

It's important to place the project folder somewhere in /home/web_user/. If your project folder is placed outside /home/web_user/, you will lose your project when closing the editor!

When you follow the steps described above, the project folder will always be located in /home/web_user/projects, keeping it safe.

Unlike the native version of Godot, the web editor is constrained to a single window. Therefore, it cannot open a new window when running the project. Instead, when you run the project by clicking the Run button or pressing F5, it will appear to "replace" the editor window.

The web editor offers an alternative way to deal with the editor and game windows (which are now "tabs"). You can switch between the Editor and Game tabs using the buttons on the top. You can also close the running game or editor by clicking the × button next to those tabs.

Due to browser security limitations, the editor will save the project files to the browser's IndexedDB storage. This storage isn't accessible as a regular folder on your machine, but is abstracted away in a database.

You can download the project files as a ZIP archive by using Project > Tools > Download Project Source. This can be used to export the project using a native Godot editor, since exporting from the web editor isn't supported yet.

In the future, it may be possible to use the HTML5 FileSystem API to store the project files on the user's filesystem as the native editor would do. However, this isn't implemented yet.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Using the XR editor — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/editor/using_the_xr_editor.html

**Contents:**
- Using the XR editor
- XR devices support
- Runtime Permissions
- Tips & Tricks
- Limitations & known issues
- User-contributed notes

In 2024, we introduced the Godot XR editor, a version of the Godot editor designed to run natively on XR devices, enabling the creation, development and export of 2D, 3D, and XR apps and games directly on device.

The app can be downloaded from the Meta Horizon Store, or from the Godot download page.

The XR editor is in early access, while we continue to refine the experience. See Limitations & known issues below.

For now, the Godot XR editor is only available for the following Meta Quest devices running Meta Horizon OS v69 or higher:

We are working to add support for more XR devices, including PCVR devices.

All files access permission: Enables the editor to create, import, and read project files from any file locations on the device. Without this permission, the editor is still functional, but has limited access to the device's files and directories.

REQUEST_INSTALL_PACKAGES: Enables the editor to install exported project APKs.

RECORD_AUDIO: Requested when the audio/driver/enable_input project setting is enabled.

USE_SCENE: Required to enable and access the scene APIs when running an XR project.

For the best experience and high level of productivity, connecting a bluetooth keyboard & mouse is recommended to interact with the XR editor. The XR editor supports all of the usual shortcuts and key mappings.

When interacting with tracked controllers or tracked hands, you can toggle on the interface/touchscreen/enable_long_press_as_right_click editor setting to enable right-click by long press.

When interacting with tracked controllers or tracked hands, you can increase the size of the scrollbar using the interface/touchscreen/increase_scrollbar_touch_area editor setting.

Theater View can be used to fullscreen the Editor window.

Enable Seamless Multitasking, available in the Quest Experimental Settings, to enable the ability to quickly transition between a running XR project and the Editor window.

When developing a non-XR project, the Godot editor app icon will provide the ability to switch between the Editor window and the Play window when the latter is active, using Quest's App menu feature.

When developing and running an XR project, you can bring back the Editor window by:

Pressing on the Meta button to invoke the menu bar

Clicking on the Godot editor app icon to summon the App menu, and select the Editor window tile.

Syncing projects via Git can be done by downloading an Android Git client. We recommend the Termux terminal, an Android terminal emulator which provides access to common terminal utilities such Git and SSH.

Note: To use Git with the Termux terminal, you'll need to grant WRITE permission to the terminal. This can be done by running the following command from within the terminal: termux-setup-storage

GDExtension plugins work as expected, but require the plugin developer to provide native Android binaries.

Here are the known limitations and issues of the XR editor:

No Meta Quest 2 support due to the limited amount of memory on the device. However advanced users can grab the XR editor APK from the download page and sideload it onto their device if they desire to do so.

No gradle build support.

No support for Android plugins as they require gradle build support. GDExtension plugins are supported.

No support for external script editors.

While available, the Vulkan Forward+ renderer is not recommended due to severe performance issues.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Using WebSockets — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/networking/websocket.html

**Contents:**
- Using WebSockets
- HTML5 and WebSocket
- Using WebSocket in Godot
  - Minimal client example
  - Minimal server example
  - Advanced chat demo
- User-contributed notes

The WebSocket protocol was standardized in 2011 with the original goal of allowing browsers to create stable and bidirectional connections with a server. Before that, browsers used to only support HTTP requests, which aren't well-suited for bidirectional communication.

The protocol is message-based and a very powerful tool to send push notifications to browsers. It has been used to implement chats, turn-based games, and more. It still uses a TCP connection, which is good for reliability but not for latency, so it's not good for real-time applications like VoIP and fast-paced games (see WebRTC for those use cases).

Due to its simplicity, its wide compatibility, and being easier to use than a raw TCP connection, WebSocket started to spread outside the browsers, in native applications as a mean to communicate with network servers.

Godot supports WebSocket in both native and web exports.

WebSocket is implemented in Godot via WebSocketPeer. The WebSocket implementation is compatible with the High-Level Multiplayer. See section on high-level multiplayer for more details.

When exporting to Android, make sure to enable the INTERNET permission in the Android export preset before exporting the project or using one-click deploy. Otherwise, network communication of any kind will be blocked by Android.

This example will show you how to create a WebSocket connection to a remote server, and how to send and receive data.

This will print something similar to:

This example will show you how to create a WebSocket server that listens for remote connections, and how to send and receive data.

When a client connects, this will print something similar to this:

A more advanced chat demo which optionally uses the multiplayer mid-level abstraction and a high-level multiplayer demo are available in the godot demo projects under networking/websocket_chat and networking/websocket_multiplayer.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
extends Node

# The URL we will connect to.
# Use "ws://localhost:9080" if testing with the minimal server example below.
# `wss://` is used for secure connections,
# while `ws://` is used for plain text (insecure) connections.
@export var websocket_url = "wss://echo.websocket.org"

# Our WebSocketClient instance.
var socket = WebSocketPeer.new()


func _ready():
    # Initiate connection to the given URL.
    var err = socket.connect_to_url(websocket_url)
    if err == OK:
        print("Connecting to %s..." % websocket_url)
        # Wait for the socket to connect.
        await get_tree().create_timer(2).timeout

        # Send data.
        print("> Sending test packet.")
        socket.send_text("Test packet")
    else:
        push_error("Unable to connect.")
        set_process(false)


func _process(_delta):
    # Call this in `_process()` or `_physics_process()`.
    # Data transfer and state updates will only happen when calling this function.
    socket.poll()

    # get_ready_state() tells you what state the socket is in.
    var state = socket.get_ready_state()

    # `WebSocketPeer.STATE_OPEN` means the socket is connected and ready
    # to send and receive data.
    if state == WebSocketPeer.STATE_OPEN:
        while socket.get_available_packet_count():
            var packet = socket.get_packet()
            if socket.was_string_packet():
                var packet_text = packet.get_string_from_utf8()
                print("< Got text data from server: %s" % packet_text)
            else:
                print("< Got binary data from server: %d bytes" % packet.size())

    # `WebSocketPeer.STATE_CLOSING` means the socket is closing.
    # It is important to keep polling for a clean close.
    elif state == WebSocketPeer.STATE_CLOSING:
        pass

    # `WebSocketPeer.STATE_CLOSED` means the connection has fully closed.
    # It is now safe to stop polling.
    elif state == WebSocketPeer.STATE_CLOSED:
        # The code will be `-1` if the disconnection was not properly notified by the remote peer.
        var code = socket.get_close_code()
        print("WebSocket closed with code: %d. Clean: %s" % [code, code != -1])
        set_process(false) # Stop processing.
```

Example 2 (unknown):
```unknown
Connecting to wss://echo.websocket.org...
< Got text data from server: Request served by 7811941c69e658
> Sending test packet.
< Got text data from server: Test packet
```

Example 3 (javascript):
```javascript
extends Node

# The port we will listen to.
const PORT = 9080

# Our TCP Server instance.
var _tcp_server = TCPServer.new()

# Our connected peers list.
var _peers: Dictionary[int, WebSocketPeer] = {}

var last_peer_id := 1


func _ready():
    # Start listening on the given port.
    var err = _tcp_server.listen(PORT)
    if err == OK:
        print("Server started.")
    else:
        push_error("Unable to start server.")
        set_process(false)


func _process(_delta):
    while _tcp_server.is_connection_available():
        last_peer_id += 1
        print("+ Peer %d connected." % last_peer_id)
        var ws = WebSocketPeer.new()
        ws.accept_stream(_tcp_server.take_connection())
        _peers[last_peer_id] = ws

    # Iterate over all connected peers using "keys()" so we can erase in the loop
    for peer_id in _peers.keys():
        var peer = _peers[peer_id]

        peer.poll()

        var peer_state = peer.get_ready_state()
        if peer_state == WebSocketPeer.STATE_OPEN:
            while peer.get_available_packet_count():
                var packet = peer.get_packet()
                if peer.was_string_packet():
                    var packet_text = packet.get_string_from_utf8()
                    print("< Got text data from peer %d: %s ... echoing" % [peer_id, packet_text])
                    # Echo the packet back.
                    peer.send_text(packet_text)
                else:
                    print("< Got binary data from peer %d: %d ... echoing" % [peer_id, packet.size()])
                    # Echo the packet back.
                    peer.send(packet)
        elif peer_state == WebSocketPeer.STATE_CLOSED:
            # Remove the disconnected peer.
            _peers.erase(peer_id)
            var code = peer.get_close_code()
            var reason = peer.get_close_reason()
            print("- Peer %s closed with code: %d, reason %s. Clean: %s" % [peer_id, code, reason, code != -1])
```

Example 4 (unknown):
```unknown
Server started.
+ Peer 2 connected.
< Got text data from peer 2: Test packet ... echoing
```

---

## Validation layers — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/debugging/vulkan/vulkan_validation_layers.html

**Contents:**
- Validation layers
- Windows
- macOS
- Linux, *BSD
- Android
- iOS
- Web
  - Enabling validation layers
    - Build validation layers from official sources
    - Copy libraries

Validation layers enable developers to verify their application's correct use of the Vulkan API. Validation layers can be enabled in both debug and release builds, including in exported projects.

Enabling validation layers has a performance impact, so only enable them when you actually need the output to debug the application.

Install the Vulkan SDK https://vulkan.lunarg.com/sdk/home, which contains validation layers as part of its default installation. No need to enable any optional features in the installer; installing the core Vulkan SDK suffices. You don't need to reboot after installing the SDK, but you may need to close and reopen your current terminal.

After installing the Vulkan SDK, run Godot with the --gpu-validation command line argument. You can also specify --gpu-abort which will make Godot quit as soon as a validation error happens. This can prevent your system from freezing if a validation error occurs.

Official Godot macOS builds do not support validation layers, as these are statically linked against the Vulkan SDK. Dynamic linking must be used instead.

In practice, this means that using validation layers on macOS requires you to use a Godot build compiled with the use_volk=yes SCons option. Compiling for macOS. If testing validation layers on an exported project, you must recompile the export template and specify it as a custom export template in your project's macOS export preset.

Install the Vulkan SDK https://vulkan.lunarg.com/sdk/home, which contains validation layers as part of its default installation. No need to enable any optional features in the installer; installing the core Vulkan SDK suffices. You don't need to reboot after installing the SDK, but you may need to close and reopen your current terminal.

After installing the Vulkan SDK, run a Godot binary that was compiled with use_volk=yes SCons option. Specify the --gpu-validation command line argument. You can also specify --gpu-abort which will make Godot quit as soon as a validation error happens. This can prevent your system from freezing if a validation error occurs.

Install Vulkan validation layers from your distribution's repositories:

You don't need to reboot after installing the validation layers, but you may need to close and reopen your current terminal.

After installing the package, run Godot with the --gpu-validation command line argument. You can also specify --gpu-abort which will make Godot quit as soon as a validation error happens. This can prevent your system from freezing if a validation error occurs.

After enabling validation layers on Android, a developer can see errors and warning messages in the adb logcat output.

Validation layers are currently not supported on iOS.

Validation layers are not supported on the web platform, as there is no support for Vulkan there.

To build Android libraries, follow the instructions on Khronos' repository. After a successful build, the libraries will be located in Vulkan-ValidationLayers/build-android/libs.

Copy libraries from Vulkan-ValidationLayers/build-android/libs to godot/platform/android/java/app/libs/debug/vulkan_validation_layers.

Your Godot source directory tree should look like on the example below:

If the subdirectory libs/debug/vulkan_validation_layers doesn't exist, create it.

Linked validation layers are automatically loaded and enabled in Android debug builds. You can use Godot's One-click deploy feature to quickly test your project with the validation layers enabled.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
vulkan-validation-layers
```

Example 2 (unknown):
```unknown
pacman -S vulkan-validation-layers
```

Example 3 (unknown):
```unknown
apt install vulkan-validationlayers
```

Example 4 (unknown):
```unknown
dnf install vulkan-validation-layers
```

---

## Vector math — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/math/vector_math.html

**Contents:**
- Vector math
- Introduction
- Coordinate systems (2D)
- Vector operations
  - Member access
  - Adding vectors
  - Scalar multiplication
- Practical applications
  - Movement
  - Pointing toward a target

This tutorial is a short and practical introduction to linear algebra as it applies to game development. Linear algebra is the study of vectors and their uses. Vectors have many applications in both 2D and 3D development and Godot uses them extensively. Developing a good understanding of vector math is essential to becoming a strong game developer.

This tutorial is not a formal textbook on linear algebra. We will only be looking at how it is applied to game development. For a broader look at the mathematics, see https://www.khanacademy.org/math/linear-algebra

In 2D space, coordinates are defined using a horizontal axis (x) and a vertical axis (y). A particular position in 2D space is written as a pair of values such as (4, 3).

If you're new to computer graphics, it might seem odd that the positive y axis points downwards instead of upwards, as you probably learned in math class. However, this is common in most computer graphics applications.

Any position in the 2D plane can be identified by a pair of numbers in this way. However, we can also think of the position (4, 3) as an offset from the (0, 0) point, or origin. Draw an arrow pointing from the origin to the point:

This is a vector. A vector represents a lot of useful information. As well as telling us that the point is at (4, 3), we can also think of it as an angle θ (theta) and a length (or magnitude) m. In this case, the arrow is a position vector - it denotes a position in space, relative to the origin.

A very important point to consider about vectors is that they only represent relative direction and magnitude. There is no concept of a vector's position. The following two vectors are identical:

Both vectors represent a point 4 units to the right and 3 units below some starting point. It does not matter where on the plane you draw the vector, it always represents a relative direction and magnitude.

You can use either method (x and y coordinates or angle and magnitude) to refer to a vector, but for convenience, programmers typically use the coordinate notation. For example, in Godot, the origin is the top-left corner of the screen, so to place a 2D node named Node2D 400 pixels to the right and 300 pixels down, use the following code:

Godot supports both Vector2 and Vector3 for 2D and 3D usage, respectively. The same mathematical rules discussed in this article apply to both types, and wherever we link to Vector2 methods in the class reference, you can also check out their Vector3 counterparts.

The individual components of the vector can be accessed directly by name.

When adding or subtracting two vectors, the corresponding components are added:

We can also see this visually by adding the second vector at the end of the first:

Note that adding a + b gives the same result as b + a.

Vectors represent both direction and magnitude. A value representing only magnitude is called a scalar. Scalars use the float type in Godot.

A vector can be multiplied by a scalar:

Multiplying a vector by a positive scalar does not change its direction, only its magnitude. Multiplying with a negative scalar results in a vector in the opposite direction. This is how you scale a vector.

Let's look at two common uses for vector addition and subtraction.

A vector can represent any quantity with a magnitude and direction. Typical examples are: position, velocity, acceleration, and force. In this image, the spaceship at step 1 has a position vector of (1, 3) and a velocity vector of (2, 1). The velocity vector represents how far the ship moves each step. We can find the position for step 2 by adding the velocity to the current position.

Velocity measures the change in position per unit of time. The new position is found by adding the velocity multiplied by the elapsed time (here assumed to be one unit, e.g. 1 s) to the previous position.

In a typical 2D game scenario, you would have a velocity in pixels per second, and multiply it by the delta parameter (time elapsed since the previous frame) from the _process() or _physics_process() callbacks.

In this scenario, you have a tank that wishes to point its turret at a robot. Subtracting the tank's position from the robot's position gives the vector pointing from the tank to the robot.

To find a vector pointing from A to B, use B - A.

A vector with magnitude of 1 is called a unit vector. They are also sometimes referred to as direction vectors or normals. Unit vectors are helpful when you need to keep track of a direction.

Normalizing a vector means reducing its length to 1 while preserving its direction. This is done by dividing each of its components by its magnitude. Because this is such a common operation, Godot provides a dedicated normalized() method for this:

Because normalization involves dividing by the vector's length, you cannot normalize a vector of length 0. Attempting to do so would normally result in an error. In GDScript though, trying to call the normalized() method on a vector of length 0 leaves the value untouched and avoids the error for you.

A common use of unit vectors is to indicate normals. Normal vectors are unit vectors aligned perpendicularly to a surface, defining its direction. They are commonly used for lighting, collisions, and other operations involving surfaces.

For example, imagine we have a moving ball that we want to bounce off a wall or other object:

The surface normal has a value of (0, -1) because this is a horizontal surface. When the ball collides, we take its remaining motion (the amount left over when it hits the surface) and reflect it using the normal. In Godot, there is a bounce() method to handle this. Here is a code example of the above diagram using a CharacterBody2D:

The dot product is one of the most important concepts in vector math, but is often misunderstood. Dot product is an operation on two vectors that returns a scalar. Unlike a vector, which contains both magnitude and direction, a scalar value has only magnitude.

The formula for dot product takes two common forms:

The mathematical notation ||A|| represents the magnitude of vector A, and Ax means the x component of vector A.

However, in most cases it is easiest to use the built-in dot() method. Note that the order of the two vectors does not matter:

The dot product is most useful when used with unit vectors, making the first formula reduce to just cos(θ). This means we can use the dot product to tell us something about the angle between two vectors:

When using unit vectors, the result will always be between -1 (180°) and 1 (0°).

We can use this fact to detect whether an object is facing toward another object. In the diagram below, the player P is trying to avoid the zombies A and B. Assuming a zombie's field of view is 180°, can they see the player?

The green arrows fA and fB are unit vectors representing the zombie's facing direction and the blue semicircle represents its field of view. For zombie A, we find the direction vector AP pointing to the player using P - A and normalize it, however, Godot has a helper method to do this called direction_to(). If the angle between this vector and the facing vector is less than 90°, then the zombie can see the player.

In code it would look like this:

Like the dot product, the cross product is an operation on two vectors. However, the result of the cross product is a vector with a direction that is perpendicular to both. Its magnitude depends on their relative angle. If two vectors are parallel, the result of their cross product will be a null vector.

The cross product is calculated like this:

With Godot, you can use the built-in Vector3.cross() method:

The cross product is not mathematically defined in 2D. The Vector2.cross() method is a commonly used analog of the 3D cross product for 2D vectors.

In the cross product, order matters. a.cross(b) does not give the same result as b.cross(a). The resulting vectors point in opposite directions.

One common use of cross products is to find the surface normal of a plane or surface in 3D space. If we have the triangle ABC we can use vector subtraction to find two edges AB and AC. Using the cross product, AB × AC produces a vector perpendicular to both: the surface normal.

Here is a function to calculate a triangle's normal:

In the dot product section above, we saw how it could be used to find the angle between two vectors. However, in 3D, this is not enough information. We also need to know what axis to rotate around. We can find that by calculating the cross product of the current facing direction and the target direction. The resulting perpendicular vector is the axis of rotation.

For more information on using vector math in Godot, see the following articles:

Matrices and transforms

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
$Node2D.position = Vector2(400, 300)
```

Example 2 (unknown):
```unknown
var node2D = GetNode<Node2D>("Node2D");
node2D.Position = new Vector2(400, 300);
```

Example 3 (unknown):
```unknown
# Create a vector with coordinates (2, 5).
var a = Vector2(2, 5)
# Create a vector and assign x and y manually.
var b = Vector2()
b.x = 3
b.y = 1
```

Example 4 (unknown):
```unknown
// Create a vector with coordinates (2, 5).
var a = new Vector2(2, 5);
// Create a vector and assign x and y manually.
var b = new Vector2();
b.X = 3;
b.Y = 1;
```

---

## Version control systems — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/best_practices/version_control_systems.html

**Contents:**
- Version control systems
- Introduction
- Version control plugins
  - Official Git plugin
- Files to exclude from VCS
- Working with Git on Windows
- Git LFS
- User-contributed notes

Godot aims to be VCS-friendly and generate mostly readable and mergeable files.

Godot also supports the use of version control systems in the editor itself. However, version control in the editor requires a plugin for the specific VCS you're using.

As of July 2023, there is only a Git plugin available, but the community may create additional VCS plugins.

Using Git from inside the editor is supported with an official plugin. You can find the latest releases on GitHub.

Documentation on how to use the Git plugin can be found on its wiki.

This lists files and folders that should be ignored from version control in Godot 4.1 and later.

The list of files of folders that should be ignored from version control in Godot 3.x and Godot 4.0 is entirely different. This is important, as Godot 3.x and 4.0 may store sensitive credentials in export_presets.cfg (unlike Godot 4.1 and later).

If you are using Godot 3, check the 3.5 version of this documentation page instead.

There are some files and folders Godot automatically creates when opening a project in the editor for the first time. To avoid bloating your version control repository with generated data, you should add them to your VCS ignore:

.godot/: This folder stores various project cache data.

*.translation: These files are binary imported translations generated from CSV files.

You can make the Godot project manager generate version control metadata for you automatically when creating a project. When choosing the Git option, this creates .gitignore and .gitattributes files in the project root:

Creating version control metadata in the project manager's New Project dialog

In existing projects, select the Project menu at the top of the editor, then choose Version Control > Generate Version Control Metadata. This creates the same files as if the operation was performed in the project manager.

Most Git for Windows clients are configured with the core.autocrlf set to true. This can lead to files unnecessarily being marked as modified by Git due to their line endings being converted from LF to CRLF automatically.

It is better to set this option as:

Creating version control metadata using the project manager or editor will automatically enforce LF line endings using the .gitattributes file. In this case, you don't need to change your Git configuration.

Git LFS (Large File Storage) is a Git extension that allows you to manage large files in your repository. It replaces large files with text pointers inside Git, while storing the file contents on a remote server. This is useful for managing large assets, such as textures, audio files, and 3D models, without bloating your Git repository.

When using Git LFS you will want to ensure it is setup before you commit any files to your repository. If you have already committed files to your repository, you will need to remove them from the repository and re-add them after setting up Git LFS.

It is possible to use git lfs migrate to convert existing files in your repository, but this is more in-depth and requires a good understanding of Git.

A common approach is setting up a new repository with Git LFS (and a proper .gitattributes), then copying the files from the old repository to the new one. This way, you can ensure that all files are tracked by LFS from the start.

To use Git LFS with Godot, you need to install the Git LFS extension and configure it to track the file types you want to manage. You can do this by running the following command in your terminal:

This will create a .gitattributes file in your repository that tells Git to use LFS for the specified file types. You can add more file types by modifying the .gitattributes file. For example, to track all GLB files, you can do this by running the following command in your terminal:

When you add or modify files that are tracked by LFS, Git will automatically store them in LFS instead of the regular Git history. You can push and pull LFS files just like regular Git files, but keep in mind that LFS files are stored separately from the rest of your Git history. This means that you may need to install Git LFS on any machine that you clone the repository to in order to access the LFS files.

Below is an example .gitattributes file that you can use as a starting point for Git LFS. These file types were chosen because they are commonly used, but you can modify the list to include any binary types you may have in your project.

For more information on Git LFS, check the official documentation: https://git-lfs.github.com/ and https://docs.github.com/en/repositories/working-with-files/managing-large-files.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
git config --global core.autocrlf input
```

Example 2 (unknown):
```unknown
git lfs install
```

Example 3 (unknown):
```unknown
git lfs track "*.glb"
```

Example 4 (unknown):
```unknown
# Normalize EOL for all files that Git considers text files.
* text=auto eol=lf

# Git LFS Tracking (Assets)

# 3D Models
*.fbx filter=lfs diff=lfs merge=lfs -text
*.gltf filter=lfs diff=lfs merge=lfs -text
*.glb filter=lfs diff=lfs merge=lfs -text
*.blend filter=lfs diff=lfs merge=lfs -text
*.obj filter=lfs diff=lfs merge=lfs -text

# Images
*.png filter=lfs diff=lfs merge=lfs -text
*.svg filter=lfs diff=lfs merge=lfs -text
*.jpg filter=lfs diff=lfs merge=lfs -text
*.jpeg filter=lfs diff=lfs merge=lfs -text
*.gif filter=lfs diff=lfs merge=lfs -text
*.tga filter=lfs diff=lfs merge=lfs -text
*.webp filter=lfs diff=lfs merge=lfs -text
*.exr filter=lfs diff=lfs merge=lfs -text
*.hdr filter=lfs diff=lfs merge=lfs -text
*.dds filter=lfs diff=lfs merge=lfs -text

# Audio
*.mp3 filter=lfs diff=lfs merge=lfs -text
*.wav filter=lfs diff=lfs merge=lfs -text
*.ogg filter=lfs diff=lfs merge=lfs -text

# Font & Icon
*.ttf filter=lfs diff=lfs merge=lfs -text
*.otf filter=lfs diff=lfs merge=lfs -text
*.ico filter=lfs diff=lfs merge=lfs -text

# Godot LFS Specific
*.scn filter=lfs diff=lfs merge=lfs -text
*.res filter=lfs diff=lfs merge=lfs -text
*.material filter=lfs diff=lfs merge=lfs -text
*.anim filter=lfs diff=lfs merge=lfs -text
*.mesh filter=lfs diff=lfs merge=lfs -text
*.lmbake filter=lfs diff=lfs merge=lfs -text
```

---

## Visual Studio Code — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/configuring_an_ide/visual_studio_code.html

**Contents:**
- Visual Studio Code
- Importing the project
- Debugging the project
- Configuring Intellisense
- User-contributed notes

This documentation is for contributions to the game engine, and not using Visual Studio Code as a C# or GDScript editor. To code C# or GDScript in an external editor, see the C# guide to configure an external editor or the GDScript guide to using an external text editor.

Visual Studio Code is a free cross-platform code editor by Microsoft (not to be confused with Visual Studio).

Make sure the C/C++ extension is installed. You can find instructions in the official documentation. Alternatively, clangd can be used instead.

When using the clangd extension, run scons compiledb=yes.

From the Visual Studio Code's main screen open the Godot root folder with File > Open Folder....

Press Ctrl + Shift + P to open the command prompt window and enter Configure Task.

Select the Create tasks.json file from template option.

If there is no such option as Create tasks.json file from template available, either delete the file if it already exists in your folder or create a .vscode/tasks.json file manually. See Tasks in Visual Studio Code for more details on tasks.

Within the tasks.json file find the "tasks" array and add a new section to it:

An example of a filled out tasks.json.

Arguments can be different based on your own setup and needs. See Introduction to the buildsystem for a full list of arguments.

To run and debug the project you need to create a new configuration in the launch.json file.

Press Ctrl + Shift + D to open the Run panel.

If launch.json file is missing you will be prompted to create a new one.

Select C++ (GDB/LLDB). There may be another platform-specific option here. If selected, adjust the configuration example provided accordingly.

Within the launch.json file find the "configurations" array and add a new section to it:

An example of a filled out launch.json.

Due to sporadic performance issues, it is recommended to use LLDB over GDB on Unix-based systems. Make sure that the CodeLLDB extension is installed for configurations using lldb.

If you encounter issues with lldb, you may consider using gdb (see the LinuxBSD_gdb configuration).

Do note that lldb may work better with LLVM-based builds. See Compiling for Linux, *BSD for further information.

The name under program depends on your build configuration, e.g. godot.linuxbsd.editor.dev.x86_64 for 64-bit LinuxBSD platform with target=editor and dev_build=yes.

For the C/C++ extension:

To fix include errors you may be having, you need to configure some settings in the c_cpp_properties.json file.

First, make sure to build the project since some files need to be generated.

Edit the C/C++ Configuration file either with the UI or with text:

Add an include path for your platform, for example, ${workspaceFolder}/platform/windows.

Add defines for the editor TOOLS_ENABLED, debug builds DEBUG_ENABLED, and tests TESTS_ENABLED.

Make sure the compiler path is configured correctly to the compiler you are using. See Introduction to the buildsystem for further information on your platform.

The c_cpp_properties.json file should look similar to this for Windows:

Alternatively, you can use the scons argument compiledb=yes and set the compile commands setting compileCommands to compile_commands.json, found in the advanced section of the C/C++ Configuration UI.

This argument can be added to your build task in tasks.json since it will need to be run whenever files are added or moved.

If you run into any issues, ask for help in one of Godot's community channels.

To get linting on class reference XML files, install the vscode-xml extension.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
{
  "label": "build",
  "group": "build",
  "type": "shell",
  "command": "scons",
  "args": [
    // enable for debugging with breakpoints
    "dev_build=yes",
  ],
  "problemMatcher": "$msCompile"
}
```

Example 2 (unknown):
```unknown
{
  "name": "Launch Project",
  "type": "lldb",
  "request": "launch",
  // Change to godot.linuxbsd.editor.dev.x86_64.llvm for llvm-based builds.
  "program": "${workspaceFolder}/bin/godot.linuxbsd.editor.dev.x86_64",
  // Change the arguments below for the project you want to test with.
  // To run the project instead of editing it, remove the "--editor" argument.
  "args": [ "--editor", "--path", "path-to-your-godot-project-folder" ],
  "stopAtEntry": false,
  "cwd": "${workspaceFolder}",
  "environment": [],
  "externalConsole": false,
  "preLaunchTask": "build"
}
```

Example 3 (unknown):
```unknown
{
  "name": "Launch Project",
  "type": "cppdbg",
  "request": "launch",
  // Change to godot.linuxbsd.editor.dev.x86_64.llvm for llvm-based builds.
  "program": "${workspaceFolder}/bin/godot.linuxbsd.editor.dev.x86_64",
  // Change the arguments below for the project you want to test with.
  // To run the project instead of editing it, remove the "--editor" argument.
  "args": [ "--editor", "--path", "path-to-your-godot-project-folder" ],
  "stopAtEntry": false,
  "cwd": "${workspaceFolder}",
  "environment": [],
  "externalConsole": false,
  "setupCommands":
  [
    {
      "description": "Enable pretty-printing for gdb",
      "text": "-enable-pretty-printing",
      "ignoreFailures": true
    },
    {
        "description": "Load custom pretty-printers for Godot types.",
        "text": "source ${workspaceRoot}/misc/utility/godot_gdb_pretty_print.py"
    }
  ],
  "preLaunchTask": "build"
}
```

Example 4 (unknown):
```unknown
{
  "name": "Launch Project",
  "type": "cppvsdbg",
  "request": "launch",
  "program": "${workspaceFolder}/bin/godot.windows.editor.dev.x86_64.exe",
  // Change the arguments below for the project you want to test with.
  // To run the project instead of editing it, remove the "--editor" argument.
  "args": [ "--editor", "--path", "path-to-your-godot-project-folder" ],
  "stopAtEntry": false,
  "cwd": "${workspaceFolder}",
  "environment": [],
  "console": "internalConsole",
  "visualizerFile": "${workspaceFolder}/platform/windows/godot.natvis",
  "preLaunchTask": "build"
}
```

---

## Visual Studio — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/configuring_an_ide/visual_studio.html

**Contents:**
- Visual Studio
- Importing the project
- Debugging the project
- User-contributed notes

Visual Studio Community is a Windows-only IDE by Microsoft that's free for individual use or non-commercial use within organizations. It has many useful features, such as memory view, performance view, source control and more.

This documentation is for contributions to the game engine, and not using Visual Studio as a C# editor. To code C# in an external editor, see the C# guide to configure an external editor.

Visual Studio requires a solution file to work on a project. While Godot does not come with the solution file, it can be generated using SCons.

Navigate to the Godot root folder and open a Command Prompt or PowerShell window.

You can now open the project by double-clicking on the godot.sln in the project root or by using the Open a project or solution option inside of the Visual Studio.

Use the Build top menu to build the project.

Visual Studio must be configured with the C++ package. It can be selected in the installer:

Visual Studio features a powerful debugger. This allows the user to examine Godot's source code, stop at specific points in the code, inspect the current execution context, and make live changes to the codebase.

You can launch the project with the debugger attached using the Debug > Start Debugging option from the top menu. However, unless you want to debug the Project Manager specifically, you'd need to configure debugging options first. This is due to the fact that when the Godot Project Manager opens a project, the initial process is terminated and the debugger gets detached.

To configure the launch options to use with the debugger use Project > Properties from the top menu:

Open the Debugging section and under Command Arguments add two new arguments: the -e flag opens the editor instead of the Project Manager, and the --path argument tells the executable to open the specified project (must be provided as an absolute path to the project root, not the project.godot file; if the path contains spaces be sure to pass it inside double quotation marks).

To learn more about command line arguments, refer to the command line tutorial.

Even if you start the project without a debugger attached it can still be connected to the running process using Debug > Attach to Process... menu.

To check that everything is working, put a breakpoint in main.cpp and press F5 to start debugging.

If you run into any issues, ask for help in one of Godot's community channels.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Vulkan — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/debugging/vulkan/index.html

**Contents:**
- Vulkan

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## WebRTC — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/networking/webrtc.html

**Contents:**
- WebRTC
- HTML5, WebSocket, WebRTC
  - WebSocket
  - WebRTC
- Using WebRTC in Godot
  - Minimal connection example
  - Local signaling example
  - Remote signaling with WebSocket
- User-contributed notes

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

One of Godot's great features is its ability to export to the HTML5/WebAssembly platform, allowing your game to run directly in the browser when a user visit your webpage.

This is a great opportunity for both demos and full games, but used to come with some limitations. In the area of networking, browsers used to support only HTTPRequests until recently, when first WebSocket and then WebRTC were proposed as standards.

When the WebSocket protocol was standardized in December 2011, it allowed browsers to create stable and bidirectional connections to a WebSocket server. The protocol is a very powerful tool to send push notifications to browsers, and has been used to implement chats, turn-based games, etc.

WebSockets, though, still use a TCP connection, which is good for reliability but not for latency, so not good for real-time applications like VoIP and fast-paced games.

For this reason, since 2010, Google started working on a new technology called WebRTC, which later on, in 2017, became a W3C candidate recommendation. WebRTC is a much more complex set of specifications, and relies on many other technologies behind the scenes (ICE, DTLS, SDP) to provide fast, real-time, and secure communication between two peers.

The idea is to find the fastest route between the two peers and establish whenever possible a direct communication (i.e. try to avoid a relaying server).

However, this comes at a price, which is that some media information must be exchanged between the two peers before the communication can start (in the form of Session Description Protocol - SDP strings). This usually takes the form of a so-called WebRTC Signaling Server.

Peers connect to a signaling server (for example a WebSocket server) and send their media information. The server then relays this information to other peers, allowing them to establish the desired direct communication. Once this step is done, peers can disconnect from the signaling server and keep the direct Peer-to-Peer (P2P) connection open.

WebRTC is implemented in Godot via two main classes WebRTCPeerConnection and WebRTCDataChannel, plus the multiplayer API implementation WebRTCMultiplayerPeer. See section on high-level multiplayer for more details.

These classes are available automatically in HTML5, but require an external GDExtension plugin on native (non-HTML5) platforms. Check out the webrtc-native plugin repository for instructions and to get the latest release.

When exporting to Android, make sure to enable the INTERNET permission in the Android export preset before exporting the project or using one-click deploy. Otherwise, network communication of any kind will be blocked by Android.

This example will show you how to create a WebRTC connection between two peers in the same application. This is not very useful in real life, but will give you a good overview of how a WebRTC connection is set up.

This example expands on the previous one, separating the peers in two different scenes, and using a singleton as a signaling server.

And now for the local signaling server:

This local signaling server is supposed to be used as a singleton to connect two peers in the same scene.

Then you can use it like this:

This will print something similar to this:

A more advanced demo using WebSocket for signaling peers and WebRTCMultiplayerPeer is available in the godot demo projects under networking/webrtc_signaling.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (gdscript):
```gdscript
extends Node

# Create the two peers
var p1 = WebRTCPeerConnection.new()
var p2 = WebRTCPeerConnection.new()
# And a negotiated channel for each each peer
var ch1 = p1.create_data_channel("chat", {"id": 1, "negotiated": true})
var ch2 = p2.create_data_channel("chat", {"id": 1, "negotiated": true})

func _ready():
    # Connect P1 session created to itself to set local description.
    p1.session_description_created.connect(p1.set_local_description)
    # Connect P1 session and ICE created to p2 set remote description and candidates.
    p1.session_description_created.connect(p2.set_remote_description)
    p1.ice_candidate_created.connect(p2.add_ice_candidate)

    # Same for P2
    p2.session_description_created.connect(p2.set_local_description)
    p2.session_description_created.connect(p1.set_remote_description)
    p2.ice_candidate_created.connect(p1.add_ice_candidate)

    # Let P1 create the offer
    p1.create_offer()

    # Wait a second and send message from P1.
    await get_tree().create_timer(1).timeout
    ch1.put_packet("Hi from P1".to_utf8_buffer())

    # Wait a second and send message from P2.
    await get_tree().create_timer(1).timeout
    ch2.put_packet("Hi from P2".to_utf8_buffer())

func _process(_delta):
    # Poll connections
    p1.poll()
    p2.poll()

    # Check for messages
    if ch1.get_ready_state() == ch1.STATE_OPEN and ch1.get_available_packet_count() > 0:
        print("P1 received: ", ch1.get_packet().get_string_from_utf8())
    if ch2.get_ready_state() == ch2.STATE_OPEN and ch2.get_available_packet_count() > 0:
        print("P2 received: ", ch2.get_packet().get_string_from_utf8())
```

Example 2 (unknown):
```unknown
P1 received: Hi from P1
P2 received: Hi from P2
```

Example 3 (gdscript):
```gdscript
extends Node
# An example p2p chat client.

var peer = WebRTCPeerConnection.new()

# Create negotiated data channel.
var channel = peer.create_data_channel("chat", {"negotiated": true, "id": 1})

func _ready():
    # Connect all functions.
    peer.ice_candidate_created.connect(self._on_ice_candidate)
    peer.session_description_created.connect(self._on_session)

    # Register to the local signaling server (see below for the implementation).
    Signaling.register(String(get_path()))


func _on_ice_candidate(mid, index, sdp):
    # Send the ICE candidate to the other peer via signaling server.
    Signaling.send_candidate(String(get_path()), mid, index, sdp)


func _on_session(type, sdp):
    # Send the session to other peer via signaling server.
    Signaling.send_session(String(get_path()), type, sdp)
    # Set generated description as local.
    peer.set_local_description(type, sdp)


func _process(delta):
    # Always poll the connection frequently.
    peer.poll()
    if channel.get_ready_state() == WebRTCDataChannel.STATE_OPEN:
        while channel.get_available_packet_count() > 0:
            print(String(get_path()), " received: ", channel.get_packet().get_string_from_utf8())


func send_message(message):
    channel.put_packet(message.to_utf8_buffer())
```

Example 4 (gdscript):
```gdscript
# A local signaling server. Add this to autoloads with name "Signaling" (/root/Signaling)
extends Node

# We will store the two peers here
var peers = []

func register(path):
    assert(peers.size() < 2)
    peers.append(path)
    if peers.size() == 2:
        get_node(peers[0]).peer.create_offer()


func _find_other(path):
    # Find the other registered peer.
    for p in peers:
        if p != path:
            return p
    return ""


func send_session(path, type, sdp):
    var other = _find_other(path)
    assert(other != "")
    get_node(other).peer.set_remote_description(type, sdp)


func send_candidate(path, mid, index, sdp):
    var other = _find_other(path)
    assert(other != "")
    get_node(other).peer.add_ice_candidate(mid, index, sdp)
```

---

## Web — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/platform/web/index.html

**Contents:**
- Web

The content of this page was not yet updated for Godot 4.5 and may be outdated. If you know how to improve this page or you can confirm that it's up to date, feel free to open a pull request.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## When and how to avoid using nodes for everything — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/best_practices/node_alternatives.html

**Contents:**
- When and how to avoid using nodes for everything
- User-contributed notes

Nodes are cheap to produce, but even they have their limits. A project may have tens of thousands of nodes all doing things. The more complex their behavior though, the larger the strain each one adds to a project's performance.

Godot provides more lightweight objects for creating APIs which nodes use. Be sure to keep these in mind as options when designing how you wish to build your project's features.

Object: The ultimate lightweight object, the original Object must use manual memory management. With that said, it isn't too difficult to create one's own custom data structures, even node structures, that are also lighter than the Node class.

Example: See the Tree node. It supports a high level of customization for a table of content with an arbitrary number of rows and columns. The data that it uses to generate its visualization though is actually a tree of TreeItem Objects.

Advantages: Simplifying one's API to smaller scoped objects helps improve its accessibility and improve iteration time. Rather than working with the entire Node library, one creates an abbreviated set of Objects from which a node can generate and manage the appropriate sub-nodes.

One should be careful when handling them. One can store an Object into a variable, but these references can become invalid without warning. For example, if the object's creator decides to delete it out of nowhere, this would trigger an error state when one next accesses it.

RefCounted: Only a little more complex than Object. They track references to themselves, only deleting loaded memory when no further references to themselves exist. These are useful in the majority of cases where one needs data in a custom class.

Example: See the FileAccess object. It functions just like a regular Object except that one need not delete it themselves.

Advantages: same as the Object.

Resource: Only slightly more complex than RefCounted. They have the innate ability to serialize/deserialize (i.e. save and load) their object properties to/from Godot resource files.

Example: Scripts, PackedScene (for scene files), and other types like each of the AudioEffect classes. Each of these can be saved and loaded, therefore they extend from Resource.

Advantages: Much has already been said on Resource's advantages over traditional data storage methods. In the context of using Resources over Nodes though, their main advantage is in Inspector-compatibility. While nearly as lightweight as Object/RefCounted, they can still display and export properties in the Inspector. This allows them to fulfill a purpose much like sub-Nodes on the usability front, but also improve performance if one plans to have many such Resources/Nodes in their scenes.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## When to use scenes versus scripts — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/best_practices/scenes_versus_scripts.html

**Contents:**
- When to use scenes versus scripts
- Anonymous types
- Named types
- Performance of Script vs PackedScene
- Conclusion
- User-contributed notes

We've already covered how scenes and scripts are different. Scripts define an engine class extension with imperative code, scenes with declarative code.

Each system's capabilities are different as a result. Scenes can define how an extended class initializes, but not what its behavior actually is. Scenes are often used in conjunction with a script, the scene declaring a composition of nodes, and the script adding behavior with imperative code.

It is possible to completely define a scenes' contents using a script alone. This is, in essence, what the Godot Editor does, only in the C++ constructor of its objects.

But, choosing which one to use can be a dilemma. Creating script instances is identical to creating in-engine classes whereas handling scenes requires a change in API:

Also, scripts will operate a little slower than scenes due to the speed differences between engine and script code. The larger and more complex the node, the more reason there is to build it as a scene.

Scripts can be registered as a new type within the editor itself. This displays it as a new type in the node or resource creation dialog with an optional icon. This way, the user's ability to use the script is much more streamlined. Rather than having to...

Know the base type of the script they would like to use.

Create an instance of that base type.

Add the script to the node.

With a registered script, the scripted type instead becomes a creation option like the other nodes and resources in the system. The creation dialog even has a search bar to look up the type by name.

There are two systems for registering types:

Editor-only. Typenames are not accessible at runtime.

Does not support inherited custom types.

An initializer tool. Creates the node with the script. Nothing more.

Editor has no type-awareness of the script or its relationship to other engine types or scripts.

Allows users to define an icon.

Works for all scripting languages because it deals with Script resources in abstract.

Set up using EditorPlugin.add_custom_type.

Editor and runtime accessible.

Displays inheritance relationships in full.

Creates the node with the script, but can also change types or extend the type from the editor.

Editor is aware of inheritance relationships between scripts, script classes, and engine C++ classes.

Allows users to define an icon.

Engine developers must add support for languages manually (both name exposure and runtime accessibility).

The Editor scans project folders and registers any exposed names for all scripting languages. Each scripting language must implement its own support for exposing this information.

Both methodologies add names to the creation dialog, but script classes, in particular, also allow for users to access the typename without loading the script resource. Creating instances and accessing constants or static methods is viable from anywhere.

With features like these, one may wish their type to be a script without a scene due to the ease of use it grants users. Those developing plugins or creating in-house tools for designers to use will find an easier time of things this way.

On the downside, it also means having to use largely imperative programming.

One last aspect to consider when choosing scenes and scripts is execution speed.

As the size of objects increases, the scripts' necessary size to create and initialize them grows much larger. Creating node hierarchies demonstrates this. Each Node's logic could be several hundred lines of code in length.

The code example below creates a new Node, changes its name, assigns a script to it, sets its future parent as its owner so it gets saved to disk along with it, and finally adds it as a child of the Main node:

Script code like this is much slower than engine-side C++ code. Each instruction makes a call to the scripting API which leads to many "lookups" on the back-end to find the logic to execute.

Scenes help to avoid this performance issue. PackedScene, the base type that scenes inherit from, defines resources that use serialized data to create objects. The engine can process scenes in batches on the back-end and provide much better performance than scripts.

In the end, the best approach is to consider the following:

If one wishes to create a basic tool that is going to be re-used in several different projects and which people of all skill levels will likely use (including those who don't label themselves as "programmers"), then chances are that it should probably be a script, likely one with a custom name/icon.

If one wishes to create a concept that is particular to their game, then it should always be a scene. Scenes are easier to track/edit and provide more security than scripts.

If one would like to give a name to a scene, then they can still sort of do this by declaring a script class and giving it a scene as a constant. The script becomes, in effect, a namespace:

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (javascript):
```javascript
const MyNode = preload("my_node.gd")
const MyScene = preload("my_scene.tscn")
var node = Node.new()
var my_node = MyNode.new() # Same method call.
var my_scene = MyScene.instantiate() # Different method call.
var my_inherited_scene = MyScene.instantiate(PackedScene.GEN_EDIT_STATE_MAIN) # Create scene inheriting from MyScene.
```

Example 2 (unknown):
```unknown
using Godot;

public partial class Game : Node
{
    public static CSharpScript MyNode { get; } =
        GD.Load<CSharpScript>("res://Path/To/MyNode.cs");
    public static PackedScene MyScene { get; } =
        GD.Load<PackedScene>("res://Path/To/MyScene.tscn");
    private Node _node;
    private Node _myNode;
    private Node _myScene;
    private Node _myInheritedScene;

    public Game()
    {
        _node = new Node();
        _myNode = MyNode.New().As<Node>();
        // Different than calling new() or MyNode.New(). Instantiated from a PackedScene.
        _myScene = MyScene.Instantiate();
        // Create scene inheriting from MyScene.
        _myInheritedScene = MyScene.Instantiate(PackedScene.GenEditState.Main);
    }
}
```

Example 3 (gdscript):
```gdscript
# main.gd
extends Node

func _init():
    var child = Node.new()
    child.name = "Child"
    child.script = preload("child.gd")
    add_child(child)
    child.owner = self
```

Example 4 (csharp):
```csharp
using Godot;

public partial class Main : Node
{
    public Node Child { get; set; }

    public Main()
    {
        Child = new Node();
        Child.Name = "Child";
        var childID = Child.GetInstanceId();
        Child.SetScript(GD.Load<Script>("res://Path/To/Child.cs"));
        // SetScript() causes the C# wrapper object to be disposed, so obtain a new
        // wrapper for the Child node using its instance ID before proceeding.
        Child = (Node)GodotObject.InstanceFromId(childID);
        AddChild(Child);
        Child.Owner = this;
    }
}
```

---

## Where to go from here — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/xr/xr_next_steps.html

**Contents:**
- Where to go from here
- XR Toolkits
- User-contributed notes

Now that we have the basics covered there are several options to look at for your XR game dev journey:

You can take a look at the Advanced topics section.

You can look at a number of XR demos here.

You can find 3rd party tutorials on our Tutorials and resources page.

There are various XR toolkits available that implement more complex XR logic ready for you to use. We have a small introduction to Godot XR Tools that you can look at, a toolkit developed by core contributors of Godot.

There are more toolkits available for Godot:

Godot XR handtracking toolkit (GDScript)

Godot XR Kit (GDScript)

Godot XR Tools (GDScript)

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---

## Xcode — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/engine_details/development/configuring_an_ide/xcode.html

**Contents:**
- Xcode
- Importing the project
- Debugging the project
- User-contributed notes

Xcode is a free macOS-only IDE. You can download it from the Mac App Store.

From Xcode's main screen create a new project using the Other > External Build System template.

Now choose a name for your project and set the path to scons executable in build tool (to find the path you can type where scons in a terminal).

Open the main target from the Targets section and select the Info tab.

Fill out the form with the following settings:

See Introduction to the buildsystem for a full list of arguments.

A full path to the Godot root folder

Add a Command Line Tool target which will be used for indexing the project by choosing File > New > Target....

Select macOS > Application > Command Line Tool.

Name it something so you know not to compile with this target (e.g. GodotXcodeIndex).

For this target open the Build Settings tab and look for Header Search Paths.

Set Header Search Paths to the absolute path to the Godot root folder. You need to include subdirectories as well. To achieve that, add two two asterisks (**) to the end of the path, e.g. /Users/me/repos/godot-source/**.

Add the Godot source to the project by dragging and dropping it into the project file browser.

Select Create groups for the Added folders option and check only your command line indexing target in the Add to targets section.

Xcode will now index the files. This may take a few minutes.

Once Xcode is done indexing, you should have jump-to-definition, autocompletion, and full syntax highlighting.

To enable debugging support you need to edit the external build target's build and run schemes.

Open the scheme editor of the external build target.

Locate the Build > Post Actions section.

Add a new script run action

Under Provide build settings from select your project. This allows to reference the project directory within the script.

Create a script that will give the binary a name that Xcode can recognize, e.g.:

Build the external build target.

Open the scheme editor again and select Run.

Set the Executable to the file you linked in your post-build action script.

Check Debug executable.

You can add two arguments on the Arguments tab: the -e flag opens the editor instead of the Project Manager, and the --path argument tells the executable to open the specified project (must be provided as an absolute path to the project root, not the project.godot file).

To check that everything is working, put a breakpoint in platform/macos/godot_main_macos.mm and run the project.

If you run into any issues, ask for help in one of Godot's community channels.

Please read the User-contributed notes policy before submitting a comment.

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

**Examples:**

Example 1 (unknown):
```unknown
ln -f ${PROJECT_DIR}/godot/bin/godot.macos.tools.64 ${PROJECT_DIR}/godot/bin/godot
```

---

## XR — Godot Engine (stable) documentation in English

**URL:** https://docs.godotengine.org/en/stable/tutorials/xr/index.html

**Contents:**
- XR
- Basic Tutorial
- Advanced topics
- Godot XR Tools

This section of the manual covers everything related to XR ( Virtual Reality and Augmented Reality).

© Copyright 2014-present Juan Linietsky, Ariel Manzur and the Godot community (CC BY 3.0).

---
